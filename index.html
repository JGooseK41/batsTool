<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob:; connect-src 'self' https://api.etherscan.io https://api.bscscan.com https://api.polygonscan.com https://api.blockcypher.com https://blockchain.info https://api.blockchair.com https://*.infura.io https://mempool.space https://api.mainnet-beta.solana.com https://rpc.ankr.com https://solana-mainnet.g.alchemy.com https://api.arkhamintelligence.com https://api.trongrid.io https://tronscan.org https://api.blockchain.info https://walletexplorer.com https://www.walletexplorer.com https://*.solscan.io https://pro-api.solscan.io https://public-api.solscan.io https://api.solscan.io https://api.xrpscan.com https://xrplcluster.com https://s1.ripple.com https://fullnode.mainnet.sui.io https://sui-mainnet.blockvision.org https://rpc-mainnet.suiscan.xyz https://suiscan.xyz https://midgard.ninerealms.com https://midgard.thorchain.info https://viewblock.io https://api.bridgers.xyz https://images.bridgers.xyz https://scan.layerzero-api.com https://layerzeroscan.com https://layerzero.network https://stargate.finance https://api.stargate.finance https://api.wormholescan.io https://wormholescan.io https://wormhole.com https://portalbridge.com https://api.synapseprotocol.com https://synapseprotocol.com https://synapsebridge.com; img-src 'self' data: https:; font-src 'self' data:;">
    <title>B.A.T.S. - Block Audit Tracing Standard v4.1.1</title>

    <!-- Modern Visualization Engine -->
    <script src="bats-visualization-engine.js"></script>

    <script>
        // Mobile detection and redirect
        (function() {
            // Check if user has explicitly chosen to view desktop version
            const forceDesktop = localStorage.getItem('bats_force_desktop') === 'true';
            
            if (!forceDesktop) {
                // Detect mobile devices
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                               (window.matchMedia && window.matchMedia("(max-width: 768px)").matches);
                
                // Check if we're not already on mobile.html to avoid redirect loop
                const currentPage = window.location.pathname.split('/').pop();
                
                if (isMobile && currentPage !== 'mobile.html') {
                    // Show a brief notice before redirecting
                    if (confirm('📱 Mobile device detected!\n\nWould you like to view the mobile-optimized version of B.A.T.S.?\n\n(You can always switch to desktop version from the mobile site)')) {
                        window.location.href = 'mobile.html';
                    } else {
                        // User chose to stay on desktop version
                        localStorage.setItem('bats_force_desktop', 'true');
                    }
                }
            }
        })();
    </script>

    <!-- Inline minimal crypto functions to avoid CSP issues -->
    <script>
    // Minimal crypto implementations for PK Converter and Address Finder
    // Using Web Crypto API for hashing (no external dependencies needed)
    window.cryptoJSBlocked = true; // Always use Web Crypto API to avoid CSP issues
    </script>

    <!-- Include the enhanced flow diagram visualization -->
    <script src="flow-diagram-enhanced.js"></script>

    <!--
    DEPLOYMENT INSTRUCTIONS:
    For full functionality (custom save locations, autosave), serve this file over HTTPS:
    
    Option 1 - Local Development Server:
    - Python: python -m http.server 8000 (then visit http://localhost:8000)
    - Node.js: npx http-server
    - VS Code: Use Live Server extension
    
    Option 2 - Web Hosting:
    - Upload to any HTTPS-enabled web server
    - GitHub Pages (free): https://pages.github.com
    - Netlify Drop (free): https://app.netlify.com/drop
    
    Option 3 - Direct File Access:
    - Open index.html directly in browser
    - Limited functionality: saves only to Downloads folder
    -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #e8ecf1 0%, #f5f7fa 100%);
            min-height: 100vh;
            color: #2c3e50;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .case-details-card {
            background: white;
            border-radius: 8px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
            border: 1px solid #e8f0fe;
        }

        .case-details-card .form-group {
            margin-bottom: 0;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 30px;
            border-radius: 8px;
            text-align: center;
            margin-bottom: 30px;
            box-shadow: 0 4px 15px rgba(44, 62, 80, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 30px;
        }

        .header-logo {
            width: 168px;
            height: auto;
            flex-shrink: 0;
        }

        .header-content {
            flex: 1;
            text-align: center;
        }

        .header h1 {
            font-size: 2.8rem;
            font-weight: 700;
            margin-bottom: 10px;
            letter-spacing: 2px;
        }

        .header .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            font-weight: 300;
        }

        .workflow-steps {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
            border: 1px solid #e8f0fe;
        }

        .steps-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .step-item {
            text-align: center;
            padding: 15px;
            border-radius: 8px;
            background: #f8f9fa;
            border: 2px solid #e8f0fe;
            transition: all 0.3s ease;
        }

        .step-item.active {
            background: #e8f4f8;
            border-color: #3498db;
        }

        .step-item.completed {
            background: #f0f0f0;
            border-color: #95a5a6;
        }

        .step-number {
            background: #95a5a6;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 10px;
            font-weight: bold;
        }

        .step-item.active .step-number {
            background: #3498db;
        }

        .step-item.completed .step-number {
            background: #2c3e50;
        }

        .main-content {
            display: block;
            width: 100%;
        }

        .sidebar {
            background: white;
            border-radius: 8px;
            padding: 25px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
            height: fit-content;
            border: 1px solid #e8f0fe;
        }

        .main-panel {
            background: linear-gradient(135deg, #ffffff 0%, #fafbfc 100%);
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(52, 152, 219, 0.25), 0 2px 8px rgba(0, 0, 0, 0.05);
            min-height: 600px;
            border: 2px solid rgba(52, 152, 219, 0.3);
            width: 100%;
            position: relative;
            transition: all 0.3s ease;
        }

        .main-panel::before {
            content: '';
            position: absolute;
            top: -4px;
            left: -4px;
            right: -4px;
            bottom: -4px;
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            border-radius: 14px;
            opacity: 0.08;
            z-index: -1;
        }

        .main-panel:hover {
            box-shadow: 0 10px 40px rgba(52, 152, 219, 0.3), 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        .section-title {
            font-size: 1.4rem;
            font-weight: 600;
            margin-bottom: 20px;
            color: white;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #34495e;
            font-size: 14px;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #95a5a6;
            border-radius: 6px;
            font-size: 14px;
            transition: all 0.3s ease;
            background: white;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.08);
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #3498db;
            background: white;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1), inset 0 1px 3px rgba(0, 0, 0, 0.08);
        }

        .datetime-timezone {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .datetime-timezone input {
            flex: 1;
        }

        .datetime-timezone select {
            width: 100px;
            flex-shrink: 0;
        }

        .btn {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            margin-right: 10px;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #95a5a6 0%, #7f8c8d 100%);
        }
        
        .btn-add-transaction {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            font-weight: 600;
            padding: 10px 20px;
            margin-right: 10px;
        }
        
        .btn-add-transaction:hover {
            background: linear-gradient(135deg, #2980b9 0%, #21618c 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
        }

        .btn-danger {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }

        .btn-success {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
        }

        .btn-confirm {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            font-size: 16px;
            padding: 15px 30px;
        }

        .btn-large {
            font-size: 18px;
            padding: 20px 40px;
            margin: 30px 0;
            font-weight: 700;
        }

        .generate-root-section {
            background: #f8f9fa;
            border: 2px solid #3498db;
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            margin-top: 30px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }

        .generate-root-section h3 {
            color: #2c3e50;
            font-size: 1.5rem;
            margin-bottom: 15px;
        }

        .generate-root-section p {
            color: #2c3e50;
            margin-bottom: 25px;
            font-size: 16px;
            line-height: 1.6;
        }

        .trace-entry {
            background: white;
            border: 2px solid #95a5a6;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        .trace-entry:hover {
            border-color: #3498db;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.1);
        }

        .trace-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .trace-notation {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #2c3e50;
            font-size: 1.2rem;
        }

        .validation-panel {
            background: #e8f4f8;
            color: #2c3e50;
            border: 2px solid #3498db;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: center;
            font-weight: 500;
        }

        .validation-error {
            background: #fef2f2;
            border: 2px solid #dc3545;
            color: #dc3545;
        }

        .validation-warning {
            background: #fff8e1;
            border: 2px solid #f39c12;
            color: #856404;
        }

        .nav-tabs {
            display: flex;
            margin-bottom: 25px;
            border-bottom: 2px solid #e8f0fe;
        }

        .nav-tab {
            padding: 15px 25px;
            border: none;
            background: #f8f9fa;
            cursor: pointer;
            font-weight: 500;
            color: #7f8c8d;
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
            font-size: 14px;
            position: relative;
            margin-right: 5px;
            border-radius: 8px 8px 0 0;
        }

        .nav-tab.active {
            color: #ffffff;
            background: #1a5490;
            border-bottom-color: #1a5490;
            font-weight: 600;
            box-shadow: 0 2px 8px rgba(26, 84, 144, 0.4);
        }

        .nav-tab:hover:not(.active) {
            color: #2c3e50;
            background: #e8f0fe;
        }
        
        /* Additional styling for better active tab visibility */
        .nav-tab.active::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            right: 0;
            height: 4px;
            background: #1a5490;
            border-radius: 2px 2px 0 0;
        }

        .tab-content {
            display: none;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            padding: 25px;
            border-radius: 0 0 12px 12px;
            min-height: 500px;
        }

        .tab-content.active {
            display: block !important;
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        /* Dashboard Styles */
        .dashboard-stat {
            background: white;
            border-radius: 6px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: transform 0.2s;
        }

        .dashboard-stat:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .stat-label {
            font-size: 14px;
            color: #7f8c8d;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .stat-value {
            font-size: 28px;
            font-weight: bold;
            color: #2c3e50;
        }

        .progress-bar-container {
            margin-bottom: 15px;
        }

        .progress-bar-label {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            margin-bottom: 5px;
        }

        .progress-bar-bg {
            background: #e0e0e0;
            border-radius: 10px;
            height: 20px;
            overflow: hidden;
        }

        .progress-bar-fill {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            height: 100%;
            border-radius: 10px;
            transition: width 0.3s ease;
        }

        .search-highlight {
            background-color: #fff3cd !important;
            border: 2px solid #ffc107 !important;
            animation: highlight-pulse 1s ease-in-out;
        }

        @keyframes highlight-pulse {
            0% { opacity: 0.7; }
            50% { opacity: 1; }
            100% { opacity: 0.7; }
        }

        .analysis-tab-content {
            padding: 20px;
            min-height: 300px;
        }

        .summary-card {
            background: #fdfdfd;
            border-radius: 8px;
            padding: 25px;
            text-align: center;
            border: 2px solid #e8f0fe;
            transition: transform 0.3s ease;
        }

        .summary-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .summary-card h3 {
            color: #3498db;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }

        .summary-card .value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #2c3e50;
        }

        .export-section {
            background: #fdfdfd;
            border-radius: 8px;
            padding: 25px;
            margin-top: 30px;
            border: 2px solid #e8f0fe;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            align-items: center;
            justify-content: center;
        }
        
        .modal.show {
            display: flex;
        }

        .modal-content {
            background-color: white;
            padding: 30px;
            border-radius: 12px;
            width: 90%;
            max-width: 700px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            max-height: 85vh;
            overflow-y: auto;
            position: relative;
        }
        
        /* Wallet Address Autocomplete Styles */
        .wallet-autocomplete-container {
            position: relative;
        }
        
        .wallet-autocomplete-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 4px 4px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }
        
        .wallet-autocomplete-item {
            padding: 10px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            font-family: monospace;
            font-size: 13px;
        }
        
        .wallet-autocomplete-item:hover {
            background-color: #f8f9fa;
        }
        
        .wallet-autocomplete-item.selected {
            background-color: #e3f2fd;
        }
        
        .wallet-autocomplete-blockchain {
            font-size: 11px;
            color: #666;
            margin-top: 4px;
            font-family: sans-serif;
        }
        
        .wallet-autocomplete-loading {
            padding: 15px;
            text-align: center;
            color: #666;
            font-size: 13px;
        }

        .modal-header {
            text-align: center;
            margin-bottom: 25px;
        }

        .modal-header h2 {
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .root-total-display {
            background: #f8f9fa;
            border: 2px solid #3498db;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            margin: 20px 0;
        }

        .root-total-amount {
            font-size: 2.5rem;
            font-weight: bold;
            color: #2c3e50;
            margin: 10px 0;
        }

        .root-explanation {
            background: #f8f9fa;
            border-left: 4px solid #3498db;
            padding: 20px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }

        .root-explanation h4 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .root-explanation ul {
            color: #34495e;
            line-height: 1.8;
            padding-left: 20px;
        }

        .root-explanation li {
            margin-bottom: 8px;
        }

        .art-display {
            background: #e8f4f8;
            border: 2px solid #3498db;
            border-radius: 6px;
            padding: 10px 15px;
            margin: 10px 0;
            text-align: center;
            font-weight: bold;
            color: #2c3e50;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            cursor: pointer;
            margin-right: 10px;
        }

        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }

        .no-traces-message {
            text-align: center;
            padding: 40px;
            color: #7f8c8d;
            background: #f8f9fa;
            border-radius: 8px;
            border: 2px dashed #bdc3c7;
        }

        .custom-currency-input {
            display: none;
        }

        .wallet-display {
            background: #f8f9fa;
            border: 2px solid #e8f0fe;
            border-radius: 6px;
            padding: 10px 15px;
            margin: 10px 0;
            font-weight: bold;
            color: #2c3e50;
        }

        .wallet-display.red { background: #fef2f2; border-color: #dc3545; color: #dc3545; }
        .wallet-display.pink { background: #fef2f8; border-color: #d63384; color: #d63384; }
        .wallet-display.yellow { background: #fff8e1; border-color: #ffc107; color: #856404; }
        .wallet-display.orange { background: #fff3e0; border-color: #fd7e14; color: #fd7e14; }
        .wallet-display.black { background: #f5f5f5; border-color: #2c3e50; color: #2c3e50; }
        .wallet-display.brown { background: #f5f5f5; border-color: #795548; color: #795548; }
        .wallet-display.blue { background: #e8f4f8; border-color: #3498db; color: #3498db; }
        .wallet-display.purple { background: #f3e5f5; border-color: #6f42c1; color: #6f42c1; }
        .wallet-display.gray { background: #f5f5f5; border-color: #95a5a6; color: #7f8c8d; }
        .wallet-display.green { background: #e8f8f5; border-color: #198754; color: #198754; }
        
        /* Pulse animation for call-to-action buttons */
        @keyframes pulse {
            0% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(255, 152, 0, 0.7);
            }
            50% {
                transform: scale(1.05);
                box-shadow: 0 0 20px 10px rgba(255, 152, 0, 0);
            }
            100% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(255, 152, 0, 0);
            }
        }

        @keyframes highlight-flash {
            0% {
                background-color: #fff;
            }
            25% {
                background-color: #fff9c4;
            }
            50% {
                background-color: #ffeb3b;
            }
            75% {
                background-color: #fff9c4;
            }
            100% {
                background-color: #fff;
            }
        }

        .highlight-flash {
            animation: highlight-flash 2s ease-in-out;
        }

        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
            }

            .steps-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        @media (max-width: 768px) {
            .steps-grid {
                grid-template-columns: 1fr;
            }

            .datetime-timezone {
                flex-direction: column;
                gap: 5px;
            }

            .datetime-timezone select {
                width: 100%;
            }
        }
        /* =================================
   PART 4: CSS ADDITIONS - Add to your existing <style> section
   ================================= */

/* Enhanced UI Styles for Thread Tracking */
.enhanced-notation {
    background: linear-gradient(135deg, #f8f9fa 0%, #e8f4f8 100%);
    border: 2px solid #3498db;
    border-radius: 8px;
    padding: 15px;
    margin: 10px 0;
    font-family: 'Courier New', monospace;
    min-height: 80px;
}

.source-chain-display {
    background: #e8f4f8;
    border: 1px solid #3498db;
    border-radius: 4px;
    padding: 10px;
    margin: 8px 0;
    font-size: 12px;
}

.thread-tracker {
    background: #fff3cd;
    border: 2px solid #ffc107;
    border-radius: 6px;
    padding: 12px;
    margin: 10px 0;
}

.assignment-preview {
    background: #f8f9fa;
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 8px;
    margin-top: 5px;
    font-size: 12px;
}

.assignment-preview.valid {
    background: #d4edda;
    border-color: #27ae60;
    color: #155724;
}

.assignment-preview.invalid {
    background: #f8d7da;
    border-color: #dc3545;
    color: #721c24;
}

.convergence-indicator {
    background: #f39c12;
    color: white;
    padding: 2px 8px;
    border-radius: 4px;
    font-size: 11px;
    font-weight: bold;
    display: inline-block;
    margin-left: 8px;
}

/* Part 4 Integration Styles */
.part4-notification {
    background: linear-gradient(135deg, #d1ecf1 0%, #b8daff 100%);
    border: 2px solid #3498db;
    border-radius: 8px;
    padding: 20px;
    margin-bottom: 20px;
    color: #0c5460;
}

.enhanced-validation-panel {
    background: linear-gradient(135deg, #f8f9fa 0%, #e8f4f8 100%);
    border: 2px solid #3498db;
    border-radius: 8px;
    padding: 20px;
    margin: 20px 0;
}

.thread-analysis {
    background: #f8f9fa;
    border: 1px solid #ddd;
    border-radius: 6px;
    padding: 15px;
    margin: 10px 0;
    font-size: 14px;
}

.source-chain-report {
    background: white;
    border: 1px solid #ddd;
    border-radius: 6px;
    padding: 15px;
    margin: 10px 0;
    font-family: 'Courier New', monospace;
    font-size: 12px;
}

/* Collapsible hop and entry animations */
.hop-container {
    transition: all 0.3s ease;
}

.hop-header {
    transition: background-color 0.3s ease;
}

.hop-header:hover {
    filter: brightness(1.1);
}

.entry-collapsed {
    transition: all 0.3s ease;
}

@keyframes pulse {
    0% {
        box-shadow: 0 0 0 0 rgba(39, 174, 96, 0.7);
        transform: scale(1);
    }
    50% {
        box-shadow: 0 0 20px 10px rgba(39, 174, 96, 0);
        transform: scale(1.05);
    }
    100% {
        box-shadow: 0 0 0 0 rgba(39, 174, 96, 0);
        transform: scale(1);
    }
}

/* Terminal Wallet Notification Styles */
.terminal-notification {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: white;
    border-radius: 12px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.3);
    z-index: 10000;
    max-width: 500px;
    animation: slideIn 0.3s ease;
}

@keyframes slideIn {
    from {
        opacity: 0;
        transform: translate(-50%, -45%);
    }
    to {
        opacity: 1;
        transform: translate(-50%, -50%);
    }
}

.terminal-notification-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.5);
    z-index: 9999;
    animation: fadeIn 0.3s ease;
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

/* Modal Styles */
.modal {
    display: none;
    position: fixed;
    z-index: 10000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.5);
    align-items: center;
    justify-content: center;
}

.modal.show {
    display: flex;
}

/* Modal Overlay (for dynamically created modals) */
.modal-overlay {
    display: flex;
    position: fixed;
    z-index: 10000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.6);
    align-items: center;
    justify-content: center;
    backdrop-filter: blur(2px);
}

.modal-content {
    background-color: white;
    margin: auto;
    padding: 30px;
    border-radius: 12px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    position: relative;
    animation: modalSlideIn 0.3s ease;
    max-height: 90vh;
    overflow-y: auto;
    max-width: 90vw;
}

@keyframes modalSlideIn {
    from {
        transform: translateY(-50px);
        opacity: 0;
    }
    to {
        transform: translateY(0);
        opacity: 1;
    }
}

/* Wallet Explorer Specific Styles */
.wallet-tx-in {
    background-color: #e8f5e9 !important;
    border-left: 4px solid #4caf50;
}

.wallet-tx-out {
    background-color: #ffebee !important;
    border-left: 4px solid #f44336;
}

.wallet-asset-card {
    background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
    color: white;
    padding: 20px;
    border-radius: 12px;
    box-shadow: 0 4px 15px rgba(0,0,0,0.1);
    transition: transform 0.2s, box-shadow 0.2s;
    cursor: pointer;
}

.wallet-asset-card:hover {
    transform: translateY(-4px);
    box-shadow: 0 8px 25px rgba(0,0,0,0.15);
}

.wallet-asset-card h4 {
    margin: 0 0 10px 0;
    font-size: 1.2rem;
    font-weight: 600;
}

.wallet-asset-card .asset-balance {
    font-size: 1.8rem;
    font-weight: bold;
    margin: 10px 0;
}

.wallet-asset-card .asset-tx-count {
    font-size: 0.9rem;
    opacity: 0.9;
}

.wallet-tx-row {
    transition: background-color 0.2s;
}

.wallet-tx-row:hover {
    background-color: #f8f9fa !important;
}

.wallet-entity-label {
    display: inline-block;
    padding: 4px 12px;
    background: #e3f2fd;
    color: #1976d2;
    border-radius: 20px;
    font-size: 0.85rem;
    font-weight: 500;
    margin-left: 8px;
}

.wallet-explorer-action-btn {
    padding: 6px 16px;
    font-size: 0.9rem;
    border-radius: 6px;
    border: none;
    cursor: pointer;
    transition: all 0.2s;
    font-weight: 500;
}

.wallet-explorer-action-btn:hover {
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
}

.wallet-explorer-external-link {
    color: #666;
    text-decoration: none;
    font-size: 0.9rem;
    transition: color 0.2s;
}

.wallet-explorer-external-link:hover {
    color: #3498db;
}

/* Modern Graph Visualization Styles */
.graph-node {
    cursor: pointer;
    filter: drop-shadow(0 2px 4px rgba(0,0,0,0.1));
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.graph-node:hover {
    filter: drop-shadow(0 8px 16px rgba(0,0,0,0.2));
    transform: translateY(-2px) scale(1.05);
}

.graph-edge {
    fill: none;
    stroke-width: 2;
    stroke-linecap: round;
    stroke-linejoin: round;
    opacity: 0.8;
    transition: all 0.3s ease;
}

.graph-edge:hover {
    stroke-width: 3;
    opacity: 1;
}

.graph-edge-animated {
    stroke-dasharray: 5 5;
    animation: flow 1s linear infinite;
}

@keyframes flow {
    to {
        stroke-dashoffset: -10;
    }
}

/* Premium Visualization Animations */
@keyframes grid-move {
    0% { transform: translate(0, 0); }
    100% { transform: translate(50px, 50px); }
}

@keyframes pulse-glow {
    0%, 100% { opacity: 1; transform: scale(1); }
    50% { opacity: 0.8; transform: scale(1.1); }
}

@keyframes flow-animation {
    0% { stroke-dashoffset: 0; }
    100% { stroke-dashoffset: -40; }
}

.viz-mode-btn:hover {
    background: rgba(255, 255, 255, 0.3) !important;
    transform: translateY(-2px);
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.2);
}

.viz-mode-btn.active {
    background: rgba(255, 255, 255, 0.2) !important;
    border-color: rgba(255, 255, 255, 0.5) !important;
}

/* Premium DAG Node Styles */
.dag-node {
    cursor: pointer;
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.dag-node:hover {
    transform: scale(1.05);
    filter: brightness(1.2);
}

.dag-edge {
    stroke-linecap: round;
    stroke-linejoin: round;
    fill: none;
    opacity: 0.8;
    transition: all 0.3s ease;
}

.dag-edge:hover {
    opacity: 1;
    stroke-width: 4;
    filter: drop-shadow(0 0 8px currentColor);
}

/* ART Verification Overlay Styles */
.art-hop-section {
    background: linear-gradient(135deg, rgba(99, 102, 241, 0.1) 0%, rgba(139, 92, 246, 0.1) 100%);
    border: 1px solid rgba(99, 102, 241, 0.3);
    border-radius: 8px;
    padding: 12px;
    margin-bottom: 12px;
}

.art-thread-item {
    display: flex;
    justify-content: space-between;
    padding: 8px;
    background: rgba(0, 0, 0, 0.2);
    border-radius: 4px;
    margin-bottom: 4px;
    font-size: 12px;
    color: rgba(255, 255, 255, 0.9);
}

.art-balance {
    font-weight: bold;
    color: #10b981;
}

.art-deficit {
    font-weight: bold;
    color: #ef4444;
}

.conversion-diamond {
    cursor: pointer;
    filter: drop-shadow(0 2px 6px rgba(139, 69, 19, 0.3));
    transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
}

.conversion-diamond:hover {
    filter: drop-shadow(0 6px 12px rgba(139, 69, 19, 0.5));
    transform: rotate(45deg) scale(1.1);
}

.thread-label {
    font-size: 11px;
    font-weight: 500;
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    fill: #495057;
    pointer-events: none;
}

.node-label {
    font-size: 12px;
    font-weight: 600;
    font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
    fill: white;
    text-shadow: 0 1px 2px rgba(0,0,0,0.2);
}

.amount-label {
    font-size: 13px;
    font-weight: 700;
    font-family: 'SF Mono', Monaco, monospace;
    fill: #2c3e50;
    background: rgba(255, 255, 255, 0.9);
    padding: 2px 6px;
    border-radius: 4px;
}

.hop-background {
    fill: url(#hopGradient);
    opacity: 0.03;
}

.hop-divider {
    stroke: #e1e4e8;
    stroke-width: 1;
    stroke-dasharray: 8 4;
    opacity: 0.3;
}

.flow-hop-lane-1 {
    fill: #FFB6C1;
}

.flow-hop-lane-2 {
    fill: #87CEEB;
}

.flow-hop-lane-3 {
    fill: #98FB98;
}

.flow-hop-lane-4 {
    fill: #DDA0DD;
}

.flow-hop-lane-5 {
    fill: #F0E68C;
}

.flow-hop-title {
    font-size: 18px;
    font-weight: bold;
    fill: #2c3e50;
}

.flow-sum-text {
    font-size: 16px;
    font-weight: bold;
    font-family: 'Courier New', monospace;
    fill: #2c3e50;
}

.flow-wallet-label {
    font-size: 12px;
    font-weight: bold;
    fill: white;
}

@media print {
    #flowDiagramControls {
        display: none !important;
    }
    
    #flowDiagramContainer {
        border: none !important;
        box-shadow: none !important;
    }
}
   </style>
</head>
<body>
    <!-- Landing Page (completely separate from app) -->
    <div id="landingPageContainer" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 10000; background: linear-gradient(135deg, #1a1a2e 0%, #0f0f1e 100%); overflow-y: auto;">
<div id="landingContent" >
                    <!-- Professional Dark Header -->
                    <div style="background: linear-gradient(135deg, #2c3e50 0%, #1a252f 100%); padding: 40px 0; border-bottom: 2px solid #34495e; box-shadow: 0 2px 10px rgba(0,0,0,0.3);">
                        <div style="max-width: 1200px; margin: 0 auto; padding: 0 20px; text-align: center;">
                            <h1 style="color: #ecf0f1; font-size: 3rem; margin-bottom: 10px; font-weight: 700; letter-spacing: 3px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3);">
                                B.A.T.S.
                            </h1>
                            <p style="font-size: 1.1rem; color: #bdc3c7; font-weight: 300; letter-spacing: 1px;">
                                Block Audit Tracing Standard
                            </p>
                        </div>
                    </div>

                    <div style="max-width: 900px; margin: 0 auto; padding: 50px 20px;">

                        <!-- Brief Info Section -->
                        <div style="text-align: center; margin-bottom: 50px;">
                            <h2 style="color: #ecf0f1; margin-bottom: 20px; font-size: 1.8rem; font-weight: 300;">Documentation Standard for Blockchain Investigations</h2>
                            <p style="color: #95a5a6; line-height: 1.8; font-size: 1.1rem; max-width: 700px; margin: 0 auto 30px;">
                                B.A.T.S. provides a systematic methodology for documenting cryptocurrency fund movements.
                                Designed to work alongside your blockchain analysis tools to ensure legally compliant investigation records.
                            </p>
                            <div style="display: inline-block; background: rgba(243, 156, 18, 0.1); border: 1px solid #f39c12; border-radius: 6px; padding: 15px 25px; color: #f39c12; max-width: 800px; text-align: left;">
                                <strong>Note:</strong> This tool is not designed to be a stand alone tracing tool but serve as guardrails in applying the BATS method. It is best used to document tracing efforts conducted via opensource explorers or commercial forensic tools to develop BATS compliant consistent documentation and reporting.
                            </div>
                        </div>

                        <!-- Primary Action Card -->
                        <div style="background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%); border-radius: 8px; padding: 40px; margin-bottom: 40px; box-shadow: 0 5px 20px rgba(0,0,0,0.4); text-align: center; cursor: pointer; transition: all 0.2s ease; border: 1px solid #4a5f7a;" onclick="startBATSDocumentation()" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 8px 25px rgba(0,0,0,0.5)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 5px 20px rgba(0,0,0,0.4)'">
                            <h2 style="color: #ecf0f1; font-size: 1.6rem; margin-bottom: 15px; font-weight: 400; letter-spacing: 1px;">
                                Enter B.A.T.S. Documentation Tool
                            </h2>
                            <p style="color: #95a5a6; font-size: 1rem; margin-bottom: 25px; line-height: 1.6;">
                                Begin documenting your investigation with the official B.A.T.S. methodology
                            </p>
                            <button style="background: linear-gradient(135deg, #3498db 0%, #2980b9 100%); color: white; border: none; padding: 12px 35px; border-radius: 4px; font-size: 1rem; font-weight: 500; cursor: pointer; transition: all 0.2s ease; box-shadow: 0 2px 10px rgba(52, 152, 219, 0.3);" onmouseover="event.stopPropagation(); this.style.boxShadow='0 4px 15px rgba(52, 152, 219, 0.5)'" onmouseout="event.stopPropagation(); this.style.boxShadow='0 2px 10px rgba(52, 152, 219, 0.3)'">
                                Start Documentation
                            </button>
                        </div>

                        <!-- Utility Tools - Smaller Cards -->
                        <div style="margin-bottom: 30px;">
                            <h3 style="color: #7f8c8d; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 2px; margin-bottom: 25px; text-align: center; font-weight: 400;">Utility Tools</h3>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;">
                                <!-- PK Converter Card -->
                                <div style="background: #2c3e50; border-radius: 6px; padding: 25px; border: 1px solid #34495e; cursor: pointer; transition: all 0.2s ease; text-align: center;" onclick="openPKConverter()" onmouseover="this.style.borderColor='#3498db'; this.style.transform='translateY(-2px)'; this.style.boxShadow='0 5px 15px rgba(0,0,0,0.3)'" onmouseout="this.style.borderColor='#34495e'; this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                                    <div style="font-size: 2rem; margin-bottom: 15px; filter: grayscale(30%);">🔑</div>
                                    <h3 style="color: #ecf0f1; margin-bottom: 10px; font-weight: 400;">Public Key Converter</h3>
                                    <p style="color: #95a5a6; font-size: 0.9rem; line-height: 1.5;">
                                        Convert public keys to addresses across Bitcoin, Ethereum, and other blockchains
                                    </p>
                                    <div style="margin-top: 15px; color: #3498db; font-weight: 500; font-size: 0.95rem;">Open Tool →</div>
                                </div>

                                <!-- Address Finder Card -->
                                <div style="background: #2c3e50; border-radius: 6px; padding: 25px; border: 1px solid #34495e; cursor: pointer; transition: all 0.2s ease; text-align: center;" onclick="openAddressFinder()" onmouseover="this.style.borderColor='#3498db'; this.style.transform='translateY(-2px)'; this.style.boxShadow='0 5px 15px rgba(0,0,0,0.3)'" onmouseout="this.style.borderColor='#34495e'; this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                                    <div style="font-size: 2rem; margin-bottom: 15px; filter: grayscale(30%);">🔍</div>
                                    <h3 style="color: #ecf0f1; margin-bottom: 10px; font-weight: 400;">Address Finder</h3>
                                    <p style="color: #95a5a6; font-size: 0.9rem; line-height: 1.5;">
                                        Search for addresses using partial information like first and last characters
                                    </p>
                                    <div style="margin-top: 15px; color: #3498db; font-weight: 500; font-size: 0.95rem;">Open Tool →</div>
                                </div>

                                <!-- Training Card -->
                                <div style="background: #2c3e50; border-radius: 6px; padding: 25px; border: 1px solid #34495e; cursor: pointer; transition: all 0.2s ease; text-align: center;" onclick="window.open('training.html', '_blank')" onmouseover="this.style.borderColor='#3498db'; this.style.transform='translateY(-2px)'; this.style.boxShadow='0 5px 15px rgba(0,0,0,0.3)'" onmouseout="this.style.borderColor='#34495e'; this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                                    <div style="font-size: 2rem; margin-bottom: 15px; filter: grayscale(30%);">📚</div>
                                    <h3 style="color: #ecf0f1; margin-bottom: 10px; font-weight: 400;">B.A.T.S. Training</h3>
                                    <p style="color: #95a5a6; font-size: 0.9rem; line-height: 1.5;">
                                        Access official training materials and certification for the B.A.T.S. methodology
                                    </p>
                                    <div style="margin-top: 15px; color: #3498db; font-weight: 500; font-size: 0.95rem;">Learn More →</div>
                                </div>
                            </div>
                        </div>

                        <!-- What BATS Does/Doesn't Do -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-bottom: 40px;">
                            <div style="background: #f0f9ff; border-radius: 12px; padding: 30px;">
                                <h3 style="color: #2c3e50; margin-bottom: 20px; display: flex; align-items: center; gap: 10px;">
                                    <span style="font-size: 24px;">✅</span> What B.A.T.S. Does
                                </h3>
                                <ul style="color: #666; line-height: 1.8; list-style: none; padding: 0;">
                                    <li style="margin-bottom: 10px;">• Provides structured documentation framework</li>
                                    <li style="margin-bottom: 10px;">• Ensures consistent notation (V-T-H system)</li>
                                    <li style="margin-bottom: 10px;">• Maintains chain of custody records</li>
                                    <li style="margin-bottom: 10px;">• Creates court-admissible reports</li>
                                    <li style="margin-bottom: 10px;">• Validates traced amounts (ART system)</li>
                                    <li>• Standardizes multi-investigator collaboration</li>
                                </ul>
                            </div>

                            <div style="background: #fff3e6; border-radius: 12px; padding: 30px;">
                                <h3 style="color: #2c3e50; margin-bottom: 20px; display: flex; align-items: center; gap: 10px;">
                                    <span style="font-size: 24px;">❌</span> What B.A.T.S. Doesn't Do
                                </h3>
                                <ul style="color: #666; line-height: 1.8; list-style: none; padding: 0;">
                                    <li style="margin-bottom: 10px;">• Perform automatic blockchain analysis</li>
                                    <li style="margin-bottom: 10px;">• Replace commercial tracing tools</li>
                                    <li style="margin-bottom: 10px;">• Make attribution decisions</li>
                                    <li style="margin-bottom: 10px;">• Identify wallet clusters automatically</li>
                                    <li style="margin-bottom: 10px;">• Provide risk scoring</li>
                                    <li>• Replace investigator expertise</li>
                                </ul>
                            </div>
                        </div>

                        <!-- Footer Section -->
                        <div style="text-align: center; padding: 30px 20px; color: #7f8c8d; font-size: 0.9rem; border-top: 1px solid #34495e; margin-top: 50px;">
                            <p style="margin-bottom: 10px;">
                                B.A.T.S. is a documentation standard for blockchain investigations
                            </p>
                            <p>For training and certification, visit <a href="training.html" target="_blank" style="color: #3498db; text-decoration: none;">B.A.T.S. Training</a></p>
                        </div>
                    </div>
                </div>

                <!-- BATS Info Tab -->

    </div>

    <!-- Main App Container -->
    <div id="appContainer" style="display: none;">
        <!-- App content stays here -->
    </div>

    <script>
        // Define utility functions early so they're available for onclick handlers
        window.openPKConverter = function() {
            const modal = document.getElementById('pkConverterModal');
            if (modal) {
                // Force display the modal
                modal.style.display = 'flex';
                modal.style.position = 'fixed';
                modal.style.zIndex = '10001';
                modal.style.top = '0';
                modal.style.left = '0';
                modal.style.width = '100%';
                modal.style.height = '100%';
                modal.style.backgroundColor = 'rgba(0,0,0,0.5)';
                modal.style.alignItems = 'center';
                modal.style.justifyContent = 'center';
            } else {
                console.error('PK Converter modal not found - will be available after page loads');
            }
        };

        window.openAddressFinder = function() {
            const modal = document.getElementById('addressFinderModal');
            if (modal) {
                // Force display the modal
                modal.style.display = 'flex';
                modal.style.position = 'fixed';
                modal.style.zIndex = '10001';
                modal.style.top = '0';
                modal.style.left = '0';
                modal.style.width = '100%';
                modal.style.height = '100%';
                modal.style.backgroundColor = 'rgba(0,0,0,0.5)';
                modal.style.alignItems = 'center';
                modal.style.justifyContent = 'center';
            } else {
                console.error('Address Finder modal not found - will be available after page loads');
            }
        };
    </script>

    <!-- Start of app content that goes in appContainer -->
    <div class="container">
        <div class="header">
            <div style="background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1); margin-right: 30px;">
                <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA1gAAAD/CAYAAADsbndjAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAJUOSURBVHhe7N11eFRHF8Dh370rUSBBgzsUt+DBHYpTnBarUEqFr8UdihRoKW0pFG9xLxR3CVqkuLsTICFEVu/3xyYLuQmx3YQkzPs8t0+ZM1mXe3ZmzkiKoigIgiAIgiAIgiAIDpPVDYIgCIIgCIIgCELiiARLEARBEARBEATBSUSCJQiCIAiCIAiC4CQiwRIEQRAEQRAEQXASkWAJgiAIgiAIgiA4iUiwBEEQBEEQBEEQnEQkWIIgCIIgCIIgCE4iEixBEARBEARBEAQnEQmWIAiCIAiCIAiCk4gESxAEQRAEQRAEwUlEgiUIgiAIgiAIguAkIsESBEEQBEEQBEFwEpFgCYIgCIIgCIIgOIlIsARBEARBEARBEJxEJFiCIAiCIAiCIAhOIhIsQRAEQRAEQRAEJxEJliAIgiAIgiAIgpOIBEsQBEEQBEEQBMFJRIIlCIIgCIIgCILgJCLBEpzu2bNn/Pzzz2zfvl0dEgRBEARBEIQ0TSRYgtOYTCZWrFhB7dq1+frrr2nevDk9evTg8uXL6q6CIAiCIAiCkCZJiqIo6kZBSKgjR44wevRotm7ditVqjRLLkiULX375JX379sXb2ztKTBAEQRAEQRDSEpFgCQ65e/cuEydOZP78+YSGhqrDURQrVowRI0bQrl07tFqtOiwIgiAIgiAIqZ5IsIREefnyJXPmzGHy5Mncv39fHX4jSZJo0KABo0aNomrVquqwIAiCIAiCIKRqIsESEsRisbBx40bGjBnD8ePH1eF4c3Nz46OPPmLgwIHky5dPHRYEQRAEQRCEVEkkWEK8nTx5knHjxvH3339jsVjU4UTJkSMH33zzDZ988gnp06dXhwVBEARBEAQhVREJlhCn+/fv8+OPPzJ79mxevHihDkelcYfc7SF3JzA8hstTIPA/da9oypYty/Dhw2nRooVYnyUIgiAIgiCkWiLBEt4oNDSUhQsX8sMPP3Dz5k11OLqsdaHYCMhWy/ZvCQh/BtfnwuXJYHii/osoNBoNzZo1Y8SIEVSoUEEdFgRBEARBEIQUTyRYQjSKorBt2zZGjx7NoUOH1OHo0r0HRQdA3s6gcYHXq7RLEbutvbgOlybCzT/BanitQ3Senp707t2bb7/9lpw5c6rDgiAIgiAIgpBiiQRLiOL8+fOMGTOGNWvWYDKZ1OGodF5Q+Cso1BfcskBsy7Iit7QOOAxnh8LjXaoO0eXKlYuBAwfSs2dP3N3d1WFBEARBEARBSHFEgiUAEBAQwM8//8xvv/3G8+fP1eGoJI1tjVWxweBV3DZiFd9XkQxYTHBnGVwYC8FX1D2iqVSpEiNHjqRx48bIcmSmJgiCIAiCIAgpj0iw3nEGg4GlS5cyfvx4rlyJO9khYyUoMQ586oEkR50OmBAaIDwQrvwE136Pc32WVquldevWDB8+nFKlSqnDgiAIgiAIgpAiiATrHbZnzx7GjBnD7t271aHo3PNCsSGQpwvoPBKfWL0ucn1W0CW4MA7urgZLmLpXFF5eXnz22Wd8/fXXZMuWTR0WBEEQBEEQhLdKJFjvoCtXrjB+/HiWLl2KwRB7wQl0GSB/L1sRC/dsCZsOGF+Rs/4e7oCL38PjPaoO0RUsWJBBgwbRpUsX3Nzc1GFBEARBEARBeCtEgvUOefbsGTNmzGD69Ok8eRL7lDxkHWRvBsVHg3dpW1KV1K8UDWA2wK2/4OJEeHlN3SOaGjVqMHLkSOrWrYskSeqwIAiCIAiCICQrkWC9A0wmE6tXr2bs2LGcP39eHY7OuwIUGwY5Wzi2ziqxNEDoA7j6q+0wxb65sV6vp0OHDgwdOpSiRYuqw4IgCIIgCIKQbESClcYdOnSIUaNGsX37duJ8qt1yQNHvIH9v0HvGXnY9qUWuz3p+Bi5OslUdVGK/QRkzZqRfv358+eWXZMyYUR0WBEEQBEEQhCQnEqw06ubNm0yaNImFCxcSFhZ74Qg0brakqkh/SJcvadZZJZYMKFZ4sBXODoHAU+oe0RQpUoThw4fToUMHdDqdOiwIgiAIgiAISUYkWGnMixcvmD17NlOnTuXBgwfqcFSSDNmbw3uDIEuVlJVYqWkAYwjcXGBbnxV2V90jCkmSqFevHiNHjsTPz08dFgRBEARBEIQkIRKsNMJsNrNhwwbGjh3LyZMn1eHo0hezFbDI1cpW0CK511klRuS0wZCHcGki3JgH5mB1ryjc3Nzo2rUrgwYNokCBAuqwIAiCIAiCIDiVSLDSgOPHjzNmzBj++ecfrNY4MiWXrBHrrHqBq/fbXWeVWFLE8fRfuDAaHm4Fq0ndK4ps2bLxzTff8Omnn+Ll5aUOC4IgCIIgCIJTiAQrFbt79y5Tp05l7ty5BAfHPpKDxhXyfgTvDYR0+VP2dMD4kgGrFe6thQvfQ2DcI3elS5dm2LBhtG7dGq1Wqw4LgiAIgiAIgkNEgpUKhYSEMH/+fCZPnszt27fVYRUZstaGEmMhSzVbUxyDXKmOBjAGw/U/4PJPEHZP3SMKWZZp3LgxI0eOpFKlSuqwIAiCIAiCICSaSLBSEavVypYtWxg1ahTHjh1Th6NLVxSKj4TcH4CsTXuJ1esi12cF34DLU+HGfLCEqntF4eHhQY8ePRgwYAC5c+dWhwVBEARBEAQhwUSClUqcPXuW0aNHs3btWiyWOBZOuWSBAp9CkW/ANWPqXGeVWJGJ1uNDr9ZnxSFHjhwMGDCA3r174+HhoQ4LgiAIgiAIQryJBCuFe/ToEdOmTeP3338nKChIHY5K4wa5PoD3hoBX0bSxziqxNIDZAPf+hvNj4MU5dY9ofH19GTFiBM2aNUOWZXVYEARBEARBEOIkEqwUKjw8nL/++otJkyZx7do1dTi6zDWg+CjwqWv7d1qeDpgQGiD8GVybCZd/BONTdY8oNBoNLVu2ZPjw4ZQtW1YdFgRBEARBEIRYiQQrhVEUhZ07dzJmzBj279+vDkeXrggUHQC5O4Le492aDhhfkdMGg67ChTFwdwVYDOpeUWTIkIGPP/6Y/v37kz17dnVYEARBEARBEGIkEqwU5MKFC0yYMIHly5djNBrV4ai06aDQF1D4K3DP9m5PB4wvOeIxerwXzo+AgAOgxD7Ulz9/fgYOHMhHH32Eq6urOiwIgiAIgiAIUYgEK4UIDQ2levXqnDp1Sh2KStJArrZQbDh4lxSJVWLIgMUEtxfDxQkQfFndI5rVq1fTpk0bdbMgCIIgCIIgRCFW8qcQVquV0NDYy4rj7Qt+m6DKEvAqaZsOKJKrhLMCkg4KdIfaB+C9waD3VveKwmCIfUqhIAiCIAiCICASrJRFkiR1k41bbij/O9TZD7kagqwRRSycwQJ4ZIFy46H2fsjTGWS9uhfE9twIgiAIgiAIwmtEgpXSaT2g+loo8hnoXOHybLixDCSLePYcIQOKAS7PgpurIWMJqLYY8nZT9xQEQRAEQRCEeBOn6Cmd7AL6zLapgIGX4MxgONoJ/NvCs1O2MuRicCX+5MiNiPfDviZw4jPbYxoSYIvrvNR/IQiCIAiCIAjxJhKsFE95tdDqyrRX+zjd/xv21ISTAyDsoUi04iJF7In18gYc+xj2NYQnu22xl1fgxmzxbhAEQRAEQRAcJqoIphAvX77E19eXS5cuRQ3ovaH+CfDMZxuxujAG7q8H5bUNrzzyw3tDbNPbdC5iLyw1DWAIhmuz4MoUCH/0Kia72NZevTcEvArBiW/h8tTX/xqApUuX0rFjR3WzkEjBwcHcv38/Wde2KYpCunTpyJIlC7du3cJqjXkho6IoeHp6kjNnTnVIEARBEAQhTiLBSiHiTLA88tlGYRQr3PsHzo+CwJNR+2auASXGQLbatn/HfP747pAjH68NEY+XqgR+5poRj1ct278l4KRIsJLDmjVr6NKlCy4uLupQkgkPD6dNmzZMmjSJqlWr8uLFC2Q5+rClwWDg/fffZ+XKleqQIAiCIAhCnKKfXQgplxVQZMjdAmrvhdJTwCXbq3jAftjfCI72gOBr7+60wcjpgM9O29aqHWoTNbnyyA8V5kCtbeBTy/a4vuvJaDIzGo2Eh4cTFBSUbIfBYCAkJASLxUJQUBDBwcHR+gQFBREeHk5ISIj6JguCIAiCIMSLSLBSIwugSwfF/gf1jkD+j21T3QCsRri5AHZVgXMTwRRsSzbeBZGJVfgTODkQ9vjB/XW2USwArScUGWB7zAr1sj1mYjrlWxE5NVCSpGQ71Nen/re6XRAEQRAEITFEgpVaKZH7OOWFin9AzR2QJWKqG4AhAM4Oht3V4fbatF/WXRORXF6bb0suL/8A5uCIoAw5Wto2FS43CVyyiE2aBUEQBEEQhCSRlk+53w1KxPS2bH5Qcxv4zgePgq/iQWfgUDs40BqenUx70wYjy64/3At7G8K/PSHk+qt4hjJQdTVUXwMZy4jEKoWIXPqpKEqcR3yo/yamA3hjYQtBEARBEARnEUUuUoh4FbmIzzOlAUKfwOUf4frvYAp6FdN6QoFPocj/wCN7xJqu1/84FZEiEqsX1+HC93B7MVgNr+Iu2Wz3s+Cn4JI+flMBNaLIRXLZsWMHgwYNQq/Xq0NRKIrCmTNnCAkJiXXaXsmSJUmXLl2sCZnRaKR+/fp89tlnlC5dmuDg4BgvU1EUmjZtysaNG9UhQRAEQRCEOIkEK4VwWoLFa8nHszNwfnTEOqTXMgz3fPDeYMj3Iehc45d8pCQawPACrs20JZIGddn1rlBsCKQvkLAkUiRYyUZRlDhHkyRJwmg0UqlSJc6cOfPGZEij0bB//36qVq2KxRL7i1mj0XDt2jXKlSsXa4L1/vvvs2HDBsLDwwkMDCQgIIDHjx/z9OlTnj17hslksv+toijodDry5MlD6dKl413e/eXLl5w/f57Lly8TGBgY422JiaIouLq6kidPHkqUKBHv6xMEQRAEIXmIBCuFcGqCFclepnwjnB8ZQ1l3Pyg+Gnzq2v4d+/nu2ydjSxTvbrDdn6DTUeNZakHxMZCtpu3fCb0/IsFKcUwmE76+vpw+fTrGBCQywfL396dy5crqcIzik2Dlzp2b0qVLc+vWLQICAuzVBeP6uMyaNSvNmjVj0KBBFClSRB0GICgoiJkzZ7Jw4UKuXr2KyWRSd4kXSZLInDkzjRs35rvvvqNUqVLqLoIgCIIgvAViDVZaZi/r3hzq7IPSU8HV51U84AAcaAxHPoIXKbisuxRZdv0U+LeBw22jJlceBcB3nm0Nmk9NUXZdcIgkSdy9e5eNGzdy9uxZHj58SFhYGIqiRKs4qD4eP37M/PnzqV27Njt27FBfNLdu3bInYBcuXLCPhCXmUBSFJ0+e8Ndff1G7dm2xb5cgCIIgpBAiwXoXWCLWXxXrD3WPQIFPXivrboJbf9oq750dD6YXKaese2RiFf4YTn4He2rA/fWvlV1PB0UHQt3DULAHSPrUN91RSLHUCY0Uw2iXWmS/Bw8e0LNnT65ff1VwxWAw0Lt3b/z9/RN0mW/y+mU8e/aMjz/+mMOHD6u7CYIgCIKQzESC9a5QIsu65wHfWVBrJ2Sp8ypuDIBzQ2FXdbi9xtb5bb46NNiKVlydCzsrw+UpYH5pi0ky5GgFdQ5A2YngGlF2XRCSiBJDRcLYSJLEnTt3+P333+1ta9eujXFU63Xq61EfbyJJEkFBQUyaNEkdEgRBEAQhmb3NU+gUwWQysWLFCubNm0doaKg6nPYoEdPnslaHmlug4kLwLPQq/uIsHPoA/FvB0xPJP23QXnZ9D+xtAMd7Q+jNV3GvslB1LVRfDd6l34my6zdv3mTq1KkcPXpUHRKSUGyJzZva1Xbt2mVfY7VhwwaISIZioigKbm5ulClThipVqlC5cmX7UalSJXx8fOK8Tn9/f+7evatuFgRBEAQhGb3TCdaRI0do1aoVnTp1olevXjRs2JBt27bFWd0sTbBgm1JX4EOoewjeGwI6r4igFR78A3trwYn/QdiDpE+0IqcDBl+Doz1hfyMI2P8q7poNSk+G2vsgdwvb2rI0/jS9fPmSX375hZo1a/Ltt99Sv359/ve//3H//n11V8GJFEXBw8ODevXqMXDgQObNm8fq1atZu3Yta9euZd26daxcuZLOnTvHmfA8f/6csLAwgCjTBdUURUGr1TJnzhyOHz/O/v37OXDggP04dOgQBw8epHTp0rFe5/Pnz0WCJQiCIAhv2TuZYN26dYsvvviCevXqsWnTJntC5e/vT/PmzenWrRvnz59X/1naZAFcMkOZ76H2fsjVDiStLWZ+CVd+hF1V4cossIQlzfosDbb9us5NhF3V4OZ8sBojYq6Q/2OocwiKfQu6dGl+OqDVauWff/6hbt26fPnll9y5cweA4OBgfvzxR6pVq8aMGTMICQlR/6ngJH5+fuzYsYOJEyfSo0cP2rRpQ6tWrWjVqhUtW7akXbt2/PbbbxQuXDjWhCeSoihxjpD7+PjQuHFjNBoNWq02yiHLMvnz56datWrqP4vCarViMLy2H5wgCIIgCMnunUqwgoOD+emnn6hevTq//fZbjCeoRqORJUuWUKNGDUaMGMGTJ0/UXdKeyPVZ3iWh6gqotha8K7yKh96CE5/Zpuw92PlqGp+jZGxXfHsN7K4JZweD4fGreJbaUGMbVPwD0uV/J6YD/vfff7Rv357WrVtz7NgxdRgifiDo27cv9evXZ/Pmze/GiGsy02ji/iXBzc0Nd3d3dXOiaTSaOK9Xq4348SMWb5qCKAiCIAhC8nDGaXKKZ7FYWL9+PbVr16Z///7cu3dP3SWaZ8+eMXbsWPz8/Fi4cCFGY8SISlpmBRQJcr0PtfdAmR+jlnV/6g8HmsCRD+HF1cRPG7SXXT8J/q3h8AeqsusFwXcB1NwK2Wq8E2XXHz58yMCBA6lVqxarV6/GbDaru0Rz+PBhWrZsSefOnTl79qw6LDggvqNS8ekXX2FhYezZs4fdu3ezc+fOaMe+ffu4ffu2+s8EQRAEQUhh0nyCderUKdq1a0ebNm04ceKEOhyny5cv0717dxo1asS+ffvU4bQpsqz7e99A3aNQ4DNVWfe/Isq6f5+wsu72suuPbBv67qkBDza8KruuSw/vDYZ6h6HgR+9E2fXw8HD++OMPqlWrxg8//EBQUJC6S6xMJhPLly+nRo0aDBky5N0YcU2DJEniyZMntGrVirp161K/fv1oR61atVi/fr0YoRIEQRCEFC7NJlgPHjzg22+/pWbNmqxbtw6LJeYzdY1Wh0/OgmTPXRi9i5s6bLdnzx4aNGhAr169uHbtmjqc9tjLuueGir9Drd2Qte6ruPEpnBsGO6vCrVVxl3W3l12fAzsrweWpYI6YoilpIGcbqOMPZcbb1oTF/HSlGYqisGPHDurXr8+nn37KjRs31F0SJDAwkAkTJlClShXmzZsn1uGkUSK5EgRBEISUL7ZT4lQpNDSU33//nWrVqjF16lSCg4PVXezyFCzF16OX8sPCU/yw4CTfTVxH4eKV1d3sjEYj8+bNo1q1aowfP57nz5+ru6Q9kYlWlqpQYwtU/BM8C7+KB5+HIx3gQEt4ejz6tMHI9VoPdsPe+nD8Ywh9bZqTVzlb2fVqK8Gr5DuxzurChQt8+OGHNG3aFH9/f3U4Gu98fhRvMZPsZToja3TqcBTXr1+3V8TcvXu3OiykcK9vHhzTIQiCIAhCypdmEiyr1crWrVupX78+n3/+OTdvvrZ3kkoG76x07jORsTP3U7VuW3R6V7Q6F8pWacjI33bR+7sZZPbJo/4zu8ePHzN06FBq1KjB8uXL7fvcpGlWQNJBgW5Q9yC8N+xVWXfFCg83wp5acOIbCLtvS7Q02NZqHekOBxpDwIFXl+fqA6WnQp19kLv5O1F2PSAggFGjRuHn58eiRYvifN24ZyxA8Ra/U77bFnJX+ZSSbf+iTOe1eOWpqu4azb59+2jSpAndu3fn0qVL6rCQQkWu60rM8frfC4IgCILw9qSJBOvcuXN07tyZ5s2bc+jQIXXYTqd3pW6L3oyesZc23Qfi4uqB0WhEUawoihWT0YhGo6dJuz6MmbGPZh2+xtU9nfpi7CKvt0WLFrFeb5piL+s+FuocgFztX5V1t4TAlWm2UuuXZ8L5H2B3Nbi1MGrZ9QKfQt3DUKy/ba1XGp8OaDAYWLhwIX5+fowePZpnz56pu0ShdUlH3urfULHXfnJV/gxZ64rFaEKxWslStBkVum/nvfd/wdXrzT8CoLreMWPG8PTpU3UXIQXRaDT4+PiQPXv2RB2Rf+viErFeUhAEQRCEt0JSUvHPnY8fP2b69OnMmDEjzul6pSs1oHW3wZSoUAdFsWKJo0qbrNGg1Wq4fPYofy/+gaN71qJEFmOIgYeHBx999BEDBgwgb9686nCcXr58ia+vb/TRBr031D8BHvlS3tQ5GVAUuL8Jzo+C5/+qe0SVpS6UGA1Z/Wz3JaXdHw224huXp6ojLF26lI4dO6qb47Rv3z5Gjx7N7t274xxZkGQtWYu3Ir/fQNLn8kWxWlGsMWSfkoxGqyHs+R1uH57G3ePzMYfF/voHKFasGEOHDuWDDz5Ar9erwymSyWTC19eX06dPxzhFTlEUNBoN/v7+VK785um9r7t27RrlypUjODj4jZfZtGlTNm7cqA5FER4eTuXKlWO9bfnz5+fUqVOkS5eOsmXLxto3V65c7N27lwwZMiS49P7rl5khQwZ0utinkgqCIAiCkHRS5QiWwWBg/vz5+Pn58f3338eaXGXNUYC+wxYyaPIGSvrWwWwyxZlcAVgtFowGI4WKV+KbMcv4dsIaChWvpO5mFxISwowZM+K19ivNsJd1bxZR1n0auOZQ9wLPQlBxIdTcDNn8Iv5O3SltuXbtGr169aJRo0bs2rUrzuQqfY6ylO20mtLtl5E+py9Wsynm5ArblEyLyYRL+pwUbTKVij13kbV4K5BifztfuHCBbt268f7778dr7ZeQvBRFIUOGDGTKlIksWbIk6MicObP9EMmVIAiCILxdsZ+RpUB79uyhUaNG9OzZkytXrqjDdukyZKLTZ+P5fvYh6rz/IZIkYzIaE3xmbzYZsSoKlWu3ZPjP2+jZfzoZs+RUd7O7f/9+vKoXpikWQOsB731lm/qXofSrWN6PoN5RKPDhO1F2PbKaX7Vq1Zg3bx7h4eHqLlG4ZsjJe01/okKP3WQp1gLFqmC1xL42K5JitWAxmUjnU5YyHVZQrvMa0ucor+4WhaIobN++nQYNGvDJJ584XL1QiB9JkuLcJPj+/ftMnDiRCxcucOXKFS5fvhzr8d9//7Fjxw6WLVvG9OnTGTp06LtR4VQQBEEQUrhUk2BdvXqVHj160KhRI/bu3asO22k0Oqo36MS4Wf606zGYdOkzYTQY4xxBiJWiYDQY0bt60KxDP8bNOkizDt/EWtb91KlTtG3blrZt23Ly5El1OO2JrDaYLje4v5aA+tQDN+80n1iZzWZWrlxp34/q8ePH6i5RaHRu5KnSl0ofHyJv9a/R6tNhNZsS/AMAgNViQlEkshRviW/PXbzXbBou6bKru0URFhbG7NmzqVq1KpMnT+bFixfqLoKTRH725MqVSx2yi5ziN2XKFMqVK0e5cuUoX758rIevry8NGjSgU6dOfPXVV0yYMIH79++rL1oQBEEQhGSW4hOs58+fM27cOKpWrcqCBQswGiOKJcSgSMmqDJ22hS9HLSJ77sIYwo1Y3zTNKhEUqxVDuJFMWXPR45sfGT1jLxVrtopxTQURlQ3//vtvatWqRf/+/d+Nkx+rLSF99W9rYnKGVOXo0aO0aNGCjh07cvbsWXU4CkmSyVK0Gb699vDe+7/ikj4XFpMp1vV98aNgNZnQ6DzJU+0rKn1ykNyV+qDRuas7RvHo0SMGDBhAjRo1WLNmDeZ4TJ8VEqdRo0bqpmgkScJgMBASEhLnEflcRX7+yLL8xs8iQRAEQRCST4pNsIxGI0uWLMHPz4/hw4cTEBCg7mKXNUd++gyZy4hfdlLKty4WsyVJTxQtFrNtfVaxivT/fgVfj11O7gIl1N3sgoOD+emnn6hWrRq//fYbISERG+wKqdqtW7f44osvqFOnDps3b46zMEE6n9KU6biSMp3WkCFXpYh1Vs59nSqKFavJhGuGvBRrMYMKPXaQuUgTdbdoTp8+zQcffEDr1q05evSoOiw4QefOnfH19Y1zNF2991VchyAIgiAIKUuKTLAOHjxI8+bN6datG+fPn1eH7TzSefF+x28YO/MA9Vr0RKPRJmqdVWKZTEZQoHq9Dxgz8wCd+0wgQ8Zs6m52kSfk9erVi9cJuZAyRSbM1atX57fffiM0NFTdJQoXTx8K1RuLb8/dZC3RBiQ5Yjpg0lGsZqxmE165q1K28xpKtfuLdD6l1N2isFqt/PPPP9SrV4+vvvqKO3fuqLu8Feo9nl4/Xo8nhLMuMz6XE/n/Xl5eLFiwgNKlS0frF1/q63j9MqxWa4IvTxAEQRAE50tRCdaNGzfo06cPDRo0YNu2bW9MQDQaHVXqtGPE9J10//pHMmTM5vg6q0RSFAWj0YibmydtPhrEqN/2UKdZD/R6V3VXuyNHjtCyZUs6d+7MmTNn1GEhBZJl21tl3bp11KlTh/79+3Pv3j11tyg0OndyVuhJxd77KVB3GFqXDLbEKhlfp1aLCSQt2ct1xbfXXgo3+B6XdD7qblG8fPmS6dOnU716daZPn87Lly/VXZKNJEm4uLggyzKurq7RDhcXF1xdXe3PT3xIkoSrqyt6vT7a5bm62t638S1jH9tt02q1uLi4RBllKlGiBNu3b2fIkCHkz58fjUYTLVmK7ZAkCTc3N7JkyULWrFnJlSsXBQsWpHTp0tSpU4dMmTJFuX2CIAiCICS/FLEPVlBQEH/88Qc//vgjDx8+VIejKFKyKq26DaKC3/tIkoTZlLQjAQml0WrRyDKnj+3i78U/cObYjljXgXl5edG3b1969uxJ8+bNo4/YpeR9sGIiAfubwMMttn9XXAAFPkodRS5i2Qdr6NChXL9+nRUrVsRZGVKSZDIVrEf+WsPxzl8Dxao4fSpgYkiSjKzVEPL4Ejf2T+LB6SVYzQZ1t2gqVqzIiBEjaNKkCRqNRh1OUoqicPnyZcLCwmKdDle4cGHc3WNfbxbJaDRy6dKlN/6Ao0SUS8+fP786FEVct01RFFxcXChSpEiMj1tgYCDnzp3j1q1bb7yMSLIskyFDBry8vMiSJQteXl5IkoRer0ev1+Pm5oZOp4v1MgRBEARBSB5vNcGyWCz8/fffjBkzhv/++08djiKLT16ad/6OOs0+ws3dE6MxcRXXkotOr8diNnN49ypWzh3NvVsX1V2iyJ8/P8+ePSMoKChqQCRYySeWBEuj0cSZWAF4ZC5KgdrDyFayPbJWn+RTARNDkrVIEjy7vpsb+8bz9NquON9LGo2GVq1aMWLECEqXfq0MvyAIgiAIghDFW0uwjh8/zqhRo9i0adMbf0kGcHX3pGGrz2ja4Wuy+OTEaDA7oeJa8pAkCZ1eR9CzJ2xd8zubVk7nZdBTdbfYiQQr+cSSYMVF5+ZF3mrfkKtSX1w8M2ExmeNMWt4uCVmrxWo28vD0Eq7vGUfos7j3UEqfPj2fffYZ/fv3J1u2N683FARBEARBeFcle4J17949Jk+ezNy5c2Nd2yFJEuWqNaND79EUKl4ek8mCNR4jCCmRLGvQ6TXcvn6RVfNGc3jXKiyWeE4Z02eMSLDypuzz9UipOcHSASe+hUvxT7AkjY7spTuSz28Qnj7FUSxWlFimhKY4EdMGjcGPuXtsJrcOTsMU9lzdK5r8+fMzaNAgunXrhpvbm/eDEwRBEARBeNckW4IVEhLCvHnzmDx5cpzVyfIUKk373qMoX7UpWp0LZtOb975KTbRaHVbFwtnje1gxeziXzx5Wd4lOmw7qHIBMpSGeOVmMZGwjKmYTaPW2/aqSQnIkWBK2+2KJuC+Kg4NFUsTj8/w8/NsLnsXjeQG88lanYO0RZCxUH5BQ4ps0p0CSpEHSyrx8cJYb+yfy6OwKW4GMOPj5+TFixAjq168v1v8IgiAIgiAkR4JlsVjYsmULY8aMiXN/Ha9MPrTsOpA6zbrjmc4Lk8lEEt+8t8A2bTA8LAT/7ctYs2Acjx/cVHeKKt178N5QyNPellAkJFmJTB6Cb8PFiRCwFwp9CQU/dSwpeZOkTrAkwBwCZ4bA412QrycU/Bj0ngm/jsjHJuQxXP0Zrs0AU6C6VzTuGQuQr8ZAspfpgkbvgdWc0qcDxp+k0QEWnl3dwbXdowm8fUjdJRqdTkf79u0ZOnQoxYoVU4cFQRAEQRDeKUmaYJ0+fZpx48axbt06TLFU+3Nx9aBavfa06T6U7LkLYjaZY12XlRZIkoxOpyXg8T3WL57M3s0LCQmO7eRegmz1odgIyOpna4rrIdIAhmC4PhuuTIWw+7Z2SQOVFkO+DglPSuKS1AmWDJz42pYQRfIub3tccjQHWY77cSHisTGFw60lcGkivLyi7hGNzs2bPFX6kaviZ7ikz47VYk7WkuvJx7Y+y2II4cF/i7ixfxJhz2+oO0WTKVMm+vbtS79+/cicObM6LAiCIAiC8E5IkgTr4cOHTJs2jZkzZ0avivcaSZIp5VuPtj2GU7xcDaxWKxZz6p1mlRiyRoNGo+HO9XOsmjeGI3vWxL4+S+MGebrCe4MgfQFbMqF+BmXAaoF7f8P5MRAUQ4VGb1+ovR+0rtH/3hFJmWDJwPOzsKsKWEKixiQN+DSFEqMgY/k3TxuUsSVFj/bA+dG2Eb04yBodWd5rQYE6I0jnUxrFmsrWWSWWJCNrNBiCH3LLfyr3js/BFBbbjwA2RYsWZciQIXTo0AEXFxd1WBAEQRAEIU1zaoIVHh7OX3/9xYQJE7hxI/ZfvLPnLkK7nsOpVr8DWq0OkzFtrLNKLK1WB8CxA+tZ9+cErpw7ou4SlWs2KPwNFPwMXDLYEhgp4gg4ZkseHm2GN1Vc1LjbimdkKBq/EZ/4SsoESwNcXwjHuqsjr2g8IH8vKDoAPHO+SkAjpwMGXoaL38Od5WCNew+oDLkrU7D2CDIVboQkaeK1LimtkWQNkizz8tFZru8ezaPza+NMMCVJonbt2owaNYqaNWuqw4IgCIIgCGmW0xKsnTt3MnLkSPz9/dWhKDJ4Z6Nxu77Ub/kJ3pmz2fazcs5NSBN0ej1GQzh7N//JmvnjCHgce0EQMpSyTY/L3Q5C78HFCXBzPlhC1T2jSl8Sau8Bl0wxj/QkVlImWDLweD/sbxz3/XPLAUUGQoFe4OIBYc/hyq+2qYXGuEvlu6bPRf6aA8hRvhcavXuaWmeVWJJGC4qVgMubub5nDEF3j6m7ROPi4kKXLl0YOnQoBQoUUIcFQRAEQRDSHIcTrEuXLjFu3DiWL18e6zorjUZLjUZdaNN9GDnzFcJksGCN41fwd5UkyehdtDx+cId/lv7Irg3zCAt9oe72iqSFTNUh9AaE3lZHo9J6QL6IER73nM7PGZIywSLi8p/9C+dGwsPNcSc9GStBjtZwezG8OKuORqPRu5PL92PyVv8WV69cWM2WN48CvpMi1mcZQ7h/Yj439k8iPOiuulM0WbJk4ZtvvqFPnz54eXmpw4IgCIIgCGlGohOs58+f8/PPP/Prr7/y9GnsIwLFy9WkXY8RlKhQB+CdW2eVWBqNBo1Ww5Vz/7Jy3mhO+P+j7hJ/kgw+zaD4KMhcPua1W86Q1AkWr60xu7sOLoyNeY1ZAkmSRJZirchfYxAZcld6d9ZZJVbE/llhz25xy38K907Mw2KMY1QRKFmyJMOGDaNdu3ZoNBp1WBAEQRCEt8xsNmMwxL2MIi6urq7v7Hd9ohOsH3/8kf/973/q5ih8chakbY/hVKnTDld3j3d+nVViaXU6zCYDxw9sZOW8Udy+FvdITBRe5aD4SMjxPsga5665UkuOBCuSBjC8sFVJvDwVwh+oe8RLOp/SFKg9nCzFWiLJOpR3cJ1VYkWuzwq6c5hru0bz9Oo2lDhG/Nzc3Dhy5AilSpVSh3j58iUBAQGpYk8tvV6Pu7s7Hh4eaLVaddghiqLw4MEDjEZjoh8LRVHw8PAgS5Ys6pCQRoWEhPDkyZNEv2YiZcuWDVdXV3Wz4ABnvKfVsmbNKjZ6f0c8ePAAg8GQ6NeOoii4u7uTNWtWdShGO3bs4Isvvkj0d1tkajF79myqVaumDr8TEp1gTZgwgSFDhqibAXD3zEC9Fr1p0flbvDP7YDKa4zzpEmInSbb9s4IDn7F743zWL55M4LNH6m5RueWEIt9Cgd6J2ycqMZIzwSLi+mQg+BZc+gFuLoh7fVYEF08f8tX4lhzle6Jz8xbrrBwga3RYLQaeXFzPtd1jePnozT8C6HQ6jhw5Qrly5dQh/vrrLz755JNUcXLn6uqKp6cn3t7e5MqVi6JFi1KuXDnKlStHgQIFHPrVLjQ0lLp163L27Fl0OlsBnIQKDw+nY8eOzJ8/Xx0S0qi1a9fSrVu3RL9mFEVBkiTWr19PjRo11GHBAWfOnKFJkyYEBwcjy7I6nGAGg4GRI0cycOBAdUhIY6xWKw0aNODw4cPo9Xp1OF4MBgNNmjRh9erV6lCMVq9eTbt27dTNCbZ161YaNmyobn4nJDrBmjhxIoMHD1Y3U6H6+3TuM4G8BUtitYLFkhY3C347JEmKKOsu8/DuDdYvnszO9bOjl3XXuEP+3lD0W/DMnXTTAWOS3AlWJDniup/EXUFRo3Mje5ku5K85GPfMBbCaLOIHAGeQJDQ6LaaQ59z9dzY3/adifPlY3Qu9Xs+RI0coW7asOsTcuXPp3bu3ujlVyZAhA+XKlaNt27a0a9cOHx8fdZc4hYaG4uvry4ULF9ShBPnggw9YsWKFullIo5YvX07Hjh3VzQm2a9cu6tSxTekXnOPrr7/m559f27/RCQoXLsyhQ4fIlCmTOiSkIVarlSpVqnDsWNyFpWLTsGFDtm7dqm6O0dq1a2nTpo1DI2YA27Zto0GDBurwO8Hxn1Fek94rC58O+oM8BUtiNpt5EfQEi8WEVpe4jFuIJEVUFwwlJDgQk9FM1hz5+OjLKfjkKqzuDHk6g+/P4J7bltgkV3L1Nlmx3dfMFcHvb9tGyrr06l7IGj2l2y+jeKvZuHrlJTzwIZJGRpISP9og2AqzyBot4YEPkfXpyF9zAL7dd+CaIZe6a7xIkpRqj6CgIPbs2UO/fv2oWLEiP/zwAyEhqn3b4kGK+GJTX358j9cvQ3g3iNdMynT79m2WL18ODjw3MR1XrlyJ94iEkLpJ4r2d6jg1wdJotUiyBqvFitVqZcb3PZk0oCVXzx9D76JHo0ncXM53mVarRavT8t+RHYz+oh5Lfh+MVqvFYrZgsVhifsNo3N680W5aZ8W26XCuluCaUx1F1rnhmb0skgyBd45w5I8qXN05BrMhCI1OBzE9nkIsJDQ6HWbjS67t/p4jsyoTeOsACuCWsSA6N2/1H6R5r3+p3b17l4EDB9KwYUMuXbqk7ioIwjtg0aJFPHz4MObvawfNnj2bsLAwdbMgpDomk4mgoKBEH+YUVkDPqQmWotj+o9HJHNi2hBP+/3Dm2A5G96vD/J++4XnAffQueiTJqVebJsmyBr2Lnnu3r/Dr2O5M/LYp1y8dZ8+mhfx3dDtanTYif4ohixJTMiMKecT0OChgtWAxGLm+ezThgbe4vnsUR2dX5/5/y0FRkDWJW7/wrpE1OpDgwZnVHJtTg2s7hxEedJtru0djDg9BUazv/PTgyETr4MGDNGvWjNOnT6u7CIKQhj179oyFCxeqm53m33//ZfPmzepmQUh1/vrrL4oWLUrp0qUTdJQqVYoyZcrw77//qi/yrUqSTMdqgVtXX5XONoSFsHH5NIZ95seW1b9jNhvQ6fXYFs0Ir5MkCb2LntCQQFbN+56RfWqwb/OfmM22ynZWi5nb12wnaeLRSyRJxhD8gPDAV3uGhTy5wJmVnTm1pBWBd44ga3VIshhxjYkka5C1OoLuHee/pW05s7wDLx+dsccNQXcxvLgnpl2+RpIkrl27RteuXbl//746LAhCGrVmzRouX76cJKNXkZc5a9asd/7HLCH18/f359GjR9y+fTtBx507d7h16xbh4eHqi3yrnJ5gKREL8jr3mci3E9aQr/CrSmEBD28xZ/LnjPuqIacOb0Oj1aDRitGCSJFr1Q5sW87Iz2uz7I9hvAh8Yo8XL1+b4dO30+SDLzGbzTGOzwhxU6xm3Lzz4ttzN/lrDkbrGrHxrWIl4PImji+ox8V/viI86A6yTidGXCNJMrJOhyH4AZc2f8vx+XV4cnE9imKrYKJ1SU/e6t/i22sP7pkKo1hT1nD92yZJEmfOnGHEiBHqkCAIaVB4eDizZ89WNzvdrl272L9/v7pZEFINs9nMuXPnIBHrzABkWU6SHzEckTRnjoqCLMtUqd2akb/upOvnk/DK9KqS1qUzB5k0oDm/je3OvZsX0bvonVK2NLXSaLTo9HqunDvK5EGt+XlkZ+5cf1XmOlvOgnw6aA5Dpm6iZIU6EVMxo1yEkECKoqD3zErhhuOp2HMP2Uq0tY9YWYwh3D48nWNzanD74G9YzGHIWt07PWYoa3UoFgN3jszi2Jwa3PKfitkQDIAkachSrCW+PXZTtMlkXNJlF1UZY7F48WIOHjyobhYEIY3ZunUrR48eVTc7lSRJmM1mZs2apQ4JQqrx8OFDrl+/rm5O1ZIsq1EUBaPRiKt7Olp9OIDRM/ZRt3kvdHrb/jZmk5F9W/5iZN9arJw7jpCXQRHrs96dk1hJktG76Hn25B7zp33D2K/qceLgRvvJqbtHBlp2HcCYGfto0KoXGo0uYrNmkV05g2K1YDWb8MxehtLtl1Om4yrS5Shvj4cH3ebixi84vqAhAZe3Ism2SnnvEkmjRdJoeXp1J8cXNubC+s8Ie37DHk/nU4bSHZZTtuMq0ucsj9VsQrEmdU3+1EuSJMLDw5k7d646JAhCGjNz5kx4bSpfUlq/fj1nz755/0FBSMmuXr1KQECAujlVS7IEK5JitWI0GPHJVZDPBs9myI+bKV6+tj0eHPiE5bOHM/LzWuzfZitjqkvzZd1tZdfNpnC2rPqd4X1qsGn5NMJDX0JEgYtKtVoz8tfddOs7iQyZsmE0GMWoQBJRIvZqy1q8Jb49d1Ok8RRc0mW3x4PuHOLkouacWfUhLx9ftE0bTOMjrlLEdMDQgCucW92Dk381JfDWqykottG/ifj22kO2km1RFLBabOsEhbjt2LGDJ09eTf8VBCFtOXDgADt27FA3JwlJknj58mWyTEcU3g1Wq+18U1GURB3qy4nLmTNnUCI2Ok8rku0s0WI2YzaZKVmhNkN/3EyfIXPJlrOgPX73xjmmj+zEDwNbcvncEXQuemRN2lskr4kou37q8DbGftWQOVM+J+DhLXs8X+Gy/G/8Kvp/v4L8RctiNBqxWsSIQNJTsJpNaHQe5KvxPyp+7E8u30+RtbYRV8Vq4uHpxRyb48e1HaMxhQWm0bLuErJOh9nwguu7vufYbD/un1qI1WIEQNa4kLN8Tyr19id/rYFo9emxmk0pclRV/YHv6OFMt2/f5syZV4VBBEFIW2bOnInZbE7WE8Zly5Zx+/ar4k2CkFgZM2akXLly+Pr6JuqoUKECFSpUwMsrYo17HE6dOqVuSvUkJZFnDhMnTmTw4MFR2rwyZeeHhSdJnyEz1limCUmShE6v49mTh2xc/hPb1s4kLOSFPe7i6kG9Fr1p3vl/ZPHJjclkRolnFpxSybIGrU7DnRsXWbNwPAd3LMMSURkQIEPGbLzfsT8NWn+KZ7oMGA2xn7RKkozRGMbQ3pW5e/NC1GDBL8D3F9vGu8lNAvY3gYdbbP+uuAAKfJS8t0UCzGGwozwEX4wS0rqmp0qfE7h5F4i1CIMka5Fkiec39nNt10ie3dgdJe6RpRgFao8gW8k2yBp9RJKRuskaHYrVzKML67i+azQvH0edbuKVtwaF6o4hY4HatqQjlscPScZqCuXo7Gq8fBT1cvR6PUeOHKFs2bJR2gHmzp1L7969HTopURSFHDlyUKtWrXj/evYmVquVhw8fcuHCBfv0BUduWyRFUfj555/58ssv1SEAQkNDqVixIufPn0/09SmKQvv27e0bnApp34oVK+jQoYNDrxlJkti5cyd16tRRh4V4OnfuHFWqVOHly5eJfi4SQ1EUvv/+e4YMGaIOCamY1WqlatWqHD16NNGvJ0VRaNSoEVu2RJybxUFRFIe/P4ln8Qmz2Uz16tUTff+UiLoPu3btolatWurwW5NsI1ivUxQFo8FIeu8sdOs7iVG/7aFSrTbIsm3EyhAewqYVPzP8Uz82r5yByRieasu6SxFl10NeBrJi7lhGfObH/i1/2ZMrnd6Vus17M3bmAVp/OABXVw+MBrHO6m1TrGasZhPe+WtQ/sPNlGizAPdMhe3xkCcXOLOqMycXtSTwduou6/6q7Pq/nFzSmtPLO0RJrtwyFqB4qzlU6L6VjAVrY7WYYk+uUoDy5cuzZMkSli1b5tCxYsUK9u7dy6lTp5gwYQLp06d32mhWWlvQKwiCzZw5c5I9uYq0YMECnj17pm4WhASRJAmNRuPwEZ/3wIMHD7h27Zq6OdV7KyNYalqdDqvVwvEDG1k1bzQ3Lp+MEi9Ssirteo6gTOWGgBRl5Ccl0+r0WEwGDu9Zw5oF33Pnhq0EZaSSFerQrscIipevhaIoWBKwC3WsI1iFvgTfnyH+F+c8aWQEKwpJQqPVEv7iEbcPTefu0d8xhT+3hzU6d3KU70U+v29x886DYrGkjvVykoSs0RIeeJdbB3/k7r+zsRht6wABtC4ZyFXxU/JW+xrXDNmxmC0Q3/v1lkewmjVrxj///KMOOWzFihV07twZi8Xi8G3s3LkzixcvVocghY9gKYrCgwcPOHPmDGfPnuXmzZs8evSIkJAQdVenUxQFvV5P5syZyZ07N8WKFaNUqVIULFgQvT551u5arVYMBoNTft11lKurK5rXptKnxBGssLAwhx+ryNvl4eGhDqU4d+7coVKlSjx8+DDRz4MjFEVh1qxZfPLJJ+qQQ5zxPGo0GlxdbdPuHWU2mzEYDOrmBFO/hxxhNBoxmZx7fipJEhaLhTp16nD8+PFEv6YSOoKVFMLCwggMDIxyH/R6PXv27KFdu3b293lCRY5grVq1ilq1amE02pY0xEZRFFxdXfH29laHnCZFJFhgO9nT6XS8fBHIzg2z+WfpTwQ+fWAPa7Q6qtXrQOsPB5OnYHHMJkvCryOZaDRaZI3M5bOHWT1/LCcPbYlywu2TsyCtPhyCX8NOuLi4YTLF/WJQizXB8mkKVVeA3iN5ExtSSIIlA+YQ2F4Bgi9FCSUqwYogyRokWebFg/+4sed7Hl9YG+UyXDPkJp/fAHKU747WxROr2ZxCRyIlZK0WsyGEB6f+4sb+SYQH3nwVlTRkea8FBWoPI33O8ihWa8IrA6bRBAugadOmbN682eHbGFvykxITrKCgINavX8+KFSs4evQoT548IZFfH07l4eFBiRIlaN68OR07dqRQoULqLommKAq3bt3i33//5cSJE1y9epX79+/z4sULh082HRF5IrJo0aIo76OUlmAdPnyYPn36YDQaE32bAAwGA+PHj+eDDz5Qh1KcyHMjR+6vIxRFoWLFiuzduxc3Nzd1OFHMZjOdOnXi9OnT6HSJ27vUYDDQsGFDfvvtN3UoUTZu3Mg333yT6B9WIk/KFyxYQIUKFdThOIWEhHD27FmOHj3K2bNnuXXrFgEBAUm22e2NGzcIDQ1N9OsqJSRYq1at4uOPP47ynEmSRFhYGC9evEj0fYvk5eWFXq+P1/eSwWDg/fffZ9GiReqQ06ScBCuCJMvodFru377K+sWT2bflL4yGMHs8XYbMNG73BY3bfk6GjFkwGW0V4FICSZLR6bU8fnCbDUumsvufuYSHvfpV190zAw1b96Fp+y/JmCU7JqM50SMdsSZYAN7l4L3hkKslSDIk7moS7m0mWFJEcvXyLlz+Ea79CtaovyY5kmBFsq1VsvDk8iau7x7Di/v/RolnyF2FArVHkLlwI5AkFEviricpSBotoPD06k6u7x5D4O0DUeLpspelQO0RZHmvObKsTXxlwDScYE2ePJkBAwY4fBtjS35SUoJlsVhYunQp48eP58KFqJ81ib1tzvT657+3tze9evXiu+++I2vWrFH6JUR4eDgbN25kwYIFHDx4MMVOuTpw4ADVq1e3/zslJViBgYE0atTIKftANWzYkL///ttpox9J5fnz51SpUoXLly8n+jlwVOT7YfXq1bRp00YdThSTyUTlypU5eTLq7KKEcubn8uLFi+natau6OUEkSWLPnj3UrFlTHXqja9eusXDhQtasWcPly5edPmL1Jo6+ntQJlqIonDx5ksDAwCTdh7ZMmTL2UaJFixbRrVs3dRdwwv1D9V0QH858PcYk6R7VRIos654tZwE+GTiTIT9upmSFuvZ4cFAAK+eOYuTntdm3dSmKYkX71su628qum4zhbF75GyM+82Pzyun25ErWaKhcuw2jft1D174TSO+dNenLrj8/CYfbw4EW8OyE7Zl2/PWbcmkiRq0u/wa7/eDKT9GSK2exRpZ1L9Yc3567KNLkR1zS5bDHg+4c5tTiFpxZ1ZWQxxci1me93beaJMnIWh0hTy5zdnV3Ti56P0pypffMRuFGP+Dbcw/ZSrQGUXb9jbJkyaJuShRn/bqclJ48eUK3bt348MMPuXDhApIkRTlSgtdvz/Pnz5kyZQq1a9fmwIGoPx7E1+7du6lXrx7t2rXjn3/+4dmzZ9Hu99s+eO1+p1SjRo2yL1pP7AGQM2dOpk+fnuKTK8B+0u3o85LQE8XXRV73H3/84dDlqEWehKufo/ger1+GM0Repvp64nu8/rfxERwczMiRI6lcuTJjx47l3LlzmEymaJebVIezKYpCv379qFevHnXr1nX6UadOHerUqcO//0b9AZo3PGfOoL7M2I7I/knJea92J4ss616ifC0GT93I50Pn45PrtbLuN8/zy6gu/DCwFVfOHkav16N5C5vAarU6tFoNJw9tZdzXDZg79QsCHt2xx/MXKcf/xq/mm7HLyVekDEZDMpZdV8zwYCPsqQ3/fgahd22JSNK+plSS+MrkiOPeZthXH05+AaGvyt4nnciy7u7k8/vGVta94mevlXU38/D0Uo7O8ePqzlGYwp6/nbLukoRGp8NsCOLa7nEcm+PHg1N/oUSWXde6kLNCbyp97E/+mt+h1Xum2LLrKYWzPpTz5s2rbkpRHjx4QJs2bVi6dCk48X4npcgvzwsXLtCiRQs2b96s7vJGVquV8ePH07RpUw4ePBjty1iIvzVr1vDrr7+qmxMkcjRt4sSJFC1aVB1OccLDwx3eh0pRFFxcXMicObPDydGuXbsS/SODENWVK1do0qQJY8aM4enTp2nmsyHyNabEsC2Jo4eQghMsGwWT0Ygsa6jbvDvjZh6kVbdBuHtksEUVhVOHtzC6X13mTv2SZ0/uoXfRJ8togSxr0LvouXfrItNHf8ikAc25fPawPe6V0YeufScz6rc9VK7VEquiYE6moeRozMFwfRbsrAyXZ9hGepyzpjMqKeIVFeXNZU2669IAgefgUAc42Aqevnr8k4uiWLGaTLh55aV4y9+p0H0HGQvUs8fNYc+5vns0x2bX4P6ppaBYkbWJm8OeULbrUXhweiVH59Tk2s7hmEJf7ZTuna8W5T/cSonWs3HzLoDVZEraUdU0wllfHiVLllQ3pRihoaH06NGDAwcOpMqTCCliNKtbt24cO3ZMHY5GURS+++47hg4dSnh4eKq8zynFzZs36d+/v8OFYAB69uzp8DSw5LJlyxaOHDmibk6wGjVqMHToUHVzgkiShMlkYtasWeqQkEDnz5+nSZMm+Pv7p4mk6nWR9+X1hNFZh5DiEywbJaKsu6dXJrr2ncDoGXupUqctcsSIldEQxuZVvzDs0+psWvHra2XdnU+yl11/zoo5Yxj+mR8Hti2OUna9XouPGTfLn1bdvsXF1d1Wdt1JJ2UOCb8PJ/vCnppwbxNIFue9AjSA4SmcHgVP/V+1X54GtzeDpDj5ugLgv0G2+3JnBVgTXijEmexl3fNVp3y3jZRssxD3TEXs8ZCAi5xZ2YWTi1oQeOtQkpZ1t5ddv3OUU4tbc3pFR0Iev6pg6ZaxIMVbzaX8R5vJWKAWVrM50evR3kX3799XNyWIoihkypSJihUrqkMpxpQpU9i6dWuq/qKUJImnT5/y1VdfxVnhcNq0afz444+QSkbqUiqz2Uz//v25deuWQ4+joiiULFmS77//Xh1KkZSIyn044fXTuXNnPvzwQ3x8fBz+MWfDhg1iQ3MHBAQE8OGHH3Lt2jWHn1fh3eOsU95kYbVYMBqM5C1Umq/HLON/41dRoOir6i9PH99h3o/9GPdVA04c3IxGo0HrxNECnU6PoljZt2UJIz+vxYo5I3n54tXi55IV6jL0py18OmgWWbLns00HfAuVpuL8IHh+AvxbwOGu8PyUY9MGNYBihOt/we7qcGE0mF+V+iboP9t1HeoAz884dl0yoBjg2jzbaNzFSWBMWYvPrWYTSBpyVPiQir33k7/WULSukWVAFZ5e3crxBfW5sKEf4UF3kHU6WxESZ5BkZJ0Ow4v7XNz4Df/Or0fA5Y320upal/TkqzGASr0PkKtiTyRZJ6YDJpDFYmHbtm3q5gSrX78++fLlUzenCNeuXWP69Onq5lRJkiQOHTrEX3/9pQ7ZnTp1ijFjxkB8PjuFWP3yyy+sXbtW3ZwgiqLg5ubGjz/+SLZs2dThFOnAgQPs3LlT3ZwgiqKQO3dumjZtSsaMGWnRooW6S4JIksSLFy+YN2+eOiTE07hx4xwqjS6825x0Zpe8zGZbkYFKNVsy4peddOs3Be/M2e3xy2cP88PAlvwy5kPu3DiP3kVv38Q4MTQaLTqdnktnDzF5YGt+Gd2VuzfO2+PZcxemz5B5DJryDyXK18JsMmF5i5XjWrZsyWeffYaLi4s69IpigTvLYHct+G8whN1LWPITufbp0X7Y3xSOfRStJLqdYoa7K2FPDTg1CMIfJ/y6JAUe7oa9deHf3hAS+yat+fPnJ0MG21TS5KdgNZnQe2SmcINxVOy1l2wl29tHrCymUO4c+ZWjs6tzy386VlNoxHS++D4gahKyVofVHMbtwzM4OseP24em2fe0kmQNWYu3wbfXXoo0moTeMytWkylljKqmMrNmzWLv3r3q5niLPHn84osv1KEUY8mSJfZ1BmnFvHnz3rhnzk8//RRtbxYh4Y4cOeK0RPXbb7+lQYMG6uYUa9asWfaCB45o06aNvfpl165d0el0Do9iLVu2jNu3b6ubhTicPn1aJKeCQ1JlgkXEiYrJaMTFzYOWXf7HmN8P0KDVp+hdbJW5LGYTB7YtYVTfWiz7YyQvg5/Z1mcl4ANQkmT0LnqePr7D3B+/ZNxXDTh5eLP9A8/D04vWHw5m9Ix91GvRA41GhykeG5wltTx58vD777+zefNmateurQ5HZX4BFyfC7hpwZSZYwmJfMyVFjFq9uAZHe8O+hvB4Z/xGQUxBcGkS7KoKV2eDJTye13UJjvWEA40h4GCs15UhQwYGDx7Mzp07yZUrlzqcrBSrBavZRDqfUpRuv4QyndaSPueraWGGF3e5tOkrji9owJOLm5BkKaKMevxJshZJlgm4vJXjCxpxcUNfwgNfFflIn6M8pTusokyH5aTPXhar2ZTwPa1SoYS8z2NjtVoJCQnh1KlTfPHFF/Tv3x8cvPx+/frh5+enbk4RzGZzkpatfVv+++8/Tp8+rW7m2rVrrF+/Xt0sJFBgYCBff/21w4mqoijUrl2bQYMGqUMp1tmzZx1+DSkRm56+vt6satWqVKtWLUq/hJIkiYcPHybpXj9p1dKlSwkODnbo9Sy821JtghUpsqx71hz5+HjA7wz9aQulfF8VGQgOesqqeWMY+Xkt9m1ZgqJY0cVV1l2KKLtuCmfTil8Z3qcGW1b98lrZdS1V6rRj5G976NJnPOm9siR92fUEiJyWWKdOHTZv3sy8efPi3nwz5Aac6AP7G8P9ba9GqF6niUiSzk2E3dXg5lywJmJTvZDrcPwT2NcAHux883UZnsDZcbCrGtxcEOs6K61WS7t27di3bx/jx4/Hx8fnrUzPjInVYkKxKmQt9j6+PXZQpMlPuKTLaY8H3T3CqSWtOLOyKy8fnUfW6ZDiGHGVZA2yTkdIwEXOrv6Ik4tbEHTnoD2u9/ShcKPJVOixi2wlWqG8Y2XXjx49SvPmzWnWrFmij0aNGlG7dm18fX2pVq0av/32m0MbpiqKQqtWrRg5cqQ6lGLcvn2bS5feMBKdQEoMlaUSczhKkiSMRmOM+zHt3bvX4aRAgNGjR3P48GGHHkclYm3itGnTcHd3V4dTrLlz5zrlRLxmzZr4+vra/63Vap1W4GPBggU8f/5c3Sy8gcFgcMpUcCFm6s94Z3zO84bLfdMR2T8pqU9rU63Isu7Fy9Vk0JR/6DtsAdlzF7bH7928wC+juzJpQEsunTmE7g1l3bVaHRqNhhMHNzPmy/rM+7EfT18ru16gaAW+Hb+Gr8cuI1/h0hiNxkRvqpwcXF1d6dGjBwcPHmTo0KF4eXmpu0T1ZB/4N4fDnSHwvC3R0QCY4eYK2x5TZweD4bH6LxMu4AAcaGpbCxZ0Kep13VhsW9N1bnic66wqVarE33//zfLlyyldurQ6nEJElnX3IJ/f11T62J9clT5H1tlGXBWriYdnlvHv3Bpc3T4CU9gz2/qsaNMGJWSdDlN4INd2juXYnBo8+G+Rquz6xxFl1799J8uuS5LEkydP+Oeff9i0aVOij23btrF//34uXrxIWFhYok+gIj/QW7duzbx581L0yeOtW7cICgpSNyeYoii4u7tTv359+vTpwxdffJGgo1+/frRv356cOXM67UswpsTx8GHnVR5Vf4En5fH69b1ta9eudUpJdoCxY8dSpkwZdTjFunv3LsuWLVM3J8qHH36obqJFixbkzZvXoedZkiSuXLnC6tWr1SHhDW7fvs21a9fUzYmifu8m9kgL0sr9iC9JSeQ9njhxIoMHD47S5pUpOz8sPEn6DJnfatIhSRI6vY7Ap4/ZuPxntq75jdCXr04a9C5u1Hm/Jy27DiBr9jyYjGYkSUKr03D72nlWLxjH4V0ro6yj8sqUneadv6V+i954pEuP0fB2T1olScZoDGNo78rcvXkhSuyLL77gl19+idIW6fz584wZM4bVq1djNsexTkzvDUX6Q+bacHE8PNwSr/vs4p6BIr6tCXx8lTuXDsTnT0DnDYX7Q+Yqtk2CH2xS94gmV65cDBw4kJ49e0Y7aQ0LC6NChQpcuBD1sdG6pqdKnxO4eRd4q5XzbFP7JAJvHeLqrhE8uxZ1mqV7piIUqDMCn5IfIGv0WC0mZI0Oq9XEo3NruL57NCFPot437/x1KFR3NN75a6BYlbd6/5BkrKZQjs6uxstHZ6OE9Ho9R44coWzZslHaifg1uHfv3olOZlKSyI9WFxcX+vfvz4gRI+K9WWpoaCgVK1bk/PnziX4sFEWhffv2LF++XB16o+XLl9OxY8dEXycR15sjRw6WLFlCrVq11OEEefToET179mTTpk0O36YOHTpEOxlu0KABO3bscPiyNRoNNWvWpH79+nh7eyfbiUSbNm3w8fGx/3vFihV06NAh0fdHidh7aufOndSpU0cdjubWrVvUrl2bmzdvJvo6ee35WbJkiVM3o01qkedBjt73woULc/jwYTJmzKgO079/f3766SeHr8PX15cDBw7Evjb7DUwmE1WrVnWo4IOiKDRv3tzh6ZSRlixZQpcuXRy6PbIss2fPHmrUqBEltnv3burWrQsOTgdXFAUfHx9atmxJyZIl0Wg0Cf5skCQJq9XKlClTHHqfKYpCo0aN2LJlC0TMdPLz8+PQoUPqrnaJvS5e+/7btm2bfT3l3bt3OXbsWJT3uF6vZ9euXUyZMiXR1xf5XI4dO5ayZctiiseWSFarlezZs1OlShV1yGnSZIIVSZY1aHUablw+zer5Yzm6bx3W15KmTFly0qLrQOq+3xOTMZzNq35h88pfolQG1OldqdXkQ1p2HUj23AUwmcwoKWDqWWITLCJejFu3brVP64idBJLGVqgiDrJGS6Fy71O11TB88lfAFB7C+YOLOLJxMs8fxvPXIEm2V717Ew8PD3r16sV33333xnVWKT3BiiRrdFgtBh6eWcn1veMIDXj9V3aJTAUbULDuKDLkqcqLu0e5tmsUAVeiJrruGQuRv9YQfEp3QqNzjRixesve8QRLURTSp09P7dq1GTBgANWrV1d3idXbSrAWLlxI9+7dE32dRFzv1KlT7evVHHX+/HkqV67My5cvE327lIgRxDVr1tjbLBYLVapU4d9//3Xocon4Phw4cKA6nOySM8GyWCy0b9+eNWvWJPr6iLjOAgUKsHv3bvLkyaMOp1iBgYFUrlyZy5cvO3z/hwwZ8saS9P/++y81a9Z0eBSdiNHGVq1aqcNxetcSrDVr1tC2bdtEXzYRl//ee++xfv16Chd+NZsqMaxWK9WqVePIkSOJvk1KDAlWgwYNOHDgAPoYtjUym81vLAwUH5GvudcTrDdx9Ie9yOdy9+7d1KxZUx1+a1LPT0WJYLVGlnUvxTdjl/HthDUUfO/VHOenT+4x/6cvGd2vLiP71mbl3NFRy6771mPYtK18OnAWWXPYyq6nhOTKUZIk0bhxY3bu3MmMGTPImzevustrlHglVz75y9H6q5W06LecbHnLYzYakDV6ytT9lM7D9lGl+Xe4eUSWK49FLMmVLMs0b96cPXv28PPPP78xuUpNrJaIsu7lu1Kx934K1BqGzi3yV0yFp9e2ceLPxhxf2IjjCxsRcGWz7TkBtK5e5K8xmIq995PTtweSrE0ZydU7TokY0WjXrh1Tp05NcHKVmkV+qTpzj68CBQokyYm34qSpNyVLlqRv377q5jTv119/jZKwJoaiKGi1WqZMmZIkz3FSWr16tVOSq3Tp0tGxY0d1yM7X19fhkeDI2zhr1iynvObTOmc9Rl9++aXDyVUkZ92mSLIs8+eff3Lu3DlOnToV5bhw4QI//vij06/zTZx1Pc66HGdJ0wlWJLPJhNVqpWKN5gz/ZQcffvkjGbO8KjJw9fxR7lx/9St79txF+HzYAgZP+Yfi5WpiMhmxxDWdLhVyd3enT58+HDp0iEGDBpEpUyZ1lzilz5Sb+h/+RIfBOylU3lZMwWK2rQdSFCtmowG3dFmp1eEHOgzeTrGq7e0bRCdE5cqVWb16NWvXro2yEDhNUCLKurtnolCDsfj22otPqY5Ism0PN7PhBc+ubsMcHggR0wuzFW+Lb889FG40XpRdT2GkiCkd8+bNw9fXl5YtW7J+/XqHfg1MTSRJQqdz3v6DGo3GqZfnbHny5MHT01PdnKrFNU3v6NGj9mItjiQYAH379qV169bq5hTNYDAwe/ZsdXOi1KtXj1KlSqmbo+jWrZu6KVF27tzJ/v371c2Ck0We6DsruUoqOXPmpFChQhQsWDDKkStXLrJnf7X1kZA4sX+KpiFKZFl3Vw9adP6GMTP20aDVZ2h1r+Yje6Tzps1HQxg9Yy913/8IWdakiLLrSS179ux06dIlQRufurilo3yDz+k8bC8VGn6NTu+J2WSI8SRfsVowmwxkzVuOZp8tovVXq8hRqLK62xtJkkTt2rVp3LgxGk3s1fVSM3tZ92wlKPXBIsp2jlrWHSB9jgqU6bia0h2WkT57mXem7HpqJEkSQUFBrF+/nlatWtGoUSP27dun7pYmOfuXRGdfnhC7RYsWMXnyZCZMmBDtmDRpEp9++ilBQUEOJVeKolCpUqUUXVXzTbZs2cKRI0fUzQkS+ZqOqbiFWpMmTShSpIhD7wNJkjCZTPzxxx/qkCBE48hrTbB5ZxKsSJFl3bPkyMcnA3+nSMmq9tgHvUbRrd/3pPeOLLue9l9gDx8+5LvvvqNatWocP35cHY5GkmUKlX+fDwZuof5Hv5IuUx7MJkO8StRbzLZy5YXKt6T9gC006D6dDJnjnhaiKAqTJk2iUqVKrFq1CoslbScUVovZVta9RDOKvf+rvWS7i6cPZTuvI1uJFu9c2fXUSpIkJElCURT27t1LkyZNmDx5corZQkAQXheZMM2ZM4cBAwYwZMiQaMegQYM4deqUw8lV+vTp+emnn/D2jsfU8RREURRmzZoFThi9K1myJPXr11c3R+Pt7c0HH3ygbk6U9evXc+bMGXWzIAhO9s4lWJEsZjOKFTTaV9PVPDwzYDGDNY2fwBNRBGLmzJlUqVKFKVOmEBwcrO4STba8ZWj++SJafbmaHAWrYjEZoxQNiR8Fs8mAVu9B+Qb96DxsHxWbfIXeNe4pNmfOnKFDhw40b96cY8eOqcNpjILVbJsOGFmqXdLqkfUeWM0W4leaUUgpIhOt0NBQBgwYwIABA96JH3CE1Cny9Rrb4aihQ4c6vJHu23DgwAF27Nihbk6Ujh07ki5dOnVzjDp16oSnp6dDnxuSJBEcHMy8efPUIUEQnOydTbAAFJQoU9riMwqT2imKwo4dO6hbty59+vTh1q1b6i7RuKfPQq2O4+kweCfFqnaKss4qsSLXZ3l656JO55/oNHQXhSs0R4pj7r/VamXz5s3UqlWLfv36ce/ePXWXNOa1L1OFiCIgjp/cCG9H5Inp1KlTmTZtmjosCGmeoig0bdqUb775Rh1KFf744w9MJpNDSaaiKHh5edGhQwd16I1KlCgRr9Gu+Fi2bBm3b99WNwuC4ESxn80KacqFCxfo0qULTZs2jUd5dtDqXChb92O6DN9HleaD0btlwGw0OHX0xGo1YzEbyZbPl5b9VtGq3wqy5ol9wS8RI3C//vorlSpV4ueffyYkJETdRXjHKTFs1uiMw1GRJ2YjRoyIdQ8SQUhrlIg90n766acUXbjkTc6ePeu0MuNNmjShUKFC6uZYde/eXd2UYJIk8fDhQxYtWqQOCYLgRCLBegcEBAQwfPhwqlevztKlS+PchE2SJPKVrEv7gVto2GMmXtmKYDYakrSYgsVsRAGKVGxLp6F7qdNpEp7eOdTdorl//z5ff/01tWrVYsOGDWJti4CiKLi4uJAjRw6yZ8/utMPHxwd3d3enJFqSJPHy5UtGjhwZ94bfgpAGKBHbF0yePJkiRYqow6nCvHnzePHihcOjV8SzuIVa/fr1KVGihMOfPwALFizg6dOn6mZBEJxEJFhpUOSHv8FgYMGCBVSrVo1x48bx/PlzdddoMuUoQrPPFtLmm/XkKlobi9mcfMUUFNv6LJ2LJ5WaDaDzsD2UrfsxelcPdc9ojh8/TuvWrWnXrh2nT5926AtQSP38/Pw4c+YMJ06ccOpx9OhRFi5cSI0aNZxykrN9+3a2bt2qbhaENCl//vw0adJE3Zwq3LlzJ0GbdsfG19c3zo2cY+Lh4UGXLl3UzQkmSRJXrlxxeB8zQRDeTCRYadSRI0do3LgxPXr04MqVK+pwNO7pMlG99VA6Dd1LierdkDV6LGbnTgeML0WxYjYZyJClAA17zKLdtxvJX7pBnEmTxWJh7dq11KxZk4EDBxIWFqbuIrwjXF1dyZgxIz4+Pk47smfPTokSJfjwww/Zvn07X375pUNJVuTref78+eqQIKQ5kiRx9epVZs6cqQ6lCosXL+b+/ftxfg/Fx/vvv4/JZOLJkycJOgIDA6lbty7p06d36LMn0uzZswkPD1c3C4LgBCLBSoNWrlxJ/fr12bNnjzoUjUbnQgm/LnQetg+/tuNw9cwc77LrSc1qMWMxm8hVtCZtvvmbZp8tJEvukupu0QQFBTF9+nRu3rypDgnvCGecfMTGxcWFsWPHUqZMGYeva+/evdy9e1fdLAhp0qRJk+K1JUhK8vz5cxYsWKBuThRJkvj9998pXrw45cuXT9BRqlQpPvjgA6clRceOHRMj6IKQRESClQY9fPiQly9fqpujyV20Om2+XkOzT//EO/t7tsQqCddZJY5iq1goaSjh140Og3dQo91o3NJlUncUhGSVPn16mjVrpm5OEEmSCAgI4MSJE+qQIKQ5UsTm2wMGDHBakpAc1qxZw6VLl5wyegXw6NEj7ty5w927dxN83Llzx+Eqhrw2gp5aRxQFIaUTCVYykSQJjUbr8IeinQRarS7OsuYx8c5WkMa9ZvLBwG3kL9M0eddZJZaiYDYacPXIRLXWI+gyfD+la3VHo01oJSoJWat34vMgI+t0aHQ6kBL+XAipW758+dRNiSI2/hRSEnXlTPXhCEmS2LVrFzNmzFCHUiSDwcAff/yhbnaIFMO+Ygk5nGnHjh34+/urmwVBcJA4I0wGsiyjKFYe3b+O1WJG62B5Wo1Gi1aj5eJpf4KePVaH38jVPQNVmg+g8/C9lKn7KbKsw2J6O+usEkuxWjAbDXj7FKVRrzl8MGAzud/zs2Wc8WAOf8Et/2kYXj5E1jqSFEnIWh1WUyi3D/3GtV3fYw57FrExsCAkTHz2oxOE5FK0aFEqVqyIr69vlKNixYoULVrU4SQLYPz48anih4WtW7dy9OhRdXOaIEkSZrOZ33//XR0SBMFBiT27FOJJlmXCw0P544fP+PbDMkwZ0pbLZw6j0+vRaBN2Mi7LGvQueh7dv87MSZ8w6bvmvAh8ou4WjazRUqxqezoO2UWtDpNwS5fNVnY9BayzSiyrxYTVYiFP8Xq0+24LTT+Zg3e2gupuMVC4dfBHjs724+6xuSgWgy3RimeCBiBrdEgSPD6/nn/n1eXiP19wdecwzqzqitkQjJTopE1IbZz1a3J8KnwKQlKLTJx+++03jh49yqFDh6Ichw8f5sCBAw6vPZQkiadPnzJ48OA4tw152yKn0DnrvZ4SrV+/nnPnzqmbBUFwgDgTTGKyRsu6hePZs3EBxvBQTh7azJiv6jP7h895fP8mehc9chzT/CRJQqfXExoSxJqFExnxmR87/56N0RB3lbwchSrR5ps1vP/ZIrLmLZdC11klloLFZECj0VOqZk86D99PtVZDcPPMqO4YTdiza5z/uzcnFjbh6ZUdSBoZWRN7wivJGmStjqB7x/lvWXv+W9aGF/f/tcefXt3GvRNzkTSaKH8npF2hoaHqpkQxGAzqJkF4azQRn2FarTbKIcsymTNnZtKkSeh0OoeSLICNGzcye/ZsdXOK4e/vz/bt29XNaYokSQQHBzN37lx1SBAEB8R+Zi84RKPR8uTBTfZsXhil3Rgeyra1vzOijx9r//yB0JAX6PV6iOEXMq1Oh6JY8d+xgtFf1GHJ74MJfPZI3S2a9Jnz0KD7dD4YsJWCZZtjtUYUi0iDIsu6u6fLQo1239Np6G6KV+2AVuei7hrN81v7OLGoGWdXd+fl44vIWh2SpEqQItZZhQfd49LGbzg+vw6PL6yNMVF9cuFvrGZTgkbEhNTr2LFj6qZEcXGJ+7WamqTlX/vfBXElTo0aNeLzzz9XNydI5GtkzJgxXLhwQR1OEWbOnInZbH4nXs9Lly7lzp076manehcex9e9a/dXiEokWElIkmUCHt0h8GnMCdHzgAcsnjGQ0V/UxX/HSkBBp9NDRHKm0+m5fPYIUwa35eeRnbh19bT6IqLRu3pSscnXdB62l/L1+6HTe2BOZeusEstqtWA2GcicsyTN+iyi1VeryVm4irpbNIrFyINTf3Fsbk2u7hyNKexpRKIl29dZ3fL/hWNz/Lh1aBpmQ7D6IlTS/mMt2PaaW79+vbo5UTJkyKBucgqz2axuShZxnaALqd/QoUMpUaKEQ8+1JEk8evSIYcOGYbWmrCnr586dc9r7O6WTJImHDx+yePFidcipQkJC1E1pmpiZkHysVisWS/Qfvd8mkWAlIavFgk+uQhQtXU0diuLW1f+YNrIjkwe24tJZ2/qsgMd3mDu1H+O+qs+JgxtR4vjykWUNhcs3p+OQndTp/CPpMuZOMftZJTeLxYTVYqVA2Wa0H7iNBt1/wStrfnW3aEyhAVzfPYpjc2py/9RiLOYwHl/YwL/z63Jp05eEB91W/8lrJDIVbECRxlORZJ1Ist6yuKbdOsJisbBp0ya6devGixcvnPIrZbZs2dRNTnHu3LlkXd8lSRKKojh1X6/AwEACAgLUzSlGQEAARmPanB0QmyxZsjBx4kS0Wq1DSRYRZdCdtc+Us8yfP99p7+/UYsGCBUn6eXH06FEOHjyobo4Xs9nMo0ePOHLkCHPmzElxr5fXRb5mli1bpg7FW0hICFeuXGHDhg2MHDmSa9euqbsIESIf70OHDqlDb5WkJPKTceLEiQwePDhKm1em7Pyw8CTpM2TGGsP0qZRGo9Ux7qsGnPl3JwCfD51H3eY9MBqc92UpyxrCw16ya8NcNiydyvOA++ouUbi6eVKmciOuXzrOkwfx2yg3a97SVGs5jEIVWiHL2jQ7FTAxJElGo9MR/PQOx7f+zKndszGEvlB3i0aStbhnLEhY4E2s5th/hfLIUpwCtYeTrURrZI0eq8U5owaSRkfw/eMcmVUFxWrGNUMeqnx+Ap2rN4qSwt9fkozVFMrR2dV4+ehslJBer+fIkSOULVs2SjvA3Llz6d27t0MnNYqiULp0ab7++munjOBIkoTRaCQkJIR79+5x+PBhTpw44ZS9aIi4vfPnz6d79+72trCwMCpVqsTZs2cdug5FUejduzdTpkyJ1yjZokWL6Natm8PX2aBBA9auXYuHh4c6nGBTp07l22+/dfg2tW3bllWrVtnbzGYzVapU4fjx44m+bEVRkCSJ6dOn88UXX6jDDlMUBZPJRGhoKMHBwQQHB/P8+XOePXvGs2fPaNy4cZTkfMWKFXTo0MHh+7Nz507q1KmjDseoT58+zJw5M9HXScT15sqVi71791KgQAF1ONndvXuXSpUq8eDBA4fuF8k4muvo7STits6ZM4devXpFaTeZTFSpUoUTJ044dD2KopA3b15Gjx5NrVq18PT0tF+exWLBaDRiNpt5+fIljx8/5u7du9y8eZNLly5x+fJl7ty5Q0BAgH2kwtHbIssye/bsoUaNGlFiq1evpl27dg5fPkDXrl358ssvyZ07N7rXKkgbDAYsFgvh4eEEBgby4MEDbt68ybVr17h06RLXr1/nwYMH9j1NHbktRNyeRo0asWXLFnUoRmvXrqVNmzaJvt7I+79t2zYaNGigDkexbNkyOnXqlOjrIuL6vLy8+O233+jQoYN9HenbJBKsJE6wwDZVUKfX8ujuTf5ePJm9mxZgCHd8cbynd3Z8G31Fmbqf4OrujdlshMQ9nWmeLGuQtVoeXv+XwxvGc/nf9TGuoUoIvUcWclf9ityVPsfFwxuLyYwzR65EguWYRH60xYszbh8Rt1Gr1XL48GEqVKhgbzeZTPj5+XH06FGHr0tRFAoWLEjVqlXJnDlzlNG9yJOMfv36kTdvXjZt2mTfPNmR61UUBT8/P3r37k2RIkVwd3dP0OUZDAYePnzI33//zaJFizAYDAn6ezVFUejVqxdz5syxt1ksFqpXr86RI0ccvmydTkfLli1p1KgR3t7e8XrtmUwm+2a7ISEhGAwGgoODefHiBc+fP+fp06f2ZCo4OJiQkBBCQkIwGo32yz9w4ADVq1e3X+bbSLAePnxI7dq1Hd6IV1EUOnXqxJIlS9ShZPfDDz8wcOBAh+4PEffJ09OTHDlyxOs1kRhSRJEKZyWDlStXZs+ePbi6utrbrVYrVatWddrnEREbtasTLJPJhMViISQkJNbqko7eBl777IspwXI0uXhd5OeDl5eXba19BKPRiMViwWAwEBYW9sYpss64DUTcjpSaYP3999+0atUq0dcVSYn4Pi1VqhQFChRI0OUZjUaqVKkSLa9xhEiwkiHBiqTRaJE1MpfPHmH1/LGcPLw5zql/MdG5uFPCrysVm/yPjNmLYDGZ3smpgImh0eqxWkxcP72JQ+u+58H1V1UA40vWupK9TBfy1RiER5ZCKGZLkjz+IsFK+xRFoWjRohw/fjzaaE/jxo3ZunWrUx6L2D7mJUnC39+fqlWrcvr0aSpVquRwQoPqOvX6hG3u/XoSgRNOMhRFYdy4cQwdOjRKe8uWLVm/fr3Dl08cj3FSkCSJAwcOUK3aqynobyPBAli1ahUdO3bEYrE4dN1EjKJ26dJFHU42gYGBVK1alYsXLyb6vkRSFIUJEybwv//9z55MO5tWq+Xy5cvUrl2bwMBAh25z5HOwbt06WrZsGSXWrFkzNm3a5NDlvy4+7xdnXVdMlFgSrH379lGnTh2sVqtTbsPbvq+k8ATr8OHD+Pn5OfT58br4PN4xadq0KRs3blQ3J1rSLVQQorFYzJiMRgqXqMx3E9fwzZjl5Csc/STzTSRJpmDZJnzw3UYadp+JV9aCqX4/q+RmMRtRFChcvhXtB26lXtcfSZcxp7pbzCSJTIUaUuGjrRRvNRv3TAWxiuRWcFDTpk2jJVcAxYoVUzclmiRJMR6vxwDy5ctH7ty5VX+dOK9frtFoxGAwxPuI/IJ8/TIcVa5cOXUTZcqUUTclmvqxTcojpWnXrl2UKa6JEXm/hg8fnuTV7GKzdu1aLl68qG5OMEVRyJ49O127dkWn05EuXbokOdzc3ChTpgzNmzdX34QEi3wOZs2aFe0ktXjx4lH+7Sj1azqm423JmzcvGTPGvd1LfKnvV0zHuyxfvnxkyZJF3Zxo6sc2PgdJsHbbuZcmxIvZZAQkqtVvx8hfd9Gt72S8M+dQd4sic67ivP/5n7Tpv5Y8xWpjMZucttbn3aNgNhnQuaajUrNv6DrqIBUa9kXn4q7uaOeeqQil2i6iXJf1eOeriWIxo4jHX3CAoih4eHjw4YcfqkMA1KxZExz4NS4x0qdPH+3XXEepv8gScjiDoijkzp0bX19fdYjatWvb+wiOGTlyJAUKFHDosZQkiRs3bjBy5Eh1KFkYDAb7vlzOeP21bduWXLlyqZuTRK9evZxScARg586d+Pv7R2l7G59Hb0vu3LkpVaqUullIIj4+PlGmyKcVIsF6SxRFwWgw4uaenlYffsvQn7bilclH3Q2AIhVb0WnoHkr6deHZ/asEPrmD9g37ZgnxI0kyGq2OgHtXUCwWGvT4lbb9/8bVw0vdFYB8ft+S07czyBqsljfPDReEhOjWrVuMUyWJOPkvVKiQujnJdenSBSmiGmBa0apVK7Jmzapuplq1alSqVEndLCRC7ty5GT9+vFNeOwsXLoxSkCS5bN261SmVyBRFwc3NjR49eqhDSaZGjRpR1uMllhRR1GfWrFlR2mvUqMF7770XpS2tkmWZdu3aqZuFJNSpUydIYwm8SLDeMqvVgtFoJnO23Li5p1eHAciWrwKe3lkIDQ7in5kfsXR8Lc7u+xMUKxrtq0WTQnxIaHUumE3hHN/yC4vH+LF9YT8sJitZ85RF75ZO/Qc2koxiAVFERHAGRVEoVqwYI0aMUIfsvL29+fTTT9XNSa5evXpOmW6UEiiKQpYsWejbt686BICrqyv9+/eHNPbF/rZ06NCBzp07q5sTRJIkrFYrw4YN4+HDh+pwkopMKpwxelWvXj3Kly+vbk4ysizTu3dvdXOirV+/nnPnztn/7eXlxWeffQbvyHulQ4cOvPfee+/EfU0JWrduTdWqVdXNqZpIsFIIW1GQmN/IitWMLMPJHTN4dPM4QY9vsHFWd1ZPbcHdywfR6vTIGq36zwQVWatDo9Fy7dQmlk9swI6/viT0xWOundrIhUPLkCRZJFBCklMUhRw5crBgwQKyZ8+uDkfRp08fatSokexf8uPHjydbtmzJfr3OFHnbhw0bRtGiRdVhuw4dOvDRRx+pm4VEGj9+PHny5HHotSNJEpcuXWLMmDHqUJLx9/dnx44d6uYEi7zfH3/8sTqU5Jo3b06RIkUceuyJePxfvHjB3Llzo7R//PHHCSp+klQURbEfSSVTpkyMGTMGjUaTpNcTH0l9X1MCd3d3Jk6cSLp06dLMfXVqgiVJUoqoPZ8WWS22UuN6t8hRLoWbZ7ezYlIDts7/nOCnd9DqXWxJghCFJGvQ6l14du8iG37vypqfWvLg2hF73D19FhTFKopVOJEkychakfS/LvJLsnjx4qxbty5eU9M8PDyYPXs2hQsXTtYvnRIlSvDHH3+k2i+7yNv85Zdf0q9fP3U4mmnTptGoUaN34kQmqeXJk4dx48aBE0Y65syZw6ZNm9TNSeKPP/7AaDQ6ZfSqfPnyNGzYUN2c5DJkyEC3bt3UzYm2dOnSKAVH3N3dmTVrVrJ/HkWKfH/KskzDhg0ZPnx4kiZAH3zwgX2WQVJdR2wi76+Pjw+jRo2iWrVqb+V2JJeaNWsybdo09Hp9mrifTj0bN4SF8OjuNXR6DbJItJzKaoVKzb6jy/ADvFe5vX3EymwM49TOmSwaU51jm6dhNoWh1bmI9VkRCb9W70J4yHMOrBrF4nE1uHBoqb04iFbnRpk6n9B15CFK1uiKRaytcpwkIWt1WAwvuOU/jdCnV9U93imRX5BKREGLvn37smvXLipWrKju+kZFixZl7dq1lCxZMlkTgBYtWrBkyRJ8fHyS9XodpSgKGo2GAQMGMHXq1HidMHt5ebF06VI6duwIb+lkKi3p2rUr7du3VzcniCRJmEwmBg4cSEBAgDrsVOfPn2fdunXq5kT76KOPouwjlZw6d+5MpkyZHH4NS5LEw4cPWbx4cZT2woULs2bNGsqWLZssnwvqz9DWrVuzefNmtmzZwmeffUamTJnUf+JUI0aMYOzYsU4rIBKX1+9vkSJFGDduHMeOHWPkyJHUq1dP3T3N6dmzJ/PmzbPvJ5gcj3lScWqCFRoSxPffNGbprFEEBwagd9GLERUnspiNZMlVguafL6b1V2vJXuDVL+Avn99n16JvWDahPldObECWZGTNu7s+S6PVoyhWzh1YxNJxNfFfO5rwl88iohJ5S9TngwFbaNRzJhmy5MNiFhUBHSMha3RIKDw6u5Jjc2pwZfsQrOak2fslpXj9yzCmQ5Ik8uXLR79+/Th48CC//vor2bJlU19MnEqUKMH27dvp3r07Op0u2b543n//fXbt2sX777+PLMvJdr0J9fpjXrhwYZYuXcqkSZPQJmAU1dvbm7/++ovffvuNnDlzRrnM5KJ+/bzpeL1vSiRJEt9//73DG+xKksTZs2ftI2JJZe7cubx48SJeyXhsFEUhZ86cfPDBB+pQsilQoEC0PawcMW/ePJ4/fx6lrWTJkmzdupWePXs6/fNI/VrX6/WUL1+eUaNGceTIEVavXk3Dhg2RJIns2bM7dTuLNxk2bBgrV660j9wl5f3NmjUrH3zwAatWreLYsWMMHTrUXomySpUq9r9Jy7p06cKOHTuoW7cupPDPutgkOvuxWGLe6DTkZSCr5o1m2KfV2fXPQsxmAzrdu3ui72wWiwmr1Uqh8u/TftA26nb9iXQZX5WBfXj9GOt+bsOGGV15cuc0Wp0LkvzujCbKshaNTs+9KwdZ81MrNs78iKf3X+1pktGnCE0/mUfb/60n93s1sZiNoty9gyRZg6zVEnT3KKeWtOH08o4EPzqj7mZntVrfuGt95Ieo+ksnpR6RZFnGzc2NTJky8d5779GkSROGDh3Kpk2bOHHiBNOnT6d06dKv3dOE8/HxYd68eWzatInmzZvj6ekZ7fYk9CAeX17FihVj7dq1rFu3jsaNGzvlep19aLVaSpcuzeTJkzl48GCiT3C1Wi2ff/45R48eZfz48ZQpU8Y+XSU5Dq1Wi6urKx4eHqRLl44MGTKQKVMmcuXKRdGiRalQoQL169enc+fOfPvtt+TNmzfK7Y98X6kvN77H63/rqEKFCjF69Ghw4PZE3o4ZM2bEe4PUhLp9+7Z9lEZ93Qk9ANq3bx/n2sqk1rNnT6e8bgGuXLnCihUr1FdB1qxZmTNnDlu3bqVly5b26cSOHkSsf6pbty7jxo1j3759HDx4kJEjR1KiRIkoSbAkSVSuXBkS8dy9/jfx0apVK/z9/fn+++8pUqQIUkS1TEcPvV5P0aJF6dGjB0uXLuXEiROsWLGCtm3bkj591MJnpUqVsu8Xpb6cuA5e+3yID2d8lkT+fWKUL1+ezZs3s3LlSho2bJjk3zsk8PGJD0mJvOQEWrduHd27dycoKEgdiqJ4uVq07z2aEuVrYbVaU9RIgUarY9xXDTjz704APh86j7rNe2A0GNVdk5Qky4SFvGDox1V4cOeKOoxf25FUbzMKs9EQpT2y1Hjg4xsc2TSFs/sWYDaG2uOuHt6Uq/855Rv2w9MrG5Y0vCmuJMlodDoCH9/k2MYpnNm/AJMhxB53dfeibP3PqdCwH57ePlhMRvubiogkISz4CX+NrMSLp3ft7ZGKt5pD7oq9sJiSbxqhpNERfP84R2ZVQbGacc2Qhyqfn0Dn6o2ixPwDR3KSJBlJqyHs2S1u+U/h3on5WIyvHvM3KVu2LBs2bIhxf5jr169z6NChVLGWU6PR4OnpiSRJuLm52U+Gvb298fT0VHd3KqvVysWLF9mxYwf+/v5cunSJR48eERoaav/xS4rYS0qn06HX6+0n7V5eXmTKlImsWbOSLVs2cubMSevWreM11cZqtXLp0iX27t3LwYMHuXTpEg8ePCA4OBiz2YzFYnnjj2+Oirwvsizj7u5O5syZKVCgABUqVKB27dr4+vri7v7mvewSIzQ0lLNnz3LkyBHOnDnDzZs3ef78OUZj4r8j3NzccHV1xdPTk4wZM5IlSxayZ89Orly5yJ07N66urri4uKDT6ewJl16vx8XFBTc3N3Q6nfoi7W7fvs2BAwcc3jCzbt26MZa1TyiDwcDWrVsJCQlxaHTIbDZTqFAh+y/4znTv3j327NnjlM8cRVGoWbMmOXPGc/P6JGIymdi2bRtBQUEOvxbMZjP58+ePtQS8oihcvHiRnTt3cuDAAS5dusTDhw/tn0dmsznq920M7+U8efJQunRpKleuTLly5cidO3e8bvv169c5fPhwvPqqSZJE3bp1E7zJbVBQEAcPHmTXrl38+++/3L59m8DAQIxGY4yfgVqtFlmW0ev1pE+fnuzZs1O4cGF8fX2pVKkSxYsXJ126N1Qwfo3FYmHbtm08f/48wffXYrGQK1cuatWqpQ7F6O7du+zfv9+h9y0R2434+MS8BVF8WSwWLl++zMGDBzl27BhXr17l8ePHvHz5kvDw2GfJaDQaXFxccHFxwdPT0/6Dlbu7O4qi4OnpSfr06fH29qZ06dJO/YxJdIJFxLzl8ePHs3Llyli/cHR6V2o27kqLLt+RK18RTEaz0zPFxEjtCVYkWaNFkmXuXT6I/9ox3DyzndcrEmb0KUKVlkMoVqUDWp0rZlPMl5M6SWh1egyhLzizbz5HN00m+Nk9e1TWaCni25qqLYeSNU8ZLBYzijX6CaBIsBJCQtZqMRtecv/kAm7u/4HwoFcLod8kS5YsfPXVV/Tp04eMGTOqw4IDDAYDgYGBvHjxApPJhBKxEDwy+XN3d7d/yej1eoe/NCOZTCaCg4MJCgoiPDwck8kU63eBIyJHCbVaLenTpyd9+vS4ubmpuyW5yJOoxNLpdGg0Gqc9B4KQ0hgMBoKCgggKCsJkMhEWFhYlwdJoNLi6ur7197IzWK1W+2dgaGgoRqMx2mdg5A8m7u7upE+fHk9PzwRNXxaiUhSF8PBwjEYjpjjOyWRZRqvV2hOt5HzcHUqwIm3fvp1Ro0Zx8OBBdSiKDBmz0bjtFzRu15d0GbwxGkxREoHkllYSrEgarR6L2cjFIys59Pc4nj24FCWet0Q9qrcZSa6ifihWa6qfGidrdIDC9f+2cHDtaB5cPxYl7pPfl2qtR1CwbBMkScZifvMbUSRY8SNptKBYeHJxAzf2TSDobtTHPCYuLi506tSJoUOHvpWNcwVBEARBEJJTwsYY36BBgwbs2LGDWbNmRZsT/rqgZ49YPns4I/rU5PDutcgaSazPciKL2QiSRMkaXek8fD/VWg3H1cPbHr91bicrJjZi27w+vHh6O9WWdZcjyq4/vXeeDTO6sHZaqyjJlYdXdup2+ZGOQ3ZSqHxzrBZLrMlVfKTGx8mZJFmDRqcj5PE5Ti/vyH9L28UruapVqxbbtm1j/vz5IrkSBEEQBOGd4LSzRjc3Nz755BMOHz7Md999F21x3uvuXD/Lj0M/YEL/Zpw/tQ+9Xo8mGYftUhpZ1qDV6Zyzx62iYDYacPXwpsYHY+g0bC/vVenwqqy7KYxTu2axeLQfRzf9hMkYmmrKuksRZdfDQp6zf+UIloyrycXDy6OUXS9b9zO6jjhAxabfoNW5YXHSdEizIQhJY0s03imSjKzTYXz5gEubB3BsTk0enVsd51q+woULM2/ePLZu3UrNmjXVYUEQBEEQhDTLaQlWJB8fH3744Qf27dtH27Zt3zjf0Wq18N/RbYzv34Tfvu/J43s30LvoE7xwLzWTJBm9i57gwCesmjeWJw9vqrskmmK1YDYa7GXd23zzN9kL2qrtALwMvM/uxf1ZPqEeV06sR5bliCl3KZNGq8dqtXJ2358sGVuDg+vGEh4SUTpWkshXsgHtB22jYc/fSZ85L2ajIc4kICGu7RrFlS0jMIU+RdbpIM2PaNn2s1IsBu6f+JOjs2tw88BkTGFRy/WqZcyYkWHDhuHv70+PHj1wcXFRdxEEQRAEQUjTkuwssUyZMixfvpw1a9bg6+urDtsZwkPZ/c98hvfxY8OSnwgPC4nYPyvlj6gknoROr8dsCmfvpkWM6FOT9YsnOzyNLSYWswmrxULBsk3pMGgb9bpOI13G3Pb4wxvHWfdzW9b/1tle1l1OQaM0skaLRqvn7mV/1vzUko1/dI+ytixj9qI0/Xg+bfr/Ta4i1bGYDEmytswcHsS1PWM5NqcGd4/+gWIJR9bqgLT3OpU0OiRZ5umVbZz8swln13xE2PMb6m5R6HQ6OnXqxL59+xg7dmyCqzIJgiAIgiCkFUmWYBFRKaZ58+bs3r2badOmxViWOVLg04csnN6fkZ/b1mdJsoQ2lnK0qZVWq0Or03L62E7GftWQX8Z04/7tqMUonE/BbDKg1bnh2+QrOg/fR/kGfdG5eABgtZi5dGQlS7+vw94VQwkNDohYn/X2kgdJktHqXXgRcIvtC/qyclIjbp7ZRuQ8SlcPb6q2HEanoXsoVesjZFljW4OWxEICLnH+70858WdTnl3fg6SRbYUf0gBJ1iBHrLM6u7obJxa9z7Ob++KsQ1OtWjU2bNjA4sWLKVGihDosCIIgCILwTknSBCuSp6cnX331FQcPHqRfv354eNhO7GNy6+ppfhzajp9HdOb6xRO2aYNO2J/ibZNlDXpXPXdvXuD38b2Z0L8Jl88eUndLUopixWw0kD5Tbup/9AvtB24jf+nG9kTKEBrI4fXjWTKuFqf3zMdqtaBN9iIkElqdCyZTGMc2TWPJ2Jqc3Pk7poj9vWSNlvcqd6DT0L3UbD8Wt3SZI6YDxpEFONnzm/s48Wdjzq/pRWjAZWStLhUXwpCQdTpMIU+4tnM0x+bW5MF/S1AssY+o5suXj5kzZ7J9+3YaNWr0VhNyQRAEQRCElCJZzwhz587N9OnT2b17N82aNXvjeiur1cqhXSsZ/UUdFk7/jucB93Fx1afKE1hJktC76Hn54hkrZo9h5Oc12f3PPMxJMB0wvqwWMxaTkZyFq9Lmm3U0++wvMuZ4zx5//vAym2f3ZPWU97l9cT8and5eJCMpyVodskbD1ZP/sHx8PXYt/obg56/2tPIpUJHWX6+jed9FZMlVwpZYxbCnVXKxmg3cO7mAY7Orc333GMyGoIj1Wakl0bCtswIL90/8ybG5Nbm2axSm0GfqjlGkT5+e//3vfxw8eJBPP/3U6Zu7CoIgCIIgpGZvJWOpWLEi69atY8WKFZQqVUodtgsLDWbDkikM/9SPjct/xWI2oHfRp5oTWJ3OtpZl/7ZljPy8JivmjCQ46Km621tjMRuRJIkSfl3oMnw/1duMjFrW/fwuVk5qxNa5n/Ii4Da6JCrrHll2PeDOOdb/1ok1P7Xi4Y1/7XFP7xzU6zqNjoN3UqhcM6wWK5Y4RleSkzH0KVd3juTYnBo8OLkICSXFr8+SZC2yVsvzm/s5uag5Z1d/REjAZXW3KGRZpnXr1uzbt48pU6aQPXt2dRdBEARBEIR3nvPPluNJq9XStm1b9u/fz8SJE8mWLZu6i13Ao9vM+7EfY75swLF9G9BobGXNUyqNRoNOr+fS2cNM6N+U6aO6cO/WRXU3O29vb7788kvy5MmjDiU5JaKsu4u7F35tR9F5+H6KVe1kryhoNoXz3+7ZLBpTnSMbp2IyhtjKujshebCXXX/5lH0rhrNkXE0uHVlpH5XS6d0pV68PXUb449vkK7Q6V8wmw1vZnDp//vy4urqqm6N4+fg8Z1Z/yMlFzQm8dRBZo0WSk37kL0Eiyq6HPb3CubU9Ob6gAU+vblf3iqZChQqsXbuWVatWUaZMGXVYEARBEARBiPDWEqxIGTJkYODAgRw8eJCPP/441pPYy2cPMWVwG34a1oHrl06muPVZsmwrux7w+C4zJ3zM2C8b8N/RbSjWmMuFa7Va2rVrx759+5gwYQJubm7qLskmsqx7phzFeL/PX7Tp/zc5XivrHhL4gN1LvmXZhPpcOf43siyh0SY+ydXqXFCsVs7sXciScbU49Pc4DKGBEVGJfCUb8sHArTTo/hvpM+V2etn1hBo2bBjr1q2jbNmy6lBUikLAla0cX1CfCxs+J/zFbWSdDkl6269TGVmrw2IM5sae8Ryd48e94/OxmmPfJyxnzpz89NNP7NmzhxYtWrxxWq8gCIIgCIJgk2LOlgoUKMAff/zB9u3badCgwRsXzFssZg7vXsXYfvVYPGMIwUFPI8q6v727Ikm2suvhoS/ZuPwXhn1SjZ3r52AID1F3tatUqRLr1q1j+fLllCxZEqvVmuyFGmJitUSUdS/ThPaDtlOv23TSZXpV1v3RjeOs+7kdf//Wmce3T6PVJ6yse2TZ9TuX9rP6x+Zs+qNHtLLrzT5bSNv/RZRdNxuTpOx6QsmyTKNGjdi7dy9TpkwhR44c6i5RWExh3Dn6O0dnVePG3klvdX2WrNWBZOHh6aX8O7cmV7YPxRjyRN0tCg8PD7744gsOHjzI119/jaenp7qLIAiCIAiCEIO3l5W8gZ+fH//88w9//fUXxYoVU4ftQl4GsvbPCQz7uCo7/p6DxWJCp0/uindEVNlTOLhzJcP7+DH/py95HnBf3c0uT548/PLLL+zatSvWQh9vV2RZd1d8G/ejy/D9lG/Y71VZd6uZy0dXsfT72uxdNpjQF0/Q6mIv6x5Zdj3oyU22ze/DikmNuHl2h326n6tnRqq1HkHnYXspWaMbkpQ8ZdcTKrLAg7+/P3369ImzwIMh+D5Xtg3i33m1eXR6BSjWZNvQWZI1yFodgbcOcmpRc86s7ErwwzPqblHIskyzZs3YuXMnv/zyy1uZtioIgiAIgpCapcSze/R6PV26dGH//v2MHj2aTJkyqbvYPbp/nZkTPmbMl/U4fWwnWp0WrQNT1+JLo9Gid9Fz9fwRJn7bnGkjOnLn+jl1N7vIUvX+/v588cUXsZaqTykiy7qn885F/W4/02HQNgqUafJaWfcgDm+YaCvrvndeRFl3l6gXIkWUXTeGcnTTTywZV4tTu2ZhNoYBIGt0FKvSkU5D9lCj7WhcPTO99emA8ZEvXz5mzJjBjh074lWiPPjhaU6v6Mx/S9sQdO+Yrax7Akb+EkKKWGcVHniLCxv6cvzPRgRc2RbnY1qqVCmWLVvGunXrqFz51fRQQRAEQRAEIf5SZIIVKVOmTIwYMQJ/f38+/PBD9LGMUF0+c4gJ/Zswc+Kn3Lt9CZ0+adZnSbKMi6uegMd3mD+tP6O+qBvrOitZlmnRogV79uyJc7PllMpqNWMxG8lRqCqtv17L+30WkylHcXv8+aMrbJ7di1VTmnHrwh40WltZd1mrQ5ZlrpxYz/IJ9di9uD8vXyu7nr1gJdp8s473P19EltwlMJvebtn1xKhatSobNmxgyZIlcW6yqygWnlzayL/z6nBp41cYXtyNmDbopLehZNvPymIK5rb/zxyd48edIzOwGF6qe0aRLVs2Jk6cyP79+/nggw/QalNYYQ5BEARBEIRUxElndkmraNGiLFy4kK1bt1KjRg112M5sNrFr/RyG9q7CslnDCQl+HrF/VuyjC/Gld9FjDA/ln6XTGfZJNTYu+wljuG0D3JiULl2aVatWsWbNGipUqKAOpzqRZd2LV+9E5+F78Ws7GlePjPb47fO7WfVDE7bM/YSggNs8vXue9b92ZO20Njy8cdzez9M7J/W6TafjoJ0ULNsUq8WC5S3uC+YonU5Hx44dOXDgAN9//z2ZM2dWd4nCYgzh1qHpHPmjKrf9f0Yxhzlc1l3WaJGAx+f+5tjcOlzc9DWGF2+eqgrg6upK7969OXToEAMHDiRDhgzqLoIgCIIgCEICpYoEK1Lt2rXZtm0bc+bMoWDBguqwXWhIEKsXjGNEn5rs3bQYRbHEa33Wm2pMaLU6tDodx/03M+bLesyf9lWs66x8fHyYPHkyBw4coHXr1miSYCTtbbGXdXfzonqbEbay7tU6RynrfnrPHBaPrsqS72tz6ehq+6iUVu9Oufqf03WEP76N+6HRuby1sutJwcvLiyFDhnDw4EF69OiBi4tquqSK4cV9Lm76mn8X1OfJxfVIsoykWp8V9TUZ/XGSZA2yTkfwg5OcXtGR/5a2IfjBKXW3aOrWrcu2bduYPXs2+fPnV4cFQRAEQRCEREpVCRYRv7r36tWLgwcPMnjwYLy8vNRd7O7dvMD00V2ZNKAl547vQaezTV2zU8DV3RO9ixt6Fzd0uqhJmKzRoHfRc+vaGX4a1oHJA1tx7cKrDXDV3N3d+fTTTzl06BDffvst6dKlU3dJMxTFVtY9c473eP+zP2nbfz05ClW1x0OCHhH+MmJTZUkif+lGdBi0jQbdfyNdplypYp1VYhUuXJh58+axdetWateurQ5HE3TnCKeWtOXMys68fHj61fosxZZAaV290Og80LpkiBjlUpAkGY1Oh+HFPa5sGcCxefV4dG51nI9p0aJF+euvv9i8eXOso8GCIAiCIAhC4khKSqgN7oAzZ84wbtw41qxZg9n85nLeOp0LNZt0o/WHQ/DJlR+TyYxitRIcFIDREA6AZ/qMuLp5ABI6vZbnAQ9Zv2QquzfM5WXwc/VF2kmSRMOGDRkxYgTVqlVTh+Pl5cuXVKhQgcuXL6tD+LUdSfU2ozAbY9+z6O2R0Or0GMOCObN/IQfWjCT85TMAvH0KU731SIpWaotG54LFlPIqAxIxEhQW/IS/RlbixdO76jDz58+ne/fu6uY4GQwGli5dyoQJE2J8btW0rl7krvQpeap8iUuGHFgM4RhfPrQlVbIWvUc2ZJ0eizGE+ycWcGP/D4QH3VZfTDSZMmWiX79+fPHFF7EWjREEQRAEQRAck+pGsNRKlSrF0qVL+fvvv6lSpYo6bGcyGdi5fg4j+vix9s9JGMND0On1ZMjoQ5bs+ciSPR+u7p5odTosZiObV81g2Kd+bFgyJdbkqnjx4ixatIj169cnOrlK/Wxl3TU6V3wbf0H2/BXtkUrNvqN07S4gySk2uUpKLi4udO/enQMHDjBs2DAyZny1Zi0m5vBAbuybxNHZ1blzZCYoZtwz58PVOz+u3rmRNBoCLm/l+IJGXPjniziTKxcXF7p168aBAwcYOXKkSK4EQRAEQRCSWKpPsIio1Ne0aVN27NjBr7/+St68edVd7J49uc/iGYMY0acmB3euBMWCTiej08loZJmTh7Ywul895k7py6N719R/bpclSxbGjh3L/v376dy5c6wVDt8VimLFYrKgvLZWSJY0WMzRFhO9c9SvF50u9q0Ewp7f5ML6Phxf0ICAy9uxmsIJfnCGs6u6cmpxcwJv+6v/JJoaNWrwzz//sHDhQt577z11WBAEQRAEQUgCaSLBiuTh4UHfvn05ePAg33zzTaxroG5dPc204R35cVgHtq6ZzbY1s/l1bHd+GNCSK+cOq7vbRY5I+Pv/v707DY6qztc4/pw+3dkIQURSRViLAhWBMoKg4BUX1BFZFIFb7o5lhikFRyguguVCioSEiAIBzcDgHQSELBBCggwxELMvbOIOKigKyiDcEA2YkK3vC8SRf0fSaAtZvp+X/Xs6VYG8OE+d/1Lk1RuJ1u6XZQv/eeP51ltvefXGs/xgqd5bPUalfx+gnf97kw5/kKT6unOfuNizZ08tW7ZMWVlZuu2223x2iiYAAAAa16IK1hlhYWGaP3++8vLyNGbMGDkcDf+abne9tuel6R9xE7U0bqLyM1eptvbXl7HddNNNyszM1PLly9W7d29zDHjlzJ69rVu3asmSJed84ypJdTVVOnl0j2oqf32pqiS1a9dOM2fOVElJiSIiIhQQEGBGAAAA8AdruHm0ENdcc43S0tKUmpqq8PBwc+y1Xr16ndepcIA3AgMDfXLqpNPp1IQJE1RYWKjY2FiFhoaaEQAAAFwgLbpg6af9Wffcc4/y8/P18ssvKywszIz8qvbt2+u5557z+l4j4Lfo1KmT5s2bp/z8fN17771yOn9xlUAjrrvuOqWnpyspKUn9+vUzxwAAALjAWnzBOqNt27aaNm2aioqK9MQTTygoKMiM/Mzlcum+++5TQUGBoqOj1bFjRzMC+Fx4eLhSUlK0fv16DRw40ByfpWvXrlq8eLGys7N11113/eoyWAAAAFxYre6prEePHkpISNDWrVt15513ehwAMHToUGVkZGjNmjXq27fvWTPgj2bbtkaPHq3c3FwtWLBAXbp0OWvetm1bTZkyRSUlJZo8ebLatGlz1hwAAAAXV6srWGcMGTLk5yLVp08fdevWTQkJCdqyZUuDxQu4kIKDgzVlyhQVFxdr8uTJCgkJ0ahRo5STk6MFCxaoc+fO5lcAAADQBLTagqVfLAXMzc1VcXFxo0sHgQuta9euio+P165du7R27dpGlw4CAADg4mrVBeuM0NBQ3gigyXI4HOrVqxfHrgMAADQDFCwAAAAA8BEKFgAAAAD4CAULAAAAAHyEggUAAAAAPkLBAgAAAAAfoWABAAAAgI9QsAAAAADARyhYAAAAAOAjFCwAAAAA8BEKFgAAAAD4CAULAAAAAHyEggUAAAAAPkLBagYsyyHL/BA+Z1mWxL80AAAAfgcKVjNQdbJMlkNy2E5zBF+wLDldTtWcOqm62mpzCgAAAHiNgtUM7M5eqs3LJur7o1/K6ecvy8F/m6/YTj9ZlvTZjjRtWDReJ78/YkYAAAAAr/Gk3gzUVlfpvXeWKTF6mEozYlRd+YNslz/L2X4Hy+GU0+Wvf3+xTemLJiht4XgdOfCeGQMAAADOCwWriXC73XK73ebHZ6k4flh5yc8pOXa4PtueIstyy3b6mTGcg2U55PLz14njB5WTOE3Jc+/Q57sy5HbXm1EAAADgvFGwmoigoCCNGzdOgYGB5sjDka/eV8arDygt/l4d3l8q2+mSw8H+rHOz5HT5q662UruyFilpzi3avmm+TlVWmEEPvXv3Vr9+/cyPAQAAAA8UrCbCtm3FxsYqLy9PI0eOlKORfVb19XXav/tfSp57u955c4oqjh+U0+Uvyzr391ojh+2Sw3Zo/+6NSon7k7aseFrlRw+YMQ+XXnqpZs2apZKSEl177bXmGAAAAPDA03gTM2jQIG3YsEEpKSnq37+/OfZQXXVSO99erDWzb9SurHjVVJ+U0+UvWezPshy2nC5/Hf16tzYmPKC0+PH65vNSM+bB5XLpoYceUlFRkSIjI9WhQwczAgAAADSIgtUEOZ1OjRs3ToWFhZo7d65CQ0PNiIcfyg5p68opWht3h/btTpdlWa12f5ZlOeT081dlxVHlJc9QUuzt2lu61qsj2IcOHarNmzdr1apVuvLKK80xAAAAcE4UrCYsJCREM2bM0LZt2xQRESF/f38z4uHb/TuUtmCc3kq4X0cO7JTT5d+K7s+yZLv8VV9Xrfdz/qE1Uf+l0o0vqerkcTPooXv37lq2bJmys7M1fPhwcwwAAAB4hYLVDPTo0ePnh/9bb73VHHuor6/T3m2pSpwzXHnJz+hk+ben789qwfuzTu+zsnVwzztaO2+EMl//q44f+cKMeQgJCdEzzzyjHTt2KCIiQgEBAWYEAAAA8FrLfeJugW644QZlZmbqzTff9Gr5WnVVhUo3ztOa6GHavTVBdbVVp/dntaD7sxw/7bMq+/ZjbV72mFLiRujg3gIz5sG2bY0fP16FhYWKi4tTx44dzQgAAABw3ihYzYzL5dKDDz54XgcwlH93QFnLJ2ntvBH64oPNcti2HLbLjDUrP++zOnFMxemzlTjnVn1UsMqrfVaDBg1Senq6kpOTvTpIBAAAAPAWBauZOnOEeFFRkR5++GH5+TV+oMWhT4uUtmCsNi15SP/37cenj3V32GasybNd/qqvr9HHhSuVFDtcBWtn6ceKY2bMQ5cuXbRo0SLl5OR4dRQ+AAAAcL54wmzmrrjiCq1cuVKZmZm68cYbzbGH2ppT+qQ4SYnRN6sg9XlVnTjWbO7PcthO2U4/Hdqbq7SF92jTkj/r2KFPzJiHNm3a6Omnn1ZpaameeuoptWnTxowAAAAAPtH0n6rhlVtuuUVZWVl6/fXX1bNnT3PsofJEmYrT5mhN9DB9VPCG6utrZDfR/VmW4/RywPLv9itr+V+1dt5IffnBFrndbjN6FofDoVGjRikvL08LFy5U586dzQgAAADgUxSsFiQgIECPP/64SktL9eyzz6pdu3ZmxEPZ4c+1aeljSn1lpA7tzZHtdDad/VmWJafLXzVVFSpNj1Fi9E16751lqjn1o5n00L9/f61bt04bNmzQwIEDzTEAAADwh6BgtUAdO3ZUTEyMioqKNGHCBDmdjd+D9dXHuUqee6fe/udfVH7ks4u+P8t2+smStHdbshLn3Ky8lOd0ovzfZsxDaGioXnrpJRUXF2vs2LGy7Yv3OwAAAKD1oWC1YH379lVycrIyMjI0ePBgc+yhrrZa7+f8U6ujhqkkY45O/Xj8p/uzLtyywTP7rA5/sU0b4scq47UH9d3XH5oxD4GBgZo4caK2b9+u6dOnKzg42IwAAAAAfzgKVgtnWZZGjBihnJwcvfrqq+rWrZsZ8fDjD0eVn/K8kmOHa0/xGrnd9bKd/mbMpyyHQ06XvyrKvlb2qr8pKWa49u3+l9z1dWb0LJZl6fbbb1d2draWLl2q7t27mxEAAADggqFgtRJBQUGaNGmSSkpKNHXqVK/e8Hz39YfamPCQNsSP1Tef5ct2+clhN77c8Pz8Z5/Vzsz5Wj37Ru3KetWrfVZXXXWVVq9erU2bNmnIkCHmGAAAALjgKFitTFhYmObPn6+8vDyNGTOm0T1Kbrdb+9/L1Np5I7V1xSR9f+zL08sGfbA/y3b6yXJY+vzddKW8dKey35ymirJvzJiHDh06KCoqSoWFhbr//vvlcjWRQzkAAADQ6lGwWqkBAwZo/fr1Sk1NVXh4uDn2UF11Qu9u+bsSo2/Wto1xqjlVIafLX/oN+7McDltOP38dObBTbyXcrw3x43V4/w4z5sHPz0+PPvqoSktL9fzzz6t9+/ZmBAAAALioKFitmG3buvvuu1VQUKBXXnlFnTp1MiMeKsq+UW7STCXF3KLPdqbKYVmynX5mrEGW5ZDLz18nvj+s3MTpSoq9TXu3paq+rtaMehg2bJiysrL0xhtvqFevXuYYAAAAaBIsd2O3taLVOHjwoGJiYrRixQpVVlaaYw+Ww6HeA0Zr6D0vKLTHALnr6+V2u7V1xSR9vSdPklvD/jtGVwwaJ7ek2lMn9XHhCm3b9LLKv/vS/HEN6tmzp1544QU98MAD8vPzrsgBAAAAFwsFCx5KS0sVGRmprKwsefPn4RcQrPBb/6KBf5qikMu6qbb6lOp/Ov3P6Tp9+uCBD99WSUaMDn1aZHy7YZdccomefPJJTZ06VZdddpk5BgAAAJokChYaVFtbq9TUVM2ePVuffPKJOW5QyGVddf2oZ3TV0IcVENxObrd07NBHKkmP0afbU1VXW21+xYPT6dT48eP14osvqk+fPuYYAAAAaNIoWDin8vJyvfbaa4qPj9fRo0fNcYO6XD5Ug0f+j458tVvvZr2myhNlZqRB119/vSIjI3XHHXdc0MuNAQAAAF+hYMEr+/btU0xMjBITE1VVVWWOPViW5dXyQknq3r27Zs6cqUceeURBQUHmGAAAAGg2KFg4L/n5+Zo1a5Zyc3PN0Xlr27atJk6cqGnTpnl1giEAAADQ1FGwcN6qq6uVmJio6Oho7du3zxw3yrZtjR49WpGRkbr66qvNMQAAANBsUbDwm5WVlWnhwoVavHixysvLzXGDwsPDFRUVpZEjR7LPCgAAAC0OBQu/2549exQVFaV169appqbGHEuSwsLCNH36dEVERCg4ONgcAwAAAC0CBQs+s2XLFs2aNUslJSU/fxYUFKTHHntMM2bMUNeuXc/KAwAAAC0NBQs+VVlZqZUrVyouLk6XX365Zs+ercGDB5sxAAAAoEWiYOEPcfz4cQUGBiogIMAcAQAAAC0WBQsAAAAAfMRhfgAAAAAA+G0oWAAAAADgIxQsAAAAAPARChYAAAAA+AgFCwAAAAB8hIIFAAAAAD5CwQIAAAAAH6FgAQAAAICPULAAAAAAwEcoWAAAAADgIxQsAAAAAPARChYAAAAA+AgFCwAAAAB8hIIFAAAAAD5CwQIAAAAAH6FgAQAAAICPULAAAAAAwEf+H/smnf6HOLheAAAAAElFTkSuQmCC

" alt="The Block Audit Logo" class="header-logo">
            </div>
            <div class="header-content">
                <h1 style="color: #FFBF00;">B.A.T.S.</h1>
                <div class="subtitle" style="color: #FFBF00;">Block Audit Tracing Standard - Professional Crypto Investigation Documentation</div>
            </div>
            <div style="position: relative;">
                <button onclick="toggleFileMenu()" style="background: #3498db; color: white; padding: 10px 20px; border: none; border-radius: 6px; cursor: pointer; font-size: 16px;">
                    File ▼
                </button>
                <div id="fileDropdown" style="display: none; position: absolute; right: 0; top: 100%; margin-top: 5px; background: white; border: 1px solid #ddd; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; min-width: 200px;">
                    <button onclick="saveInvestigation(); toggleFileMenu();" style="display: block; width: 100%; padding: 12px 20px; border: none; background: none; text-align: left; cursor: pointer; font-size: 14px; transition: background 0.2s;" onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background='none'">
                        💾 Save .bats File
                    </button>
                    <button onclick="handleLoadFile(); toggleFileMenu();" style="display: block; width: 100%; padding: 12px 20px; border: none; background: none; text-align: left; cursor: pointer; font-size: 14px; transition: background 0.2s;" onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background='none'">
                        📂 Load .bats File
                    </button>
                    <button onclick="document.getElementById('excelInput').click(); toggleFileMenu();" style="display: block; width: 100%; padding: 12px 20px; border: none; background: none; text-align: left; cursor: pointer; font-size: 14px; transition: background 0.2s;" onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background='none'">
                        📊 Import Excel Traces
                    </button>
                    <button onclick="document.getElementById('graphImageInput').click(); toggleFileMenu();" style="display: block; width: 100%; padding: 12px 20px; border: none; background: none; text-align: left; cursor: pointer; font-size: 14px; transition: background 0.2s; position: relative;" onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background='none'" title="Import a PNG graph exported from BATS - contains embedded investigation data!">
                        🖼️ Import Graph Image
                        <span style="position: absolute; right: 20px; top: 50%; transform: translateY(-50%); width: 16px; height: 16px; background: #ff9800; color: white; border-radius: 50%; font-size: 10px; display: flex; align-items: center; justify-content: center; font-weight: bold;">✨</span>
                    </button>
                    <div style="border-top: 1px solid #e0e0e0; margin: 5px 0;"></div>
                    <button onclick="showNavigationMenu(); toggleFileMenu();" style="display: block; width: 100%; padding: 12px 20px; border: none; background: none; text-align: left; cursor: pointer; font-size: 14px; transition: background 0.2s;" onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background='none'">
                        📍 Navigate
                    </button>
                    <button onclick="window.open('training.html', '_blank'); toggleFileMenu();" style="display: block; width: 100%; padding: 12px 20px; border: none; background: none; text-align: left; cursor: pointer; font-size: 14px; transition: background 0.2s;" onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background='none'">
                        📚 Training Materials
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Hidden file inputs -->
        <input type="file" id="fileInput" accept=".bats,.json" onchange="loadInvestigation(event)" style="display: none;">
        <input type="file" id="excelInput" accept=".xlsx,.xls,.csv" onchange="importExcelTraces(event)" style="display: none;">
        <input type="file" id="graphImageInput" accept=".png" onchange="importGraphImage(event)" style="display: none;">

        <!-- Progress Indicator (hidden by default, shown when case is loaded) -->
        <div id="progressIndicator" style="display: none; background: linear-gradient(90deg, #2c3e50 0%, #34495e 100%); color: white; padding: 15px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <h3 style="margin: 0; font-size: 16px;">Investigation Progress</h3>
                <span id="progressPercentage" style="font-weight: bold;">0%</span>
            </div>
            <div style="background: rgba(255,255,255,0.2); border-radius: 10px; height: 8px; overflow: hidden;">
                <div id="progressBar" style="background: #3498db; height: 100%; width: 0%; transition: width 0.3s ease; border-radius: 10px;"></div>
            </div>
            <div id="progressStatus" style="margin-top: 10px; font-size: 14px; opacity: 0.9;">Loading...</div>
        </div>

        <!-- Workflow Steps -->
        <div class="workflow-steps">
            <div class="steps-grid">
                <div class="step-item" id="step1">
                    <div class="step-number">1</div>
                    <div><strong>Investigation Setup</strong></div>
                    <div>Case details & investigator info</div>
                </div>
                <div class="step-item" id="step2">
                    <div class="step-number">2</div>
                    <div><strong>Add Victims</strong></div>
                    <div>Document victim transactions</div>
                </div>
                <div class="step-item" id="step3">
                    <div class="step-number">3</div>
                    <div><strong>Confirm Root Total</strong></div>
                    <div>Establish investigation baseline</div>
                </div>
                <div class="step-item" id="step4">
                    <div class="step-number">4</div>
                    <div><strong>Document Traces</strong></div>
                    <div>Record blockchain hops</div>
                </div>
                <div class="step-item" id="step5">
                    <div class="step-number">5</div>
                    <div><strong>Add Write-offs</strong></div>
                    <div>Document abandoned paths</div>
                </div>
                <div class="step-item" id="step6">
                    <div class="step-number">6</div>
                    <div><strong>Validate & Export</strong></div>
                    <div>Generate B.A.T.S. report</div>
                </div>
            </div>
        </div>


        <div class="main-content" style="display: block;">
            <!-- Main Panel -->
            <div class="main-panel" style="margin: 0; width: 100%;">
                <!-- Simplified Action Bar with Breadcrumbs -->
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px 20px; background: #f8f9fa; border-bottom: 2px solid #e8f0fe;">
                    <div id="breadcrumbs" style="font-size: 14px; color: #666;">
                        <!-- Breadcrumbs will be dynamically updated -->
                    </div>
                    <div style="display: flex; gap: 10px;">
                        <button class="btn btn-primary" onclick="openWalletExplorer()"
                                style="background: #3498db; padding: 8px 16px;"
                                title="Open Wallet Explorer - Search wallet transaction history">
                            🔍 Wallet Explorer
                        </button>
                        <button id="undoButton" class="btn" onclick="performUndo()" disabled
                                style="background: #95a5a6; padding: 8px 16px;"
                                title="No actions to undo">
                            ↶ Undo
                        </button>
                    </div>
                </div>
                
                <div class="nav-tabs" id="mainNavTabs" style="display: none;">
                    <button class="nav-tab" onclick="returnToLanding()" style="background: #34495e; color: white;">🏠 Home</button>
                    <button class="nav-tab" onclick="switchTab('casedetails')">Case Details</button>
                    <button class="nav-tab active" onclick="switchTab('victims')">Victims & Transactions</button>
                    <button class="nav-tab" onclick="switchTab('victims'); setTimeout(() => { const hopsSection = document.getElementById('hops-section'); if (hopsSection) hopsSection.scrollIntoView({ behavior: 'smooth', block: 'start' }); }, 100);">Trace Documentation</button>
                    <!-- Old tabs removed - using modern completion modal workflow -->
                </div>

                <!-- Welcome Screen / Landing Page -->
                <!-- BATS Info Tab -->
                <div id="batsinfo-tab" class="tab-content">
                    <div class="section-title">B.A.T.S. Framework Education Center</div>
                    
                    <!-- Key Benefit Highlight -->
                    <div style="background: #e8f4f8; border: 2px solid #3498db; border-radius: 12px; padding: 30px; margin-bottom: 30px; text-align: center;">
                        <h2 style="color: #2c3e50; margin-bottom: 15px;">The Key Benefit of B.A.T.S.</h2>
                        <p style="font-size: 1.3rem; color: #2c3e50; font-weight: 600; margin-bottom: 15px;">
                            Standardized Documentation = Reproducible Results
                        </p>
                        <p style="color: #34495e; font-size: 1.1rem; line-height: 1.6;">
                            Any investigator following the B.A.T.S. methodology will arrive at the same conclusions, creating legally defensible evidence that withstands scrutiny and enables successful asset forfeiture.
                        </p>
                    </div>

                    <!-- Quick Navigation -->
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 30px;">
                        <button class="btn" style="background: #3498db;" onclick="document.getElementById('batsOverview').scrollIntoView({behavior: 'smooth'})">
                            Overview
                        </button>
                        <button class="btn" style="background: #27ae60;" onclick="document.getElementById('batsMethodology').scrollIntoView({behavior: 'smooth'})">
                            Methodology
                        </button>
                        <button class="btn" style="background: #e74c3c;" onclick="document.getElementById('batsNotation').scrollIntoView({behavior: 'smooth'})">
                            V-T-H Notation
                        </button>
                        <button class="btn" style="background: #9b59b6;" onclick="document.getElementById('batsColors').scrollIntoView({behavior: 'smooth'})">
                            Wallet Colors
                        </button>
                        <button class="btn" style="background: #f39c12;" onclick="document.getElementById('batsGoldenThread').scrollIntoView({behavior: 'smooth'})">
                            Golden Thread
                        </button>
                        <button class="btn" style="background: #1abc9c;" onclick="document.getElementById('batsQuickRef').scrollIntoView({behavior: 'smooth'})">
                            Quick Reference
                        </button>
                    </div>

                    <!-- Overview Section -->
                    <div id="batsOverview" style="background: white; border-radius: 8px; padding: 30px; margin-bottom: 30px; box-shadow: 0 2px 10px rgba(0,0,0,0.08);">
                        <h3 style="color: #2c3e50; margin-bottom: 20px;">What is B.A.T.S.?</h3>
                        <p style="line-height: 1.8; margin-bottom: 15px;">
                            The <strong>Block Audit Tracing Standard (B.A.T.S.)</strong> is a revolutionary framework for cryptocurrency investigation that transforms blockchain analysis from an art into a science. It provides the mathematical certainty required for successful asset forfeiture cases.
                        </p>
                        <div style="background: #ecf0f1; padding: 20px; border-radius: 8px; margin: 20px 0;">
                            <h4 style="color: #2c3e50; margin-bottom: 15px;">Core Principles:</h4>
                            <ul style="line-height: 1.8;">
                                <li><strong>Mathematical Precision</strong> - Every dollar accounted for</li>
                                <li><strong>Standardized Process</strong> - Consistent methodology across all cases</li>
                                <li><strong>Legal Compliance</strong> - Meets court requirements for asset forfeiture</li>
                                <li><strong>Scope Control</strong> - Prevents investigation creep</li>
                                <li><strong>Complete Documentation</strong> - Full audit trail for legal review</li>
                            </ul>
                        </div>
                        <div style="background: #d5f4e6; padding: 20px; border-radius: 8px; border-left: 4px solid #27ae60;">
                            <p style="margin: 0;">
                                <strong>Remember:</strong> B.A.T.S. ensures that two different investigators analyzing the same case will reach identical conclusions, providing the reproducibility that courts demand.
                            </p>
                        </div>
                    </div>

                    <!-- Methodology Section -->
                    <div id="batsMethodology" style="background: white; border-radius: 8px; padding: 30px; margin-bottom: 30px; box-shadow: 0 2px 10px rgba(0,0,0,0.08);">
                        <h3 style="color: #2c3e50; margin-bottom: 20px;">The B.A.T.S. Methodology</h3>
                        
                        <div style="margin-bottom: 30px;">
                            <h4 style="color: #27ae60; margin-bottom: 15px;">Step 1: Establish Root Total</h4>
                            <p style="line-height: 1.8; margin-bottom: 10px;">Document all victim losses to create your mathematical baseline. This becomes your Adjusted Root Total (ART) after any justified write-offs.</p>
                            <div style="background: #f8f9fa; padding: 15px; border-radius: 6px; font-family: monospace;">
                                Example: Victim 1 lost $10,000 + Victim 2 lost $5,000 = $15,000 Root Total
                            </div>
                        </div>

                        <div style="margin-bottom: 30px;">
                            <h4 style="color: #27ae60; margin-bottom: 15px;">Step 2: Apply V-T-H Notation</h4>
                            <p style="line-height: 1.8; margin-bottom: 10px;">Assign unique identifiers to every transaction maintaining clear lineage from victims.</p>
                            <div style="background: #f8f9fa; padding: 15px; border-radius: 6px; font-family: monospace;">
                                V1-T1 V1-T1-H1 V1-T1-H2 Terminal Wallet
                            </div>
                        </div>

                        <div style="margin-bottom: 30px;">
                            <h4 style="color: #27ae60; margin-bottom: 15px;">Step 3: Classify Wallets by Color</h4>
                            <p style="line-height: 1.8; margin-bottom: 10px;">Assign permanent colors based on wallet function, not ownership assumptions.</p>
                        </div>

                        <div style="margin-bottom: 30px;">
                            <h4 style="color: #27ae60; margin-bottom: 15px;">Step 4: Validate at Each Hop</h4>
                            <p style="line-height: 1.8; margin-bottom: 10px;">Ensure all thread totals at each hop level sum to your ART. This mathematical validation proves completeness.</p>
                            <div style="background: #fee; padding: 15px; border-radius: 6px; border-left: 4px solid #e74c3c;">
                                <strong>Critical:</strong> If totals don't match, you've missed transactions!
                            </div>
                        </div>

                        <div style="margin-bottom: 30px;">
                            <h4 style="color: #27ae60; margin-bottom: 15px;">Step 5: Document Terminal Points</h4>
                            <p style="line-height: 1.8;">Identify where funds reach exchanges (PURPLE) or cold storage (BLUE) for legal process or monitoring.</p>
                        </div>
                    </div>

                    <!-- V-T-H Notation Section -->
                    <div id="batsNotation" style="background: white; border-radius: 8px; padding: 30px; margin-bottom: 30px; box-shadow: 0 2px 10px rgba(0,0,0,0.08);">
                        <h3 style="color: #2c3e50; margin-bottom: 20px;">Understanding V-T-H Notation</h3>
                        
                        <div style="background: #e8f5e8; padding: 25px; border-radius: 8px; margin-bottom: 20px;">
                            <h4 style="color: #27ae60; margin-bottom: 15px;">The Formula: V[#]-T[#]-H[#]</h4>
                            <ul style="line-height: 2; font-size: 1.1rem;">
                                <li><strong>V</strong> = Victim number (V1, V2, V3...)</li>
                                <li><strong>T</strong> = Transaction number (T1, T2, T3...)</li>
                                <li><strong>H</strong> = Hop count from victim (H1, H2, H3...)</li>
                            </ul>
                        </div>

                        <div style="margin-bottom: 20px;">
                            <h4 style="color: #3498db; margin-bottom: 15px;">Practical Examples:</h4>
                            <table style="width: 100%; border-collapse: collapse;">
                                <tr style="background: #f8f9fa;">
                                    <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Notation</th>
                                    <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Meaning</th>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #ddd; padding: 12px; font-family: monospace;">V1-T1</td>
                                    <td style="border: 1px solid #ddd; padding: 12px;">First victim's first transaction (at RED wallet)</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #ddd; padding: 12px; font-family: monospace;">V1-T1-H1</td>
                                    <td style="border: 1px solid #ddd; padding: 12px;">One hop away from victim's transaction</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #ddd; padding: 12px; font-family: monospace;">V2-T3-H5</td>
                                    <td style="border: 1px solid #ddd; padding: 12px;">Second victim's third transaction, five hops away</td>
                                </tr>
                            </table>
                        </div>

                        <div style="background: #ffeaa7; padding: 20px; border-radius: 8px; border-left: 4px solid #fdcb6e;">
                            <p style="margin: 0;">
                                <strong>Why This Matters:</strong> V-T-H notation creates an unambiguous audit trail that any investigator can follow, ensuring reproducible results.
                            </p>
                        </div>
                    </div>

                    <!-- Wallet Colors Section -->
                    <div id="batsColors" style="background: white; border-radius: 8px; padding: 30px; margin-bottom: 30px; box-shadow: 0 2px 10px rgba(0,0,0,0.08);">
                        <h3 style="color: #2c3e50; margin-bottom: 20px;">Wallet Color Classification</h3>
                        
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                            <div style="background: #ffebee; padding: 20px; border-radius: 8px; border-left: 4px solid #e74c3c;">
                                <h4 style="color: #c0392b; margin-bottom: 10px;">RED Wallets</h4>
                                <p><strong>Definition:</strong> Victim-facing wallets</p>
                                <p><strong>Rule:</strong> First wallet to receive victim funds</p>
                                <p><strong>Example:</strong> Scammer's receiving address</p>
                            </div>

                            <div style="background: #fff8e1; padding: 20px; border-radius: 8px; border-left: 4px solid #f39c12;">
                                <h4 style="color: #f39c12; margin-bottom: 10px;">YELLOW Wallets</h4>
                                <p><strong>Definition:</strong> Convergence/hub wallets</p>
                                <p><strong>Rule:</strong> Where multiple victim traces meet</p>
                                <p><strong>Example:</strong> Criminal consolidation wallet</p>
                            </div>

                            <div style="background: #f3e5f5; padding: 20px; border-radius: 8px; border-left: 4px solid #9b59b6;">
                                <h4 style="color: #8e44ad; margin-bottom: 10px;">PURPLE Wallets</h4>
                                <p><strong>Definition:</strong> Exchange deposit addresses</p>
                                <p><strong>Rule:</strong> Known VASP/exchange wallets</p>
                                <p><strong>Example:</strong> Binance deposit address</p>
                            </div>

                            <div style="background: #e3f2fd; padding: 20px; border-radius: 8px; border-left: 4px solid #3498db;">
                                <h4 style="color: #2980b9; margin-bottom: 10px;">BLUE Wallets</h4>
                                <p><strong>Definition:</strong> Cold storage wallets</p>
                                <p><strong>Rule:</strong> Long-term holding addresses</p>
                                <p><strong>Example:</strong> Criminal savings wallet</p>
                            </div>

                            <div style="background: #f5f5f5; padding: 20px; border-radius: 8px; border-left: 4px solid #34495e;">
                                <h4 style="color: #2c3e50; margin-bottom: 10px;">BLACK Wallets</h4>
                                <p><strong>Definition:</strong> Standard intermediary</p>
                                <p><strong>Rule:</strong> Default for unclassified</p>
                                <p><strong>Example:</strong> Pass-through addresses</p>
                            </div>

                            <div style="background: #e8f5e8; padding: 20px; border-radius: 8px; border-left: 4px solid #27ae60;">
                                <h4 style="color: #27ae60; margin-bottom: 10px;">Remember</h4>
                                <p><strong>Colors are permanent!</strong></p>
                                <p>Once assigned, never change</p>
                                <p>Based on function, not ownership</p>
                            </div>
                        </div>
                    </div>

                    <!-- Golden Thread Section -->
                    <div id="batsGoldenThread" style="background: white; border-radius: 8px; padding: 30px; margin-bottom: 30px; box-shadow: 0 2px 10px rgba(0,0,0,0.08);">
                        <h3 style="color: #2c3e50; margin-bottom: 20px;">The Golden Thread Principle</h3>
                        
                        <div style="background: linear-gradient(135deg, #ffeaa7 0%, #fab1a0 100%); padding: 25px; border-radius: 8px; margin-bottom: 20px;">
                            <h4 style="color: #2c3e50; margin-bottom: 15px;">Definition</h4>
                            <p style="font-size: 1.1rem; line-height: 1.8;">
                                The unbroken connection between a victim's original funds and any assets ultimately seized by law enforcement. This principle is essential for proving in court that specific seized cryptocurrency originated from criminal activity.
                            </p>
                        </div>

                        <div style="margin-bottom: 20px;">
                            <h4 style="color: #e74c3c; margin-bottom: 15px;">The PIFO Method (Proceeds In First Out)</h4>
                            <p style="line-height: 1.8; margin-bottom: 15px;">
                                When traced funds enter a wallet, the very next outbound transaction contains those funds. Apply this strictly chronologically to maintain the golden thread through commingled funds.
                            </p>
                            <div style="background: #f8f9fa; padding: 20px; border-radius: 8px;">
                                <strong>Example:</strong><br>
                                Wallet has 5 BTC existing balance<br>
                                Victim sends 2 BTC (our traced funds)<br>
                                Next transaction out is 3 BTC<br>
                                We trace 2 BTC of that 3 BTC transaction
                            </div>
                        </div>

                        <div style="background: #fee; padding: 20px; border-radius: 8px; border-left: 4px solid #e74c3c;">
                            <h4 style="color: #c0392b; margin-bottom: 10px;">Breaking the Thread</h4>
                            <p style="margin: 0;">
                                The golden thread breaks if you cannot mathematically prove the connection. Common breaks: mixers, privacy coins, or poor documentation. Document these as write-offs.
                            </p>
                        </div>
                    </div>

                    <!-- Quick Reference Section -->
                    <div id="batsQuickRef" style="background: white; border-radius: 8px; padding: 30px; margin-bottom: 30px; box-shadow: 0 2px 10px rgba(0,0,0,0.08);">
                        <h3 style="color: #2c3e50; margin-bottom: 20px;">Quick Reference Guide</h3>
                        
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 20px;">
                            <div style="background: #e8f8f5; padding: 20px; border-radius: 8px;">
                                <h4 style="color: #1abc9c; margin-bottom: 15px;">B.A.T.S. Checklist</h4>
                                <ul style="line-height: 1.8;">
                                    <li>☐ Document all victim transactions</li>
                                    <li>☐ Calculate and confirm root total</li>
                                    <li>☐ Apply V-T-H notation consistently</li>
                                    <li>☐ Classify wallets by color (permanent!)</li>
                                    <li>☐ Validate totals at each hop level</li>
                                    <li>☐ Document all write-offs with justification</li>
                                    <li>☐ Identify terminal wallets (PURPLE/BLUE)</li>
                                    <li>☐ Export comprehensive report</li>
                                </ul>
                            </div>

                            <div style="background: #fef9e7; padding: 20px; border-radius: 8px;">
                                <h4 style="color: #f39c12; margin-bottom: 15px;">Key Terms</h4>
                                <dl style="line-height: 1.8;">
                                    <dt><strong>ART</strong></dt>
                                    <dd>Adjusted Root Total (after write-offs)</dd>
                                    
                                    <dt><strong>Thread Total</strong></dt>
                                    <dd>Amount being traced at specific hop</dd>
                                    
                                    <dt><strong>Convergence</strong></dt>
                                    <dd>Multiple traces meeting at one wallet</dd>
                                    
                                    <dt><strong>Write-off</strong></dt>
                                    <dd>Documented abandonment of trace</dd>
                                    
                                    <dt><strong>Terminal Wallet</strong></dt>
                                    <dd>Exchange or cold storage endpoint</dd>
                                </dl>
                            </div>
                        </div>

                        <div style="background: #d5f4e6; padding: 20px; border-radius: 8px; margin-top: 20px; text-align: center;">
                            <h4 style="color: #27ae60; margin-bottom: 15px;">Always Remember</h4>
                            <p style="font-size: 1.2rem; font-weight: 600; margin: 0;">
                                Standardized Process = Reproducible Results = Successful Forfeiture
                            </p>
                        </div>
                    </div>

                    <!-- Getting Started -->
                    <div style="background: linear-gradient(135deg, #a29bfe 0%, #6c5ce7 100%); color: white; padding: 30px; border-radius: 8px; text-align: center;">
                        <h3 style="margin-bottom: 20px;">Ready to Begin?</h3>
                        <p style="font-size: 1.1rem; margin-bottom: 20px;">
                            Now that you understand the B.A.T.S. methodology, start your investigation with confidence!
                        </p>
                        <button class="btn btn-large" style="background: white; color: #6c5ce7;" onclick="switchTab('victims')">
                            Start Investigation
                        </button>
                    </div>
                </div>

                <!-- Case Details Tab -->
                <div id="casedetails-tab" class="tab-content">
                    <div class="section-title">Case Information & Management</div>
                    
                    <div class="case-details-card" style="max-width: 900px; margin: 0 auto;">
                        <div style="background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-radius: 12px; padding: 30px; margin-bottom: 30px;">
                            <h3 style="color: #2c3e50; margin-bottom: 25px;">Investigation Details</h3>
                            
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                                <div class="form-group">
                                    <label for="caseId">Case ID</label>
                                    <input type="text" id="caseId" placeholder="e.g., CASE-2025-001">
                                </div>
                                <div class="form-group">
                                    <label for="investigator">Investigator</label>
                                    <input type="text" id="investigator" placeholder="Your name">
                                </div>
                            </div>
                            
                            <div class="form-group">
                                <label for="caseType">Case Type</label>
                                <select id="caseType">
                                    <option value="">Select type...</option>
                                    <option value="investment_fraud">Investment Fraud</option>
                                    <option value="ransomware">Ransomware</option>
                                    <option value="romance_scam">Romance Scam</option>
                                    <option value="business_email_compromise">Business Email Compromise</option>
                                    <option value="crypto_theft">Cryptocurrency Theft</option>
                                    <option value="other">Other</option>
                                </select>
                            </div>
                            
                            <div class="form-group">
                                <label for="caseSynopsis">Case Synopsis</label>
                                <textarea id="caseSynopsis" rows="5" placeholder="Briefly describe the circumstances that led to the victim's asset loss (e.g., investment platform, romance scam details, ransomware attack, etc.)" style="width: 100%; padding: 12px; border: 2px solid #e8f0fe; border-radius: 6px; resize: vertical;"></textarea>
                                <div style="font-size: 12px; color: #666; margin-top: 5px;">This will be included in the final report</div>
                            </div>
                            
                            <!-- Tracing Method Selection - PROMINENT -->
                            <div class="form-group" style="background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%); padding: 25px; border-radius: 12px; margin-top: 25px; border: 3px solid #2196f3; box-shadow: 0 4px 12px rgba(33, 150, 243, 0.2);">
                                <div style="text-align: center; margin-bottom: 20px;">
                                    <h3 style="color: #1565c0; margin: 0 0 5px 0; font-size: 20px;">⚖️ Select Tracing Methodology</h3>
                                    <p style="color: #666; font-size: 13px; margin: 0;">Critical Decision: Choose the methodology that best fits your investigation type</p>
                                </div>

                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px;">
                                    <!-- PIFO Option -->
                                    <label style="cursor: pointer; background: white; padding: 20px; border-radius: 8px; border: 3px solid #ddd; transition: all 0.3s; position: relative;"
                                           onmouseover="this.style.borderColor='#2196f3'; this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(33, 150, 243, 0.3)'"
                                           onmouseout="this.style.borderColor='#ddd'; this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                                            <div style="display: flex; align-items: center; gap: 10px;">
                                                <input type="radio" name="tracingMethod" value="PIFO" checked onchange="updateTracingMethod('PIFO')"
                                                       style="width: 20px; height: 20px; cursor: pointer;">
                                                <strong style="font-size: 16px; color: #2c3e50;">PIFO (Default)</strong>
                                            </div>
                                            <button type="button" onclick="event.preventDefault(); event.stopPropagation(); showMethodologyInfo('PIFO'); return false;"
                                                    style="background: #2196f3; color: white; border: none; border-radius: 50%; width: 28px; height: 28px; cursor: pointer; font-weight: bold; font-size: 14px;"
                                                    title="Click for detailed explanation">ℹ️</button>
                                        </div>
                                        <div style="color: #1976d2; font-size: 13px; font-weight: 600; margin-bottom: 8px;">Proceeds In, First Out</div>
                                        <div style="font-size: 13px; color: #555; line-height: 1.5;">
                                            Next outbound transaction after deposit contains the traced funds. Best for rapid movement scenarios and most investigations.
                                        </div>
                                        <div style="margin-top: 12px; padding: 8px; background: #e8f5e9; border-radius: 4px; font-size: 12px; color: #2e7d32;">
                                            ✅ <strong>Best for:</strong> Most fraud cases, rapid fund movement
                                        </div>
                                    </label>

                                    <!-- LIBR Option -->
                                    <label style="cursor: pointer; background: white; padding: 20px; border-radius: 8px; border: 3px solid #ddd; transition: all 0.3s; position: relative;"
                                           onmouseover="this.style.borderColor='#ff9800'; this.style.transform='translateY(-2px)'; this.style.boxShadow='0 6px 16px rgba(255, 152, 0, 0.3)'"
                                           onmouseout="this.style.borderColor='#ddd'; this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                                        <div style="display: flex; align-items: center; justify-content: space-between; margin-bottom: 12px;">
                                            <div style="display: flex; align-items: center; gap: 10px;">
                                                <input type="radio" name="tracingMethod" value="LIBR" onchange="updateTracingMethod('LIBR')"
                                                       style="width: 20px; height: 20px; cursor: pointer;">
                                                <strong style="font-size: 16px; color: #2c3e50;">LIBR</strong>
                                            </div>
                                            <button type="button" onclick="event.preventDefault(); event.stopPropagation(); showMethodologyInfo('LIBR'); return false;"
                                                    style="background: #ff9800; color: white; border: none; border-radius: 50%; width: 28px; height: 28px; cursor: pointer; font-weight: bold; font-size: 14px;"
                                                    title="Click for detailed explanation">ℹ️</button>
                                        </div>
                                        <div style="color: #f57c00; font-size: 13px; font-weight: 600; margin-bottom: 8px;">Lowest Intermediate Balance Rule</div>
                                        <div style="font-size: 13px; color: #555; line-height: 1.5;">
                                            Arrests asset flow, keeping funds in fewer wallets. Monitors balance drops to identify outbound proceeds.
                                        </div>
                                        <div style="margin-top: 12px; padding: 8px; background: #fff3cd; border-radius: 4px; font-size: 12px; color: #f57c00;">
                                            ⚡ <strong>Best for:</strong> Stablecoin cases, wallet seizure scenarios
                                        </div>
                                    </label>
                                </div>

                                <div style="background: #fff; border: 2px solid #ffc107; border-radius: 6px; padding: 15px; margin-top: 20px; text-align: center;">
                                    <strong style="color: #f57c00;">⚠️ Important:</strong>
                                    <span style="color: #2c3e50;"> Once chosen, maintain the same method throughout your investigation for consistency and legal defensibility.</span>
                                </div>
                            </div>
                            
                            <div style="text-align: center; margin-top: 30px;">
                                <button class="btn btn-confirm" onclick="saveCaseDetails()" style="padding: 15px 40px; font-size: 18px;">
                                    Save Case Details
                                </button>
                                <div id="nextStepContainer" style="display: none; margin-top: 20px;">
                                    <button class="btn btn-primary" onclick="switchTab('victims')" style="padding: 15px 40px; font-size: 18px; background: #27ae60;">
                                        Next: Add Victims →
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Investigation Statistics -->
                        <div style="background: white; border-radius: 12px; padding: 30px; box-shadow: 0 2px 10px rgba(0,0,0,0.08);">
                            <h3 style="color: #2c3e50; margin-bottom: 25px;">Investigation Progress</h3>
                            <div id="caseStats" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;">
                                <!-- Stats will be populated dynamically -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Victims Tab -->
                <div id="victims-tab" class="tab-content">
                    <div class="section-title">Step 2: Victim Transactions</div>
                    
                    <div id="addVictimSection" style="text-align: center; margin: 30px 0;">
                        <!-- Add New Victim button will be shown conditionally -->
                    </div>
                    
                    <!-- Enhanced Instructions -->
                    <div id="victimInstructions" style="background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%); border: 2px solid #2196f3; border-radius: 12px; padding: 25px; margin-bottom: 30px;">
                        <h3 style="color: #1976d2; margin-bottom: 15px;">Document All Victim Transactions</h3>
                        <p style="color: #2c3e50; margin-bottom: 15px;">
                            Enter ALL transactions where victims sent assets to scammer-controlled wallets. This creates the foundation for your entire investigation.
                        </p>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                            <div style="background: white; padding: 15px; border-radius: 6px;">
                                <strong style="color: #1976d2;">Required Information:</strong>
                                <ul style="margin: 10px 0 0 20px; color: #555;">
                                    <li>Transaction hash</li>
                                    <li>Amount & currency</li>
                                    <li>Date & time (UTC)</li>
                                    <li>Receiving (RED) wallet</li>
                                </ul>
                            </div>
                            <div style="background: white; padding: 15px; border-radius: 6px;">
                                <strong style="color: #27ae60;">Pro Tips:</strong>
                                <ul style="margin: 10px 0 0 20px; color: #555;">
                                    <li>Use API lookup to auto-fill</li>
                                    <li>Paste multiple hashes at once</li>
                                    <li>V-T notation auto-assigns</li>
                                    <li>Save regularly (.bats file)</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                    
                    <div id="victimsList"></div>
                    
                    <!-- Generate Root Total Section -->
                    <div id="generateRootSection" style="display: none; max-width: 800px; margin: 0 auto;">
                        <div class="generate-root-section">
                            <h3>Ready to Generate Root Total?</h3>
                            <p>You've entered victim transaction data. The next step is to establish your investigation baseline by generating and confirming your Root Total.</p>
                            <div id="saveRequiredMessage" style="display: none; background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 20px; margin: 20px 0;">
                                <h4 style="color: #856404; margin: 0 0 10px 0;">Save Required to Continue</h4>
                                <p style="color: #666; margin-bottom: 15px;">
                                    Before proceeding, you must save your investigation file. This will enable automatic saving at each hop.
                                </p>
                                <button class="btn btn-confirm" onclick="saveAndCaptureFilePath()" style="background: #ffc107; color: #333; padding: 10px 30px;">
                                    Save Investigation and Calculate ART
                                </button>
                            </div>
                            <div style="text-align: center; margin: 20px 0;">
                                <button class="btn btn-confirm btn-large" id="generateRootBtn" onclick="generateRootTotal()" style="display: none; padding: 15px 40px; font-size: 1.2rem; margin: 0 auto;">
                                    Generate Root Total & Begin Tracing
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Trace Documentation / Hops Section -->
                    <div id="hops-section" style="margin-top: 40px;">
                        <div id="hopsList"></div>
                    </div>

                </div>

                <!-- Reports Tab -->
                <div id="reports-tab" class="tab-content">
                    <div class="section-title">Investigation Reports</div>

                    <div class="controls">
                        <button class="btn-secondary" onclick="switchTab('victims')">← Back to Investigation</button>
                        <span style="flex: 1;"></span>
                        <button class="btn-primary" onclick="proceedWithVisualizationFirst()">📊 Open Visualization</button>
                        <button class="btn-success" onclick="exportCompleteReport()">📄 Export Complete Report</button>
                    </div>

                    <!-- Case Info Header -->
                    <div style="padding: 20px; max-width: 1200px; margin: 0 auto;">
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                            <strong>Case ID:</strong> <span id="report-case-id"></span> |
                            <strong>Investigator:</strong> <span id="report-investigator"></span> |
                            <strong>Date:</strong> <span id="report-date"></span>
                        </div>
                    </div>

                    <!-- Reports Sub-Navigation -->
                    <div style="display: flex; justify-content: center; gap: 10px; margin-bottom: 20px; padding: 0 20px;">
                        <button class="btn-primary" onclick="switchReportTab('audit-trail')" id="report-tab-audit" style="background: #3498db;">
                            🔍 Audit Trail
                        </button>
                        <button class="btn-primary" onclick="switchReportTab('indexes')" id="report-tab-indexes" style="background: #95a5a6;">
                            📋 Wallet Indexes
                        </button>
                        <button class="btn-primary" onclick="switchReportTab('narrative')" id="report-tab-narrative" style="background: #95a5a6;">
                            📝 Narrative
                        </button>
                    </div>

                    <div id="reports-container" style="padding: 20px; max-width: 1200px; margin: 0 auto;">

                        <!-- Audit Trail Tab -->
                        <div id="report-audit-trail-section" class="report-section" style="display: block;">
                            <h2 style="color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 10px; margin-bottom: 20px;">🔍 Technical Audit Trail</h2>
                            <div id="report-technical-content"></div>
                        </div>

                        <!-- Wallet Indexes Tab -->
                        <div id="report-indexes-section" class="report-section" style="display: none;">
                            <h2 style="color: #2c3e50; border-bottom: 2px solid #e74c3c; padding-bottom: 10px; margin-bottom: 20px;">📋 Wallet Indexes</h2>

                            <!-- Index Type Selector -->
                            <div style="margin-bottom: 20px;">
                                <button class="btn-secondary" onclick="showWalletIndex('universal')" id="index-btn-universal" style="background: #34495e;">
                                    Universal Index
                                </button>
                                <button class="btn-secondary" onclick="showWalletIndex('red')" id="index-btn-red" style="background: #95a5a6;">
                                    Red (Victim) Wallets
                                </button>
                                <button class="btn-secondary" onclick="showWalletIndex('purple')" id="index-btn-purple" style="background: #95a5a6;">
                                    Purple (Terminal) Wallets
                                </button>
                            </div>

                            <!-- Universal Wallet Index -->
                            <div id="wallet-index-universal" class="wallet-index-view" style="display: block;">
                                <h3 style="color: #34495e;">Universal Wallet Index</h3>
                                <p style="color: #7f8c8d; font-size: 14px; margin-bottom: 15px;">All wallets encountered in this investigation, in chronological order of first appearance.</p>
                                <div id="report-universal-index" style="overflow-x: auto;"></div>
                            </div>

                            <!-- Red Wallet Index -->
                            <div id="wallet-index-red" class="wallet-index-view" style="display: none;">
                                <h3 style="color: #e74c3c;">Red Wallet Index (Bad Actor Wallets)</h3>
                                <p style="color: #7f8c8d; font-size: 14px; margin-bottom: 15px;">First bad actor wallets that directly received stolen funds from victims.</p>
                                <div id="report-red-index" style="overflow-x: auto;"></div>
                            </div>

                            <!-- Purple Wallet Index -->
                            <div id="wallet-index-purple" class="wallet-index-view" style="display: none;">
                                <h3 style="color: #9b59b6;">Purple Wallet Index (Terminal/Exchange Wallets)</h3>
                                <p style="color: #7f8c8d; font-size: 14px; margin-bottom: 15px;">Exchange deposit addresses and other terminal destinations where funds cannot be traced further.</p>
                                <div id="report-purple-index" style="overflow-x: auto;"></div>
                            </div>
                        </div>

                        <!-- Narrative Tab -->
                        <div id="report-narrative-section" class="report-section" style="display: none;">
                            <h2 style="color: #2c3e50; border-bottom: 2px solid #27ae60; padding-bottom: 10px; margin-bottom: 20px;">📝 Investigation Narrative</h2>
                            <p style="color: #7f8c8d; font-size: 14px; margin-bottom: 15px;">
                                Document your investigation methodology, findings, and conclusions. This narrative will be included in exported reports.
                            </p>
                            <textarea id="report-narrative-textarea"
                                style="width: 100%; min-height: 400px; padding: 15px; border: 2px solid #bdc3c7; border-radius: 8px; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; font-size: 14px; line-height: 1.6;"
                                placeholder="Write your investigation narrative here. Include:
- Summary of the incident
- Investigation methodology
- Key findings and evidence
- Conclusions and recommendations
- Any outstanding questions or next steps"></textarea>
                            <div style="margin-top: 15px;">
                                <button class="btn-success" onclick="saveNarrative()">💾 Save Narrative</button>
                                <span id="narrative-save-status" style="margin-left: 15px; color: #27ae60; font-weight: bold;"></span>
                            </div>
                        </div>

                    </div>
                </div>

    <!-- OLD TABS REMOVED: Wallet Indexes, PK Converter, Flow Diagram, Reports, Summary
         These were duplicate/legacy features. The modern workflow uses:
         1. Enhanced completion modal when investigation completes
         2. Visualization opens in popup window with Canvas-based interactive graph
         3. Reports integrated into the completion workflow
         The investigation workflow uses 3 tabs: BATS Info, Case Details, and Victims/Transactions -->

    <!-- Root Total Confirmation Modal -->
    <div id="rootTotalModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Confirm Investigation Root Total</h2>
                <p>Review your baseline before beginning trace documentation</p>
            </div>
            
            <!-- Root Total Explanation -->
            <div class="root-explanation">
                <h4>📚 What is a Root Total?</h4>
                <ul>
                    <li><strong>Investigation Baseline:</strong> The total amount of confirmed victim losses</li>
                    <li><strong>Mathematical Foundation:</strong> All traced amounts must sum back to this total</li>
                    <li><strong>Golden Thread:</strong> Ensures complete accounting and prevents scope creep</li>
                    <li><strong>Legal Requirement:</strong> Essential for asset forfeiture case integrity</li>
                </ul>
            </div>

            <!-- Transaction Breakdown -->
            <div id="rootTotalBreakdown"></div>
            
            <!-- Root Total Display -->
            <div class="root-total-display">
                <div style="font-size: 1.2rem; margin-bottom: 10px;">🔢 Total Root Amount</div>
                <div id="totalRootAmount" class="root-total-amount">$0</div>
                <div style="font-size: 0.9rem; color: #666; margin-top: 10px;">
                    This becomes your Adjusted Root Total (ART) for validation
                </div>
            </div>
            
            <div style="text-align: center; margin-top: 30px;">
                <button class="btn btn-confirm btn-large" onclick="confirmAndProceed()">
                    Confirm Root Total & Start Tracing
                </button>
                <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Convergence Modal -->
    <div id="convergenceModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Record Convergence</h2>
                <p>Select multiple traces that are merging at a single wallet</p>
            </div>
            <div id="convergenceTraceSelection"></div>
            <div class="form-group">
                <label>Resulting Notation</label>
                <input type="text" id="convergenceNotation" placeholder="e.g., V1-T1(3)-H6 or V1,V2-T1-H4">
            </div>
            <div class="form-group">
                <label>Resulting Hop Level</label>
                <input type="number" id="convergenceHopLevel" readonly>
            </div>
            <div class="form-group">
                <label>Total Amount</label>
                <input type="number" id="convergenceAmount" readonly>
            </div>
            <div style="text-align: center; margin-top: 25px;">
                <button class="btn btn-confirm" onclick="createConvergenceTrace()">Create Merged Trace</button>
                <button class="btn btn-secondary" onclick="closeConvergenceModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Asset Conversion Modal -->
    <div id="assetConversionModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Asset Conversion Documentation</h2>
                <p>Document the cryptocurrency conversion process</p>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                <div class="form-group">
                    <label>Original Currency (From Source Thread)</label>
                    <select id="conversionFromCurrency" disabled style="background: #f8f9fa;">
                        <option value="">Not Set</option>
                        <option value="USD">US Dollar</option>
                        <option value="BTC">Bitcoin</option>
                        <option value="ETH">Ethereum</option>
                        <option value="USDT">Tether</option>
                        <option value="USDC">USD Coin</option>
                        <option value="TRX">TRON</option>
                        <option value="SOL">Solana</option>
                        <option value="ADA">Cardano</option>
                        <option value="DAI">DAI</option>
                        <option value="BNB">BNB</option>
                        <option value="MATIC">MATIC</option>
                        <option value="AVAX">AVAX</option>
                        <option value="HYPE">HYPE</option>
                        <option value="MNT">MNT</option>
                        <option value="CUSTOM">Custom Currency</option>
                    </select>
                    <div style="font-size: 11px; color: #666; margin-top: 5px;">
                        Currency is inherited from the selected source thread
                    </div>
                </div>
                <div class="form-group">
                    <label>Converted To Currency</label>
                    <select id="conversionToCurrency">
                        <option value="USD">US Dollar</option>
                        <option value="BTC">Bitcoin</option>
                        <option value="ETH">Ethereum</option>
                        <option value="USDT">Tether</option>
                        <option value="USDC">USD Coin</option>
                        <option value="TRX">TRON</option>
                        <option value="SOL">Solana</option>
                        <option value="ADA">Cardano</option>
                        <option value="DAI">DAI</option>
                        <option value="BNB">BNB</option>
                        <option value="MATIC">MATIC</option>
                        <option value="AVAX">AVAX</option>
                        <option value="HYPE">HYPE</option>
                        <option value="MNT">MNT</option>
                        <option value="CUSTOM">Custom Currency</option>
                    </select>
                </div>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                <div class="form-group" id="customFromCurrencyGroup" style="display: none;">
                    <label>Custom Original Currency</label>
                    <input type="text" id="conversionFromCurrencyCustom" placeholder="e.g., DOGE, SHIB">
                </div>
                <div class="form-group" id="customToCurrencyGroup" style="display: none;">
                    <label>Custom Converted Currency</label>
                    <input type="text" id="conversionToCurrencyCustom" placeholder="e.g., DOGE, SHIB">
                </div>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                <div class="form-group">
                    <label>Original Amount</label>
                    <div style="display: flex; gap: 10px;">
                        <input type="number" step="0.01" id="conversionFromAmount" placeholder="Amount sent" style="flex: 1;">
                        <button class="btn btn-sm" onclick="copyConversionAmount()" title="Copy amount for stablecoin swaps" style="padding: 8px 12px;">
                            📋 Copy
                        </button>
                    </div>
                </div>
                <div class="form-group">
                    <label>Converted Amount</label>
                    <input type="number" step="0.01" id="conversionToAmount" placeholder="Amount received">
                </div>
            </div>

            <div class="form-group">
                <label>Conversion Platform/Service</label>
                <input type="text" id="conversionPlatform" placeholder="e.g., Uniswap, PancakeSwap, Bridge Protocol">
            </div>

            <div class="form-group">
                <label>Conversion Notes</label>
                <textarea id="conversionNotes" rows="3" placeholder="Additional details about the conversion process, fees, slippage, etc."></textarea>
            </div>
            
            <div style="text-align: center; margin-top: 25px;">
                <button class="btn btn-confirm" onclick="confirmAssetConversion()">Document Conversion</button>
                <button class="btn btn-secondary" onclick="closeAssetConversionModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Smart Allocation Modal -->
    <div id="smartAllocationModal" class="modal">
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-header">
                <h2>🎯 Smart Amount Allocation</h2>
                <p>Automatically calculate how to split a transaction amount across available funds</p>
            </div>
            
            <div style="background: #e3f2fd; border: 2px solid #2196f3; border-radius: 8px; padding: 20px; margin: 20px 0;">
                <h4 style="color: #1976d2; margin-bottom: 15px;">📚 What is this for?</h4>
                <p style="margin-bottom: 15px; font-size: 16px;">
                    When you see a transaction on the blockchain (e.g., 50 BTC sent), but you have funds from multiple sources 
                    (e.g., 30 BTC from one victim, 40 BTC from another), this tool helps you determine which funds were used.
                </p>
                <div style="background: white; border-radius: 6px; padding: 15px; margin-top: 10px;">
                    <strong>Example:</strong> If the scammer has 30 BTC from Victim 1 and 40 BTC from Victim 2, and sends 50 BTC:
                    <ul style="margin: 10px 0 0 20px;">
                        <li>The tool will automatically use all 30 BTC from Victim 1</li>
                        <li>Then take 20 BTC from Victim 2</li>
                        <li>Following FIFO (First In, First Out) principle</li>
                    </ul>
                </div>
            </div>
            
            <div style="background: #e8f5e8; border: 2px solid #27ae60; border-radius: 8px; padding: 20px; margin: 20px 0;">
                <h4 style="color: #27ae60; margin-bottom: 15px;">🔧 How it works:</h4>
                <p style="margin-bottom: 10px;">Enter the total amount from the blockchain transaction, and the system will:</p>
                <ol style="margin-left: 20px; color: #2c3e50;">
                    <li>Use available funds in chronological order (oldest first)</li>
                    <li>Fully deplete each source before using the next</li>
                    <li>Show you exactly how the amount is distributed across sources</li>
                </ol>
                <div style="margin-top: 15px; padding: 15px; background: white; border-radius: 6px; font-family: monospace; font-size: 12px;">
                    <div style="margin-bottom: 5px;"><strong>Example:</strong> You need 20 BTC</div>
                    <div style="margin-bottom: 3px;">• Source 1: V1-T1 has 10 BTC Use all 10 BTC</div>
                    <div style="margin-bottom: 3px;">• Source 2: V1-T2 has 15 BTC Use 10 BTC (5 BTC remains)</div>
                    <div style="color: #27ae60; font-weight: bold;">Total allocated: 20 BTC</div>
                </div>
            </div>
            
            <div style="margin-bottom: 20px;">
                <h4 style="color: #2c3e50; margin-bottom: 15px;">Target Amount:</h4>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="number" 
                           id="smartAllocationTargetAmount"
                           step="0.00000001" 
                           placeholder="Enter amount to allocate"
                           style="flex: 1; padding: 12px; border: 2px solid #27ae60; border-radius: 6px; font-size: 16px;">
                    <select id="smartAllocationTargetCurrency" 
                            style="padding: 12px; border: 2px solid #27ae60; border-radius: 6px; font-size: 16px;">
                        <option value="">Select currency...</option>
                    </select>
                </div>
            </div>
            
            <div id="smartAllocationAvailableSources" style="margin-bottom: 20px; display: none;">
                <h4 style="color: #2c3e50; margin-bottom: 15px;">Available Source Threads:</h4>
                <div id="availableSourcesList" style="max-height: 200px; overflow-y: auto;"></div>
            </div>
            
            <div id="smartAllocationPreview" style="display: none;">
                <h4 style="color: #2c3e50; margin-bottom: 15px;">Allocation Preview:</h4>
                <div id="allocationPreviewContent"></div>
            </div>
            
            <div id="smartAllocationError" style="display: none; background: #fee; border: 1px solid #c00; border-radius: 6px; padding: 15px; margin: 20px 0; color: #c00;">
            </div>
            
            <div style="text-align: center; margin-top: 25px;">
                <button class="btn btn-confirm" id="confirmSmartAllocation" onclick="confirmSmartAllocation()" style="display: none;">
                    Apply Allocation
                </button>
                <button class="btn btn-secondary" onclick="closeSmartAllocationModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Excel Import Modal -->
    <div id="excelImportModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>📊 Import Excel Traces</h2>
                <p>Import blockchain traces from your analysis software</p>
            </div>
            
            <div style="background: #e8f4f8; border: 2px solid #3498db; border-radius: 8px; padding: 20px; margin: 20px 0;">
                <h4 style="color: #2c3e50; margin-bottom: 15px;">Required Excel Format</h4>
                <div style="font-family: monospace; font-size: 12px; background: white; padding: 15px; border-radius: 6px;">
                    <div style="font-weight: bold; margin-bottom: 8px; color: #666;">
                        Hop_Notation | Wallet_Address | Wallet_ID | Amount | Currency
                    </div>
                    <div style="margin-bottom: 4px;">V1-T1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| bc1q...abc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| RED1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 5000&nbsp;&nbsp;&nbsp;| USD</div>
                    <div style="margin-bottom: 4px;">V1-T1-H1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 1A2B...def&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| BLACK1&nbsp;&nbsp;&nbsp;&nbsp;| 5000&nbsp;&nbsp;&nbsp;| USD</div>
                    <div style="margin-bottom: 4px;">V1-T1-H2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 3CdE...ghi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| BLUE1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 4950&nbsp;&nbsp;&nbsp;| USD</div>
                    <div>V2-T1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| bc1q...xyz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| RED2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 2500&nbsp;&nbsp;&nbsp;| BTC</div>
                </div>
                <div style="margin-top: 15px; font-size: 14px; color: #2c3e50;">
                    <strong>Supported Wallet IDs:</strong> RED1, BLACK1, BLUE1, PURPLE1, YELLOW1, ORANGE1, BROWN1, PINK1, GRAY1, GREEN1
                </div>
            </div>
            
            <div id="importPreview" style="display: none;">
                <h4 style="color: #2c3e50; margin-bottom: 15px;">Import Preview</h4>
                <div id="importSummary" style="background: #f8f9fa; padding: 15px; border-radius: 6px; margin-bottom: 15px;"></div>
                <div id="importErrors" style="display: none;"></div>
            </div>
            
            <div style="text-align: center; margin-top: 25px;">
                <button class="btn btn-confirm" id="confirmImportBtn" onclick="confirmExcelImport()" style="display: none;">
                    Import Investigation
                </button>
                <button class="btn btn-secondary" onclick="closeExcelImportModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Bulk Transaction Modal -->
    <div id="bulkTransactionModal" class="modal">
        <div class="modal-content" style="max-width: 900px;">
            <div class="modal-header">
                <h2>Bulk Add Transactions</h2>
                <p>Paste multiple transaction hashes (one per line) to add them all at once. They will be automatically sorted by date.</p>
            </div>
            
            <div style="margin: 20px 0;">
                <label style="display: block; font-weight: bold; margin-bottom: 10px;">Transaction Hashes:</label>
                <textarea id="bulkTransactionHashes" 
                          placeholder="Paste transaction hashes here, one per line&#10;&#10;Example:&#10;0x123abc...&#10;0x456def...&#10;0x789ghi..."
                          style="width: 100%; height: 200px; padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace; font-size: 13px;"></textarea>
                
                <div style="margin-top: 15px; padding: 15px; background: #e8f4f8; border: 1px solid #3498db; border-radius: 6px;">
                    <h4 style="color: #2c3e50; margin-bottom: 10px;">💡 How it works:</h4>
                    <ul style="margin: 0; padding-left: 20px; color: #34495e;">
                        <li>Paste all transaction hashes at once</li>
                        <li>Click "Process Transactions" to fetch all data</li>
                        <li>Transactions will be automatically sorted by date</li>
                        <li>V-T notation will be assigned in chronological order</li>
                        <li>Failed lookups will be created as empty transactions for manual entry</li>
                    </ul>
                </div>
                
                <div id="bulkProcessingStatus" style="margin-top: 15px; display: none;">
                    <div style="padding: 10px; background: #f8f9fa; border-radius: 4px;">
                        <div id="bulkProgressBar" style="background: #e0e0e0; height: 20px; border-radius: 10px; overflow: hidden;">
                            <div id="bulkProgressFill" style="background: #3498db; height: 100%; width: 0%; transition: width 0.3s;"></div>
                        </div>
                        <div id="bulkProgressText" style="text-align: center; margin-top: 10px; font-size: 14px; color: #666;">Processing...</div>
                    </div>
                </div>
                
                <div id="bulkProcessingResults" style="margin-top: 15px; display: none;">
                    <h4>Processing Results:</h4>
                    <div id="bulkResultsList" style="max-height: 300px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px; padding: 10px; background: #f8f9fa;"></div>
                </div>
            </div>
            
            <div style="text-align: center; margin-top: 25px;">
                <button class="btn btn-confirm" onclick="processBulkTransactions()" id="bulkProcessBtn">
                    🚀 Process Transactions
                </button>
                <button class="btn btn-secondary" onclick="closeBulkTransactionModal()">
                    Cancel
                </button>
            </div>
        </div>
    </div>

    <!-- Transfer Selection Modal -->
    <div id="transferSelectionModal" class="modal">
        <div class="modal-content" style="max-width: 900px;">
            <div class="modal-header">
                <h2>Select Transfer</h2>
                <p>This transaction contains multiple token transfers. Please select the one that belongs to your victim:</p>
            </div>
            
            <!-- Filter Section -->
            <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 15px 0;">
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr auto; gap: 10px; align-items: end;">
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: 500;">Filter by Asset:</label>
                        <select id="transferAssetFilter" 
                               style="width: 100%; padding: 8px; border: 2px solid #e8f0fe; border-radius: 6px;"
                               onchange="filterTransfers()">
                            <option value="">All Assets</option>
                        </select>
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: 500;">Filter by Amount:</label>
                        <input type="text" id="transferAmountFilter" placeholder="e.g., 1000 or 1000.50" 
                               style="width: 100%; padding: 8px; border: 2px solid #e8f0fe; border-radius: 6px;"
                               oninput="filterTransfers()">
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: 500;">Filter by Address:</label>
                        <input type="text" id="transferAddressFilter" placeholder="To or From address" 
                               style="width: 100%; padding: 8px; border: 2px solid #e8f0fe; border-radius: 6px;"
                               oninput="filterTransfers()">
                    </div>
                    <button class="btn btn-secondary" onclick="clearTransferFilters()" style="padding: 8px 15px;">
                        Clear
                    </button>
                </div>
                <div id="filterResultsInfo" style="margin-top: 10px; font-size: 14px; color: #666;"></div>
            </div>
            
            <div id="transfersList" style="margin: 20px 0; max-height: 400px; overflow-y: auto;">
                <!-- Transfers will be populated here -->
            </div>
            
            <div style="text-align: center; margin-top: 25px;">
                <button class="btn btn-secondary" onclick="closeTransferSelectionModal()">
                    Cancel
                </button>
            </div>
        </div>
    </div>

    <!-- Address Attribution Modal -->
    <div id="attributionModal" class="modal">
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-header">
                <h2>🔍 Address Attribution Detected</h2>
                <button class="close" onclick="hideModal('attributionModal')">&times;</button>
            </div>
            
            <div id="attributionContent" style="padding: 20px;">
                <!-- Content will be dynamically populated -->
            </div>
            
            <div style="text-align: center; margin-top: 20px; padding-top: 20px; border-top: 1px solid #e8f0fe;">
                <button class="btn btn-primary" onclick="applyAttribution()">
                    Apply Attribution to Wallet
                </button>
                <button class="btn btn-secondary" onclick="hideModal('attributionModal')">
                    Ignore
                </button>
            </div>
        </div>
    </div>

    <!-- Wallet Explorer Modal -->
    <div id="walletExplorerModal" class="modal">
        <div class="modal-content" style="max-width: 1200px; max-height: 90vh;">
            <div class="modal-header">
                <h2>🔍 Wallet Explorer</h2>
                <p>View wallet transaction history across all blockchains</p>
            </div>

            <!-- Wallet Input Section -->
            <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                <div style="display: grid; grid-template-columns: 2fr 1fr auto; gap: 15px; align-items: end;">
                    <div>
                        <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #333;">
                            Wallet Address
                        </label>
                        <input type="text" id="walletExplorerAddress" placeholder="Enter wallet address (e.g., 0xabc... or bc1...)"
                               style="width: 100%; padding: 12px; border: 2px solid #e1e8ed; border-radius: 8px; font-family: monospace; font-size: 14px;">
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #333;">
                            Blockchain
                        </label>
                        <select id="walletExplorerBlockchain"
                                style="width: 100%; padding: 12px; border: 2px solid #e1e8ed; border-radius: 8px; font-size: 14px;">
                            <option value="">Select blockchain...</option>
                            <option value="ethereum">Ethereum</option>
                            <option value="bitcoin">Bitcoin</option>
                            <option value="tron">Tron</option>
                            <option value="solana">Solana</option>
                            <option value="base">Base</option>
                            <option value="arbitrum">Arbitrum</option>
                            <option value="optimism">Optimism</option>
                            <option value="polygon">Polygon</option>
                            <option value="bsc">BNB Chain</option>
                            <option value="avalanche">Avalanche</option>
                            <option value="sui">Sui</option>
                            <option value="ripple">XRP</option>
                        </select>
                    </div>
                    <div>
                        <button class="btn btn-primary" onclick="searchWalletHistory()"
                                style="padding: 12px 24px; white-space: nowrap;">
                            🔎 Search
                        </button>
                    </div>
                </div>
            </div>

            <!-- Loading Indicator -->
            <div id="walletExplorerLoading" style="display: none; text-align: center; padding: 40px;">
                <div style="font-size: 48px; margin-bottom: 15px;">⏳</div>
                <div style="font-size: 18px; color: #666;">Loading wallet history...</div>
            </div>

            <!-- Asset Summary Section -->
            <div id="walletExplorerAssetSummary" style="display: none; margin-bottom: 20px;">
                <h3 style="margin-bottom: 15px; color: #333;">📊 Assets in Wallet</h3>
                <div id="walletExplorerAssetList" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(250px, 1fr)); gap: 15px; margin-bottom: 20px;">
                    <!-- Asset cards will be populated here -->
                </div>
                <div style="margin-bottom: 15px;">
                    <label style="display: block; margin-bottom: 8px; font-weight: 600; color: #333;">
                        Select Asset to View History:
                    </label>
                    <select id="walletExplorerAssetSelector" onchange="displayAssetTransactions()"
                            style="width: 100%; padding: 12px; border: 2px solid #e1e8ed; border-radius: 8px; font-size: 14px;">
                        <option value="">Choose an asset...</option>
                    </select>
                </div>
            </div>

            <!-- Transaction List Section -->
            <div id="walletExplorerTransactions" style="display: none;">
                <!-- Filter Section -->
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr auto; gap: 10px; align-items: end;">
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 500;">From Date:</label>
                            <input type="date" id="walletExplorerDateFrom" onchange="filterWalletTransactions()"
                                   style="width: 100%; padding: 8px; border: 2px solid #e1e8ed; border-radius: 6px;">
                        </div>
                        <div>
                            <label style="display: block; margin-bottom: 5px; font-weight: 500;">To Date:</label>
                            <input type="date" id="walletExplorerDateTo" onchange="filterWalletTransactions()"
                                   style="width: 100%; padding: 8px; border: 2px solid #e1e8ed; border-radius: 6px;">
                        </div>
                        <div>
                            <button class="btn btn-secondary" onclick="clearDateFilter()" style="padding: 8px 16px;">
                                Clear Dates
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Running Balance Warning -->
                <div id="walletExplorerBalanceWarning" style="display: none; background: #fff3cd; border: 2px solid #ffc107; padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                    <strong>⚠️ Large Wallet Warning:</strong> This wallet has too many transactions to calculate accurate running balance. Balance column may be incomplete.
                </div>

                <!-- Transaction Table -->
                <div style="overflow-x: auto; border: 1px solid #e1e8ed; border-radius: 8px;">
                    <table style="width: 100%; border-collapse: collapse; background: white;">
                        <thead style="background: #f8f9fa; border-bottom: 2px solid #e1e8ed;">
                            <tr>
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Date/Time</th>
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Type</th>
                                <th style="padding: 12px; text-align: right; font-weight: 600;">Amount</th>
                                <th style="padding: 12px; text-align: right; font-weight: 600;">Balance</th>
                                <th style="padding: 12px; text-align: left; font-weight: 600;">Counterparty</th>
                                <th style="padding: 12px; text-align: center; font-weight: 600;">Actions</th>
                            </tr>
                        </thead>
                        <tbody id="walletExplorerTableBody">
                            <!-- Transaction rows will be populated here -->
                        </tbody>
                    </table>
                </div>

                <!-- Pagination -->
                <div id="walletExplorerPagination" style="display: flex; justify-content: space-between; align-items: center; margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                    <button class="btn btn-secondary" id="walletExplorerPrevPage" onclick="previousWalletPage()" disabled>
                        ← Previous
                    </button>
                    <div id="walletExplorerPageInfo" style="font-weight: 500; color: #666;">
                        Page 1 of 1
                    </div>
                    <button class="btn btn-secondary" id="walletExplorerNextPage" onclick="nextWalletPage()" disabled>
                        Next →
                    </button>
                </div>
            </div>

            <!-- Empty State -->
            <div id="walletExplorerEmpty" style="display: none; text-align: center; padding: 60px 20px; color: #999;">
                <div style="font-size: 64px; margin-bottom: 20px;">📭</div>
                <div style="font-size: 18px;">No transactions found</div>
            </div>

            <!-- Close Button -->
            <div style="text-align: center; margin-top: 30px;">
                <button class="btn btn-secondary" onclick="closeWalletExplorer()">Close</button>
            </div>
        </div>
    </div>

    <!-- API Settings Modal -->
    <div id="apiSettingsModal" class="modal">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-header">
                <h2>⚙️ Blockchain API Settings</h2>
                <p>Configure API keys for enhanced reliability and higher rate limits</p>
            </div>
            
            <div style="background: #e8f4f8; border: 2px solid #3498db; border-radius: 8px; padding: 20px; margin: 20px 0;">
                <h4 style="color: #2c3e50; margin-bottom: 15px;">Why Use API Keys?</h4>
                <ul style="margin-left: 20px; color: #34495e;">
                    <li>Higher rate limits (more lookups per day)</li>
                    <li>More reliable service</li>
                    <li>Access to additional features</li>
                    <li>All services offer FREE tiers</li>
                </ul>
            </div>
            
            <div style="margin: 20px 0;">
                <h4>API Key Configuration</h4>
                
                <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 6px;">
                    <label style="display: block; font-weight: bold; margin-bottom: 5px;">
                        Ethereum - Etherscan API Key
                    </label>
                    <input type="text" id="etherscanApiKey" placeholder="Your Etherscan API key" 
                           style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace;">
                    <div style="font-size: 12px; color: #666; margin-top: 5px;">
                        Get free key at: <a href="https://etherscan.io/apis" target="_blank" style="color: #3498db;">https://etherscan.io/apis</a>
                    </div>
                </div>
                
                <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 6px;">
                    <label style="display: block; font-weight: bold; margin-bottom: 5px;">
                        Bitcoin - Blockchain.com API Key (Optional)
                    </label>
                    <input type="text" id="blockchainApiKey" placeholder="Your Blockchain.com API key (optional)" 
                           style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace;">
                    <div style="font-size: 12px; color: #666; margin-top: 5px;">
                        Works without key, but get one for higher limits at: <a href="https://www.blockchain.com/api" target="_blank" style="color: #3498db;">https://www.blockchain.com/api</a>
                    </div>
                </div>
                
                <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 6px;">
                    <label style="display: block; font-weight: bold; margin-bottom: 5px;">
                        Tron - TronGrid API Key (Optional)
                    </label>
                    <input type="text" id="trongridApiKey" placeholder="Your TronGrid API key (optional)" 
                           style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace;">
                    <div style="font-size: 12px; color: #666; margin-top: 5px;">
                        Works without key, but get one for stability at: <a href="https://www.trongrid.io/" target="_blank" style="color: #3498db;">https://www.trongrid.io/</a>
                    </div>
                </div>
                
                <div style="margin-bottom: 20px; padding: 15px; background: #e8f5e9; border-radius: 6px; border: 2px solid #4caf50;">
                    <label style="display: block; font-weight: bold; margin-bottom: 5px; color: #2e7d32;">
                        🔑 Solscan Pro API (Attribution Enabled by Default)
                    </label>
                    <div style="background: #d4edda; padding: 10px; border-radius: 4px; margin-bottom: 10px;">
                        <strong style="color: #27ae60;">✓ Solana attribution is enabled for all users</strong><br>
                        <span style="font-size: 12px; color: #555;">Solscan Pro API provides enhanced wallet attribution for Solana addresses</span>
                    </div>
                    <input type="text" id="solscanApiKey" placeholder="Optional: Override with your own API key"
                           style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace;">
                    <div style="font-size: 12px; color: #666; margin-top: 5px;">
                        Advanced users can override with their own key. Get one at: <a href="https://pro-api.solscan.io/pro-api-docs/v2.0" target="_blank" style="color: #3498db;">https://pro-api.solscan.io/</a>
                    </div>
                </div>

                <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 6px;">
                    <label style="display: block; font-weight: bold; margin-bottom: 5px;">
                        Solana RPC Endpoint
                    </label>
                    <input type="text" id="solanaRpcEndpoint" placeholder="https://api.mainnet-beta.solana.com"
                           value="https://api.mainnet-beta.solana.com"
                           style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace;">
                    <div style="font-size: 12px; color: #666; margin-top: 5px;">
                        Default public RPC or use: <a href="https://www.helius.dev/" target="_blank" style="color: #3498db;">Helius</a>,
                        <a href="https://www.quicknode.com/" target="_blank" style="color: #3498db;">QuickNode</a>
                    </div>
                </div>
                
                <div style="margin-bottom: 20px; padding: 15px; background: #e6f3ff; border-radius: 6px; border: 2px solid #0066cc;">
                    <label style="display: block; font-weight: bold; margin-bottom: 5px; color: #0066cc;">
                        🔍 Arkham Intelligence API (Attribution Enabled by Default)
                    </label>
                    <div style="background: #d4edda; padding: 10px; border-radius: 4px; margin-bottom: 10px;">
                        <strong style="color: #27ae60;">✓ Attribution is enabled for all users</strong><br>
                        <span style="font-size: 12px; color: #555;">Both Arkham and Etherscan attribution checks are active by default</span>
                    </div>
                    <input type="text" id="arkhamApiKey" placeholder="Optional: Override with your own API key" 
                           style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace;">
                    <div style="font-size: 12px; color: #666; margin-top: 5px;">
                        Advanced users can override with their own key. Get one at: <a href="https://info.arkm.com/api-platform" target="_blank" style="color: #3498db;">https://info.arkm.com/api-platform</a>
                    </div>
                    <div style="margin-top: 10px;">
                        <label style="display: flex; align-items: center; font-size: 13px;">
                            <input type="checkbox" id="arkhamAutoCheck" style="margin-right: 8px;" checked>
                            Automatically check addresses for attribution (recommended)
                        </label>
                    </div>
                </div>
                
                <div style="margin-bottom: 20px; padding: 15px; background: #fff3cd; border: 2px solid #ffc107; border-radius: 6px;">
                    <h5 style="color: #856404; margin-bottom: 10px;">🔐 Security Note</h5>
                    <p style="font-size: 13px; color: #856404; margin: 0;">
                        API keys are stored locally in your browser only. They are never sent to any server except the official blockchain APIs.
                        For production use, consider using a backend proxy for additional security.
                    </p>
                </div>
                
            </div>
            
            <div style="text-align: center; margin-top: 25px;">
                <button class="btn btn-confirm" onclick="saveApiSettings()">
                    Save Settings
                </button>
                <button class="btn btn-secondary" onclick="closeApiSettingsModal()">
                    Cancel
                </button>
            </div>
        </div>
    </div>

    <!-- Blockchain Lookup Modal -->
    <div id="blockchainLookupModal" class="modal">
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-header">
                <h2>Blockchain Transaction Lookup</h2>
                <p>Automatically fetch transaction details from the blockchain</p>
            </div>
            
            <div style="margin: 20px 0;">
                <div class="form-group" style="margin-bottom: 15px;">
                    <label>Select Blockchain</label>
                    <select id="chainSelector" style="width: 100%; padding: 12px; border: 2px solid #3498db; border-radius: 6px; font-size: 14px;" onchange="updateChainDisplay()">
                        <option value="">Auto-detect from transaction hash</option>
                        <option value="bitcoin">Bitcoin</option>
                        <option value="ethereum">Ethereum</option>
                        <option value="base">Base</option>
                        <option value="arbitrum">Arbitrum</option>
                        <option value="optimism">Optimism</option>
                        <option value="polygon">Polygon</option>
                        <option value="bsc">BNB Chain</option>
                        <option value="unichain">Unichain</option>
                        <option value="sonic">Sonic</option>
                        <option value="abstract">Abstract</option>
                        <option value="memecore">Memecore</option>
                        <option value="sophon">Sophon</option>
                        <option value="berachain">Berachain</option>
                        <option value="tron">Tron</option>
                        <option value="xrp">XRP (Ripple)</option>
                        <option value="thorchain">THORChain</option>
                        <option value="sui">Sui</option>
                        <option value="solana">Solana</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Transaction Hash</label>
                    <input type="text" id="txHashInput" placeholder="Enter transaction hash..."
                           style="width: 100%; padding: 12px; border: 2px solid #3498db; border-radius: 6px; font-family: monospace; font-size: 14px;"
                           onkeyup="detectBlockchainFromHash(this.value)">
                    <div id="detectedBlockchain" style="margin-top: 10px; font-size: 14px; color: #666;"></div>

                    <!-- Wallet Explorer Option -->
                    <div style="text-align: center; margin: 15px 0; padding: 15px; background: #e8f4fd; border-radius: 8px; border: 2px dashed #3498db;">
                        <div style="color: #666; margin-bottom: 10px;">
                            <strong>Don't have the transaction hash?</strong>
                        </div>
                        <button class="btn btn-primary" onclick="closeBlockchainLookupModal(); openWalletExplorer();" type="button"
                                style="background: #3498db; padding: 10px 20px;">
                            🔍 Search Wallet History Instead
                        </button>
                        <div style="font-size: 12px; color: #666; margin-top: 8px;">
                            Browse wallet transactions to find the one you need
                        </div>
                    </div>
                </div>

                <div id="lookupError" style="display: none; background: #fee; border: 1px solid #c00; border-radius: 6px; padding: 15px; margin: 20px 0; color: #c00;"></div>
                <div id="lookupLoading" style="display: none; text-align: center; margin: 20px 0;">
                    <div style="font-size: 24px; margin-bottom: 10px;">⏳</div>
                    <div>Fetching transaction data...</div>
                </div>
                
                <div id="lookupResult" style="display: none; margin-top: 20px;">
                    <h4 style="color: #2c3e50; margin-bottom: 15px;">Transaction Details</h4>
                    <div id="txDetailsDisplay" style="background: #f8f9fa; padding: 15px; border-radius: 6px;"></div>
                </div>
            </div>
            
            <div style="text-align: center; margin-top: 25px;">
                <button class="btn btn-primary" onclick="lookupTransaction()" id="lookupBtn">
                    Lookup Transaction
                </button>
                <button class="btn btn-confirm" id="applyTxDataBtn" onclick="applyTransactionData()" style="display: none;">
                    Apply to Entry
                </button>
                <button class="btn btn-secondary" onclick="openApiSettings()" style="background: #95a5a6;">
                    ⚙️ API Settings
                </button>
                <button class="btn btn-secondary" onclick="closeBlockchainLookupModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- PK Converter Modal -->
    <div id="pkConverterModal" class="modal">
        <div class="modal-content" style="max-width: 1200px; height: 90vh; overflow-y: auto;">
            <div class="modal-header" style="background: linear-gradient(135deg, #3498db 0%, #2980b9 100%); color: white; padding: 20px; border-radius: 8px 8px 0 0;">
                <h2 style="color: white; margin-bottom: 10px;">🔑 Multi-Blockchain Public Key Converter</h2>
                <p style="color: rgba(255,255,255,0.9); font-size: 14px;">Convert public keys to addresses across all blockchain networks and check for activity</p>
                <button onclick="closePKConverterModal()" style="position: absolute; right: 20px; top: 20px; background: none; border: none; color: white; font-size: 24px; cursor: pointer;">&times;</button>
            </div>

            <div style="padding: 30px;">
                <!-- Instructions -->
                <div style="background: #e8f4fd; border-left: 4px solid #3498db; padding: 15px; margin-bottom: 25px; border-radius: 4px;">
                    <strong style="color: #2c3e50;">How to Extract Public Keys:</strong>
                    <span style="color: #555;">Use blockchain explorers to find transaction details. Look for "pubkey" field in transaction inputs when spending from an address.</span>
                </div>

                <!-- Input Section -->
                <div style="background: #f8f9fa; padding: 25px; border-radius: 8px; margin-bottom: 30px; border: 1px solid #dee2e6;">
                    <label for="pkInput" style="display: block; font-weight: 600; margin-bottom: 10px; color: #2c3e50; font-size: 16px;">Enter Public Key (Hex Format):</label>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="pkInput" placeholder="Enter public key or public key hash (hex format)"
                               style="flex: 1; padding: 12px; border: 2px solid #3498db; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 14px;">
                        <button onclick="convertPKAddresses()" class="btn btn-primary" style="padding: 12px 30px; background: #3498db; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">
                            Convert & Check Activity
                        </button>
                    </div>
                    <div style="margin-top: 10px;">
                        <small style="color: #666;">Examples: </small>
                        <a href="#" onclick="document.getElementById('pkInput').value='04c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5628f5c6c7c7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7'; return false;" style="color: #3498db; text-decoration: underline; font-size: 12px;">Use sample uncompressed key</a> |
                        <a href="#" onclick="document.getElementById('pkInput').value='02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5'; return false;" style="color: #3498db; text-decoration: underline; font-size: 12px;">Use sample compressed key</a>
                    </div>
                </div>

                <!-- Results Section -->
                <div id="pkConverterResults" style="display: none;">
                    <h3 style="color: #2c3e50; margin-bottom: 20px;">Generated Addresses & Activity Status</h3>
                    <div id="pkAddressGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(400px, 1fr)); gap: 20px;">
                        <!-- Results will be populated here -->
                    </div>
                </div>

                <!-- Loading Indicator -->
                <div id="pkConverterLoading" style="display: none; text-align: center; padding: 40px;">
                    <div class="loading-spinner" style="margin: 0 auto 20px;"></div>
                    <p style="color: #666;">Converting addresses and checking blockchain activity...</p>
                </div>

                <!-- Error Display -->
                <div id="pkConverterError" style="display: none; background: #fee; border: 1px solid #fcc; padding: 15px; border-radius: 6px; color: #c00; margin-top: 20px;">
                </div>
            </div>
        </div>
    </div>

    <!-- Address Finder Modal -->
    <div id="addressFinderModal" class="modal">
        <div class="modal-content" style="max-width: 1200px; height: 90vh; overflow-y: auto;">
            <div class="modal-header" style="background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%); color: white; padding: 20px; border-radius: 8px 8px 0 0;">
                <h2 style="color: white; margin-bottom: 10px;">🔍 Blockchain Address Finder</h2>
                <p style="color: rgba(255,255,255,0.9); font-size: 14px;">Find complete addresses using partial information - perfect for investigations with limited data</p>
                <button onclick="closeAddressFinderModal()" style="position: absolute; right: 20px; top: 20px; background: none; border: none; color: white; font-size: 24px; cursor: pointer;">&times;</button>
            </div>

            <div style="padding: 30px;">
                <!-- Instructions -->
                <div style="background: #f3e5f5; border-left: 4px solid #9b59b6; padding: 15px; margin-bottom: 25px; border-radius: 4px;">
                    <strong style="color: #2c3e50;">How it works:</strong>
                    <span style="color: #555;">Enter the characters you know from an address. For example: first 6 characters "1A2B3C" or first 6 and last 4 "1A2B3C...wxyz". We'll search blockchain records for matching addresses.</span>
                </div>

                <!-- Search Options -->
                <div style="background: #f8f9fa; padding: 25px; border-radius: 8px; margin-bottom: 30px; border: 1px solid #dee2e6;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                        <div>
                            <label style="display: block; font-weight: 600; margin-bottom: 10px; color: #2c3e50;">Select Blockchain:</label>
                            <select id="addressFinderChain" style="width: 100%; padding: 12px; border: 2px solid #9b59b6; border-radius: 6px; font-size: 14px;">
                                <option value="bitcoin">Bitcoin (BTC)</option>
                                <option value="ethereum">Ethereum (ETH)</option>
                                <option value="bsc">Binance Smart Chain (BSC)</option>
                                <option value="polygon">Polygon (MATIC)</option>
                                <option value="unichain">Unichain</option>
                                <option value="sonic">Sonic (S)</option>
                                <option value="abstract">Abstract</option>
                                <option value="memecore">Memecore (M)</option>
                                <option value="sophon">Sophon (SOPH)</option>
                                <option value="berachain">Berachain (BERA)</option>
                                <option value="tron">Tron (TRX)</option>
                                <option value="xrp">XRP (Ripple)</option>
                                <option value="thorchain">THORChain (RUNE)</option>
                                <option value="sui">Sui</option>
                                <option value="solana">Solana (SOL)</option>
                            </select>
                        </div>
                        <div>
                            <label style="display: block; font-weight: 600; margin-bottom: 10px; color: #2c3e50;">Search Type:</label>
                            <select id="addressFinderType" style="width: 100%; padding: 12px; border: 2px solid #9b59b6; border-radius: 6px; font-size: 14px;" onchange="updateAddressFinderInputs()">
                                <option value="prefix">Starts with (first characters)</option>
                                <option value="suffix">Ends with (last characters)</option>
                                <option value="both">First and Last characters</option>
                                <option value="contains">Contains anywhere</option>
                            </select>
                        </div>
                    </div>

                    <div id="addressFinderInputs">
                        <label style="display: block; font-weight: 600; margin-bottom: 10px; color: #2c3e50;">Enter known characters:</label>
                        <div id="singleInput" style="display: flex; gap: 10px;">
                            <input type="text" id="addressPrefix" placeholder="Enter first characters (e.g., 1A2B3C or bc1qxy)"
                                   style="flex: 1; padding: 12px; border: 2px solid #9b59b6; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 14px;">
                        </div>
                        <div id="doubleInput" style="display: none; gap: 10px;">
                            <input type="text" id="addressPrefixDouble" placeholder="First characters (e.g., 1A2B3C)"
                                   style="flex: 1; padding: 12px; border: 2px solid #9b59b6; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 14px;">
                            <span style="padding: 12px; color: #666;">...</span>
                            <input type="text" id="addressSuffix" placeholder="Last characters (e.g., XyZ9)"
                                   style="flex: 1; padding: 12px; border: 2px solid #9b59b6; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 14px;">
                        </div>
                    </div>

                    <div style="margin-top: 20px; display: flex; gap: 10px; align-items: center;">
                        <button onclick="searchAddresses()" class="btn btn-primary" style="padding: 12px 30px; background: #9b59b6; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">
                            Search Blockchain
                        </button>
                        <label style="display: flex; align-items: center; gap: 8px; margin: 0;">
                            <input type="checkbox" id="activeOnly" checked>
                            <span style="color: #666;">Show only addresses with activity</span>
                        </label>
                    </div>
                </div>

                <!-- Results Section -->
                <div id="addressFinderResults" style="display: none;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h3 style="color: #2c3e50; margin: 0;">Search Results</h3>
                        <span id="resultCount" style="color: #666; font-size: 14px;"></span>
                    </div>
                    <div id="addressResultsGrid" style="display: grid; gap: 15px;">
                        <!-- Results will be populated here -->
                    </div>
                </div>

                <!-- Loading Indicator -->
                <div id="addressFinderLoading" style="display: none; text-align: center; padding: 40px;">
                    <div class="loading-spinner" style="margin: 0 auto 20px;"></div>
                    <p style="color: #666;">Searching blockchain records for matching addresses...</p>
                </div>

                <!-- Error Display -->
                <div id="addressFinderError" style="display: none; background: #fee; border: 1px solid #fcc; padding: 15px; border-radius: 6px; color: #c00; margin-top: 20px;">
                </div>
            </div>
        </div>
    </div>

    <script>
        // HTTPS Enforcement and Security Check
        (function() {
            // List of trusted domains (add your domains here)
            const trustedDomains = [
                'batstool.com',
                'www.batstool.com',
                'netlify.app',
                'localhost',
                '127.0.0.1'
            ];
            
            // Check if current domain is trusted
            const currentHost = window.location.hostname;
            const isTrusted = trustedDomains.some(domain => 
                currentHost === domain || currentHost.endsWith('.' + domain)
            );
            
            // Check if we're running on HTTP (not HTTPS or file://)
            if (window.location.protocol === 'http:' && currentHost !== 'localhost' && currentHost !== '127.0.0.1') {
                // Only redirect to HTTPS for trusted domains
                if (isTrusted) {
                    window.location.href = 'https:' + window.location.href.substring(5);
                    return; // Stop execution
                } else {
                    console.warn('⚠️ Running on HTTP. For security, please use HTTPS.');
                }
            }
            
            // Security warning for file:// protocol
            if (window.location.protocol === 'file:') {
                console.warn('⚠️ Running from file:// protocol. Some features may be limited. For full functionality, serve over HTTPS.');
            }
        })();

        // Global constants
        // Note: walletTypes is declared later with full emoji support

        // Global CORS helper - automatically tries multiple proxies
        async function fetchWithCORS(url, options = {}) {
            // List of public CORS proxies to try in order
            const corsProxies = [
                '', // Try direct first
                'https://corsproxy.io/?',
                'https://api.allorigins.win/raw?url=',
                'https://cors.bridged.cc/',
            ];

            let lastError = null;

            for (const proxy of corsProxies) {
                try {
                    const finalUrl = proxy ? proxy + encodeURIComponent(url) : url;
                    const response = await fetch(finalUrl, {
                        method: 'GET',
                        headers: { 'Accept': 'application/json' },
                        mode: 'cors',
                        ...options
                    });

                    // Return first successful response
                    return response;
                } catch (e) {
                    lastError = e;
                    // Try next proxy silently
                    continue;
                }
            }

            // If all attempts failed, throw the last error
            throw lastError || new Error('All connection attempts failed');
        }

        // Switch report sub-tabs
        function switchReportTab(tabName) {
            // Hide all report tabs
            document.querySelectorAll('.report-tab-content').forEach(tab => {
                tab.style.display = 'none';
            });

            // Remove active class from all buttons
            document.querySelectorAll('.report-tab-btn').forEach(btn => {
                btn.style.background = '#ecf0f1';
                btn.style.color = '#2c3e50';
                btn.classList.remove('active');
            });

            // Show selected tab
            const selectedTab = document.getElementById(`report-${tabName}`);
            if (selectedTab) {
                selectedTab.style.display = 'block';
            }

            // Highlight active button
            event.target.style.background = '#3498db';
            event.target.style.color = 'white';
            event.target.classList.add('active');

            // Load content for the tab if needed
            loadReportTabContent(tabName);
        }

        // Load content for report tabs
        function loadReportTabContent(tabName) {
            switch(tabName) {
                case 'victims':
                    generateVictimIndexReport();
                    break;
                case 'redwallet':
                    generateRedWalletIndexReport();
                    break;
                case 'terminal':
                    generateTerminalIndexReport();
                    break;
                case 'technical':
                    generateTechnicalAuditTrail();
                    break;
                case 'cover':
                    updateCoverPage();
                    break;
            }
        }

        // Generate Technical Audit Trail
        function generateTechnicalAuditTrail() {
            const container = document.getElementById('report-technical-content');
            if (!container) return;

            let html = '<div style="font-family: \'Courier New\', monospace; font-size: 13px;">';

            // Opening - Initial Stolen Funds
            const rootTotals = investigation.confirmedRootTotalsByCurrency || {};
            html += '<div style="background: #1a1a2e; color: #fff; padding: 20px; margin-bottom: 30px; border-radius: 8px;">';
            html += '<h2 style="margin: 0 0 15px 0; text-align: center; border-bottom: 2px solid #fff; padding-bottom: 10px;">═══ FORENSIC TRANSACTION FLOW ANALYSIS ═══</h2>';
            html += '<h3 style="margin: 15px 0 10px 0; text-align: center; color: #ff6b6b;">Initial Stolen Funds</h3>';
            html += '<table style="width: 100%; margin-top: 15px;">';
            html += '<tr><th style="text-align: left; padding: 5px;">Currency</th><th style="text-align: right; padding: 5px;">Amount</th></tr>';
            Object.entries(rootTotals).forEach(([currency, amount]) => {
                html += `<tr><td style="padding: 5px;">${currency}</td><td style="text-align: right; padding: 5px;">${amount.toLocaleString()}</td></tr>`;
            });
            html += '</table>';
            html += '</div>';

            // Process each hop with hierarchical structure
            investigation.hops?.forEach(hop => {
                html += `<div style="border: 3px solid #2c3e50; margin-bottom: 40px; box-shadow: 0 4px 6px rgba(0,0,0,0.1);">`;
                html += `<div style="background: linear-gradient(135deg, #3498db 0%, #2980b9 100%); color: white; padding: 15px;">`;
                html += `<h2 style="margin: 0;">🔹 HOP ${hop.hopNumber}</h2>`;
                html += `<div style="font-size: 14px; margin-top: 5px; opacity: 0.9;">Funds Available: `;
                const hopART = hop.artAtStartByCurrency || {};
                Object.entries(hopART).forEach(([currency, amount], index) => {
                    if (index > 0) html += ' | ';
                    html += `${amount.toLocaleString()} ${currency}`;
                });
                html += `</div>`;
                html += `</div>`;

                html += '<div style="padding: 20px;">';

                // Show hierarchical structure: Entries contain threads
                html += '<div style="margin-bottom: 20px;">';
                html += '<h3 style="margin: 0 0 15px 0; color: #2c3e50;">Transaction Flow:</h3>';

                hop.entries?.forEach((entry, entryIndex) => {
                    const isTerminal = entry.isTerminalWallet || entry.toWalletType === 'purple';
                    const isConversion = entry.isBridge || entry.isSwap || entry.toWalletType === 'brown';
                    const isWriteoff = entry.entryType === 'writeoff';

                    // Determine entry type and styling
                    let entryType = 'TRACE';
                    let bgColor = '#ffffff';
                    let borderColor = '#3498db';
                    if (isTerminal) {
                        entryType = 'TERMINAL';
                        bgColor = '#f3e5ff';
                        borderColor = '#9b59b6';
                    } else if (isConversion) {
                        entryType = 'CONVERSION';
                        bgColor = '#fff9f0';
                        borderColor = '#f39c12';
                    } else if (isWriteoff) {
                        entryType = 'WRITE-OFF';
                        bgColor = '#f5f5f5';
                        borderColor = '#95a5a6';
                    }

                    // Entry container with hierarchy
                    html += `<div style="margin-bottom: 20px; border-left: 4px solid ${borderColor}; padding-left: 15px;">`;

                    // Check if commingled (notation contains multiple sources)
                    const isCommingled = entry.notation && (entry.notation.includes(',') || (entry.notation.match(/\(/g) || []).length > 1);

                    // Entry header
                    html += `<div style="background: ${bgColor}; padding: 12px; border-radius: 5px; margin-bottom: 10px; ${isCommingled ? 'border: 2px dashed #e67e22;' : ''}">`;
                    html += `<div style="display: flex; justify-content: space-between; align-items: center;">`;
                    html += `<div>`;
                    html += `<strong style="font-size: 16px;">📄 Entry ${entryIndex + 1}: ${entryType}${isCommingled ? ' (COMMINGLED)' : ''}</strong>`;
                    if (entry.notation) {
                        // Simplify notation for display - remove duplicate transaction numbers
                        // Convert (V1-T1,1,2,2,2,2) H2 to (V1-T1,2) H2
                        let displayNotation = entry.notation;
                        const complexPattern = /\(([^,]+),([,\d]+)\)(\s*H\d+.*)?/;
                        const match = displayNotation.match(complexPattern);
                        if (match) {
                            const victimTx = match[1]; // V1-T1
                            const txNumbers = match[2].split(',').map(n => parseInt(n)); // [1,2,2,2,2,2]
                            const hopSuffix = match[3] || ''; // H2

                            // Get unique transaction numbers and sort them
                            const uniqueTxs = [...new Set(txNumbers)].sort((a, b) => a - b);
                            displayNotation = `(${victimTx},${uniqueTxs.join(',')})${hopSuffix}`;
                        }
                        html += ` <span style="color: #7f8c8d; margin-left: 10px;">${displayNotation}</span>`;
                    }
                    html += `</div>`;
                    html += `<div style="font-size: 18px; font-weight: bold;">${parseFloat(entry.amount).toLocaleString()} ${entry.currency}</div>`;
                    html += `</div>`;

                    // Entry details
                    html += `<div style="margin-top: 10px; font-size: 12px; color: #555;">`;
                    if (entry.txHash || entry.transactionHash) {
                        const txHash = entry.txHash || entry.transactionHash;
                        html += `<div><strong>Transaction:</strong> <code style="background: #f4f4f4; padding: 2px 4px; border-radius: 3px; font-size: 11px; word-break: break-all;">${txHash}</code></div>`;
                    }
                    if (entry.toWallet || entry.destinationWallet) {
                        const wallet = entry.toWallet || entry.destinationWallet;
                        html += `<div><strong>Destination:</strong> <code style="background: #f4f4f4; padding: 2px 4px; border-radius: 3px; font-size: 11px; word-break: break-all;">${wallet}</code></div>`;
                    }
                    if (entry.walletLabel) {
                        html += `<div><strong>Wallet Label:</strong> ${entry.walletLabel}</div>`;
                    }
                    if (entry.timestamp || entry.datetime) {
                        const timeDisplay = entry.timestamp ?
                            formatDateTimeForReport(entry.timestamp, entry.timezone || 'UTC') :
                            entry.datetime + ' ' + (entry.timezone || 'UTC');
                        html += `<div><strong>Time:</strong> ${timeDisplay}</div>`;
                    }
                    if (entry.notes) {
                        html += `<div style="margin-top: 8px; padding: 8px; background: #fffef7; border-left: 3px solid #f39c12; border-radius: 3px;"><strong>Notes:</strong> ${entry.notes}</div>`;
                    }
                    html += `</div>`;
                    html += `</div>`;

                    // Show threads that compose this entry
                    if (entry.allocatedThreads && entry.allocatedThreads.length > 0) {
                        html += `<div style="margin-left: 20px; margin-top: 10px;">`;
                        html += `<div style="font-weight: bold; margin-bottom: 8px; color: #2c3e50;">└─ Source Threads Used:</div>`;
                        entry.allocatedThreads.forEach(thread => {
                            html += `<div style="margin-left: 20px; padding: 8px; background: #f8f9fa; border-radius: 4px; margin-bottom: 5px;">`;
                            html += `<span style="font-family: monospace; color: #e74c3c;">🧵 ${thread.notation}</span>`;
                            html += ` - ${thread.amount.toLocaleString()} ${thread.currency}`;
                            if (thread.wasPartialTrace) {
                                const percentage = (thread.proportionalMultiplier * 100).toFixed(2);
                                html += ` <span style="color: #e67e22; font-weight: bold;">(${percentage}% ownership)</span>`;
                            }
                            html += `</div>`;
                        });
                        html += `</div>`;
                    }

                    // Show conversion output
                    if (isConversion) {
                        html += `<div style="margin-left: 20px; margin-top: 15px; background: #ffe4b5; padding: 10px; border-radius: 5px;">`;
                        html += `<strong>🔄 Conversion Output:</strong> `;

                        let outputShown = false;

                        // Check for bridge output in notes
                        if (entry.notes && entry.notes.includes('[BRIDGE OUTPUT]')) {
                            const outputMatch = entry.notes.match(/Output Amount: ([\d,\.]+) (\w+)/);
                            if (outputMatch) {
                                html += `${outputMatch[1]} ${outputMatch[2]}`;
                                outputShown = true;

                                // Check if this created new threads
                                const outputThreads = investigation.sourceThreadsIndex?.filter(t =>
                                    t.sourceType === 'bridge' && t.bridgeFromNotation === entry.notation
                                );
                                if (outputThreads && outputThreads.length > 0) {
                                    html += `<div style="margin-top: 8px;">`;
                                    html += `<strong>New threads created:</strong>`;
                                    outputThreads.forEach(thread => {
                                        html += `<div style="margin-top: 5px;">`;
                                        html += `• <span style="font-family: monospace; color: #27ae60;">🧵 ${thread.notation}</span>`;
                                        html += ` - ${thread.amount.toLocaleString()} ${thread.currency}`;
                                        if (!thread.allocated && !thread.writtenOff) {
                                            html += ` <span style="color: #e74c3c; font-weight: bold;">[UNALLOCATED]</span>`;
                                        }
                                        html += `</div>`;
                                    });
                                    html += `</div>`;
                                }
                            }
                        }

                        // Check swapDetails
                        if (!outputShown && entry.swapDetails && entry.swapDetails.outputAmount) {
                            html += `${entry.swapDetails.outputAmount.toLocaleString()} ${entry.swapDetails.outputCurrency}`;
                            outputShown = true;
                        }

                        // Check bridgeDetails
                        if (!outputShown && entry.bridgeDetails && entry.bridgeDetails.destinationAmount) {
                            html += `${entry.bridgeDetails.destinationAmount.toLocaleString()} ${entry.bridgeDetails.destinationAsset}`;
                            outputShown = true;
                        }

                        // Fallback if no output found
                        if (!outputShown) {
                            html += `<span style="color: #e74c3c; font-style: italic;">Output amount not recorded</span>`;
                        }

                        html += `</div>`;
                    }

                    // Show terminal exchange
                    if (isTerminal) {
                        const exchangeName = entry.exchangeName ||
                            (entry.notes && entry.notes.match(/Terminal wallet: ([^\n]+)/)?.[1]) ||
                            'Unknown Exchange';
                        html += `<div style="margin-left: 20px; margin-top: 15px; background: #e6d7ff; padding: 10px; border-radius: 5px;">`;
                        html += `<strong>🏦 Terminal Exchange:</strong> ${exchangeName}`;
                        html += `</div>`;
                    }

                    html += `</div>`; // Close entry container
                });

                html += `</div>`; // Close flow container

                // Hop Summary
                html += '<div style="background: #f8f9fa; padding: 15px; margin-top: 20px; border-radius: 8px;">';
                html += `<h4 style="margin: 0 0 10px 0; color: #2c3e50;">Hop ${hop.hopNumber} Summary:</h4>`;

                // Calculate totals by category
                const terminalEntries = hop.entries.filter(e => e.isTerminalWallet || e.toWalletType === 'purple');
                const writeoffEntries = hop.entries.filter(e => e.entryType === 'writeoff');
                const conversionEntries = hop.entries.filter(e => e.isBridge || e.isSwap || e.toWalletType === 'brown');
                const continuingEntries = hop.entries.filter(e =>
                    !e.isTerminalWallet &&
                    e.entryType !== 'writeoff' &&
                    e.toWalletType !== 'purple' &&
                    !e.isBridge && !e.isSwap && e.toWalletType !== 'brown'
                );

                // Group totals by currency and track conversions
                const currencyFlows = {};
                const conversions = [];
                const createdCurrencies = {}; // Track currencies created from conversions

                Object.keys(hopART).forEach(currency => {
                    currencyFlows[currency] = {
                        opening: hopART[currency] || 0,
                        terminal: 0,
                        writeoff: 0,
                        continuing: 0,
                        converted: 0,
                        createdFromConversion: 0
                    };
                });

                terminalEntries.forEach(e => {
                    const curr = e.currency;
                    if (!currencyFlows[curr]) currencyFlows[curr] = { opening: 0, terminal: 0, writeoff: 0, continuing: 0, converted: 0, createdFromConversion: 0 };
                    currencyFlows[curr].terminal += parseFloat(e.amount);
                });

                writeoffEntries.forEach(e => {
                    const curr = e.currency;
                    if (!currencyFlows[curr]) currencyFlows[curr] = { opening: 0, terminal: 0, writeoff: 0, continuing: 0, converted: 0, createdFromConversion: 0 };
                    currencyFlows[curr].writeoff += parseFloat(e.amount);
                });

                conversionEntries.forEach(e => {
                    const curr = e.currency;
                    if (!currencyFlows[curr]) currencyFlows[curr] = { opening: 0, terminal: 0, writeoff: 0, continuing: 0, converted: 0, createdFromConversion: 0 };
                    currencyFlows[curr].converted += parseFloat(e.amount);

                    // Track conversion details and output currency
                    if (e.notes && e.notes.includes('[BRIDGE OUTPUT]')) {
                        const outputMatch = e.notes.match(/Output Amount: ([\d,\.]+) (\w+)/);
                        if (outputMatch) {
                            const outputAmount = parseFloat(outputMatch[1].replace(/,/g, ''));
                            const outputCurr = outputMatch[2];
                            conversions.push({
                                from: `${parseFloat(e.amount).toLocaleString()} ${curr}`,
                                to: `${outputMatch[1]} ${outputCurr}`,
                                notation: e.notation
                            });
                            // Track that this currency was created from conversion
                            if (!currencyFlows[outputCurr]) {
                                currencyFlows[outputCurr] = { opening: 0, terminal: 0, writeoff: 0, continuing: 0, converted: 0, createdFromConversion: 0 };
                            }
                            currencyFlows[outputCurr].createdFromConversion += outputAmount;
                        }
                    } else if (e.swapDetails) {
                        const outputAmount = parseFloat(e.swapDetails.outputAmount);
                        const outputCurr = e.swapDetails.outputCurrency;
                        conversions.push({
                            from: `${parseFloat(e.amount).toLocaleString()} ${curr}`,
                            to: `${e.swapDetails.outputAmount} ${outputCurr}`,
                            notation: e.notation
                        });
                        // Track that this currency was created from conversion
                        if (!currencyFlows[outputCurr]) {
                            currencyFlows[outputCurr] = { opening: 0, terminal: 0, writeoff: 0, continuing: 0, converted: 0, createdFromConversion: 0 };
                        }
                        currencyFlows[outputCurr].createdFromConversion += outputAmount;
                    } else if (e.bridgeDetails) {
                        const outputAmount = parseFloat(e.bridgeDetails.destinationAmount);
                        const outputCurr = e.bridgeDetails.destinationAsset;
                        conversions.push({
                            from: `${parseFloat(e.amount).toLocaleString()} ${curr}`,
                            to: `${outputAmount.toLocaleString()} ${outputCurr}`,
                            notation: e.notation
                        });
                        // Track that this currency was created from conversion
                        if (!currencyFlows[outputCurr]) {
                            currencyFlows[outputCurr] = { opening: 0, terminal: 0, writeoff: 0, continuing: 0, converted: 0, createdFromConversion: 0 };
                        }
                        currencyFlows[outputCurr].createdFromConversion += outputAmount;
                    }
                });

                continuingEntries.forEach(e => {
                    const curr = e.currency;
                    if (!currencyFlows[curr]) currencyFlows[curr] = { opening: 0, terminal: 0, writeoff: 0, continuing: 0, converted: 0, createdFromConversion: 0 };
                    currencyFlows[curr].continuing += parseFloat(e.amount);
                });

                // Display flow summary
                html += '<div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;">';

                // Left side: Fund flows
                html += '<div>';
                html += '<strong>Fund Movements:</strong>';
                Object.entries(currencyFlows).forEach(([currency, flows]) => {
                    if (flows.opening > 0 || flows.terminal > 0 || flows.writeoff > 0 || flows.continuing > 0 || flows.converted > 0 || flows.createdFromConversion > 0) {
                        html += `<div style="margin: 10px 0; padding: 10px; background: white; border-radius: 5px;">`;
                        html += `<strong>${currency}:</strong><br>`;

                        // Show opening balance if exists
                        if (flows.opening > 0) {
                            html += `Starting: ${flows.opening.toLocaleString()}<br>`;
                        }

                        // Show created from conversion if exists
                        if (flows.createdFromConversion > 0) {
                            html += `<span style="color: #f39c12;">+ Created from conversion: ${flows.createdFromConversion.toLocaleString()}</span><br>`;
                        }

                        // Calculate total available (opening + created)
                        const totalAvailable = flows.opening + flows.createdFromConversion;

                        if (flows.terminal > 0) {
                            html += `<span style="color: #9b59b6;">→ To Exchanges: ${flows.terminal.toLocaleString()}</span><br>`;
                        }
                        if (flows.converted > 0) {
                            html += `<span style="color: #f39c12;">→ Converted: ${flows.converted.toLocaleString()}</span><br>`;
                        }
                        if (flows.writeoff > 0) {
                            html += `<span style="color: #95a5a6;">→ Written off: ${flows.writeoff.toLocaleString()}</span><br>`;
                        }
                        if (flows.continuing > 0) {
                            html += `<span style="color: #27ae60;">→ Continuing: ${flows.continuing.toLocaleString()}</span><br>`;
                        }

                        // Calculate remaining based on total available
                        const remaining = totalAvailable - flows.terminal - flows.writeoff - flows.converted - flows.continuing;
                        if (Math.abs(remaining) > 0.01) {
                            html += `<strong style="color: #e74c3c;">⚠ Unaccounted: ${remaining.toLocaleString()}</strong>`;
                        }
                        html += `</div>`;
                    }
                });
                html += '</div>';

                // Right side: Conversions
                if (conversions.length > 0) {
                    html += '<div>';
                    html += '<strong>Currency Conversions:</strong>';
                    conversions.forEach(conv => {
                        html += `<div style="margin: 10px 0; padding: 10px; background: #fff9f0; border-radius: 5px;">`;
                        html += `<div style="font-size: 12px; color: #666;">${conv.notation}</div>`;
                        html += `${conv.from} → ${conv.to}`;
                        html += `</div>`;
                    });
                    html += '</div>';
                }

                html += '</div>'; // Close grid

                // Show any new currency threads created
                const newCurrencies = new Set();
                conversionEntries.forEach(entry => {
                    if (entry.notes && entry.notes.includes('[BRIDGE OUTPUT]')) {
                        const outputMatch = entry.notes.match(/Output Amount: ([\d,\.]+) (\w+)/);
                        if (outputMatch && !currencyFlows[outputMatch[2]]) {
                            newCurrencies.add(outputMatch[2]);
                        }
                    } else if (entry.swapDetails && !currencyFlows[entry.swapDetails.outputCurrency]) {
                        newCurrencies.add(entry.swapDetails.outputCurrency);
                    }
                });

                if (newCurrencies.size > 0) {
                    html += `<div style="margin-top: 10px; padding: 10px; background: #d4edda; border-radius: 5px;">`;
                    html += `<strong>New Currencies Introduced:</strong> ${Array.from(newCurrencies).join(', ')}`;
                    html += `</div>`;
                }

                html += '</div>'; // Close summary box
                html += '</div>'; // Close hop padding
                html += '</div>'; // Close hop container
            });

            // Final summary
            const finalTerminals = investigation.terminalWalletIndex || [];
            if (finalTerminals.length > 0) {
                html += '<div style="background: #e8e4f3; border: 2px solid #9b59b6; padding: 20px; border-radius: 8px;">';
                html += '<h3 style="color: #9b59b6; margin: 0 0 15px 0;">FINAL TERMINAL WALLET SUMMARY</h3>';

                const terminalsByExchange = {};
                finalTerminals.forEach(terminal => {
                    const exchange = terminal.exchangeName || 'Unknown Exchange';
                    if (!terminalsByExchange[exchange]) {
                        terminalsByExchange[exchange] = [];
                    }
                    terminalsByExchange[exchange].push(terminal);
                });

                Object.entries(terminalsByExchange).forEach(([exchange, terminals]) => {
                    html += `<div style="margin-bottom: 15px;">`;
                    html += `<strong>${exchange}:</strong><br>`;
                    terminals.forEach(t => {
                        html += `&nbsp;&nbsp;• ${t.amount} ${t.currency} (${t.notation})<br>`;
                    });
                    html += '</div>';
                });

                html += '</div>';
            }

            html += '</div>';
            container.innerHTML = html;
        }

        // Generate Victim Index Report
        function generateVictimIndexReport() {
            const container = document.getElementById('report-victims-content');
            if (!container) return;

            let html = '<table style="width: 100%; border-collapse: collapse;">';
            html += '<thead><tr style="background: #3498db; color: white;">';
            html += '<th style="padding: 12px; border: 1px solid #dee2e6;">Victim ID</th>';
            html += '<th style="padding: 12px; border: 1px solid #dee2e6;">Name</th>';
            html += '<th style="padding: 12px; border: 1px solid #dee2e6;">Total Loss</th>';
            html += '<th style="padding: 12px; border: 1px solid #dee2e6;">Transactions</th>';
            html += '<th style="padding: 12px; border: 1px solid #dee2e6;">Contact</th>';
            html += '</tr></thead><tbody>';

            investigation.victims?.forEach(victim => {
                // Calculate total loss from transactions
                const totalLossByCurrency = {};
                victim.transactions?.forEach(transaction => {
                    if (parseFloat(transaction.amount) > 0) {
                        const currency = transaction.currency === 'CUSTOM' ?
                            transaction.customCurrency : transaction.currency;
                        if (!totalLossByCurrency[currency]) {
                            totalLossByCurrency[currency] = 0;
                        }
                        totalLossByCurrency[currency] += parseFloat(transaction.amount);
                    }
                });

                const totalLossDisplay = Object.entries(totalLossByCurrency)
                    .map(([curr, amt]) => `${amt.toLocaleString()} ${curr}`)
                    .join(', ') || '0';

                html += '<tr>';
                html += `<td style="padding: 10px; border: 1px solid #dee2e6;">V${victim.id}</td>`;
                html += `<td style="padding: 10px; border: 1px solid #dee2e6;">${victim.name || `Victim ${victim.id}`}</td>`;
                html += `<td style="padding: 10px; border: 1px solid #dee2e6;">${totalLossDisplay}</td>`;
                html += `<td style="padding: 10px; border: 1px solid #dee2e6;">${victim.transactions?.filter(t => parseFloat(t.amount) > 0).length || 0}</td>`;
                html += `<td style="padding: 10px; border: 1px solid #dee2e6;">${victim.contactInfo || 'N/A'}</td>`;
                html += '</tr>';
            });

            html += '</tbody></table>';
            container.innerHTML = html;
        }

        // Generate Red Wallet Index Report
        function generateRedWalletIndexReport() {
            const container = document.getElementById('report-redwallet-content');
            if (!container) return;

            const redWalletIndex = investigation.redWalletIndex || [];

            let html = '<table style="width: 100%; border-collapse: collapse;">';
            html += '<thead><tr style="background: #e74c3c; color: white;">';
            html += '<th style="padding: 12px; border: 1px solid #dee2e6;">V-T Notation</th>';
            html += '<th style="padding: 12px; border: 1px solid #dee2e6;">Wallet Address</th>';
            html += '<th style="padding: 12px; border: 1px solid #dee2e6;">Amount</th>';
            html += '<th style="padding: 12px; border: 1px solid #dee2e6;">Currency</th>';
            html += '<th style="padding: 12px; border: 1px solid #dee2e6;">Date</th>';
            html += '</tr></thead><tbody>';

            redWalletIndex.forEach(entry => {
                html += '<tr>';
                html += `<td style="padding: 10px; border: 1px solid #dee2e6;">${entry.vtNotation}</td>`;
                html += `<td style="padding: 10px; border: 1px solid #dee2e6; font-family: monospace; font-size: 12px;">${entry.walletAddress}</td>`;
                html += `<td style="padding: 10px; border: 1px solid #dee2e6;">${entry.amount.toLocaleString()}</td>`;
                html += `<td style="padding: 10px; border: 1px solid #dee2e6;">${entry.currency}</td>`;
                html += `<td style="padding: 10px; border: 1px solid #dee2e6;">${entry.depositDate ? formatDateTimeForReport(entry.depositDate, 'UTC') : 'N/A'}</td>`;
                html += '</tr>';
            });

            html += '</tbody></table>';
            container.innerHTML = html;
        }

        // Generate Terminal Index Report
        function generateTerminalIndexReport() {
            const container = document.getElementById('report-terminal-content');
            if (!container) return;

            const terminalIndex = investigation.terminalWalletIndex || [];

            let html = '<div style="margin-bottom: 20px; padding: 15px; background: #f0ebf5; border: 2px solid #9b59b6; border-radius: 8px;">';
            html += '<p style="margin: 0; color: #6c2e8a;"><strong>⚖️ Legal Process Note:</strong> This index contains transaction hashes and timestamps for use in legal proceedings and exchange subpoenas. Click on any exchange name to see detailed drill-down and export options for legal process requests.</p>';
            html += '</div>';

            // Group by exchange for summary view
            const byExchange = {};
            terminalIndex.forEach(entry => {
                const exchangeName = entry.exchangeName || 'Unknown';
                if (!byExchange[exchangeName]) {
                    byExchange[exchangeName] = [];
                }
                byExchange[exchangeName].push(entry);
            });

            // Create summary table with clickable exchange names
            html += '<div style="margin-bottom: 30px;">';
            html += '<h3 style="color: #9b59b6; margin-bottom: 15px;">📊 Summary by Exchange</h3>';
            html += '<table style="width: 100%; border-collapse: collapse;">';
            html += '<thead><tr style="background: #9b59b6; color: white;">';
            html += '<th style="padding: 12px; border: 1px solid #dee2e6;">Exchange</th>';
            html += '<th style="padding: 12px; border: 1px solid #dee2e6;">Total Arrivals</th>';
            html += '<th style="padding: 12px; border: 1px solid #dee2e6;">Total Amount</th>';
            html += '<th style="padding: 12px; border: 1px solid #dee2e6;">Actions</th>';
            html += '</tr></thead><tbody>';

            Object.entries(byExchange).forEach(([exchangeName, entries]) => {
                const totalsByCurrency = {};
                entries.forEach(entry => {
                    if (!totalsByCurrency[entry.currency]) {
                        totalsByCurrency[entry.currency] = 0;
                    }
                    totalsByCurrency[entry.currency] += entry.amount;
                });

                const totalsDisplay = Object.entries(totalsByCurrency)
                    .map(([curr, amt]) => amt.toLocaleString() + ' ' + curr)
                    .join(', ');

                html += '<tr>';
                html += '<td style="padding: 10px; border: 1px solid #dee2e6; font-weight: bold; color: #9b59b6; cursor: pointer;" onclick="showTerminalWalletDrilldown(\'' + exchangeName.replace(/'/g, "\\'") + '\')">' + exchangeName + ' 🔍</td>';
                html += '<td style="padding: 10px; border: 1px solid #dee2e6;">' + entries.length + '</td>';
                html += '<td style="padding: 10px; border: 1px solid #dee2e6;">' + totalsDisplay + '</td>';
                html += '<td style="padding: 10px; border: 1px solid #dee2e6;"><button class="btn btn-sm btn-primary" onclick="exportExchangeTransactionsToExcel(\'' + exchangeName.replace(/'/g, "\\'") + '\')">📄 Export for Legal Process</button></td>';
                html += '</tr>';
            });

            html += '</tbody></table>';
            html += '</div>';

            // Full detailed table
            html += '<h3 style="color: #9b59b6; margin-bottom: 15px;">📋 All Terminal Wallet Arrivals</h3>';
            html += '<table style="width: 100%; border-collapse: collapse;">';
            html += '<thead><tr style="background: #9b59b6; color: white;">';
            html += '<th style="padding: 12px; border: 1px solid #dee2e6;">Exchange</th>';
            html += '<th style="padding: 12px; border: 1px solid #dee2e6;">Wallet Address</th>';
            html += '<th style="padding: 12px; border: 1px solid #dee2e6;">Amount</th>';
            html += '<th style="padding: 12px; border: 1px solid #dee2e6;">Currency</th>';
            html += '<th style="padding: 12px; border: 1px solid #dee2e6;">Transaction Hash</th>';
            html += '<th style="padding: 12px; border: 1px solid #dee2e6;">Date/Time</th>';
            html += '<th style="padding: 12px; border: 1px solid #dee2e6;">Notation</th>';
            html += '<th style="padding: 12px; border: 1px solid #dee2e6;">Hop</th>';
            html += '</tr></thead><tbody>';

            terminalIndex.forEach(entry => {
                // Format the timestamp
                let dateTimeDisplay = 'N/A';
                if (entry.timestamp) {
                    const date = new Date(entry.timestamp);
                    dateTimeDisplay = date.toISOString().replace('T', ' ').replace('Z', ' UTC');
                } else if (entry.datetime) {
                    dateTimeDisplay = entry.datetime + ' ' + (entry.timezone || 'UTC');
                }

                html += '<tr>';
                html += '<td style="padding: 10px; border: 1px solid #dee2e6;">' + (entry.exchangeName || 'Unknown') + '</td>';
                html += '<td style="padding: 10px; border: 1px solid #dee2e6; font-family: monospace; font-size: 11px; word-break: break-all;">' + (entry.toWallet || entry.walletAddress || 'N/A') + '</td>';
                html += '<td style="padding: 10px; border: 1px solid #dee2e6;">' + entry.amount.toLocaleString() + '</td>';
                html += '<td style="padding: 10px; border: 1px solid #dee2e6;">' + entry.currency + '</td>';
                html += '<td style="padding: 10px; border: 1px solid #dee2e6; font-family: monospace; font-size: 11px; word-break: break-all;">' + (entry.txHash || 'Not recorded') + '</td>';
                html += '<td style="padding: 10px; border: 1px solid #dee2e6; font-size: 12px;">' + dateTimeDisplay + '</td>';
                html += '<td style="padding: 10px; border: 1px solid #dee2e6;">' + entry.notation + '</td>';
                html += '<td style="padding: 10px; border: 1px solid #dee2e6;">H' + entry.hopNumber + '</td>';
                html += '</tr>';
            });

            html += '</tbody></table>';

            // Add export note
            html += '<div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-left: 4px solid #9b59b6;">';
            html += '<p style="margin: 0 0 10px 0; font-weight: bold;">📋 Export Instructions:</p>';
            html += '<ul style="margin: 0; padding-left: 20px;">';
            html += '<li>Click on an exchange name to see detailed drill-down view</li>';
            html += '<li>Use "Export for Legal Process" to generate exchange-specific Excel sheets for subpoenas</li>';
            html += '<li>Each export includes entity name, sending wallet, receiving wallet, date/time, amount, and transaction hash</li>';
            html += '<li>Transaction hashes can be used for exchange subpoenas and legal process requests</li>';
            html += '<li>Timestamps are preserved in UTC for international coordination</li>';
            html += '</ul>';
            html += '</div>';

            container.innerHTML = html;
        }

        // Show drill-down modal for specific exchange
        window.showTerminalWalletDrilldown = function(exchangeName) {
            console.log('🔍 [Terminal Wallet Drill-Down] Opening drill-down for exchange:', exchangeName);

            const terminalIndex = investigation.terminalWalletIndex || [];
            const exchangeEntries = terminalIndex.filter(entry =>
                (entry.exchangeName || 'Unknown') === exchangeName
            );

            if (exchangeEntries.length === 0) {
                alert('No terminal wallet entries found for ' + exchangeName);
                return;
            }

            // Sort by date (newest first)
            exchangeEntries.sort((a, b) => {
                const dateA = a.timestamp ? new Date(a.timestamp) : new Date(0);
                const dateB = b.timestamp ? new Date(b.timestamp) : new Date(0);
                return dateB - dateA;
            });

            // Calculate totals
            const totalsByCurrency = {};
            exchangeEntries.forEach(entry => {
                if (!totalsByCurrency[entry.currency]) {
                    totalsByCurrency[entry.currency] = 0;
                }
                totalsByCurrency[entry.currency] += entry.amount;
            });

            const totalsDisplay = Object.entries(totalsByCurrency)
                .map(([curr, amt]) => amt.toLocaleString() + ' ' + curr)
                .join(', ');

            let html = '<div id="terminalDrilldownModal" class="modal show">';
            html += '<div class="modal-content" style="max-width: 95%; width: 1200px;">';

            // Header
            html += '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 2px solid #9b59b6;">';
            html += '<div>';
            html += '<h2 style="margin: 0; color: #9b59b6;">⚖️ ' + exchangeName + ' - Legal Process Export</h2>';
            html += '<p style="margin: 5px 0 0 0; color: #666;">Total Arrivals: ' + exchangeEntries.length + ' | Total Amount: ' + totalsDisplay + '</p>';
            html += '</div>';
            html += '<button onclick="closeTerminalDrilldownModal()" style="background: none; border: none; font-size: 28px; cursor: pointer; color: #999;">&times;</button>';
            html += '</div>';

            // Legal process note
            html += '<div style="margin-bottom: 20px; padding: 15px; background: #fff3e0; border: 2px solid #ff9800; border-radius: 8px;">';
            html += '<p style="margin: 0; color: #e65100;"><strong>📋 Legal Process Ready:</strong> This drill-down shows all threads arriving at ' + exchangeName + '. Use the export button below to generate an Excel/CSV file formatted for subpoena and legal process requests.</p>';
            html += '</div>';

            // Export button
            html += '<div style="margin-bottom: 20px; text-align: right;">';
            html += '<button class="btn btn-primary" onclick="exportExchangeTransactionsToExcel(\'' + exchangeName.replace(/'/g, "\\'") + '\')" style="padding: 12px 24px; font-size: 16px;">';
            html += '📄 Export ' + exchangeName + ' for Legal Process';
            html += '</button>';
            html += '</div>';

            // Detailed transactions table
            html += '<div style="max-height: 500px; overflow-y: auto; border: 1px solid #dee2e6; border-radius: 4px;">';
            html += '<table style="width: 100%; border-collapse: collapse;">';
            html += '<thead style="position: sticky; top: 0; background: #9b59b6; color: white; z-index: 10;">';
            html += '<tr>';
            html += '<th style="padding: 12px; border: 1px solid #dee2e6; text-align: left;">Entity Name</th>';
            html += '<th style="padding: 12px; border: 1px solid #dee2e6; text-align: left;">Sending Wallet</th>';
            html += '<th style="padding: 12px; border: 1px solid #dee2e6; text-align: left;">Receiving Wallet</th>';
            html += '<th style="padding: 12px; border: 1px solid #dee2e6; text-align: left;">Date/Time (UTC)</th>';
            html += '<th style="padding: 12px; border: 1px solid #dee2e6; text-align: left;">Amount</th>';
            html += '<th style="padding: 12px; border: 1px solid #dee2e6; text-align: left;">Transaction Hash</th>';
            html += '<th style="padding: 12px; border: 1px solid #dee2e6; text-align: left;">Thread</th>';
            html += '</tr>';
            html += '</thead>';
            html += '<tbody>';

            exchangeEntries.forEach((entry, index) => {
                // Format the timestamp
                let dateTimeDisplay = 'N/A';
                if (entry.timestamp) {
                    const date = new Date(entry.timestamp);
                    dateTimeDisplay = date.toISOString().replace('T', ' ').replace('Z', ' UTC');
                } else if (entry.datetime) {
                    dateTimeDisplay = entry.datetime + ' ' + (entry.timezone || 'UTC');
                }

                const bgColor = index % 2 === 0 ? '#ffffff' : '#f8f9fa';

                html += '<tr style="background: ' + bgColor + ';">';
                html += '<td style="padding: 10px; border: 1px solid #dee2e6; font-weight: bold;">' + (entry.exchangeName || 'Unknown') + '</td>';
                html += '<td style="padding: 10px; border: 1px solid #dee2e6; font-family: monospace; font-size: 11px; word-break: break-all;">' + (entry.fromWallet || 'N/A') + '</td>';
                html += '<td style="padding: 10px; border: 1px solid #dee2e6; font-family: monospace; font-size: 11px; word-break: break-all;">' + (entry.toWallet || entry.walletAddress || 'N/A') + '</td>';
                html += '<td style="padding: 10px; border: 1px solid #dee2e6; font-size: 12px; white-space: nowrap;">' + dateTimeDisplay + '</td>';
                html += '<td style="padding: 10px; border: 1px solid #dee2e6; font-weight: bold; white-space: nowrap;">' + entry.amount.toLocaleString() + ' ' + entry.currency + '</td>';
                html += '<td style="padding: 10px; border: 1px solid #dee2e6; font-family: monospace; font-size: 11px; word-break: break-all;">' + (entry.txHash || 'Not recorded') + '</td>';
                html += '<td style="padding: 10px; border: 1px solid #dee2e6;">' + entry.notation + '</td>';
                html += '</tr>';
            });

            html += '</tbody>';
            html += '</table>';
            html += '</div>';

            // Footer info
            html += '<div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-left: 4px solid #9b59b6;">';
            html += '<p style="margin: 0 0 5px 0; font-weight: bold;">📌 Legal Process Information:</p>';
            html += '<ul style="margin: 5px 0 0 0; padding-left: 20px; font-size: 14px;">';
            html += '<li>Each row represents one thread (victim transaction path) arriving at this exchange</li>';
            html += '<li>Transaction hashes can be submitted with subpoenas to identify account holders</li>';
            html += '<li>All timestamps are in UTC for international coordination</li>';
            html += '<li>Case ID: ' + (investigation.caseId || 'Not specified') + '</li>';
            html += '<li>Report Generated: ' + new Date().toISOString().replace('T', ' ').replace('Z', ' UTC') + '</li>';
            html += '</ul>';
            html += '</div>';

            html += '</div></div>';

            createCenteredModal('terminalDrilldownModal', html);
        };

        // Close terminal wallet drill-down modal
        window.closeTerminalDrilldownModal = function() {
            const modal = document.getElementById('terminalDrilldownModal');
            if (modal) {
                modal.remove();
            }
        };

        // Export exchange-specific transactions to Excel for legal process
        window.exportExchangeTransactionsToExcel = function(exchangeName) {
            console.log('📄 [Terminal Wallet Export] Exporting transactions for:', exchangeName);

            const terminalIndex = investigation.terminalWalletIndex || [];
            const exchangeEntries = terminalIndex.filter(entry =>
                (entry.exchangeName || 'Unknown') === exchangeName
            );

            if (exchangeEntries.length === 0) {
                alert('No terminal wallet entries found for ' + exchangeName);
                return;
            }

            // Sort by date (oldest first for legal process chronological order)
            exchangeEntries.sort((a, b) => {
                const dateA = a.timestamp ? new Date(a.timestamp) : new Date(0);
                const dateB = b.timestamp ? new Date(b.timestamp) : new Date(0);
                return dateA - dateB;
            });

            // Create CSV content with comprehensive header
            let csvContent = '';

            // Add case information header
            csvContent += 'LEGAL PROCESS REQUEST - TERMINAL WALLET TRANSACTIONS\n';
            csvContent += 'Case ID:,' + (investigation.caseId || 'Not specified') + '\n';
            csvContent += 'Investigator:,' + (investigation.investigator || 'Not specified') + '\n';
            csvContent += 'Agency:,' + (investigation.agency || 'Not specified') + '\n';
            csvContent += 'Report Generated:,' + new Date().toISOString().replace('T', ' ').replace('Z', ' UTC') + '\n';
            csvContent += 'Exchange/Entity:,' + exchangeName + '\n';
            csvContent += 'Total Transactions:,' + exchangeEntries.length + '\n';
            csvContent += '\n';

            // Add column headers
            csvContent += 'Entity Name,Sending Wallet Address,Receiving (Terminal) Wallet Address,Date/Time (UTC),Amount,Currency,Transaction Hash,Thread Notation,Hop Number,Case ID\n';

            // Add data rows
            exchangeEntries.forEach(entry => {
                // Format the timestamp
                let dateTimeDisplay = 'N/A';
                if (entry.timestamp) {
                    const date = new Date(entry.timestamp);
                    dateTimeDisplay = date.toISOString().replace('T', ' ').replace('Z', ' UTC');
                } else if (entry.datetime) {
                    dateTimeDisplay = entry.datetime + ' ' + (entry.timezone || 'UTC');
                }

                // CSV row with proper escaping
                const entityName = (entry.exchangeName || 'Unknown').replace(/"/g, '""');
                const sendingWallet = (entry.fromWallet || 'N/A').replace(/"/g, '""');
                const receivingWallet = (entry.toWallet || entry.walletAddress || 'N/A').replace(/"/g, '""');
                const dateTime = dateTimeDisplay.replace(/"/g, '""');
                const amount = entry.amount;
                const currency = entry.currency.replace(/"/g, '""');
                const txHash = (entry.txHash || 'Not recorded').replace(/"/g, '""');
                const notation = entry.notation.replace(/"/g, '""');
                const hopNumber = entry.hopNumber || 'N/A';
                const caseId = (investigation.caseId || 'Not specified').replace(/"/g, '""');

                csvContent += '"' + entityName + '","' + sendingWallet + '","' + receivingWallet + '","' + dateTime + '",' + amount + ',"' + currency + '","' + txHash + '","' + notation + '",' + hopNumber + ',"' + caseId + '"\n';
            });

            // Add summary footer
            csvContent += '\n';
            csvContent += 'SUMMARY\n';
            const totalsByCurrency = {};
            exchangeEntries.forEach(entry => {
                if (!totalsByCurrency[entry.currency]) {
                    totalsByCurrency[entry.currency] = 0;
                }
                totalsByCurrency[entry.currency] += entry.amount;
            });

            Object.entries(totalsByCurrency).forEach(([currency, total]) => {
                csvContent += 'Total ' + currency + ':,' + total.toLocaleString() + '\n';
            });

            // Generate filename
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const safeExchangeName = exchangeName.replace(/[^a-zA-Z0-9]/g, '_');
            const filename = 'Legal_Process_' + safeExchangeName + '_' + (investigation.caseId || 'Case').replace(/[^a-zA-Z0-9]/g, '_') + '_' + timestamp + '.csv';

            // Download the file
            downloadFile(csvContent, filename, 'text/csv');

            showNotification('✅ Legal process export generated: ' + filename, 'success');
            console.log('✅ [Terminal Wallet Export] Export completed:', filename);
        };

        // Update Cover Page
        function updateCoverPage() {
            // Safely update elements only if they exist
            const updateElement = (id, value) => {
                const el = document.getElementById(id);
                if (el) el.textContent = value;
            };

            updateElement('report-caseId', investigation.caseId || 'Not specified');
            updateElement('report-date', new Date().toLocaleDateString());
            updateElement('report-investigator', investigation.investigator || 'Not specified');
            updateElement('report-agency', investigation.agency || 'Not specified');
            updateElement('report-caseType', investigation.caseType || 'Not specified');
            updateElement('report-synopsis', investigation.caseSynopsis || 'No synopsis provided');

            // Update Investigation Summary
            updateElement('report-totalVictims', investigation.victims?.length || 0);
            updateElement('report-totalHops', investigation.hops?.length || 0);

            // Calculate total loss
            const totalLoss = Object.entries(investigation.confirmedRootTotalsByCurrency || {})
                .map(([curr, amt]) => `${amt.toLocaleString()} ${curr}`);
            updateElement('report-totalLoss', totalLoss.length > 0 ? totalLoss.join(', ') : 'Not calculated');

            updateElement('report-terminalWallets', investigation.terminalWalletIndex?.length || 0);
        }

        // Narrative Editor Functions
        function formatNarrativeText(command) {
            document.execCommand(command, false, null);
            document.getElementById('narrativeEditor').focus();
        }

        function insertNarrativeBullet() {
            document.execCommand('insertUnorderedList', false, null);
            document.getElementById('narrativeEditor').focus();
        }

        function saveNarrative() {
            const editor = document.getElementById('narrativeEditor');
            investigation.narrativeReport = editor.innerHTML;
            saveToStorage();
            showNotification('Narrative saved successfully', 'success');
        }

        // Export Functions
        function exportCurrentReportTab() {
            const activeTab = document.querySelector('.report-tab-btn.active');
            const tabName = activeTab ? activeTab.textContent.trim() : 'Report';
            const content = document.querySelector('.report-tab-content[style*="display: block"]');

            if (content) {
                const html = generateExportHTML(tabName, content.innerHTML);
                downloadFile(html, `${investigation.caseId}_${tabName.replace(/\s/g, '_')}.html`, 'text/html');
            }
        }

        function exportFullReport() {
            let fullHTML = '<html><head><title>Complete Investigation Report</title>';
            fullHTML += '<style>body { font-family: Arial, sans-serif; } .page-break { page-break-after: always; }</style>';
            fullHTML += '</head><body>';

            // Cover Page
            updateCoverPage();
            const coverContent = document.getElementById('report-cover').innerHTML;
            fullHTML += '<div class="page-break">' + coverContent + '</div>';

            // Victim Index
            generateVictimIndexReport();
            const victimsContent = document.getElementById('report-victims-content').innerHTML;
            fullHTML += '<div class="page-break"><h2>Victim Index</h2>' + victimsContent + '</div>';

            // Red Wallet Index
            generateRedWalletIndexReport();
            const redContent = document.getElementById('report-redwallet-content').innerHTML;
            fullHTML += '<div class="page-break"><h2>Red Wallet Index</h2>' + redContent + '</div>';

            // Terminal Index
            generateTerminalIndexReport();
            const terminalContent = document.getElementById('report-terminal-content').innerHTML;
            fullHTML += '<div class="page-break"><h2>Terminal Wallet Index</h2>' + terminalContent + '</div>';

            // Narrative
            const narrativeContent = document.getElementById('narrativeEditor').innerHTML;
            fullHTML += '<div class="page-break"><h2>Narrative Report</h2>' + narrativeContent + '</div>';

            // Technical Trail
            generateTechnicalAuditTrail();
            const technicalContent = document.getElementById('report-technical-content').innerHTML;
            fullHTML += '<div class="page-break"><h2>Technical Audit Trail</h2>' + technicalContent + '</div>';

            fullHTML += '</body></html>';

            const format = document.getElementById('exportFormat').value;
            const filename = `${investigation.caseId}_Complete_Report_${new Date().toISOString().split('T')[0]}.${format}`;
            downloadFile(fullHTML, filename, 'text/html');
        }

        function generateExportHTML(title, content) {
            return `<!DOCTYPE html>
                <html>
                <head>
                    <title>${title} - ${investigation.caseId}</title>
                    <style>
                        body { font-family: Arial, sans-serif; margin: 40px; }
                        table { border-collapse: collapse; width: 100%; }
                        th, td { border: 1px solid #dee2e6; padding: 10px; }
                        code { background: #f8f9fa; padding: 2px 4px; border-radius: 2px; }
                    </style>
                </head>
                <body>
                    <h1>${title}</h1>
                    <p>Case ID: ${investigation.caseId} | Date: ${new Date().toLocaleDateString()}</p>
                    <hr>
                    ${content}
                </body>
                </html>`;
        }

        function printPreview() {
            const content = document.querySelector('.report-tab-content[style*="display: block"]');
            if (content) {
                const printWindow = window.open('', '_blank');
                printWindow.document.write(generateExportHTML('Print Preview', content.innerHTML));
                printWindow.document.close();
                printWindow.print();
            }
        }

        // Define switchTab function early to ensure it's available when HTML loads
        function switchTab(tabName) {
            // Show navigation tabs when switching away from welcome screen
            const navTabs = document.getElementById('mainNavTabs');
            if (navTabs) {
                navTabs.style.display = 'flex';
            }

            // First, hide all tabs and remove active state
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.style.display = 'none';
                tab.classList.remove('active');
            });
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });

            const tabElement = document.getElementById(tabName + '-tab');
            if (tabElement) tabElement.classList.add('active');
            
            const tabContent = document.getElementById(tabName + 'Tab');
            if (tabContent) tabContent.classList.add('active');
            
            // Find and activate the corresponding nav tab
            const navTab = document.querySelector(`[onclick="switchTab('${tabName}')"]`);
            if (navTab) {
                navTab.classList.add('active');
            }

            // Tab-specific actions (these functions will be defined later)
            if (typeof window.tabActions !== 'undefined' && window.tabActions[tabName]) {
                window.tabActions[tabName]();
            }

            // Special handling for flow diagram tab - auto-save and initialize
            if (tabName === 'flowdiagram') {
                // Auto-save before switching to graph
                try {
                    console.log('Auto-saving before graph visualization...');
                    if (typeof saveInvestigation === 'function') {
                        saveInvestigation();
                    }
                } catch (saveError) {
                    console.error('Error auto-saving:', saveError);
                }

                // Initialize graph visualization when tab is shown
                setTimeout(() => {
                    try {
                        if (typeof initializeGraphVisualization === 'function') {
                            initializeGraphVisualization();
                        } else {
                            console.error('Graph initialization function not found');
                            if (typeof showGraphErrorState === 'function') {
                                showGraphErrorState('Graph visualization not loaded. Please refresh the page.');
                            }
                        }
                    } catch (initError) {
                        console.error('Error initializing graph:', initError);
                        if (typeof showGraphErrorState === 'function') {
                            showGraphErrorState('Failed to initialize graph. Your data is safe - please return to investigation.');
                        }
                    }
                }, 100);
            }
            
            // Update the workflow indicators (function will be defined later)
            if (typeof updateWorkflowSteps !== 'undefined') {
                updateWorkflowSteps();
            }
            
            // Update breadcrumbs if function exists
            if (typeof updateBreadcrumbs !== 'undefined') {
                updateBreadcrumbs();
            }
        }
        
        // Make switchTab globally available immediately
        window.switchTab = switchTab;
        
        // Helper function to safely get currency with validation
        function getCurrencyFromTransaction(transaction) {
            if (!transaction) return null;
            
            if (transaction.currency === 'CUSTOM') {
                if (!transaction.customCurrency || transaction.customCurrency.trim() === '') {
                    console.warn('Transaction has CUSTOM currency but no customCurrency value:', transaction);
                    return null;
                }
                return transaction.customCurrency.trim();
            }
            
            return transaction.currency || null;
        }
        
        // Helper function to safely get currency from entry
        function getCurrencyFromEntry(entry) {
            if (!entry) return null;
            
            if (entry.currency === 'CUSTOM') {
                if (!entry.customCurrency || entry.customCurrency.trim() === '') {
                    console.warn('Entry has CUSTOM currency but no customCurrency value:', entry);
                    return null;
                }
                return entry.customCurrency.trim();
            }
            
            return entry.currency || null;
        }
        
        // Validate wallet address format
        function validateWalletAddress(address, currency) {
            if (!address || address.trim() === '') return { valid: false, error: 'Wallet address cannot be empty' };
            
            const trimmedAddress = address.trim();
            
            // Basic validation patterns for common cryptocurrencies
            const patterns = {
                'BTC': /^(bc1|[13])[a-zA-HJ-NP-Z0-9]{25,62}$/,  // Bitcoin (Legacy, SegWit, Native SegWit)
                'ETH': /^0x[a-fA-F0-9]{40}$/,  // Ethereum
                'USDT': /^0x[a-fA-F0-9]{40}$/,  // USDT on Ethereum
                'USDC': /^0x[a-fA-F0-9]{40}$/,  // USDC on Ethereum
                'TRX': /^T[a-zA-Z0-9]{33}$/,    // TRON
                'SOL': /^[1-9A-HJ-NP-Za-km-z]{32,44}$/,  // Solana
                'ADA': /^(addr1|DdzFF|Ae2)[a-zA-Z0-9]{50,}$/,  // Cardano
                'BNB': /^(bnb1|0x)[a-zA-Z0-9]+$/,  // BNB (Beacon Chain or BSC)
            };
            
            // If we have a pattern for this currency, validate it
            if (patterns[currency]) {
                if (!patterns[currency].test(trimmedAddress)) {
                    return { 
                        valid: false, 
                        error: `Invalid ${currency} wallet address format`,
                        suggestion: getWalletFormatHint(currency)
                    };
                }
            }
            
            // General validation for any address
            if (trimmedAddress.length < 10) {
                return { valid: false, error: 'Wallet address seems too short' };
            }
            
            if (trimmedAddress.length > 150) {
                return { valid: false, error: 'Wallet address seems too long' };
            }
            
            // Check for common invalid patterns
            if (/\s/.test(trimmedAddress)) {
                return { valid: false, error: 'Wallet address cannot contain spaces' };
            }
            
            return { valid: true };
        }
        
        // Get wallet format hint for a currency
        function getWalletFormatHint(currency) {
            const hints = {
                'BTC': 'Bitcoin addresses start with 1, 3, or bc1',
                'ETH': 'Ethereum addresses start with 0x and are 42 characters long',
                'USDT': 'USDT addresses depend on the blockchain (usually Ethereum: 0x...)',
                'USDC': 'USDC addresses depend on the blockchain (usually Ethereum: 0x...)',
                'TRX': 'TRON addresses start with T and are 34 characters long',
                'SOL': 'Solana addresses are 32-44 characters of base58',
                'ADA': 'Cardano addresses start with addr1, DdzFF, or Ae2',
                'BNB': 'BNB addresses start with bnb1 (Beacon) or 0x (BSC)'
            };
            
            return hints[currency] || 'Please check the address format for this currency';
        }
        
        // Get decimal precision for currency
        function getCurrencyPrecision(currency) {
            const precisions = {
                'USD': 2,
                'BTC': 8,
                'ETH': 18,
                'USDT': 6,
                'USDC': 6,
                'TRX': 6,
                'SOL': 9,
                'ADA': 6,
                'DAI': 18,
                'BNB': 8
            };
            return precisions[currency] || 2;
        }
        
        // Safe addition for currency amounts
        function addCurrencyAmounts(amount1, amount2, currency) {
            const precision = getCurrencyPrecision(currency);
            const factor = Math.pow(10, precision);
            return Math.round((amount1 * factor) + (amount2 * factor)) / factor;
        }

        // Round amount to proper precision for currency
        function roundToCurrencyPrecision(amount, currency) {
            const precision = getCurrencyPrecision(currency);
            const factor = Math.pow(10, Math.min(precision, 6)); // Cap at 6 decimals for display
            return Math.round(amount * factor) / factor;
        }
        
        // Safe subtraction for currency amounts
        function subtractCurrencyAmounts(amount1, amount2, currency) {
            const precision = getCurrencyPrecision(currency);
            const factor = Math.pow(10, precision);
            return Math.round((amount1 * factor) - (amount2 * factor)) / factor;
        }
        
        // Format currency amount with proper precision
        // Simple wrapper for backwards compatibility
        function formatCurrency(amount, currency) {
            // Default to no currency symbol if not provided
            if (!currency) {
                return amount.toLocaleString();
            }
            return formatCurrencyAmount(amount, currency);
        }

        function formatCurrencyAmount(amount, currency) {
            const precision = getCurrencyPrecision(currency);
            return parseFloat(amount).toFixed(precision);
        }

        // Safe amount parsing with validation
        function parseAmount(value, currency = null) {
            // Handle various input types
            if (value === null || value === undefined || value === '') {
                return 0;
            }

            // Convert to string and clean
            const cleanValue = String(value).trim().replace(/,/g, '');

            // Parse the number
            const parsed = parseFloat(cleanValue);

            // Check for invalid numbers
            if (isNaN(parsed) || !isFinite(parsed)) {
                return 0;
            }

            // Apply precision if currency specified
            if (currency) {
                const precision = getCurrencyPrecision(currency);
                const factor = Math.pow(10, precision);
                return Math.round(parsed * factor) / factor;
            }

            return parsed;
        }

        // Validate if amount is valid and positive
        function isValidAmount(value) {
            const parsed = parseAmount(value);
            return parsed > 0 && isFinite(parsed);
        }

        // Enhanced fetch with timeout and retry logic
        async function fetchWithTimeout(url, options = {}, timeoutMs = 30000, retries = 3) {
            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), timeoutMs);

            const fetchOptions = {
                ...options,
                signal: controller.signal
            };

            let lastError = null;
            for (let attempt = 0; attempt <= retries; attempt++) {
                try {
                    if (attempt > 0) {
                        // Wait before retry (exponential backoff)
                        await new Promise(resolve => setTimeout(resolve, Math.min(1000 * Math.pow(2, attempt - 1), 5000)));
                    }

                    const response = await fetch(url, fetchOptions);
                    clearTimeout(timeout);

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    return response;
                } catch (error) {
                    lastError = error;
                    if (error.name === 'AbortError') {
                        console.log(`Request timeout for ${url} (attempt ${attempt + 1}/${retries + 1})`);
                    } else {
                        console.log(`Request failed for ${url} (attempt ${attempt + 1}/${retries + 1}):`, error.message);
                    }

                    // Don't retry on certain errors
                    if (error.message.includes('HTTP 404') || error.message.includes('HTTP 403')) {
                        break;
                    }
                }
            }

            clearTimeout(timeout);
            throw lastError || new Error('Failed to fetch after retries');
        }
        
        // Add entry to validation history
        function addValidationHistoryEntry(type, details, status = 'info') {
            if (!investigation.validationHistory) {
                investigation.validationHistory = [];
            }
            
            investigation.validationHistory.push({
                timestamp: new Date().toISOString(),
                type: type,
                status: status, // 'success', 'warning', 'error', 'info'
                details: details,
                user: investigation.investigator || 'Unknown'
            });
            
            // Keep only last 100 entries
            if (investigation.validationHistory.length > 100) {
                investigation.validationHistory = investigation.validationHistory.slice(-100);
            }
        }
        
        // Convert datetime from any timezone to UTC for reports
        function convertDateTimeToUTC(datetime, timezone) {
            if (!datetime) return null;
            
            // If already UTC, just return it
            if (timezone === 'UTC') {
                return new Date(datetime);
            }
            
            // Convert to UTC timestamp using our timezone conversion
            const utcTimestamp = convertToUTC(datetime, timezone);
            return new Date(utcTimestamp);
        }
        
        // Format datetime for UTC display in reports
        function formatDateTimeForReport(datetime, timezone) {
            if (!datetime) return 'No date';
            
            const utcDate = convertDateTimeToUTC(datetime, timezone);
            if (!utcDate) return 'Invalid date';
            
            // Format as ISO string but make it more readable
            const year = utcDate.getUTCFullYear();
            const month = String(utcDate.getUTCMonth() + 1).padStart(2, '0');
            const day = String(utcDate.getUTCDate()).padStart(2, '0');
            const hours = String(utcDate.getUTCHours()).padStart(2, '0');
            const minutes = String(utcDate.getUTCMinutes()).padStart(2, '0');
            const seconds = String(utcDate.getUTCSeconds()).padStart(2, '0');
            
            return `${year}-${month}-${day} ${hours}:${minutes}:${seconds} UTC`;
        }
        
        // Convert all investigation timestamps to UTC for reporting
        function prepareInvestigationForUTCReport() {
            const utcInvestigation = JSON.parse(JSON.stringify(investigation)); // Deep clone
            
            // Convert victim transaction times
            utcInvestigation.victims.forEach(victim => {
                victim.transactions.forEach(transaction => {
                    if (transaction.datetime && transaction.timezone) {
                        transaction.utcDatetime = formatDateTimeForReport(transaction.datetime, transaction.timezone);
                        transaction.originalDatetime = transaction.datetime;
                        transaction.originalTimezone = transaction.timezone;
                    }
                });
            });
            
            // Convert hop entry times
            utcInvestigation.hops.forEach(hop => {
                hop.entries.forEach(entry => {
                    if (entry.timestamp && entry.timezone) {
                        entry.utcTimestamp = formatDateTimeForReport(entry.timestamp, entry.timezone);
                        entry.originalTimestamp = entry.timestamp;
                        entry.originalTimezone = entry.timezone;
                    }
                });
            });
            
            return utcInvestigation;
        }

        // Global state
        let investigation = {
            caseId: '',
            investigator: '',
            caseType: '',
            caseSynopsis: '',
            setupComplete: false,
            victims: [],
            hops: [],
            conversions: [],
            redWalletIndex: [],
            universalWalletIndex: [],
            terminalWalletIndex: [],  // New: Track all terminal wallet arrivals
            rootTotalConfirmed: false,
            confirmedRootTotal: 0,
            confirmedRootTotalsByCurrency: {},
            currentART: {},
            created: new Date().toISOString(),
            availableThreads: {},
            threadAssignments: {},
            sourceChainData: {},
            enhancedNotationEnabled: true,
            validationHistory: [],
            lastValidationTimestamp: null,
            threadValidationErrors: [],
            sourceChainReports: [],
            integrationVersion: '4.0',
            tracingMethod: 'PIFO' // Default to PIFO, can be changed to 'LIBR'
        };
        
        // Undo system
        let undoHistory = [];
        const MAX_UNDO_HISTORY = 20;
        
        // File system integration
        let savedFilePath = null;
        let isFileSystemAvailable = false;
        let fileHandle = null;
        
        // Blockchain API Integration
        let targetEntryContext = null;
        
        // Wallet Types - Per B.A.T.S. Official Framework
        const walletTypes = {
            'red': '🔴 RED - Victim-Facing',
            'pink': '🌸 PINK - Dividend/Deception',
            'yellow': '🟡 YELLOW - Hub (Convergence)',
            'orange': '🟠 ORANGE - Bitcoin Change',
            'brown': '🟤 BROWN - Asset Conversion',
            'black': '⚫ BLACK - Default Intermediary',
            'blue': '🔵 BLUE - Cold Storage',
            'purple': '🟣 PURPLE - Exchange Deposit',
            'gray': '⚪ GRAY - Obfuscated/Diluted',
            'green': '🟢 GREEN - Victim Owned'
        };
        
        // Entry Types - defined later with full descriptions
        
        // Timezones
        const timezones = {
            'UTC': 'UTC',
            'LOCAL': 'Local',
            'EST': 'EST',
            'EDT': 'EDT',
            'CST': 'CST',
            'CDT': 'CDT',
            'MST': 'MST',
            'MDT': 'MDT',
            'PST': 'PST',
            'PDT': 'PDT',
            'GMT': 'GMT',
            'CET': 'CET',
            'CEST': 'CEST',
            'JST': 'JST',
            'ET': 'Eastern Time',
            'CT': 'Central Time',
            'MT': 'Mountain Time',
            'PT': 'Pacific Time'
        };
        
        // Currencies
        const currencies = {
            'BTC': { name: 'Bitcoin', symbol: '₿', decimals: 8 },
            'ETH': { name: 'Ethereum', symbol: 'Ξ', decimals: 18 },
            'USDT': { name: 'Tether', symbol: '₮', decimals: 6 },
            'USDC': { name: 'USD Coin', symbol: '$', decimals: 6 },
            'MATIC': { name: 'Polygon', symbol: 'MATIC', decimals: 18 },
            'USD': { name: 'US Dollar', symbol: '$', decimals: 2 },
            'TRX': { name: 'TRON', symbol: 'TRX', decimals: 6 },
            'SOL': { name: 'Solana', symbol: 'SOL', decimals: 9 },
            'ADA': { name: 'Cardano', symbol: 'ADA', decimals: 6 },
            'DAI': { name: 'DAI', symbol: 'DAI', decimals: 18 },
            'BNB': { name: 'BNB', symbol: 'BNB', decimals: 18 },
            // Native currencies for newer chains
            'HYPE': { name: 'HyperEVM', symbol: 'HYPE', decimals: 18 },
            'AVAX': { name: 'Avalanche', symbol: 'AVAX', decimals: 18 },
            'MNT': { name: 'Mantle', symbol: 'MNT', decimals: 18 },
            'xDAI': { name: 'Gnosis', symbol: 'xDAI', decimals: 18 },
            'CELO': { name: 'Celo', symbol: 'CELO', decimals: 18 },
            'GLMR': { name: 'Moonbeam', symbol: 'GLMR', decimals: 18 },
            'MOVR': { name: 'Moonriver', symbol: 'MOVR', decimals: 18 },
            'frxETH': { name: 'Fraxtal', symbol: 'frxETH', decimals: 18 },
            'BTT': { name: 'BitTorrent', symbol: 'BTT', decimals: 18 },
            'CUSTOM': { name: 'Custom', symbol: '', decimals: 8 }
        };
        let currentTxData = null;
        let currentBulkVictimId = null;
        let pendingTransfers = null;
        let pendingTransferCallback = null;

        // Cache for wallet attributions to reduce API calls
        const walletAttributionCache = {};

        // Add entry to terminal wallet index
        function addToTerminalWalletIndex(entry) {
            if (!investigation.terminalWalletIndex) {
                investigation.terminalWalletIndex = [];
            }

            // Extract exchange name from various possible sources
            let exchangeName = entry.exchangeAttribution?.name ||
                              entry.exchangeAttribution?.label ||
                              entry.exchangeName ||
                              entry.terminalAttribution?.name ||
                              (entry.notes && entry.notes.match(/Terminal wallet: ([^\n]+)/)?.[1]) ||
                              'Unknown Exchange';

            const terminalRecord = {
                id: Date.now(),
                timestamp: entry.timestamp || new Date().toISOString(),
                hopNumber: entry.hopNumber,
                txHash: entry.txHash,
                fromWallet: entry.fromWallet,
                toWallet: entry.toWallet,
                walletAddress: entry.toWallet,  // Add for compatibility with generateTerminalSummary
                walletLabel: exchangeName,      // Add for compatibility with generateTerminalSummary
                exchangeName: exchangeName,
                exchangeType: entry.exchangeAttribution?.type || 'Terminal',
                amount: parseFloat(entry.amount),
                currency: entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency,
                notation: entry.notation,
                detectionSource: entry.exchangeAttribution?.source || entry.terminalAttribution?.source || 'manual',
                notes: entry.notes || '',
                walletType: entry.toWalletType || 'purple'
            };

            investigation.terminalWalletIndex.push(terminalRecord);
            console.log('Added to terminal wallet index:', terminalRecord);

            // Rebuild universal wallet index to include this terminal wallet
            buildUniversalWalletIndex();

            saveToStorage();
        }

        // Centralized function to add wallet to universal index
        function addWalletToUniversalIndex(walletAddress, walletType, data = {}) {
            if (!investigation.universalWalletIndex) {
                investigation.universalWalletIndex = [];
            }

            // Check if wallet already exists
            const existing = investigation.universalWalletIndex.find(w => w.address === walletAddress);
            if (existing) {
                console.log(`Wallet ${walletAddress.substring(0, 20)}... already in universal index as ${existing.permanentId}`);
                return existing.permanentId;
            }

            // Generate permanent ID based on type
            const typePrefix = {
                'red': 'RED',
                'purple': 'P',
                'black': 'B',
                'brown': 'Br',
                'gray': 'G',
                'blue': 'BL',
                'orange': 'O',
                'green': 'GR'
            }[walletType] || 'U';

            const countOfType = investigation.universalWalletIndex.filter(w => w.permanentType === walletType).length + 1;
            const permanentId = `${typePrefix}-${countOfType}`;

            const entry = {
                id: permanentId,
                permanentId: permanentId,
                address: walletAddress,
                permanentType: walletType,
                currentStatus: walletType,
                label: data.label || data.exchangeName || `${walletType.toUpperCase()} Wallet`,
                totalAmount: data.amount || 0,
                currencies: data.currencies || {},
                exposureChain: data.exposureChain || [],
                firstSeen: data.firstSeen || data.notation || 'Unknown',
                statusHistory: [walletType],
                isDestination: data.isDestination || false,
                isSource: data.isSource || false,
                notes: data.notes || ''
            };

            investigation.universalWalletIndex.push(entry);
            console.log(`✅ Added to universal index: ${permanentId} (${entry.label}) - ${walletAddress.substring(0, 20)}...`);
            return permanentId;
        }

        // Get Solana wallet attribution from known addresses and patterns
        async function getSolanaWalletAttribution(address) {
            if (!address) return null;

            console.log(`Checking Solana attribution for ${address}`);

            // NO HARDCODED ADDRESSES - Only use API calls for attribution

            // Try to use Solscan API with API key (default provided for all users)
            const solscanApiKey = localStorage.getItem('bats_solscan_api_key') || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJjcmVhdGVkQXQiOjE3NTg4OTk1ODMyNTksImVtYWlsIjoiamVzc2VAdGhlYmxvY2thdWRpdC5jb20iLCJhY3Rpb24iOiJ0b2tlbi1hcGkiLCJhcGlWZXJzaW9uIjoidjIiLCJpYXQiOjE3NTg4OTk1ODN9.C3By0UPXwI5bmLrAl9o1U_SDnT7uQLoizbd8qr36GmQ';

            try {
                // Use proxy to avoid CORS issues
                let proxyUrl;

                if (solscanApiKey) {
                    // Use Pro API with API key through proxy
                    proxyUrl = `/.netlify/functions/solscan-proxy?address=${address}&apiKey=${encodeURIComponent(solscanApiKey)}`;
                    console.log('🔍 Using Solscan Pro API (via proxy)');
                    console.log('📡 Proxy URL:', proxyUrl);
                    console.log('🔑 API Key present:', true);
                } else {
                    // Fall back to public API through proxy
                    proxyUrl = `/.netlify/functions/solscan-proxy?address=${address}`;
                    console.log('Using Solscan public API (via proxy)');
                }

                const response = await fetch(proxyUrl).catch(err => {
                    console.log('❌ Solscan proxy call failed:', err);
                    return null;
                });

                console.log('📊 Solscan response status:', response?.status);
                console.log('📊 Solscan response ok:', response?.ok);
                console.log('📊 Solscan response headers:', response?.headers);

                if (response && response.ok) {
                    const data = await response.json();
                    console.log('📦 Solscan API response data:', JSON.stringify(data, null, 2));

                    // Handle Pro API v2.0 metadata response
                    if (solscanApiKey && data.success && data.data) {
                        // Pro API metadata response
                        const metadata = data.data;
                        console.log('🔍 Solscan Pro API v2.0 metadata:');
                        console.log('  - account_label:', metadata.account_label);
                        console.log('  - account_tags:', metadata.account_tags);
                        console.log('  - account_type:', metadata.account_type);
                        console.log('  - Full metadata:', JSON.stringify(metadata, null, 2));

                        // Check for label or tags in the metadata response
                        if (metadata.account_label || metadata.account_tags?.length > 0) {
                            const label = metadata.account_label || metadata.account_tags?.[0];

                            // Check if it's an exchange based on label or tags
                            const exchangeKeywords = ['exchange', 'cex', 'dex', 'binance', 'coinbase', 'kraken', 'kucoin', 'okx', 'bybit', 'gate', 'huobi', 'ftx', 'bitfinex', 'bitmex'];
                            const labelLower = label.toLowerCase();
                            const isExchange = exchangeKeywords.some(keyword => labelLower.includes(keyword)) ||
                                             metadata.account_tags?.some(tag => exchangeKeywords.some(kw => tag.toLowerCase().includes(kw)));

                            if (label) {
                                const attribution = {
                                    name: metadata.account_label || label,
                                    label: metadata.account_label || label,
                                    type: isExchange ? 'CEX' : (metadata.account_type || 'Service'),
                                    tags: metadata.account_tags || [],
                                    source: 'solscan_pro_api',
                                    isExchange: isExchange
                                };
                                console.log(`✅ Solscan Pro API attribution found: ${attribution.name}`);
                                return attribution;
                            }
                        }
                    } else if (data.tag || data.tags || data.label) {
                        // Public API response (legacy structure)
                        console.log('🔍 Solscan Public API response:');
                        console.log('  - tag:', data.tag);
                        console.log('  - tags:', data.tags);
                        console.log('  - label:', data.label);
                        console.log('  - Full data:', JSON.stringify(data, null, 2));
                        const tag = data.tag || data.tags?.[0] || data.label;

                        // Check if it's an exchange based on the tag
                        const exchangeKeywords = ['exchange', 'cex', 'binance', 'coinbase', 'kraken', 'kucoin', 'okx', 'bybit', 'gate'];
                        const isExchange = exchangeKeywords.some(keyword => tag.toLowerCase().includes(keyword));

                        if (isExchange) {
                            const attribution = {
                                name: tag,
                                label: tag,
                                type: 'CEX',
                                source: 'solscan_public_api',
                                isExchange: true
                            };
                            console.log(`Solscan public API attribution found: ${attribution.name}`);
                            return attribution;
                        }
                    }
                } else {
                    console.log('❌ Solscan API returned error or no data');
                    if (response) {
                        console.log('  Status:', response.status);
                        console.log('  StatusText:', response.statusText);
                        try {
                            const errorText = await response.text();
                            console.log('  Error response:', errorText);
                        } catch (e) {
                            console.log('  Could not read error response');
                        }
                    }
                }
            } catch (error) {
                console.log('❌ Error checking Solscan:', error);
                console.log('  Error details:', error.message);
                console.log('  Error stack:', error.stack);
            }

            return null;
        }

        // Get wallet attribution - checks multiple sources with Arkham as primary
        async function getWalletAttribution(address, chainId = null) {
            if (!address) return null;

            const lowerAddress = address.toLowerCase();

            // Check cache first
            if (walletAttributionCache[lowerAddress]) {
                console.log(`Using cached attribution for ${address}`);
                return walletAttributionCache[lowerAddress];
            }

            let attribution = null;
            let isSmartContract = false;
            let contractName = null;
            let etherscanLabel = null;

            // First, check if this is a smart contract (for EVM chains)
            if (lowerAddress.startsWith('0x') && lowerAddress.length === 42) {
                try {
                    const etherscanApiKey = localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8';
                    let apiUrl = 'https://api.etherscan.io/api';

                    // Determine API URL based on chainId if provided
                    if (chainId === 56 || chainId === 'bsc') {
                        apiUrl = 'https://api.bscscan.com/api';
                    } else if (chainId === 137 || chainId === 'polygon') {
                        apiUrl = 'https://api.polygonscan.com/api';
                    }

                    // Check if it's a verified contract
                    const contractUrl = `${apiUrl}?module=contract&action=getsourcecode&address=${address}&apikey=${etherscanApiKey}`;
                    const contractResponse = await fetch(contractUrl);

                    if (contractResponse.ok) {
                        const contractData = await contractResponse.json();
                        if (contractData.status === '1' && contractData.result && contractData.result[0]) {
                            const contract = contractData.result[0];
                            if (contract.ContractName && contract.ContractName !== '') {
                                isSmartContract = true;
                                contractName = contract.ContractName;
                                console.log(`🤖 Smart Contract detected: ${contractName} at ${address}`);
                            }
                        }
                    }

                    // Also check Etherscan labels/tags for known services using v2 API
                    // This can identify known DEXs, bridges, and other services
                    // Build the v2 API URL based on chain
                    let chainIdForV2 = 1; // Default to Ethereum
                    if (chainId === 56 || chainId === 'bsc') {
                        chainIdForV2 = 56;
                    } else if (chainId === 137 || chainId === 'polygon') {
                        chainIdForV2 = 137;
                    }

                    const labelUrl = `https://api.etherscan.io/v2/api?chainid=${chainIdForV2}&module=account&action=addressinfo&address=${address}&apikey=${etherscanApiKey}`;
                    console.log('Checking Etherscan v2 labels:', labelUrl);

                    const labelResponse = await fetch(labelUrl);
                    if (labelResponse.ok) {
                        const labelData = await labelResponse.json();
                        console.log('Etherscan label data:', labelData);

                        // Check if we got label information
                        if (labelData.status === '1' && labelData.result) {
                            const result = Array.isArray(labelData.result) ? labelData.result[0] : labelData.result;

                            if (result && result.tag) {
                                console.log(`🏷️ Etherscan label found: ${result.tag} for ${address}`);

                                // Check if this label suggests it's a DEX/Bridge
                                const tagLower = result.tag.toLowerCase();
                                const isDEXTag = tagLower.includes('dex') ||
                                                tagLower.includes('swap') ||
                                                tagLower.includes('router') ||
                                                tagLower.includes('bridge') ||
                                                tagLower.includes('amm') ||
                                                tagLower.includes('aggregator');

                                // Store this information for later use
                                if (!etherscanLabel) {
                                    etherscanLabel = {
                                        name: result.tag,
                                        url: result.url || '',
                                        isDEX: isDEXTag,
                                        isSmartContract: isSmartContract || isDEXTag
                                    };
                                }
                            }
                        }
                    }
                } catch (err) {
                    console.log('Error checking contract status:', err);
                }
            }

            try {
                // ALWAYS CHECK ARKHAM FIRST - IT'S OUR PRIMARY SOURCE FOR ALL CHAINS
                console.log(`🔍 Checking Arkham Intelligence for address: ${address}`);
                const arkhamApiKey = window.apiKeys?.arkham || 'd377a526-c9ea-4cb6-a647-775559583ff6';

                if (arkhamApiKey) {
                    try {
                        // Use the new enhanced Arkham endpoint with tags for better attribution data
                        const proxyUrl = `/.netlify/functions/arkham3?endpoint=/intelligence/address_with_extra_enrichment/${address}/all&tags=true`;
                        console.log(`📡 Arkham API URL (enhanced endpoint with tags): ${proxyUrl}`);
                        console.log(`🔑 Using API key: ${arkhamApiKey.substring(0, 10)}...`);

                        const arkhamResponse = await fetch(proxyUrl, {
                            headers: {
                                'X-Arkham-API-Key': arkhamApiKey,
                                'Accept': 'application/json'
                            }
                        }).catch(err => {
                            console.error('❌ Arkham API fetch failed:', err);
                            return null;
                        });

                        console.log(`📊 Arkham response status: ${arkhamResponse?.status}`);

                        if (arkhamResponse && arkhamResponse.ok) {
                            const arkhamData = await arkhamResponse.json();
                            console.log('📦 Arkham API full response:', JSON.stringify(arkhamData, null, 2));

                            // The /all endpoints return an object with chain names as keys
                            // Each chain can have arkhamEntity or arkhamLabel
                            console.log('🔍 Arkham response structure:');
                            console.log('  - Response type:', typeof arkhamData);
                            console.log('  - Keys:', Object.keys(arkhamData || {}));

                            // Check if this is a multi-chain response (object with chain keys)
                            const chains = Object.keys(arkhamData || {});
                            let foundAttribution = null;

                            // Look through all chains for attribution
                            for (const chain of chains) {
                                const chainData = arkhamData[chain];
                                console.log(`  - Chain ${chain} data:`, chainData);

                                if (chainData?.arkhamEntity) {
                                    // arkhamEntity = actual exchange or service
                                    console.log(`    Found arkhamEntity on ${chain}:`, chainData.arkhamEntity);

                                    // Check if the entity name strongly suggests it's a DEX/Bridge
                                    // Be conservative - only mark as DEX if we're very confident
                                    const entityName = (chainData.arkhamEntity.name || chainData.arkhamEntity.service || '').toLowerCase();
                                    const indicators = checkExchangeIndicators(entityName);

                                    // Only mark as DEX if it's explicitly identified as such by indicators with high confidence
                                    // OR if the entity type from Arkham explicitly says it's a DEX/Router
                                    const entityType = (chainData.arkhamEntity.type || '').toLowerCase();
                                    const isDEX = (indicators.suggestedType === 'DEX/Bridge' && indicators.confidence >= 85) ||
                                                 entityType.includes('dex') ||
                                                 entityType.includes('router') ||
                                                 entityType.includes('amm');

                                    foundAttribution = {
                                        name: chainData.arkhamEntity.name || chainData.arkhamEntity.service,
                                        label: chainData.arkhamEntity.type || 'Exchange',
                                        type: isDEX ? 'Bridge/DEX' : (chainData.arkhamEntity.type || 'CEX'),
                                        service: chainData.arkhamEntity.service,
                                        chain: chain,
                                        source: 'arkham_intelligence',
                                        isExchange: true,  // Default to exchange - user can convert if needed
                                        isDEX: isDEX,  // Add DEX flag for reference
                                        isSmartContract: isDEX,  // DEXes are smart contracts
                                        isPersonalLabel: false,
                                        tags: chainData.populatedTags || [],  // Include tags for richer metadata
                                        // Add note if this might be a DEX but we're not certain
                                        suspectedDEX: !isDEX && (indicators.suggestedType === 'DEX/Bridge' ||
                                                                 entityName.includes('swap') ||
                                                                 entityName.includes('router'))
                                    };
                                    break;
                                } else if (chainData?.arkhamLabel) {
                                    console.log(`    Found arkhamLabel on ${chain}:`, chainData.arkhamLabel);

                                    const labelName = chainData.arkhamLabel.name || '';
                                    const indicators = checkExchangeIndicators(labelName);

                                    if (indicators.isLikely) {
                                        // Likely an exchange/service - mark appropriately
                                        console.log(`    High confidence (${indicators.confidence}%) exchange detected: ${labelName}`);
                                        foundAttribution = {
                                            name: chainData.arkhamLabel.name,
                                            label: chainData.arkhamLabel.name,
                                            type: indicators.suggestedType === 'DEX/Bridge' ? 'Bridge/DEX' : 'CEX',
                                            chain: chain,
                                            source: 'arkham_intelligence',
                                            isExchange: true,
                                            isPersonalLabel: false,
                                            detectionConfidence: indicators.confidence,
                                            detectionMatches: indicators.matches
                                        };
                                    } else {
                                        // Treat as personal label but track any weak indicators
                                        foundAttribution = {
                                            name: chainData.arkhamLabel.name,
                                            label: chainData.arkhamLabel.name,
                                            type: 'Personal Label',
                                            chain: chain,
                                            source: 'arkham_intelligence',
                                            isExchange: false,
                                            isPersonalLabel: true,
                                            noteText: `Label: ${chainData.arkhamLabel.name}`,
                                            suspectedExchange: indicators.confidence > 0,
                                            detectionConfidence: indicators.confidence,
                                            detectionMatches: indicators.matches,
                                            tags: chainData.populatedTags || []  // Include tags for richer metadata
                                        };
                                    }
                                    break;
                                }
                            }

                            // If we found attribution on any chain, return it
                            if (foundAttribution) {
                                console.log(`✅ Arkham attribution found for ${address}:`, foundAttribution);
                                walletAttributionCache[lowerAddress] = foundAttribution;
                                return foundAttribution;
                            }

                            // Also check if it's a single chain response (not using /all endpoint)
                            if (arkhamData?.arkhamEntity) {
                                // arkhamEntity = actual exchange or service
                                // Be conservative - only mark as DEX if we're very confident
                                const entityName = (arkhamData.arkhamEntity.name || arkhamData.arkhamEntity.service || '').toLowerCase();
                                const indicators = checkExchangeIndicators(entityName);

                                // Only mark as DEX if explicitly identified with high confidence
                                const entityType = (arkhamData.arkhamEntity.type || '').toLowerCase();
                                const isDEX = (indicators.suggestedType === 'DEX/Bridge' && indicators.confidence >= 85) ||
                                             entityType.includes('dex') ||
                                             entityType.includes('router') ||
                                             entityType.includes('amm');

                                attribution = {
                                    name: arkhamData.arkhamEntity.name || arkhamData.arkhamEntity.service,
                                    label: arkhamData.arkhamEntity.type || 'Exchange',
                                    type: isDEX ? 'Bridge/DEX' : (arkhamData.arkhamEntity.type || 'CEX'),
                                    service: arkhamData.arkhamEntity.service,
                                    source: 'arkham_intelligence',
                                    isExchange: true,  // Default to exchange - user can convert if needed
                                    isDEX: isDEX,  // Add DEX flag for reference
                                    isSmartContract: isDEX,  // DEXes are smart contracts
                                    isPersonalLabel: false,
                                    // Add note if this might be a DEX but we're not certain
                                    suspectedDEX: !isDEX && (indicators.suggestedType === 'DEX/Bridge' ||
                                                             entityName.includes('swap') ||
                                                             entityName.includes('router'))
                                };
                                console.log(`✅ Arkham attribution found (single chain) for ${address}:`, attribution);
                                walletAttributionCache[lowerAddress] = attribution;
                                return attribution;
                            } else if (arkhamData?.arkhamLabel) {
                                const labelName = arkhamData.arkhamLabel.name || '';
                                const indicators = checkExchangeIndicators(labelName);

                                if (indicators.isLikely) {
                                    // Likely an exchange/service - mark appropriately
                                    console.log(`    High confidence (${indicators.confidence}%) exchange detected: ${labelName}`);
                                    attribution = {
                                        name: arkhamData.arkhamLabel.name,
                                        label: arkhamData.arkhamLabel.name,
                                        type: indicators.suggestedType === 'DEX/Bridge' ? 'Bridge/DEX' : 'CEX',
                                        source: 'arkham_intelligence',
                                        isExchange: true,
                                        isPersonalLabel: false,
                                        detectionConfidence: indicators.confidence,
                                        detectionMatches: indicators.matches
                                    };
                                } else {
                                    // Treat as personal label but track any weak indicators
                                    attribution = {
                                        name: arkhamData.arkhamLabel.name,
                                        label: arkhamData.arkhamLabel.name,
                                        type: 'Personal Label',
                                        source: 'arkham_intelligence',
                                        isExchange: false,
                                        isPersonalLabel: true,
                                        noteText: `Label: ${arkhamData.arkhamLabel.name}`,
                                        suspectedExchange: indicators.confidence > 0,
                                        detectionConfidence: indicators.confidence,
                                        detectionMatches: indicators.matches
                                    };
                                }
                                console.log(`✅ Arkham personal label found for ${address}:`, attribution);
                                walletAttributionCache[lowerAddress] = attribution;
                                return attribution;
                            }

                            console.log('⚠️ No Arkham entity or label found in response');
                        } else {
                            const errorText = arkhamResponse ? await arkhamResponse.text() : 'No response';
                            console.log(`⚠️ Arkham API returned non-OK status. Response:`, errorText);
                        }
                    } catch (e) {
                        console.error('❌ Arkham API error:', e);
                    }
                } else {
                    console.log('⚠️ No Arkham API key configured');
                }

                // If Arkham didn't find attribution, check chain-specific secondary sources
                if (!attribution) {
                    console.log('Arkham did not find attribution, checking secondary chain-specific sources');

                    // Check if this looks like a Solana address (base58, typically 32-44 chars)
                    const isSolanaAddress = /^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(address);
                    if (isSolanaAddress) {
                        console.log('Detected Solana address format, checking Solana-specific sources');
                        const solanaAttribution = await getSolanaWalletAttribution(address);
                        if (solanaAttribution) {
                            attribution = solanaAttribution;
                            walletAttributionCache[lowerAddress] = attribution;
                            console.log('Found Solana attribution:', attribution);
                            return attribution;
                        }
                    }
                }

                // For EVM chains, check Etherscan as secondary source
                const apiKey = '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8';

                // Use the chainId if provided, otherwise default to Ethereum (1)
                const chainIdToUse = chainId || 1;

                // Use Etherscan v2 API with chainid parameter for all chains
                const balanceUrl = `https://api.etherscan.io/v2/api?chainid=${chainIdToUse}&module=account&action=balance&address=${address}&tag=latest&apikey=${apiKey}`;

                // Also fetch transactions to check for labeled addresses
                const txUrl = `https://api.etherscan.io/v2/api?chainid=${chainIdToUse}&module=account&action=txlist&address=${address}&startblock=0&endblock=99999999&page=1&offset=10&sort=desc&apikey=${apiKey}`;

                // Fetch both in parallel
                const [balanceResponse, txResponse] = await Promise.all([
                    fetch(balanceUrl),
                    fetch(txUrl)
                ]);

                if (txResponse.ok) {
                    const txData = await txResponse.json();

                    if (txData.result && Array.isArray(txData.result) && txData.result.length > 0) {
                        // Check transactions for exchange indicators
                        for (const tx of txData.result) {
                            // Etherscan provides labels in transaction responses
                            // Check both to and from labels
                            const labels = [];

                            // Collect all possible label fields
                            if (tx.to && tx.to.toLowerCase() === lowerAddress) {
                                if (tx.to_label) labels.push(tx.to_label);
                                if (tx.toLabel) labels.push(tx.toLabel);
                            }
                            if (tx.from && tx.from.toLowerCase() === lowerAddress) {
                                if (tx.from_label) labels.push(tx.from_label);
                                if (tx.fromLabel) labels.push(tx.fromLabel);
                            }

                            // Check for exchange indicators in labels
                            for (const label of labels) {
                                if (label && typeof label === 'string' && label.length > 0) {
                                    // Direct exchange match
                                    const exchangeNames = [
                                        'Bybit', 'Binance', 'Coinbase', 'Kraken', 'Huobi',
                                        'OKEx', 'OKX', 'KuCoin', 'Gate.io', 'Bitfinex',
                                        'Bitstamp', 'Gemini', 'FTX', 'Crypto.com', 'Bittrex',
                                        'Poloniex', 'BitMEX', 'Deribit', 'Bitget', 'MEXC'
                                    ];

                                    for (const exchange of exchangeNames) {
                                        if (label.toLowerCase().includes(exchange.toLowerCase())) {
                                            attribution = {
                                                name: exchange,
                                                label: label,
                                                type: 'CEX',
                                                source: 'etherscan_label'
                                            };
                                            break;
                                        }
                                    }

                                    // Check for other terminal wallet indicators
                                    if (!attribution) {
                                        const terminalIndicators = [
                                            'exchange', 'cex', 'hot wallet', 'cold wallet',
                                            'custody', 'vault', 'treasury', 'reserve'
                                        ];

                                        for (const indicator of terminalIndicators) {
                                            if (label.toLowerCase().includes(indicator)) {
                                                attribution = {
                                                    name: label,
                                                    label: label,
                                                    type: 'Terminal',
                                                    source: 'etherscan_label'
                                                };
                                                break;
                                            }
                                        }
                                    }
                                }
                                if (attribution) break;
                            }
                            if (attribution) break;
                        }
                    }
                }

                // Second try: Get token transfers which may have richer label data
                if (!attribution) {
                    const tokenUrl = `https://api.etherscan.io/v2/api?chainid=${chainIdToUse}&module=account&action=tokentx&address=${address}&startblock=0&endblock=99999999&page=1&offset=10&sort=desc&apikey=${apiKey}`;

                    try {
                        const tokenResponse = await fetch(tokenUrl);
                        if (tokenResponse.ok) {
                            const tokenData = await tokenResponse.json();

                            if (tokenData.result && Array.isArray(tokenData.result)) {
                                for (const tx of tokenData.result) {
                                    // Check for labels in token transfers
                                    const checkFields = ['to_label', 'from_label', 'toLabel', 'fromLabel'];

                                    for (const field of checkFields) {
                                        if (tx[field]) {
                                            const label = tx[field];
                                            // Use same exchange detection logic
                                            const exchangeKeywords = [
                                                'bybit', 'binance', 'coinbase', 'kraken', 'exchange',
                                                'okx', 'kucoin', 'gate', 'bitfinex', 'gemini'
                                            ];

                                            for (const keyword of exchangeKeywords) {
                                                if (label.toLowerCase().includes(keyword)) {
                                                    attribution = {
                                                        name: label,
                                                        label: label,
                                                        type: 'CEX',
                                                        source: 'etherscan_token_label'
                                                    };
                                                    break;
                                                }
                                            }
                                            if (attribution) break;
                                        }
                                    }
                                    if (attribution) break;
                                }
                            }
                        }
                    } catch (err) {
                        console.log('Token label check failed:', err);
                    }
                }

                // Third try: Check if it's a smart contract with exchange-like properties
                if (!attribution) {
                    const codeUrl = `https://api.etherscan.io/api?module=proxy&action=eth_getCode&address=${address}&apikey=${apiKey}`;

                    try {
                        const codeResponse = await fetch(codeUrl);
                        if (codeResponse.ok) {
                            const codeData = await codeResponse.json();

                            // If it has contract code and high activity, likely an exchange
                            if (codeData.result && codeData.result !== '0x') {
                                // It's a contract - check contract verification status
                                const contractUrl = `https://api.etherscan.io/api?module=contract&action=getsourcecode&address=${address}&apikey=${apiKey}`;

                                const contractResponse = await fetch(contractUrl);
                                if (contractResponse.ok) {
                                    const contractData = await contractResponse.json();

                                    if (contractData.result && contractData.result[0]) {
                                        const contractName = contractData.result[0].ContractName;

                                        if (contractName && contractName !== '') {
                                            // Check if contract name indicates exchange
                                            const exchangePatterns = [
                                                /bybit/i, /binance/i, /coinbase/i, /kraken/i,
                                                /exchange/i, /vault/i, /custody/i, /treasury/i
                                            ];

                                            for (const pattern of exchangePatterns) {
                                                if (pattern.test(contractName)) {
                                                    attribution = {
                                                        name: contractName,
                                                        label: contractName,
                                                        type: 'CEX/Contract',
                                                        source: 'etherscan_contract'
                                                    };
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } catch (err) {
                        console.log('Contract check failed:', err);
                    }
                }

                // Check for smart contract as conversion wallet if no other attribution found
                if (!attribution && isSmartContract && contractName) {
                    // Smart contracts should be treated as conversion wallets (brown) not terminal wallets (purple)
                    attribution = {
                        name: contractName,
                        label: `Smart Contract: ${contractName}`,
                        type: 'Smart Contract',
                        isSmartContract: true,
                        isConversionWallet: true,  // This indicates it should be brown, not purple
                        source: 'etherscan_verified_contract',
                        contractName: contractName,
                        isDEX: etherscanLabel?.isDEX || false
                    };
                    console.log(`🤖 Smart Contract will be treated as conversion wallet: ${contractName}`);
                }

                // Check for Etherscan label if no other attribution found
                if (!attribution && etherscanLabel) {
                    attribution = {
                        name: etherscanLabel.name,
                        label: etherscanLabel.name,
                        type: etherscanLabel.isDEX ? 'Bridge/DEX' : 'Service',
                        isSmartContract: etherscanLabel.isSmartContract,
                        isDEX: etherscanLabel.isDEX,
                        isConversionWallet: etherscanLabel.isDEX,
                        isExchange: !etherscanLabel.isDEX, // Only mark as exchange if NOT a DEX
                        source: 'etherscan_v2_label',
                        url: etherscanLabel.url
                    };
                    console.log(`🏷️ Using Etherscan v2 label for ${address}:`, attribution);
                }

                // Final fallback: Known exchange addresses
                if (!attribution) {
                    const knownExchanges = {
                        // Bybit addresses
                        '0x07624a16592ab3ca24cccaee13d9ee21eea86fe8': { name: 'Bybit', label: 'Bybit Hot Wallet' },
                        '0xf89d7b9c864f589bbf53a82105107622b35eaa40': { name: 'Bybit', label: 'Bybit Exchange' },
                        // Binance addresses
                        '0x28c6c06298d514db089934071355e5743bf21d60': { name: 'Binance', label: 'Binance Hot Wallet' },
                        '0x21a31ee1afc51d94c2efccaa2092ad1028285549': { name: 'Binance', label: 'Binance 15' },
                        '0xdfd5293d8e347dfe59e90efd55b2956a1343963d': { name: 'Binance', label: 'Binance 16' },
                        // Coinbase
                        '0x71660c4005ba85c37ccec55d0c4493e66fe775d3': { name: 'Coinbase', label: 'Coinbase 1' },
                        '0x503828976d22510aad0201ac7ec88293211d23da': { name: 'Coinbase', label: 'Coinbase 2' },
                        // Kraken
                        '0x267be94bfcdf32565f3c99ec94af879a8829f7e5': { name: 'Kraken', label: 'Kraken Hot Wallet' },
                        '0x53d284357ec70ce289d6d64134dfac8e511c8a3d': { name: 'Kraken', label: 'Kraken Exchange' },
                        // Add more as needed
                    };

                    if (knownExchanges[lowerAddress]) {
                        attribution = {
                            ...knownExchanges[lowerAddress],
                            type: 'CEX',
                            source: 'known_addresses'
                        };
                    }
                }

                // Cache the result (even if null to avoid repeated lookups)
                walletAttributionCache[lowerAddress] = attribution;

                if (attribution) {
                    if (attribution.isPersonalLabel) {
                        console.log(`🏷️ Personal label found: ${attribution.name} (${address})`);
                        console.log(`   Source: ${attribution.source}`);
                        console.log(`   Note: This is NOT a terminal wallet`);
                    } else if (attribution.isSmartContract) {
                        console.log(`🤖 Smart Contract detected: ${attribution.name} (${address})`);
                        console.log(`   Type: Conversion Wallet (Bridge/DEX)`);
                        console.log(`   Source: ${attribution.source}`);
                    } else {
                        console.log(`🟣 Terminal wallet detected: ${attribution.name} (${address})`);
                        console.log(`   Label: ${attribution.label || 'N/A'}`);
                        console.log(`   Source: ${attribution.source}`);
                    }
                }

                return attribution;

            } catch (error) {
                console.error('Error fetching wallet attribution:', error);
                return null;
            }
        }

        // Synchronous check for known exchanges (for non-async contexts)
        function checkExchangeAttribution(address) {
            if (!address) return null;

            const lowerAddress = address.toLowerCase();

            // Check cache first
            if (walletAttributionCache[lowerAddress]) {
                return walletAttributionCache[lowerAddress];
            }

            // Basic known exchanges for synchronous checks
            const knownExchanges = {
                '0x07624a16592ab3ca24cccaee13d9ee21eea86fe8': { name: 'Bybit', type: 'CEX' },
                '0xf89d7b9c864f589bbf53a82105107622b35eaa40': { name: 'Bybit', type: 'CEX' },
                '0x28c6c06298d514db089934071355e5743bf21d60': { name: 'Binance', type: 'CEX' },
                '0x21a31ee1afc51d94c2efccaa2092ad1028285549': { name: 'Binance', type: 'CEX' }
            };

            if (knownExchanges[lowerAddress]) {
                walletAttributionCache[lowerAddress] = knownExchanges[lowerAddress];
                return knownExchanges[lowerAddress];
            }

            return null;
        }

        // Get Bitcoin wallet attribution from Arkham Intelligence or other sources
        async function getBitcoinWalletAttribution(address) {
            if (!address) return null;

            // Check cache first
            if (walletAttributionCache[address]) {
                console.log(`Using cached Bitcoin attribution for ${address}`);
                return walletAttributionCache[address];
            }

            try {
                let attribution = null;

                // Try Arkham Intelligence API first
                // Use the same key as in address search
                const arkhamApiKey = window.apiKeys?.arkham || 'd377a526-c9ea-4cb6-a647-775559583ff6';

                if (arkhamApiKey) {
                    try {
                        // Use Netlify Function proxy for Arkham API
                        const proxyUrl = `/.netlify/functions/arkham3?endpoint=/intelligence/address/${address}`;
                        const arkhamResponse = await fetch(proxyUrl, {
                            headers: {
                                'X-Arkham-API-Key': arkhamApiKey,
                                'Accept': 'application/json'
                            }
                        }).catch(err => {
                            console.log('Bitcoin Arkham attribution API failed:', err);
                            return null;
                        });

                        if (arkhamResponse && arkhamResponse.ok) {
                            const arkhamData = await arkhamResponse.json();
                            if (arkhamData && arkhamData.arkhamEntity) {
                                attribution = {
                                    name: arkhamData.arkhamEntity.name,
                                    label: arkhamData.arkhamEntity.type || 'Exchange',
                                    type: arkhamData.arkhamEntity.category || 'CEX',
                                    source: 'arkham_intelligence',
                                    metadata: arkhamData.arkhamEntity
                                };
                                console.log('Arkham Intelligence attribution found:', attribution);
                            }
                        }
                    } catch (err) {
                        console.log('Arkham API lookup failed:', err);
                    }
                }

                // Fallback to WalletExplorer API
                if (!attribution) {
                    try {
                        const walletExplorerUrl = `https://www.walletexplorer.com/api/1/address-lookup?address=${address}`;
                        const walletResponse = await fetch(walletExplorerUrl);

                        if (walletResponse.ok) {
                            const walletData = await walletResponse.json();
                            if (walletData.found && walletData.wallet && walletData.wallet.name) {
                                attribution = {
                                    name: walletData.wallet.name,
                                    label: walletData.wallet.category || 'Exchange/Service',
                                    type: walletData.wallet.category || 'Service',
                                    source: 'walletexplorer',
                                    isExchange: walletData.wallet.category === 'Exchange' ||
                                               walletData.wallet.name.toLowerCase().includes('exchange')
                                };
                                console.log(`WalletExplorer attribution found for ${address}:`, attribution);
                                walletAttributionCache[address] = attribution;
                                return attribution;
                            }
                        }
                    } catch (e) {
                        console.log('WalletExplorer API error:', e);
                    }
                }

                // Fallback to Blockchain.info transaction analysis
                if (!attribution) {
                    try {
                        // Check if address has known tags from blockchain.info
                        const blockchainInfoUrl = `https://blockchain.info/rawaddr/${address}?limit=1`;
                        const blockchainResponse = await fetch(blockchainInfoUrl);

                        if (blockchainResponse.ok) {
                            const blockchainData = await blockchainResponse.json();

                            // Check for high transaction count (indicator of exchange)
                            if (blockchainData.n_tx > 10000) {
                                attribution = {
                                    name: 'High-Activity Wallet',
                                    label: 'Possible Exchange',
                                    type: 'Possible CEX',
                                    source: 'transaction_analysis',
                                    transactionCount: blockchainData.n_tx
                                };
                            }
                        }
                    } catch (err) {
                        console.log('Blockchain.info check failed:', err);
                    }
                }

                // Fallback to known Bitcoin exchange addresses
                if (!attribution) {
                    const knownBitcoinExchanges = {
                        // Binance
                        '34xp4vRoCGJym3xR7yCVPFHoCNxv4Twseo': { name: 'Binance', label: 'Binance Cold Wallet' },
                        '3LYJfcfHPXYJreMsASk2jkn69LWEYKzexb': { name: 'Binance', label: 'Binance Hot Wallet' },
                        // Coinbase
                        '3PX76NNVuJUetXJRUrzLCqVssHGVPhBz5A': { name: 'Coinbase', label: 'Coinbase Cold Storage' },
                        // Bitfinex
                        '3D2oetdNuZUqQHPJmcMDDHYoqkyNVsFk9r': { name: 'Bitfinex', label: 'Bitfinex Cold Wallet' },
                        '1Kr6QSydW9bFQG1mXiPNNu6WpJGmUa9i1g': { name: 'Bitfinex', label: 'Bitfinex Old Cold Wallet' },
                        // Kraken
                        '3KBjvJZMRrjAqN5fCkPJBUXuLwR8Lq2Rpr': { name: 'Kraken', label: 'Kraken Cold Wallet' },
                        // Huobi
                        '3Kzh7ZV5NszLMLJrW5dgvgWb7PbYtLxm5W': { name: 'Huobi', label: 'Huobi Cold Wallet' },
                        // Bitstamp
                        '3CgUiDF7M76BkXaKvixMSrKhq1cVqAFetH': { name: 'Bitstamp', label: 'Bitstamp Cold Wallet' },
                        // Add more as needed
                    };

                    if (knownBitcoinExchanges[address]) {
                        attribution = {
                            ...knownBitcoinExchanges[address],
                            type: 'CEX',
                            source: 'known_btc_addresses'
                        };
                    }
                }

                // Cache the result
                walletAttributionCache[address] = attribution;

                if (attribution) {
                    console.log(`🟣 Bitcoin terminal wallet detected: ${attribution.name}`);
                    console.log(`   Address: ${address}`);
                    console.log(`   Source: ${attribution.source}`);
                }

                return attribution;

            } catch (error) {
                console.error('Error fetching Bitcoin wallet attribution:', error);
                return null;
            }
        }

        // Override attribution function
        function overrideAttribution() {
            if (!window.hopWizardData) {
                alert('No transaction data available.');
                return;
            }

            const currentAttribution = window.hopWizardData.detectedAttribution;
            const walletAddress = window.hopWizardData.txData?.to || '';

            // Create override modal
            const modal = document.createElement('div');
            modal.id = 'attributionOverrideModal';
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                background: rgba(0,0,0,0.5);
                display: flex;
                align-items: center;
                justify-content: center;
                z-index: 10000;
            `;

            modal.innerHTML = `
                <div style="background: white; padding: 30px; border-radius: 12px; max-width: 600px; width: 90%; max-height: 80vh; overflow-y: auto;">
                    <h3 style="margin: 0 0 20px 0; color: #dc3545;">⚠️ Attribution Override Warning</h3>

                    <div style="background: #fff3cd; border: 2px solid #ffc107; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                        <strong>🚨 CRITICAL WARNING:</strong><br>
                        • Only override attribution with data from trusted sources (TRM, Chainalysis, CipherTrace, etc.)<br>
                        • Incorrect attribution can invalidate your entire trace<br>
                        • Tracing through an exchange account without marking it as terminal will corrupt the investigation<br>
                        • This action will be documented in the transaction notes
                    </div>

                    <div style="margin-bottom: 20px;">
                        <strong>Current Attribution:</strong><br>
                        <div style="padding: 10px; background: #f8f9fa; border-radius: 4px; margin-top: 5px;">
                            ${currentAttribution ? `
                                Name: ${currentAttribution.name || 'Unknown'}<br>
                                Source: ${currentAttribution.source || 'Unknown'}<br>
                                Type: ${currentAttribution.isExchange ? 'Exchange/VASP' : 'Other'}
                            ` : 'No attribution detected'}
                        </div>
                    </div>

                    <div style="margin-bottom: 20px;">
                        <strong>Wallet Address:</strong><br>
                        <div style="padding: 10px; background: #f8f9fa; border-radius: 4px; margin-top: 5px; font-family: monospace; font-size: 12px; word-break: break-all;">
                            ${walletAddress}
                        </div>
                    </div>

                    <div style="margin-bottom: 20px;">
                        <label style="font-weight: bold;">Override Type:</label>
                        <select id="overrideType" onchange="toggleOverrideFields()" style="width: 100%; padding: 10px; margin-top: 5px; border: 1px solid #dee2e6; border-radius: 4px;">
                            <option value="">Select override action...</option>
                            <option value="terminal">Mark as Terminal Exchange/VASP</option>
                            <option value="not-terminal">Mark as NOT Terminal (Bridge/DEX/Personal)</option>
                            <option value="rename">Change Attribution Name Only</option>
                        </select>
                    </div>

                    <div id="overrideFields" style="display: none;">
                        <div style="margin-bottom: 20px;">
                            <label style="font-weight: bold;">New Attribution Name:</label>
                            <input type="text" id="newAttributionName" placeholder="e.g., Binance, Coinbase, Uniswap Router"
                                   style="width: 100%; padding: 10px; margin-top: 5px; border: 1px solid #dee2e6; border-radius: 4px;">
                        </div>

                        <div style="margin-bottom: 20px;">
                            <label style="font-weight: bold;">Attribution Source:</label>
                            <select id="attributionSource" style="width: 100%; padding: 10px; margin-top: 5px; border: 1px solid #dee2e6; border-radius: 4px;">
                                <option value="">Select source...</option>
                                <option value="TRM Labs">TRM Labs</option>
                                <option value="Chainalysis">Chainalysis</option>
                                <option value="CipherTrace">CipherTrace</option>
                                <option value="Elliptic">Elliptic</option>
                                <option value="Crystal Blockchain">Crystal Blockchain</option>
                                <option value="Manual Research">Manual Research</option>
                                <option value="Exchange Documentation">Exchange Documentation</option>
                                <option value="Other">Other (specify in notes)</option>
                            </select>
                        </div>

                        <div style="margin-bottom: 20px;">
                            <label style="font-weight: bold;">Additional Notes (Optional):</label>
                            <textarea id="overrideNotes" placeholder="Explain the reason for override..."
                                      style="width: 100%; padding: 10px; margin-top: 5px; border: 1px solid #dee2e6; border-radius: 4px; min-height: 80px;"></textarea>
                        </div>
                    </div>

                    <div style="display: flex; gap: 10px; justify-content: flex-end;">
                        <button class="btn btn-secondary" onclick="cancelAttributionOverride()">
                            Cancel
                        </button>
                        <button class="btn btn-danger" id="confirmOverrideBtn" onclick="applyAttributionOverride()" disabled>
                            Apply Override
                        </button>
                    </div>
                </div>
            `;

            document.body.appendChild(modal);
        }

        // Toggle override fields visibility
        function toggleOverrideFields() {
            const overrideType = document.getElementById('overrideType').value;
            const fieldsDiv = document.getElementById('overrideFields');
            const confirmBtn = document.getElementById('confirmOverrideBtn');

            if (overrideType) {
                fieldsDiv.style.display = 'block';
                confirmBtn.disabled = false;
            } else {
                fieldsDiv.style.display = 'none';
                confirmBtn.disabled = true;
            }
        }

        // Cancel attribution override
        function cancelAttributionOverride() {
            const modal = document.getElementById('attributionOverrideModal');
            if (modal) {
                modal.remove();
            }
        }

        // Apply attribution override
        function applyAttributionOverride() {
            const overrideType = document.getElementById('overrideType').value;
            const newName = document.getElementById('newAttributionName').value.trim();
            const source = document.getElementById('attributionSource').value;
            const notes = document.getElementById('overrideNotes').value.trim();

            if (!overrideType) {
                alert('Please select an override type');
                return;
            }

            if (!newName && overrideType !== 'not-terminal') {
                alert('Please enter the new attribution name');
                return;
            }

            if (!source) {
                alert('Please select the attribution source');
                return;
            }

            // Create override record
            const overrideRecord = {
                timestamp: new Date().toISOString(),
                type: overrideType,
                newName: newName,
                source: source,
                notes: notes,
                originalAttribution: window.hopWizardData.detectedAttribution
            };

            // Apply the override
            if (overrideType === 'terminal') {
                // Mark as terminal exchange
                window.hopWizardData.detectedAttribution = {
                    name: newName,
                    source: source,
                    isExchange: true,
                    isTerminal: true,
                    overridden: true,
                    overrideRecord: overrideRecord
                };
                window.hopWizardData.isTerminalWallet = true;
                window.hopWizardData.terminalWalletType = 'purple';
            } else if (overrideType === 'not-terminal') {
                // Mark as NOT terminal (bridge/DEX/personal)
                window.hopWizardData.detectedAttribution = {
                    name: newName || 'Unknown',
                    source: source,
                    isExchange: false,
                    isTerminal: false,
                    isPersonalLabel: true,
                    overridden: true,
                    overrideRecord: overrideRecord
                };
                window.hopWizardData.isTerminalWallet = false;
                delete window.hopWizardData.terminalWalletType;
            } else if (overrideType === 'rename') {
                // Just change the name, keep terminal status
                if (window.hopWizardData.detectedAttribution) {
                    window.hopWizardData.detectedAttribution.name = newName;
                    window.hopWizardData.detectedAttribution.source = source;
                    window.hopWizardData.detectedAttribution.overridden = true;
                    window.hopWizardData.detectedAttribution.overrideRecord = overrideRecord;
                } else {
                    window.hopWizardData.detectedAttribution = {
                        name: newName,
                        source: source,
                        overridden: true,
                        overrideRecord: overrideRecord
                    };
                }
            }

            // Add override note to transaction notes
            const overrideNote = `\n\n[ATTRIBUTION OVERRIDE - ${new Date().toLocaleString()}]\n` +
                `Type: ${overrideType}\n` +
                `New Name: ${newName || 'N/A'}\n` +
                `Source: ${source}\n` +
                (notes ? `Notes: ${notes}\n` : '') +
                `Original: ${overrideRecord.originalAttribution?.name || 'None detected'} (${overrideRecord.originalAttribution?.source || 'N/A'})`;

            if (window.hopWizardData.notes) {
                window.hopWizardData.notes += overrideNote;
            } else {
                window.hopWizardData.notes = overrideNote;
            }

            // Update the UI
            const resultDiv = document.getElementById('wizardTxResult');

            // Remove existing terminal confirmation div
            const existingConfirmDiv = resultDiv.querySelector('div[style*="#fff3cd"]');
            if (existingConfirmDiv) {
                existingConfirmDiv.remove();
            }

            // Add override confirmation message
            const overrideConfirmation = document.createElement('div');
            overrideConfirmation.style.cssText = 'background: #d4edda; border: 2px solid #28a745; padding: 15px; margin-top: 10px; border-radius: 4px;';
            overrideConfirmation.innerHTML = `
                <strong>✅ Attribution Override Applied</strong><br>
                ${overrideType === 'terminal' ? `Terminal Exchange: ${newName}` :
                  overrideType === 'not-terminal' ? `NOT Terminal: ${newName || 'Unmarked'}` :
                  `Renamed to: ${newName}`}<br>
                Source: ${source}<br>
                <small>This override has been documented in the transaction notes</small>
            `;
            resultDiv.appendChild(overrideConfirmation);

            // Update the next button
            const nextBtn = document.getElementById('wizardNextBtn');
            if (nextBtn) {
                nextBtn.disabled = false;
                if (overrideType === 'terminal') {
                    nextBtn.textContent = 'Create Terminal Entry';
                    nextBtn.style.background = '#9c27b0';
                } else {
                    nextBtn.textContent = 'Log Entry';
                    nextBtn.style.background = '';
                }
            }

            // Close the modal
            cancelAttributionOverride();
        }

        // Terminal wallet confirmation functions
        function confirmTerminalWallet() {
            if (!window.hopWizardData || !window.hopWizardData.detectedAttribution) {
                alert('No terminal wallet attribution detected.');
                return;
            }

            const attribution = window.hopWizardData.detectedAttribution;

            // Mark wizard data to create terminal entry (no confirmation dialog - it's required)
            window.hopWizardData.isTerminalWallet = true;
            window.hopWizardData.terminalWalletType = 'purple';

            // Update the UI to show terminal wallet will be created
            const resultDiv = document.getElementById('wizardTxResult');

            // Remove the action buttons div since decision was made
            const actionDiv = resultDiv.querySelector('div[style*="#fff3cd"]');
            if (actionDiv) {
                actionDiv.remove();
            }

            // Add confirmation message
            const terminalNote = document.createElement('div');
            terminalNote.style.cssText = 'background: #e1bee7; border: 2px solid #9c27b0; padding: 10px; margin-top: 10px; border-radius: 4px;';
            terminalNote.innerHTML = `
                <strong>✅ Terminal Wallet Entry Confirmed</strong><br>
                Exchange: ${attribution.name || attribution.label}<br>
                This will be marked as a PURPLE terminal wallet and added to the terminal index.
            `;

            const existingNote = resultDiv.querySelector('div[style*="#e1bee7"]');
            if (!existingNote) {
                resultDiv.appendChild(terminalNote);
            }

            // Re-enable and update the Next/Log Entry button
            const nextBtn = document.getElementById('wizardNextBtn');
            if (nextBtn) {
                nextBtn.disabled = false;
                nextBtn.textContent = 'Create Terminal Entry';
                nextBtn.style.background = '#9c27b0'; // Purple button for terminal
            }

            showNotification('✅ Terminal wallet confirmed. Click "Create Terminal Entry" to proceed.', 'success');
        }

        // Convert personal label to terminal wallet
        window.convertToTerminalWallet = function() {
            if (!window.hopWizardData || !window.hopWizardData.detectedAttribution) {
                alert('No label detected to convert.');
                return;
            }

            const attribution = window.hopWizardData.detectedAttribution;
            const walletName = attribution.name || attribution.label || 'Unknown';
            const walletAddress = window.hopWizardData.txData?.to || '';

            // Show confirmation dialog
            const confirmMessage = `Convert "${walletName}" to Terminal Wallet?\n\n` +
                `This will mark the wallet as a terminal destination (exchange/service).\n` +
                `Funds arriving here will be considered as having reached their final destination.\n\n` +
                `Wallet: ${walletAddress.substring(0, 10)}...${walletAddress.substring(walletAddress.length - 8)}\n\n` +
                `Do you want to proceed?`;

            if (!confirm(confirmMessage)) {
                return;
            }

            // Override the personal label flag and mark as terminal
            attribution.isPersonalLabel = false;
            attribution.isExchange = true;
            attribution.type = attribution.type || 'CEX';

            // Mark wizard data to create terminal entry
            window.hopWizardData.isTerminalWallet = true;
            window.hopWizardData.terminalWalletType = 'purple';

            // Show brief notification
            showNotification(`🟣 Converting "${walletName}" to terminal wallet...`, 'info', 2000);

            // Automatically create the terminal entry after a brief delay
            setTimeout(() => {
                console.log('Auto-creating terminal entry after conversion');
                // Check if we're on step 3 and can proceed
                const currentStep = window.hopWizardData?.step || 3;
                if (currentStep === 3) {
                    // Call hopWizardNext to create the entry
                    if (typeof hopWizardNext === 'function') {
                        hopWizardNext();
                    } else {
                        console.error('hopWizardNext not found, trying direct entry creation');
                        // Fallback: simulate button click
                        const nextBtn = document.getElementById('wizardNextBtn');
                        if (nextBtn && !nextBtn.disabled) {
                            nextBtn.click();
                        }
                    }
                } else {
                    // Update UI to show conversion complete
                    const resultDiv = document.getElementById('wizardTxResult');
                    const alertDiv = resultDiv?.querySelector('div[style*="#e3f2fd"]');
                    if (alertDiv) {
                        alertDiv.style.cssText = 'background: #e1bee7; border: 2px solid #9c27b0; border-radius: 8px; padding: 15px; margin-top: 15px;';
                        alertDiv.innerHTML = `
                            <h4 style="margin: 0 0 10px 0; color: #6a1b9a;">🟣 Terminal Wallet Ready</h4>
                            <div style="font-size: 14px;">
                                <strong>Exchange/Service:</strong> ${walletName}<br>
                                <strong>Type:</strong> Terminal Wallet (CEX)<br>
                                <div style="margin-top: 10px; padding: 10px; background: white; border-radius: 4px;">
                                    <strong>✅ Ready to create terminal entry</strong><br>
                                    Click "Create Terminal Entry" below
                                </div>
                            </div>
                        `;
                    }
                    // Update button
                    const nextBtn = document.getElementById('wizardNextBtn');
                    if (nextBtn) {
                        nextBtn.disabled = false;
                        nextBtn.textContent = 'Create Terminal Entry';
                        nextBtn.style.background = '#9c27b0';
                    }
                }
            }, 500);
        }

        // Keep as personal label (user chose to ignore exchange indicators)
        window.keepAsPersonalLabel = function() {
            if (!window.hopWizardData || !window.hopWizardData.detectedAttribution) {
                return;
            }

            const attribution = window.hopWizardData.detectedAttribution;

            // Ensure it stays as personal label
            attribution.isPersonalLabel = true;
            attribution.isExchange = false;
            attribution.userConfirmedPersonal = true; // Track that user explicitly chose this

            // Update the UI to show confirmation
            const resultDiv = document.getElementById('wizardTxResult');
            const alertDiv = resultDiv.querySelector('div[style*="#fff3cd"], div[style*="#e3f2fd"]');

            if (alertDiv) {
                alertDiv.style.cssText = 'background: #d4edda; border: 2px solid #27ae60; border-radius: 8px; padding: 15px; margin-top: 15px;';
                alertDiv.innerHTML = `
                    <h4 style="margin: 0 0 10px 0; color: #1e7e34;">✅ Confirmed as Personal Label</h4>
                    <div style="font-size: 14px;">
                        <strong>Label:</strong> ${attribution.name || attribution.label}<br>
                        <strong>Status:</strong> Will be treated as a personal label (not a terminal wallet)<br>
                        <div style="margin-top: 10px; padding: 10px; background: white; border-radius: 4px;">
                            <strong>Next steps:</strong><br>
                            • Continue tracing funds through this wallet<br>
                            • The label will be added to your entry notes<br>
                            • No thread exhaustion will occur
                        </div>
                    </div>
                `;
            }

            // Continue button remains enabled for normal tracing
            const nextBtn = document.getElementById('wizardNextBtn');
            if (nextBtn) {
                nextBtn.disabled = false;
                nextBtn.textContent = 'Continue to Next Step';
                nextBtn.style.background = '';
            }

            showNotification('Label confirmed as personal (not an exchange). Continue tracing normally.', 'success');
        }

        // Convert personal label to conversion wallet (brown)
        window.convertToConversionWallet = function() {
            console.log('convertToConversionWallet called');
            console.log('hopWizardData:', window.hopWizardData);
            console.log('detectedAttribution:', window.hopWizardData?.detectedAttribution);

            if (!window.hopWizardData || !window.hopWizardData.detectedAttribution) {
                alert('No label detected to convert.');
                return;
            }

            const attribution = window.hopWizardData.detectedAttribution;
            const walletName = attribution.name || attribution.label || 'Unknown';
            const walletAddress = window.hopWizardData.txData?.to || '';

            console.log('Converting wallet to Bridge/DEX:', {
                walletName,
                walletAddress,
                attribution,
                currentHopNumber: window.hopWizardData?.hopNumber
            });

            // Show confirmation dialog
            const confirmMessage = `Convert "${walletName}" to Conversion Wallet (Bridge/DEX)?\n\n` +
                `This will mark the wallet as a bridge or DEX for asset conversion.\n` +
                `You'll need to specify the output currency and amount in the next step.\n\n` +
                `Wallet: ${walletAddress.substring(0, 10)}...${walletAddress.substring(walletAddress.length - 8)}\n\n` +
                `Do you want to proceed?`;

            if (!confirm(confirmMessage)) {
                console.log('User cancelled conversion');
                return;
            }

            // Store the data we need before closing wizard
            const hopNumber = window.hopWizardData.hopNumber;
            const storedWalletAddress = walletAddress;
            const storedWalletName = walletName;

            console.log('Stored data before wizard close:', {
                hopNumber,
                storedWalletAddress,
                storedWalletName
            });

            // Mark as conversion/bridge
            attribution.isPersonalLabel = false;
            attribution.isConversion = true;
            attribution.type = 'Bridge/DEX';

            // Mark wizard data for conversion wallet
            window.hopWizardData.isConversionWallet = true;
            window.hopWizardData.terminalWalletType = 'brown';
            window.hopWizardData.isSwap = true; // Mark as swap to trigger swap wizard

            // Show brief notification
            showNotification(`🟤 Converting "${walletName}" to conversion wallet...`, 'info', 2000);

            // Close current wizard and open swap wizard
            setTimeout(() => {
                console.log('Auto-opening swap wizard after conversion wallet designation');

                // Close the current wizard
                closeHopWizard();

                // Open swap wizard with pre-filled data
                setTimeout(() => {
                    // Use the stored hopNumber from before we closed the wizard
                    if (hopNumber) {
                        console.log('Opening swap wizard for hop:', hopNumber);
                        // Open swap wizard using the correct function
                        showSwapWizard(hopNumber);

                        // Pre-fill the swap service with the detected wallet
                        setTimeout(() => {
                            const swapServiceInput = document.getElementById('swapService');
                            if (swapServiceInput) {
                                swapServiceInput.value = storedWalletAddress;
                                console.log('Pre-filled swap service with:', storedWalletAddress);
                            }
                            const providerInput = document.getElementById('providerName');
                            if (providerInput) {
                                providerInput.value = storedWalletName;
                                console.log('Pre-filled provider name with:', storedWalletName);
                            }
                        }, 100);
                    } else {
                        console.error('No hop number found');
                    }
                }, 500);
            }, 500);
        }

        // REMOVED: continueTraceFromTerminal function
        // Exchange wallets MUST be marked as terminal - no option to continue regular trace

        // Shared EVM chain response parser
        const parseEVMResponse = (data, receiptData, blockTimestamp, chainConfig) => {
            // This is the same parser used for all EVM chains
            console.log('parseEVMResponse called with:',
                'hasData:', !!data,
                'hasReceiptData:', !!receiptData,
                'receiptKeys:', receiptData ? Object.keys(receiptData) : [],
                'hasResult:', receiptData && receiptData.result ? true : false,
                'hasLogs:', receiptData && receiptData.result && receiptData.result.logs ? true : false,
                'logsLength:', receiptData && receiptData.result && receiptData.result.logs ? receiptData.result.logs.length : 0
            );

            // Check if we have a token transfer in the receipt logs
            if (receiptData && receiptData.result && receiptData.result.logs && receiptData.result.logs.length > 0) {
                console.log('Checking receipt logs for token transfers:', receiptData.result.logs);
                
                // Look for Transfer events (topic0 = 0xddf252ad...)
                const transferTopic = '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef';
                const transferLogs = receiptData.result.logs.filter(log => 
                    log.topics && log.topics[0] === transferTopic && log.topics.length >= 3
                );
                
                console.log(`Found ${transferLogs.length} token transfers in this transaction`);
                
                if (transferLogs.length > 0) {
                    // Always show selection modal when token transfers exist
                    console.log('Token transfers detected - user selection required');
                    
                    // Parse all transfers for selection
                    const transfers = transferLogs.map(log => {
                            const from = '0x' + log.topics[1].slice(26);
                            const to = '0x' + log.topics[2].slice(26);
                            const value = log.data;
                            const contractAddress = log.address;
                            
                            // Get chain ID for token lookup
                            const chainId = chainConfig && chainConfig.chainId ? chainConfig.chainId : 1;
                            const tokenAddr = contractAddress.toLowerCase();

                            // Convert amount
                            let amount = 0;
                            try {
                                const amountBN = parseInt(value, 16);

                                // Determine decimals based on token
                                let decimals = 18; // default

                                // Check if it's a known stablecoin (USDT/USDC typically use 6 decimals)
                                const stablecoins6Decimals = [
                                    // USDT on most chains (except BSC which uses 18)
                                    '0xdac17f958d2ee523a2206206994597c13d831ec7', // USDT Ethereum
                                    '0xc2132d05d31c914a87c6611c10748aeb04b58e8f', // USDT Polygon
                                    '0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9', // USDT Arbitrum
                                    '0x94b008aa00579c1307b0ef2c499ad98a8ce58e58', // USDT Optimism
                                    '0x9702230a8ea53601f5cd2dc00fdbc13d4df4a8c7', // USDT Avalanche
                                    '0xfde4c96c8593536e31f229ea8f37b2ada2699bb2', // USDT Base
                                    // USDC on all chains uses 6 decimals
                                    '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', // USDC Ethereum
                                    '0x2791bca1f2de4661ed88a30c99a7a9449aa84174', // USDC Polygon (legacy)
                                    '0x3c499c542cef5e3811e1192ce70d8cc03d5c3359', // USDC Polygon (native)
                                    '0xaf88d065e77c8cc2239327c5edb3a432268e5831', // USDC Arbitrum
                                    '0x7f5c764cbc14f9669b88837ca1490cca17c31607', // USDC.e Optimism
                                    '0x0b2c639c533813f4aa9d7837caf62653d097ff85', // USDC Optimism
                                    '0xb97ef9ef8734c71904d8002f8b6bc66dd9c48a6e', // USDC Avalanche
                                    '0x833589fcd6edb6e08f4c7c32d4f71b54bda02913', // USDC Base
                                    '0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d', // USDC BSC (actually uses 18!)
                                ];

                                // Special case: BSC USDT uses 18 decimals
                                if (tokenAddr === '0x55d398326f99059ff775485246999027b3197955' && chainId === 56) {
                                    decimals = 18;
                                } else if (stablecoins6Decimals.includes(tokenAddr)) {
                                    decimals = 6;
                                }
                                // WBTC uses 8 decimals
                                else if (tokenAddr === '0x2260fac5e5542a773aa44fbcfedf7c193bc2c599' ||
                                         tokenAddr === '0x1bfd67037b42cf73acf2047067bd4f2c47d9bfd6' ||
                                         tokenAddr === '0x2f2a2543b76a4166549f7aab2e75bef0aefc5b0f') {
                                    decimals = 8;
                                }

                                amount = amountBN / Math.pow(10, decimals);
                            } catch (e) {
                                console.error('Error parsing amount:', e);
                            }
                            
                            // Get token symbol - check chain-specific addresses
                            // (chainId already declared above)
                            const tokenAddress = contractAddress.toLowerCase();

                            // Multi-chain token mappings
                            const multiChainTokens = {
                                // USDT addresses
                                1: { // Ethereum
                                    '0xdac17f958d2ee523a2206206994597c13d831ec7': { symbol: 'USDT', decimals: 6 }
                                },
                                56: { // BSC
                                    '0x55d398326f99059ff775485246999027b3197955': { symbol: 'USDT', decimals: 18 }
                                },
                                137: { // Polygon
                                    '0xc2132d05d31c914a87c6611c10748aeb04b58e8f': { symbol: 'USDT', decimals: 6 }
                                },
                                42161: { // Arbitrum
                                    '0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9': { symbol: 'USDT', decimals: 6 }
                                },
                                10: { // Optimism
                                    '0x94b008aa00579c1307b0ef2c499ad98a8ce58e58': { symbol: 'USDT', decimals: 6 }
                                },
                                43114: { // Avalanche
                                    '0x9702230a8ea53601f5cd2dc00fdbc13d4df4a8c7': { symbol: 'USDT', decimals: 6 }
                                },
                                8453: { // Base
                                    '0xfde4c96c8593536e31f229ea8f37b2ada2699bb2': { symbol: 'USDT', decimals: 6 }
                                },

                                // Add USDC addresses for each chain
                                // (continuing pattern for other tokens...)
                            };

                            // Common token addresses across multiple chains (lowercase)
                            const commonTokenPatterns = {
                                // USDC patterns
                                '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48': 'USDC', // Ethereum
                                '0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d': 'USDC', // BSC
                                '0x2791bca1f2de4661ed88a30c99a7a9449aa84174': 'USDC', // Polygon (legacy)
                                '0x3c499c542cef5e3811e1192ce70d8cc03d5c3359': 'USDC', // Polygon (native)
                                '0xaf88d065e77c8cc2239327c5edb3a432268e5831': 'USDC', // Arbitrum
                                '0x7f5c764cbc14f9669b88837ca1490cca17c31607': 'USDC.e', // Optimism (bridged)
                                '0x0b2c639c533813f4aa9d7837caf62653d097ff85': 'USDC', // Optimism (native)
                                '0xb97ef9ef8734c71904d8002f8b6bc66dd9c48a6e': 'USDC', // Avalanche
                                '0x833589fcd6edb6e08f4c7c32d4f71b54bda02913': 'USDC', // Base

                                // DAI patterns
                                '0x6b175474e89094c44da98b954eedeac495271d0f': 'DAI', // Ethereum
                                '0x1af3f329e8be154074d8769d1ffa4ee058b1dbc3': 'DAI', // BSC
                                '0x8f3cf7ad23cd3cadbd9735aff958023239c6a063': 'DAI', // Polygon
                                '0xda10009cbd5d07dd0cecc66161fc93d7c9000da1': 'DAI', // Arbitrum & Optimism
                                '0xd586e7f844cea2f87f50152665bcbc2c279d8d70': 'DAI', // Avalanche
                                '0x50c5725949a6f0c72e6c4a641f24049a917db0cb': 'DAI', // Base

                                // WBTC patterns
                                '0x2260fac5e5542a773aa44fbcfedf7c193bc2c599': 'WBTC', // Ethereum
                                '0x1bfd67037b42cf73acf2047067bd4f2c47d9bfd6': 'WBTC', // Polygon
                                '0x2f2a2543b76a4166549f7aab2e75bef0aefc5b0f': 'WBTC', // Arbitrum
                                '0x68f180fcce6836688e9084f035309e29bf0a2095': 'WBTC', // Optimism
                                '0x50b7545627a5162f82a992c33b87adc75187b218': 'WBTC', // Avalanche

                                // WETH patterns
                                '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2': 'WETH', // Ethereum
                                '0x4200000000000000000000000000000000000006': 'WETH', // Base & Optimism
                                '0x82af49447d8a07e3bd95bd0d56f35241523fbab1': 'WETH', // Arbitrum
                                '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619': 'WETH', // Polygon
                                '0x49d5c2bdffac6ce2bfdb6640f4f80f226bc10bab': 'WETH', // Avalanche
                            };

                            // First check chain-specific mappings
                            let tokenInfo = null;
                            if (multiChainTokens[chainId] && multiChainTokens[chainId][tokenAddress]) {
                                tokenInfo = multiChainTokens[chainId][tokenAddress];
                            }

                            // Then check common patterns
                            const currency = tokenInfo ? tokenInfo.symbol :
                                           (commonTokenPatterns[tokenAddress] || 'Token');
                            
                            return {
                                from: from,
                                to: to,
                                amount: amount,
                                currency: currency,
                                contractAddress: contractAddress,
                                rawData: log
                            };
                        });
                    
                    // Use block timestamp if available, otherwise current time
                    let timestamp = blockTimestamp || Date.now();
                    const hasRealTimestamp = !!blockTimestamp;
                    if (!blockTimestamp) {
                        console.warn('No block timestamp available for token transfers');
                    }
                    
                    // Only add the ETH transaction if it has value > 0
                    const tx = data.result;
                    if (tx && parseInt(tx.value, 16) > 0) {
                        transfers.unshift({
                            from: tx.from,
                            to: tx.to,
                            amount: parseInt(tx.value, 16) / 1e18,
                            currency: chainConfig && chainConfig.nativeCurrency ? chainConfig.nativeCurrency : 'ETH',
                            contractAddress: `Native ${chainConfig && chainConfig.nativeCurrency ? chainConfig.nativeCurrency : 'ETH'} Transfer`,
                            rawData: tx
                        });
                    }
                    
                    // Always return multiple transfers to show selection modal
                    return {
                        multipleTransfers: true,
                        transfers: transfers,
                        transaction: data.result,
                        time: timestamp,
                        hasRealTimestamp: hasRealTimestamp
                    };
                }
            }
            // Otherwise use regular ETH transaction
            else if (data.result) {
                const tx = data.result;
                
                // For bulk upload, don't skip 0 ETH transactions - they might have token transfers
                // that we couldn't detect due to API limitations
                const ethAmount = parseInt(tx.value, 16) / 1e18;
                if (ethAmount === 0) {
                    console.log('Warning: 0 ETH transaction - may have token transfers not detected by API');
                    // Still return transaction data for user to review
                }
                
                // Use block timestamp if available, otherwise current time
                let timestamp = blockTimestamp || Date.now();
                const hasRealTimestamp = !!blockTimestamp;
                if (!blockTimestamp) {
                    console.warn('No block timestamp available for ETH transaction');
                }
                
                return {
                    time: timestamp,
                    amount: ethAmount,
                    currency: chainConfig && chainConfig.nativeCurrency ? chainConfig.nativeCurrency : 'ETH',
                    from: tx.from,
                    to: tx.to,
                    fee: tx.gasPrice && tx.gas ? 
                        parseInt(tx.gasPrice, 16) * parseInt(tx.gas, 16) / 1e18 : 0,
                    hasRealTimestamp: hasRealTimestamp
                };
            }
            return null;
        };
        
        // Global API keys storage
        // Make it globally accessible for other functions
        window.apiKeys = {
            arkham: 'd377a526-c9ea-4cb6-a647-775559583ff6'  // Default, will be overridden from env vars or localStorage
        };

        // Blockchain API configurations
        // Make it globally accessible for other functions
        const blockchainAPIs = window.blockchainAPIs = {
            bitcoin: {
                name: 'Bitcoin',
                hashPattern: /^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$|^bc1[a-z0-9]{39,59}$/,
                addressPattern: /^([13][a-km-zA-HJ-NP-Z1-9]{25,34}|bc1[a-z0-9]{39,59})$/,
                addressPrefixes: ['1', '3', 'bc1'],
                txPattern: /^[a-f0-9]{64}$/i,
                apiUrl: 'https://blockchain.info/rawtx/',
                addressApiUrl: 'https://blockchain.info/rawaddr/',
                entityApiUrl: 'https://www.walletexplorer.com/api/1/address-lookup?address=',
                apiKey: null,
                fallbackUrls: [
                    'https://api.blockcypher.com/v1/btc/main/txs/',
                    'https://mempool.space/api/tx/',
                    'https://api.blockchair.com/bitcoin/raw/transaction/',
                    'https://btc.blockbook.api.blockchair.com/api/v2/tx/'
                ],
                parseResponse: (data) => {
                    if (data.hash) {
                        // blockchain.info format
                        console.log('Bitcoin transaction data from blockchain.info:', data);
                        
                        // blockchain.info may use 'inputs' or 'in' for inputs array
                        const inputs = data.inputs || data.in;
                        if (!inputs || !Array.isArray(inputs) || inputs.length === 0) {
                            console.error('No inputs found in transaction');
                            return null;
                        }
                        
                        const firstInput = inputs[0];
                        
                        // Check for timestamp - blockchain.info provides 'time' in unix seconds
                        if (!data.time) {
                            console.warn('No timestamp in Bitcoin transaction data! Using current time as fallback.');
                        } else {
                            console.log(`Bitcoin transaction timestamp: ${data.time} (${new Date(data.time * 1000).toISOString()})`);
                        }
                        
                        const timestamp = data.time ? data.time * 1000 : Date.now();
                        
                        // Check if there are multiple outputs
                        // Show ALL outputs for selection so user can choose the correct one
                        const senderAddress = firstInput.prev_out ? firstInput.prev_out.addr : null;
                        
                        // For victim transaction selection, we want to see ALL outputs
                        // The user will select which one represents their victim's transaction
                        
                        // Check if outputs exist - blockchain.info uses 'out' not 'outputs'
                        const outputs = data.outputs || data.out;
                        if (!outputs || !Array.isArray(outputs)) {
                            console.error('No outputs array in transaction data. Keys available:', Object.keys(data));
                            return null;
                        }
                        
                        // Use the correct outputs array for consistency
                        data.outputs = outputs;
                        
                        console.log(`Bitcoin transaction has ${data.outputs.length} total outputs`);
                        
                        const significantOutputs = data.outputs.filter(output => {
                            // Only filter out tiny dust outputs (< 546 satoshis, Bitcoin's dust limit)
                            if (output.value < 546) {
                                console.log(`Filtering out dust output: ${output.value} satoshis to ${output.addr}`);
                                return false;
                            }
                            
                            // Include everything else - let the user decide which output is relevant
                            return true;
                        });
                        
                        console.log(`After filtering: ${significantOutputs.length} significant outputs`);
                        
                        // Show selection modal if there are 2 or more outputs
                        // Even with just 2, user needs to choose which one is theirs
                        if (significantOutputs.length > 1) {
                            // Calculate total input amount for unnecessary input heuristic
                            let totalInputAmount = 0;
                            let inputDetails = [];

                            inputs.forEach(input => {
                                if (input.prev_out && input.prev_out.value) {
                                    const inputAmount = input.prev_out.value / 100000000;
                                    totalInputAmount += inputAmount;
                                    inputDetails.push({
                                        address: input.prev_out.addr || 'Unknown',
                                        amount: inputAmount
                                    });
                                }
                            });

                            // Multiple outputs - return them as transfers for selection
                            const transfers = significantOutputs.map((output, index) => ({
                                from: senderAddress || 'Unknown',
                                to: output.addr || 'Unknown',
                                amount: output.value / 100000000,
                                currency: 'BTC',
                                outputIndex: index,
                                scriptType: output.script ? output.script.substring(0, 6) : 'unknown',
                                rawData: output,
                                // Include input info for change detection
                                totalInputAmount: totalInputAmount,
                                inputCount: inputs.length,
                                inputDetails: inputDetails
                            }));
                            
                            return {
                                multipleTransfers: true,
                                transfers: transfers,
                                time: timestamp,
                                hasRealTimestamp: !!data.time,
                                fee: data.fee ? data.fee / 100000000 : null
                            };
                        } else {
                            // Single output transaction
                            const firstOutput = significantOutputs[0] || data.outputs[0];
                            return {
                                time: timestamp,
                                amount: firstOutput.value / 100000000,
                                currency: 'BTC',
                                from: senderAddress || 'Unknown',
                                to: firstOutput.addr || 'Unknown',
                                fee: data.fee ? data.fee / 100000000 : null
                            };
                        }
                    } else if (data.tx_hash) {
                        // blockcypher format
                        let timestamp;
                        try {
                            timestamp = new Date(data.received).getTime();
                            if (isNaN(timestamp)) timestamp = Date.now();
                            console.log(`BlockCypher timestamp: ${data.received} -> ${new Date(timestamp).toISOString()}`);
                        } catch (e) {
                            timestamp = Date.now();
                            console.warn('Failed to parse BlockCypher timestamp, using current time');
                        }
                        
                        // Check if outputs exist
                        if (!data.outputs || !Array.isArray(data.outputs)) {
                            console.error('No outputs array in BlockCypher data');
                            return null;
                        }
                        
                        // Check for multiple outputs
                        const senderAddress = data.inputs && data.inputs[0] && data.inputs[0].addresses ? data.inputs[0].addresses[0] : null;
                        
                        console.log(`BlockCypher transaction has ${data.outputs.length} total outputs`);
                        
                        // For victim transaction selection, show ALL non-dust outputs
                        const significantOutputs = data.outputs.filter(output => {
                            // Only filter out tiny dust outputs (< 546 satoshis)
                            if (output.value < 546) return false;
                            
                            // Include everything else for user selection
                            return true;
                        });
                        
                        if (significantOutputs.length > 1) {
                            // Multiple outputs - return them as transfers for selection
                            const transfers = significantOutputs.map((output, index) => ({
                                from: senderAddress || 'Unknown',
                                to: output.addresses ? output.addresses[0] : 'Unknown',
                                amount: output.value / 100000000,
                                currency: 'BTC',
                                outputIndex: index,
                                scriptType: output.script_type || 'unknown',
                                rawData: output
                            }));
                            
                            return {
                                multipleTransfers: true,
                                transfers: transfers,
                                time: timestamp,
                                hasRealTimestamp: true,
                                fee: data.fees ? data.fees / 100000000 : null
                            };
                        } else {
                            // Single output transaction
                            const firstOutput = significantOutputs[0] || data.outputs[0];
                            return {
                                time: timestamp,
                                amount: firstOutput.value / 100000000,
                                currency: 'BTC',
                                from: senderAddress || 'Unknown',
                                to: firstOutput.addresses ? firstOutput.addresses[0] : 'Unknown',
                                fee: data.fees ? data.fees / 100000000 : null
                            };
                        }
                    }
                    return null;
                }
            },
            ethereum: {
                name: 'Ethereum',
                nativeCurrency: 'ETH',
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                chainId: 1, // Ethereum mainnet
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=1&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=1&module=proxy&action=eth_getTransactionReceipt&txhash=',
                txReceiptUrl: 'https://api.etherscan.io/v2/api?chainid=1&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=1&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=1&module=account&action=txlist&address=',
                labelApiUrl: 'https://api.etherscan.io/v2/api?chainid=1&module=account&action=addressinfo&address=',
                apiKey: '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                fallbackUrls: [],
                parseResponse: parseEVMResponse
            },
            base: {
                name: 'Base',
                nativeCurrency: 'ETH',
                chainId: 8453,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=8453&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=8453&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=8453&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=8453&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            arbitrum: {
                name: 'Arbitrum',
                nativeCurrency: 'ETH',
                chainId: 42161,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=42161&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=42161&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=42161&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=42161&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            optimism: {
                name: 'Optimism',
                nativeCurrency: 'ETH',
                chainId: 10,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=10&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=10&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=10&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=10&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            polygon: {
                name: 'Polygon',
                nativeCurrency: 'MATIC',
                chainId: 137,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=137&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=137&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=137&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=137&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            bsc: {
                name: 'BNB Chain',
                nativeCurrency: 'BNB',
                chainId: 56,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=56&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=56&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=56&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=56&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            // Additional EVM chains supported by Etherscan API v2
            avalanche: {
                name: 'Avalanche C-Chain',
                nativeCurrency: 'AVAX',
                chainId: 43114,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=43114&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=43114&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=43114&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=43114&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            hyperevm: {
                name: 'HyperEVM',
                nativeCurrency: 'HYPE',
                chainId: 999,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=999&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=999&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=999&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=999&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            linea: {
                name: 'Linea',
                nativeCurrency: 'ETH',
                chainId: 59144,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=59144&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=59144&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=59144&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=59144&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            scroll: {
                name: 'Scroll',
                nativeCurrency: 'ETH',
                chainId: 534352,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=534352&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=534352&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=534352&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=534352&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            mantle: {
                name: 'Mantle',
                nativeCurrency: 'MNT',
                chainId: 5000,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=5000&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=5000&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=5000&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=5000&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            blast: {
                name: 'Blast',
                nativeCurrency: 'ETH',
                chainId: 81457,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=81457&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=81457&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=81457&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=81457&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            zksync: {
                name: 'zkSync',
                nativeCurrency: 'ETH',
                chainId: 324,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=324&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=324&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=324&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=324&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            gnosis: {
                name: 'Gnosis',
                nativeCurrency: 'xDAI',
                chainId: 100,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=100&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=100&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=100&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=100&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            celo: {
                name: 'Celo',
                nativeCurrency: 'CELO',
                chainId: 42220,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=42220&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=42220&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=42220&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=42220&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            moonbeam: {
                name: 'Moonbeam',
                nativeCurrency: 'GLMR',
                chainId: 1284,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=1284&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=1284&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=1284&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=1284&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            moonriver: {
                name: 'Moonriver',
                nativeCurrency: 'MOVR',
                chainId: 1285,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=1285&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=1285&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=1285&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=1285&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            fraxtal: {
                name: 'Fraxtal',
                nativeCurrency: 'frxETH',
                chainId: 252,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=252&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=252&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=252&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=252&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            taiko: {
                name: 'Taiko',
                nativeCurrency: 'ETH',
                chainId: 167000,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=167000&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=167000&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=167000&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=167000&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            arbitrumnova: {
                name: 'Arbitrum Nova',
                nativeCurrency: 'ETH',
                chainId: 42170,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=42170&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=42170&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=42170&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=42170&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            bittorrent: {
                name: 'BitTorrent Chain',
                nativeCurrency: 'BTT',
                chainId: 199,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=199&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=199&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=199&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=199&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            opbnb: {
                name: 'opBNB',
                nativeCurrency: 'BNB',
                chainId: 204,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=204&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=204&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=204&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=204&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            unichain: {
                name: 'Unichain',
                nativeCurrency: 'ETH',
                chainId: 130,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=130&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=130&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=130&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=130&module=account&action=txlist&address=',
                apiKey: '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            sonic: {
                name: 'Sonic',
                nativeCurrency: 'S',
                chainId: 146,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=146&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=146&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=146&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=146&module=account&action=txlist&address=',
                apiKey: '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            abstract: {
                name: 'Abstract',
                nativeCurrency: 'ETH',
                chainId: 2741,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=2741&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=2741&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=2741&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=2741&module=account&action=txlist&address=',
                apiKey: '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            memecore: {
                name: 'Memecore',
                nativeCurrency: 'M',
                chainId: 4352,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=4352&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=4352&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=4352&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=4352&module=account&action=txlist&address=',
                apiKey: '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            sophon: {
                name: 'Sophon',
                nativeCurrency: 'SOPH',
                chainId: 50104,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=50104&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=50104&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=50104&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=50104&module=account&action=txlist&address=',
                apiKey: '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            berachain: {
                name: 'Berachain',
                nativeCurrency: 'BERA',
                chainId: 80094,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=80094&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=80094&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=80094&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=80094&module=account&action=txlist&address=',
                apiKey: '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            tron: {
                name: 'Tron',
                hashPattern: /^T[a-zA-Z0-9]{33}$/,
                addressPattern: /^T[a-zA-Z0-9]{33}$/,
                addressPrefixes: ['T'],
                txPattern: /^[a-f0-9]{64}$/i,
                apiUrl: 'https://api.trongrid.io/v1/transactions/',
                addressApiUrl: 'https://api.trongrid.io/v1/accounts/',
                apiKey: null,
                fallbackUrls: [
                    'https://apilist.tronscan.org/api/transaction-info?hash='
                ],
                parseResponse: (data) => {
                    if (data.data && data.data[0]) {
                        const tx = data.data[0];
                        return {
                            time: tx.block_timestamp,
                            amount: (tx.raw_data.contract[0].parameter.value.amount || 0) / 1e6,
                            currency: 'TRX',
                            from: tx.raw_data.contract[0].parameter.value.owner_address,
                            to: tx.raw_data.contract[0].parameter.value.to_address,
                            fee: tx.fee ? tx.fee / 1e6 : null
                        };
                    }
                    return null;
                }
            },
            xrp: {
                name: 'XRP (Ripple)',
                hashPattern: /^r[a-zA-Z0-9]{24,34}$/,
                addressPattern: /^r[a-zA-Z0-9]{24,34}$/,
                addressPrefixes: ['r'],
                txPattern: /^[A-F0-9]{64}$/i,
                apiUrl: 'https://api.xrpscan.com/api/v1/tx/',
                addressApiUrl: 'https://api.xrpscan.com/api/v1/account/',
                apiKey: null,
                fallbackUrls: [
                    'https://xrplcluster.com/v1/tx/',
                    'https://s1.ripple.com:51234/'
                ],
                parseResponse: (data) => {
                    console.log('XRP transaction data:', data);

                    // XRPSCAN API response format
                    if (data && data.transaction) {
                        const tx = data.transaction;

                        // Check if transaction was successful
                        if (tx.meta && tx.meta.TransactionResult !== 'tesSUCCESS') {
                            console.error('XRP transaction failed:', tx.meta.TransactionResult);
                            return null;
                        }

                        // Handle Payment transactions
                        if (tx.TransactionType === 'Payment') {
                            let amount = 0;

                            // XRP native payments
                            if (typeof tx.Amount === 'string') {
                                // Amount is in drops (1 XRP = 1,000,000 drops)
                                amount = parseFloat(tx.Amount) / 1000000;
                            }
                            // Issued currency (tokens)
                            else if (typeof tx.Amount === 'object' && tx.Amount.value) {
                                amount = parseFloat(tx.Amount.value);
                            }

                            // Get timestamp (Ripple epoch: January 1, 2000 00:00 UTC)
                            // Convert to Unix timestamp (milliseconds)
                            const rippleEpoch = 946684800; // Unix timestamp for January 1, 2000
                            const timestamp = tx.date ? (tx.date + rippleEpoch) * 1000 : Date.now();

                            // Get fee (always in drops for native XRP)
                            const fee = tx.Fee ? parseFloat(tx.Fee) / 1000000 : null;

                            // Determine currency
                            let currency = 'XRP';
                            if (typeof tx.Amount === 'object' && tx.Amount.currency) {
                                currency = tx.Amount.currency;
                            }

                            return {
                                time: timestamp,
                                amount: amount,
                                currency: currency,
                                from: tx.Account || 'Unknown',
                                to: tx.Destination || 'Unknown',
                                fee: fee,
                                destinationTag: tx.DestinationTag || null,
                                sourceTag: tx.SourceTag || null
                            };
                        }
                    }

                    return null;
                }
            },
            thorchain: {
                name: 'THORChain',
                hashPattern: /^[A-F0-9]{64}$/i,
                addressPattern: /^thor[a-zA-Z0-9]{39}$/,
                addressPrefixes: ['thor'],
                txPattern: /^[A-F0-9]{64}$/i,
                apiUrl: 'https://midgard.ninerealms.com/v2/actions?txid=',
                addressApiUrl: 'https://midgard.ninerealms.com/v2/member/',
                explorerUrl: 'https://viewblock.io/thorchain/tx/',
                apiKey: null,
                fallbackUrls: [
                    'https://midgard.thorchain.info/v2/actions?txid='
                ],
                parseResponse: (data) => {
                    console.log('THORChain action data:', data);

                    // Midgard API returns actions array
                    if (data && data.actions && data.actions.length > 0) {
                        const action = data.actions[0];

                        // Extract timestamp (in nanoseconds, convert to milliseconds)
                        const timestamp = action.date ? parseInt(action.date) / 1000000 : Date.now();

                        // Handle different action types
                        if (action.type === 'swap') {
                            // Swap transaction
                            const inTx = action.in && action.in[0];
                            const outTx = action.out && action.out[0];

                            if (inTx && outTx) {
                                // Parse coin amounts (format: "100000000 RUNE" or "5000000 BTC.BTC")
                                const parseAmount = (coins) => {
                                    if (!coins || coins.length === 0) return { amount: 0, currency: 'RUNE' };
                                    const coin = coins[0];
                                    const parts = coin.amount.split(' ');
                                    const amount = parts[0] ? parseFloat(parts[0]) / 100000000 : 0; // 8 decimals
                                    const currency = parts[1] || 'RUNE';
                                    return { amount, currency: currency.split('.')[0] }; // Remove chain prefix
                                };

                                const inAmount = parseAmount(inTx.coins);
                                const outAmount = parseAmount(outTx.coins);

                                return {
                                    time: timestamp,
                                    amount: inAmount.amount,
                                    currency: inAmount.currency,
                                    from: inTx.address || 'Unknown',
                                    to: outTx.address || 'Unknown',
                                    fee: null,
                                    hasRealTimestamp: !!action.date,
                                    swapInfo: {
                                        type: 'swap',
                                        inAmount: inAmount.amount,
                                        inCurrency: inAmount.currency,
                                        outAmount: outAmount.amount,
                                        outCurrency: outAmount.currency
                                    }
                                };
                            }
                        } else if (action.type === 'addLiquidity' || action.type === 'withdraw') {
                            // Liquidity operations
                            const inTx = action.in && action.in[0];
                            if (inTx) {
                                const parseAmount = (coins) => {
                                    if (!coins || coins.length === 0) return { amount: 0, currency: 'RUNE' };
                                    const coin = coins[0];
                                    const parts = coin.amount.split(' ');
                                    const amount = parts[0] ? parseFloat(parts[0]) / 100000000 : 0;
                                    const currency = parts[1] || 'RUNE';
                                    return { amount, currency: currency.split('.')[0] };
                                };

                                const amount = parseAmount(inTx.coins);

                                return {
                                    time: timestamp,
                                    amount: amount.amount,
                                    currency: amount.currency,
                                    from: inTx.address || 'Unknown',
                                    to: action.pools && action.pools[0] ? action.pools[0] : 'Pool',
                                    fee: null,
                                    hasRealTimestamp: !!action.date,
                                    actionType: action.type
                                };
                            }
                        }

                        // Fallback for other action types
                        return {
                            time: timestamp,
                            amount: 0,
                            currency: 'RUNE',
                            from: action.in && action.in[0] ? action.in[0].address : 'Unknown',
                            to: action.out && action.out[0] ? action.out[0].address : 'Unknown',
                            fee: null,
                            hasRealTimestamp: !!action.date,
                            actionType: action.type
                        };
                    }

                    return null;
                }
            },
            solana: {
                name: 'Solana',
                hashPattern: /^[1-9A-HJ-NP-Za-km-z]{32,44}$/,
                addressPattern: /^[1-9A-HJ-NP-Za-km-z]{32,44}$/,
                addressPrefixes: ['1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'],
                txPattern: /^[1-9A-HJ-NP-Za-km-z]{87,88}$/,
                apiUrl: 'https://api.mainnet-beta.solana.com',
                addressApiUrl: 'https://api.mainnet-beta.solana.com',
                apiKey: null,
                fallbackUrls: [
                    'https://solana-mainnet.g.alchemy.com/v2/demo',
                    'https://rpc.ankr.com/solana'
                ],
                parseResponse: (data) => {
                    if (data.result) {
                        const tx = data.result;
                        const meta = tx.meta;

                        // Check for errors
                        if (meta.err) {
                            console.error('Transaction failed:', meta.err);
                            return null;
                        }

                        // Try to parse token transfers first (SPL tokens)
                        const transfers = [];

                        // Check for token balance changes (SPL tokens)
                        if (meta.postTokenBalances && meta.preTokenBalances) {
                            const tokenBalanceChanges = {};

                            // Process pre-balances
                            meta.preTokenBalances.forEach(balance => {
                                const key = `${balance.accountIndex}-${balance.mint}`;
                                tokenBalanceChanges[key] = {
                                    accountIndex: balance.accountIndex,
                                    mint: balance.mint,
                                    owner: balance.owner,
                                    preBalance: parseFloat(balance.uiTokenAmount.uiAmount || 0),
                                    postBalance: 0,
                                    decimals: balance.uiTokenAmount.decimals,
                                    symbol: null
                                };
                            });

                            // Process post-balances
                            meta.postTokenBalances.forEach(balance => {
                                const key = `${balance.accountIndex}-${balance.mint}`;
                                if (tokenBalanceChanges[key]) {
                                    tokenBalanceChanges[key].postBalance = parseFloat(balance.uiTokenAmount.uiAmount || 0);
                                } else {
                                    tokenBalanceChanges[key] = {
                                        accountIndex: balance.accountIndex,
                                        mint: balance.mint,
                                        owner: balance.owner,
                                        preBalance: 0,
                                        postBalance: parseFloat(balance.uiTokenAmount.uiAmount || 0),
                                        decimals: balance.uiTokenAmount.decimals,
                                        symbol: null
                                    };
                                }
                            });

                            // Create transfer objects for significant changes
                            // Group by mint to find paired transfers
                            const transfersByMint = {};
                            Object.values(tokenBalanceChanges).forEach(change => {
                                const amount = Math.abs(change.postBalance - change.preBalance);
                                if (amount > 0.0000001) { // Filter tiny amounts
                                    if (!transfersByMint[change.mint]) {
                                        transfersByMint[change.mint] = [];
                                    }
                                    transfersByMint[change.mint].push({
                                        owner: change.owner,
                                        amount: amount,
                                        isSender: change.postBalance < change.preBalance,
                                        mint: change.mint,
                                        decimals: change.decimals
                                    });
                                }
                            });

                            // Map known SPL token mints to symbols
                            const tokenSymbols = {
                                'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v': 'USDC',
                                'Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB': 'USDT',
                                'So11111111111111111111111111111111111111112': 'SOL',
                                'DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263': 'BONK',
                                'JUPyiwrYJFskUPiHa8hkeR8VUtAeFoSYbKedZNsDvCN': 'JUP'
                            };

                            // Create single transfers from paired debits/credits
                            Object.entries(transfersByMint).forEach(([mint, changes]) => {
                                const symbol = tokenSymbols[mint] || 'Unknown Token';

                                if (changes.length === 2) {
                                    // Paired transfer - combine into single entry
                                    const sender = changes.find(c => c.isSender);
                                    const receiver = changes.find(c => !c.isSender);

                                    if (sender && receiver) {
                                        transfers.push({
                                            from: sender.owner,
                                            to: receiver.owner,
                                            amount: Math.max(sender.amount, receiver.amount), // Use max in case of rounding
                                            currency: symbol,
                                            mint: mint,
                                            type: 'SPL Token'
                                        });
                                    }
                                } else {
                                    // Unpaired transfers - show each separately (might be mint/burn)
                                    changes.forEach(change => {
                                        transfers.push({
                                            from: change.isSender ? change.owner : 'Unknown',
                                            to: !change.isSender ? change.owner : 'Unknown',
                                            amount: change.amount,
                                            currency: symbol,
                                            mint: mint,
                                            type: 'SPL Token'
                                        });
                                    });
                                }
                            });
                        }

                        // If we found token transfers, return them
                        if (transfers.length > 0) {
                            if (transfers.length === 1) {
                                return {
                                    time: tx.blockTime * 1000,
                                    amount: transfers[0].amount,
                                    currency: transfers[0].currency,
                                    from: transfers[0].from,
                                    to: transfers[0].to,
                                    fee: meta.fee / 1e9,
                                    hasRealTimestamp: true
                                };
                            } else {
                                // Multiple transfers
                                return {
                                    multipleTransfers: true,
                                    transfers: transfers.map(t => ({
                                        ...t,
                                        time: tx.blockTime * 1000,
                                        hasRealTimestamp: true
                                    })),
                                    time: tx.blockTime * 1000,
                                    fee: meta.fee / 1e9,
                                    hasRealTimestamp: true
                                };
                            }
                        }

                        // Fallback to SOL transfer parsing
                        const accountKeys = tx.transaction.message.accountKeys;
                        const preBalances = meta.preBalances;
                        const postBalances = meta.postBalances;

                        // Find the main SOL transfer
                        let mainTransfer = null;
                        for (let i = 0; i < accountKeys.length && i < preBalances.length; i++) {
                            const diff = (postBalances[i] - preBalances[i]) / 1e9;
                            if (Math.abs(diff) > 0.000001 && i > 0) { // Skip system program (index 0) and tiny amounts
                                if (!mainTransfer || Math.abs(diff) > Math.abs(mainTransfer.amount)) {
                                    mainTransfer = {
                                        from: diff < 0 ? accountKeys[i] : accountKeys[0],
                                        to: diff > 0 ? accountKeys[i] : 'Unknown',
                                        amount: Math.abs(diff)
                                    };
                                }
                            }
                        }

                        if (mainTransfer) {
                            return {
                                time: tx.blockTime * 1000,
                                amount: mainTransfer.amount,
                                currency: 'SOL',
                                from: mainTransfer.from,
                                to: mainTransfer.to,
                                fee: meta.fee / 1e9,
                                hasRealTimestamp: true
                            };
                        }

                        // Last resort - basic parsing
                        const amount = Math.abs(postBalances[1] - preBalances[1]) / 1e9;
                        return {
                            time: tx.blockTime * 1000,
                            amount: amount,
                            currency: 'SOL',
                            from: accountKeys[0],
                            to: accountKeys[1] || 'Unknown',
                            fee: meta.fee / 1e9,
                            hasRealTimestamp: true
                        };
                    }
                    return null;
                }
            },
            sui: {
                name: 'Sui',
                hashPattern: /^0x[a-fA-F0-9]{64}$/,
                addressPattern: /^0x[a-fA-F0-9]{64}$/,
                addressPrefixes: ['0x'],
                txPattern: /^[a-zA-Z0-9]{44}$/,
                apiUrl: 'https://fullnode.mainnet.sui.io:443',
                addressApiUrl: 'https://fullnode.mainnet.sui.io:443',
                explorerApiUrl: 'https://suiscan.xyz/api/mainnet/transaction/',
                apiKey: null,
                fallbackUrls: [
                    'https://sui-mainnet.blockvision.org',
                    'https://rpc-mainnet.suiscan.xyz:443'
                ],
                parseResponse: (data) => {
                    console.log('Sui transaction data:', data);

                    if (data && data.result) {
                        const tx = data.result;

                        // Check transaction status
                        if (tx.effects && tx.effects.status && tx.effects.status.status !== 'success') {
                            console.error('Sui transaction failed:', tx.effects.status);
                            return null;
                        }

                        // Parse timestamp (Sui uses milliseconds since epoch)
                        const timestamp = tx.timestampMs ? parseInt(tx.timestampMs) : Date.now();

                        // Parse transfers from ProgrammableTransaction
                        const transfers = [];

                        // Get sender from transaction data
                        const sender = tx.transaction?.data?.sender || 'Unknown';

                        // Parse ProgrammableTransaction inputs and transactions
                        if (tx.transaction && tx.transaction.data && tx.transaction.data.transaction) {
                            const txData = tx.transaction.data.transaction;
                            const inputs = txData.inputs || [];
                            const transactions = txData.transactions || [];

                            // Look for TransferObjects transaction (common pattern)
                            const transferTx = transactions.find(t => t.TransferObjects);
                            if (transferTx) {
                                // Find amount and recipient from inputs
                                let amount = 0;
                                let recipient = 'Unknown';

                                // Look for u64 value (amount in MIST) in inputs
                                const amountInput = inputs.find(inp => inp.valueType === 'u64');
                                if (amountInput && amountInput.value) {
                                    // Convert from MIST to SUI (1 SUI = 1,000,000,000 MIST)
                                    amount = parseInt(amountInput.value) / 1000000000;
                                }

                                // Look for address value (recipient) in inputs
                                const recipientInput = inputs.find(inp => inp.valueType === 'address');
                                if (recipientInput && recipientInput.value) {
                                    recipient = recipientInput.value;
                                }

                                if (amount > 0 && recipient !== 'Unknown') {
                                    transfers.push({
                                        from: sender,
                                        to: recipient,
                                        amount: amount,
                                        currency: 'SUI',
                                        type: 'Sui Transfer'
                                    });
                                }
                            }
                        }

                        // Get gas fee (in MIST, convert to SUI)
                        const gasFee = tx.effects && tx.effects.gasUsed ?
                            (parseInt(tx.effects.gasUsed.computationCost || 0) +
                             parseInt(tx.effects.gasUsed.storageCost || 0)) / 1000000000 : 0;

                        // Return single or multiple transfers
                        if (transfers.length === 1) {
                            return {
                                time: timestamp,
                                amount: transfers[0].amount,
                                currency: transfers[0].currency,
                                from: transfers[0].from,
                                to: transfers[0].to,
                                fee: gasFee,
                                hasRealTimestamp: !!tx.timestampMs
                            };
                        } else if (transfers.length > 1) {
                            return {
                                multipleTransfers: true,
                                transfers: transfers.map(t => ({
                                    ...t,
                                    time: timestamp,
                                    hasRealTimestamp: !!tx.timestampMs
                                })),
                                time: timestamp,
                                fee: gasFee,
                                hasRealTimestamp: !!tx.timestampMs
                            };
                        }

                        // Fallback: try to parse from transaction data directly
                        if (tx.transaction && tx.transaction.data) {
                            const txData = tx.transaction.data;

                            // Handle PaySui or Pay transactions
                            if (txData.transactions) {
                                const payTx = txData.transactions.find(t => t.Pay || t.PaySui);
                                if (payTx) {
                                    const pay = payTx.Pay || payTx.PaySui;
                                    const amount = pay.amounts ? pay.amounts[0] / 1000000000 : 0;

                                    return {
                                        time: timestamp,
                                        amount: amount,
                                        currency: 'SUI',
                                        from: txData.sender || 'Unknown',
                                        to: pay.recipients ? pay.recipients[0] : 'Unknown',
                                        fee: gasFee,
                                        hasRealTimestamp: !!tx.timestampMs
                                    };
                                }
                            }
                        }
                    }

                    return null;
                }
            },
            ripple: {
                name: 'Ripple (XRP)',
                hashPattern: /^[A-F0-9]{64}$/i,
                addressPattern: /^r[0-9a-zA-Z]{24,34}$/,
                addressPrefixes: ['r'],
                txPattern: /^[A-F0-9]{64}$/i,
                apiUrl: 'https://api.xrpscan.com/api/v1/tx/',
                apiKey: null,
                parseResponse: (data) => {
                    if (data) {
                        return {
                            time: data.date ? new Date(data.date * 1000).getTime() : Date.now(),
                            amount: data.Amount ? (typeof data.Amount === 'string' ?
                                parseInt(data.Amount) / 1000000 :
                                parseFloat(data.Amount.value || 0)) : 0,
                            currency: data.Amount?.currency || 'XRP',
                            from: data.Account || '',
                            to: data.Destination || '',
                            fee: data.Fee ? parseInt(data.Fee) / 1000000 : 0,
                            hasRealTimestamp: !!data.date
                        };
                    }
                    return null;
                }
            }
        };

        // Bridge/DEX Contract Addresses for Auto-Detection
        // Pattern: provider → chain → contract address (lowercase for comparison)
        const BRIDGE_DEX_CONTRACTS = {
            bridgers: {
                ethereum: '0xb685760ebd368a891f27ae547391f4e2a289895b',
                bsc: '0xb685760ebd368a891f27ae547391f4e2a289895b',
                polygon: '0xb685760ebd368a891f27ae547391f4e2a289895b',
                heco: '0xaeae2cbb1e024e27e80cc61ee9a8b300282209b4',
                oec: '0xb685760ebd368a891f27ae547391f4e2a289895b',
                tron: 'TPwezUWpEGmFBENNWJHwXHRG1D2NCEEt5s',
                fantom: '0xb685760ebd368a891f27ae547391f4e2a289895b',
                arbitrum: '0xb685760ebd368a891f27ae547391f4e2a289895b',
                avalanche: '0xb685760ebd368a891f27ae547391f4e2a289895b',
                optimism: '0xb685760ebd368a891f27ae547391f4e2a289895b',
                cronos: '0x332fae8fa47941305e5de262ae3587ad6dca0a78',
                solana: 'FDF8AxHB8UK7RS6xay6aBvwS3h7kez9gozqz14JyfKsg',
                aptos: '0x4512ba8a4862edcb20d5027a8d1b47129299d4bed9e41a8a727b78808d6faef4',
                sui: '0x2b0876f0b7034320ad6d2f378501fe92e41c8b4780bda7769094d2431170e532',
                base: '0xa18968cc31232724f1dbd0d1e8d0b323d89f3501',
                opbnb: '0x8f957ed3f969d7b6e5d6df81e61a5ff45f594dd1',
                zksync: '0x2042ecdc71f9ffb2eb9cda7f801eccc5c6c8b7eb',
                cfx: '0x8f957ed3f969d7b6e5d6df81e61a5ff45f594dd1',
                mantle: '0xd1088d3376c2384d469d1c0d55d503695e1be3e6',
                core: '0x8159891dfe9de7fc3bf1b665eb1adda60f2acd0e',
                linea: '0x8159891dfe9de7fc3bf1b665eb1adda60f2acd0e',
                zkevm: '0x8f957ed3f969d7b6e5d6df81e61a5ff45f594dd1',
                scroll: '0x8f957ed3f969d7b6e5d6df81e61a5ff45f594dd1',
                ton: 'EQCqTuPS-cMN9SSRhaFrwJOGL7dKkFF8C0a05g2WzI9uRJ19',
                merlin: '0x8159891dfe9de7fc3bf1b665eb1adda60f2acd0e',
                onchain: '0x8159891dfe9de7fc3bf1b665eb1adda60f2acd0e',
                celo: '0xd1088d3376c2384d469d1c0d55d503695e1be3e6',
                xlayer: '0xd1088d3376c2384d469d1c0d55d503695e1be3e6',
                blast: '0xd1088d3376c2384d469d1c0d55d503695e1be3e6',
                ape: '0xd1088d3376c2384d469d1c0d55d503695e1be3e6',
                xrp: 'rM27yzkCw6WA3T4g1sPaeC1kpxHUhuxRWn',
                bitcoin: 'bc1q7t4vyehjsexdme84qhdgd4dawcn54djh0m78fz',
                doge: 'DNqWDenhxgWTfy2bpJn4tES6uMwz1nqt6C',
                ltc: 'ltc1q0sc0myh0a2wap7eshhyz2ahc2xdn86g7fv32r2',
                bch: 'qq9ndmhw4dyxfc2cy5czth9gwq7xmu7evvjudqj8lt',
                cosmos: 'cosmos12kvp0fgulyd9glnq8cj8t9f62amtdeaeh2zxl8',
                ethf: '0x89a70b162be7dbc8b5e7579066fa58190c48d693',
                sonic: '0x89a70b162be7dbc8b5e7579066fa58190c48d693',
                berachain: '0x89a70b162be7dbc8b5e7579066fa58190c48d693'
            },
            layerzero: {
                // LayerZero V1 Endpoints - Universal messaging protocol
                ethereum: '0x66a71dcef29a0ffbdbe3c6a460a3b5bc225cd675',
                bsc: '0x3c2269811836af69497e5f486a85d7316753cf62',
                polygon: '0x3c2269811836af69497e5f486a85d7316753cf62',
                arbitrum: '0x3c2269811836af69497e5f486a85d7316753cf62',
                optimism: '0x3c2269811836af69497e5f486a85d7316753cf62',
                avalanche: '0x3c2269811836af69497e5f486a85d7316753cf62',
                fantom: '0xb6319cc6c8c27a8f5daf0dd3df91ea35c4720dd7',
                base: '0xb6319cc6c8c27a8f5daf0dd3df91ea35c4720dd7',
                linea: '0xb6319cc6c8c27a8f5daf0dd3df91ea35c4720dd7',
                scroll: '0xb6319cc6c8c27a8f5daf0dd3df91ea35c4720dd7',
                blast: '0xb6319cc6c8c27a8f5daf0dd3df91ea35c4720dd7',
                zksync: '0x9b896c0e23220469c7ae69cb4bbae391eaa4c8da',
                mantle: '0xb6319cc6c8c27a8f5daf0dd3df91ea35c4720dd7',
                celo: '0x3a73033c0b1407574c76bdbaa9de301be46b026c',
                moonbeam: '0x9740ff91f1985d8d2b71494ae1a2f723bb3ed9e4',
                moonriver: '0x7004396c99d5690da76a7c59057c5f3461d8e4a2',
                gnosis: '0x9740ff91f1985d8d2b71494ae1a2f723bb3ed9e4',
                opbnb: '0xb6319cc6c8c27a8f5daf0dd3df91ea35c4720dd7'
            },
            stargate: {
                // Stargate Finance V1 Routers - Bridge application on LayerZero
                ethereum: '0x8731d54e9d02c286767d56ac03e8037c07e01e98',
                bsc: '0x4a364f8c717caad9a442737eb7b8a55cc6cf18d8',
                polygon: '0x45a01e4e04f14f7a4a6702c74187c5f6222033cd',
                arbitrum: '0x53bf833a5d6c4dda888f69c22c88c9f356a41614',
                optimism: '0xb0d502e938ed5f4df2e681fe6e419ff29631d62b',
                avalanche: '0x45a01e4e04f14f7a4a6702c74187c5f6222033cd',
                fantom: '0xaf5191b0de278c7286d6c7cc6ab6bb8a73ba2cd6',
                base: '0x45f1a95a4d3f3836523f5c83673c797f4d4d263b',
                linea: '0x2f6f07cdcf3588944bf4c42ac74ff24bf56e7590',
                scroll: '0x45f1a95a4d3f3836523f5c83673c797f4d4d263b',
                blast: '0x45f1a95a4d3f3836523f5c83673c797f4d4d263b',
                mantle: '0x45f1a95a4d3f3836523f5c83673c797f4d4d263b',
                metis: '0x2f6f07cdcf3588944bf4c42ac74ff24bf56e7590',
                kava: '0x2f6f07cdcf3588944bf4c42ac74ff24bf56e7590'
            },
            wormhole: {
                // Wormhole Portal Token Bridge - Cross-chain messaging and token bridge
                ethereum: '0x3ee18b2214aff97000d974cf647e7c347e8fa585',
                bsc: '0xb6f6d86a8f9879a9c87f643768d9efc38c1da6e7',
                polygon: '0x5a58505a96d1dbf8df91cb21b54419fc36e93fde',
                arbitrum: '0x0b2402144bb366a632d14b83f244d2e0e21bd39c',
                optimism: '0x1d68124e65fafc907325e3edbf8c4d84499daa8b',
                avalanche: '0x0e082f06ff657d94310cb8ce8b0d9a04541d8052',
                fantom: '0x7c9fc5741288cdfdd83ceb07f3ea7e22618d79d2',
                base: '0x8d2de8d2f73f1f4cab472ac9a881c9b123c79627',
                solana: 'worm2ZoG2kUd4vFXhvjh93UUH596ayRfgQ2MgjNMTth'
            },
            synapse: {
                // Synapse Protocol Bridge - Cross-chain liquidity network with best REST API
                ethereum: '0x2796317b0ff8538f253012862c06787adfb8ceb6',
                bsc: '0xd123f70ae324d34a9e76b67a27bf77593ba8749f',
                polygon: '0x8f5bbb2bb8c2ee94639e55d5f41de9b4839c1280',
                arbitrum: '0x6f4e8eba4d337f874ab57478acc2cb5bacdc19c9',
                optimism: '0xaf41a65f786339e7911f4acdad6bd49426f2dc6b',
                avalanche: '0xc05e61d0e7a63d27546389b7ad62fdff5a91aace',
                fantom: '0xaf41a65f786339e7911f4acdad6bd49426f2dc6b',
                base: '0xaa3d85ad9d128dfecb55424085754f6dfa643eb1'
            }
            // Future: axelar, hop, cbridge, across, etc.
        };

        // Currency decimal place configuration
        const currencyDecimals = {
            'USD': 2,
            'EUR': 2,
            'GBP': 2,
            'CAD': 2,
            'AUD': 2,
            'JPY': 0,  // Japanese Yen typically has no decimal places
            'BTC': 8,  // Bitcoin: 8 decimal places (satoshis)
            'ETH': 18, // Ethereum: 18 decimal places (wei)
            'USDT': 6, // Tether: 6 decimal places
            'USDC': 6, // USD Coin: 6 decimal places
            'DAI': 18, // DAI: 18 decimal places
            'TRX': 6,  // TRON: 6 decimal places
            'SOL': 9,  // Solana: 9 decimal places
            'ADA': 6,  // Cardano: 6 decimal places
            'BNB': 8,  // BNB: 8 decimal places
            'XRP': 6,  // Ripple: 6 decimal places
            'SUI': 9,  // Sui: 9 decimal places (MIST)
            'RUNE': 8, // THORChain: 8 decimal places
            'BERA': 18, // Berachain: 18 decimal places
            'S': 18,    // Sonic: 18 decimal places
            'M': 18,    // Memecore: 18 decimal places
            'SOPH': 18, // Sophon: 18 decimal places
            'CUSTOM': 8 // Default for custom currencies
        };
        
        // Get decimal places for a currency
        function getCurrencyDecimals(currency) {
            return currencyDecimals[currency] || 8; // Default to 8 if not found
        }
        
        // Get step value for input based on currency
        function getCurrencyStep(currency) {
            const decimals = getCurrencyDecimals(currency);
            if (decimals === 0) return '1';
            return '0.' + '0'.repeat(decimals - 1) + '1';
        }
        
        // Format amount with proper decimal places
        function formatCurrencyAmount(amount, currency, preserveFullPrecision = false) {
            const decimals = getCurrencyDecimals(currency);
            const num = parseFloat(amount);
            if (isNaN(num)) return '0';
            
            // If preserveFullPrecision is true, keep all decimal places
            if (preserveFullPrecision) {
                return num.toFixed(decimals);
            }
            
            // For display, show meaningful decimals (remove trailing zeros)
            if (decimals > 2) {
                // For crypto, show up to decimals places but remove trailing zeros
                return num.toFixed(decimals).replace(/\.?0+$/, '');
            } else {
                // For fiat, always show 2 decimals
                return num.toFixed(decimals);
            }
        }

        // ========================================
        // Bridge/DEX Auto-Detection Functions
        // ========================================

        /**
         * Detect if a transaction address matches any known bridge/DEX contract
         * @param {string} toAddress - The destination address from the transaction
         * @param {string} chain - The blockchain identifier (ethereum, bsc, etc.)
         * @returns {object|null} - { provider: 'bridgers', name: 'Bridgers', logo: 'url' } or null
         */
        function detectBridgeProvider(toAddress, chain) {
            if (!toAddress || !chain) return null;

            const addressLower = toAddress.toLowerCase();
            const chainLower = chain.toLowerCase();

            // Check each provider
            for (const [provider, chains] of Object.entries(BRIDGE_DEX_CONTRACTS)) {
                if (chains[chainLower]) {
                    const contractAddress = chains[chainLower].toLowerCase();
                    if (addressLower === contractAddress) {
                        // Map provider name for display
                        const providerNames = {
                            'bridgers': {
                                name: 'Bridgers',
                                logo: 'https://images.bridgers.xyz/dex/bridgers1.png'
                            },
                            'layerzero': {
                                name: 'LayerZero',
                                logo: 'https://layerzero.network/favicon.ico'
                            },
                            'stargate': {
                                name: 'Stargate',
                                logo: 'https://stargate.finance/favicons/favicon-32x32.png'
                            },
                            'wormhole': {
                                name: 'Wormhole',
                                logo: 'https://wormhole.com/favicon.ico'
                            },
                            'synapse': {
                                name: 'Synapse',
                                logo: 'https://synapseprotocol.com/favicon.ico'
                            }
                            // Future: axelar, hop, cbridge, across
                        };

                        return {
                            provider: provider,
                            ...providerNames[provider]
                        };
                    }
                }
            }

            return null;
        }

        /**
         * Query Bridgers API for transaction details
         * @param {string} fromAddress - Wallet address that initiated the bridge
         * @param {string} txHash - Transaction hash on source chain
         * @returns {Promise<object|null>} - Bridge transaction details or null
         */
        async function queryBridgersAPI(fromAddress, txHash) {
            try {
                console.log(`🌉 Querying Bridgers API for ${txHash}...`);

                // Step 1: Get transaction history for wallet
                const equipmentNo = fromAddress.substring(0, 32); // Use first 32 chars as unique ID
                const response = await fetch('https://api.bridgers.xyz/api/exchangeRecord/getTransData', {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        equipmentNo: equipmentNo,
                        sourceType: 'API',
                        sourceFlag: 'bats-tool',
                        pageNo: 1,
                        pageSize: 50,
                        fromAddress: fromAddress
                    })
                });

                if (!response.ok) {
                    throw new Error(`Bridgers API error: ${response.status}`);
                }

                const data = await response.json();

                if (data.resCode !== 100 || !data.data || !data.data.list) {
                    console.error('Bridgers API returned error:', data.resMsg);
                    return null;
                }

                // Step 2: Find matching transaction by hash
                const txHashLower = txHash.toLowerCase();
                const matchingTx = data.data.list.find(tx =>
                    (tx.hash && tx.hash.toLowerCase() === txHashLower) ||
                    (tx.toHash && tx.toHash.toLowerCase() === txHashLower) ||
                    (tx.refundHash && tx.refundHash.toLowerCase() === txHashLower)
                );

                if (!matchingTx) {
                    console.log('No matching Bridgers transaction found for hash:', txHash);
                    return null;
                }

                console.log('✅ Found Bridgers transaction:', matchingTx);

                // Step 3: Parse status
                const statusMap = {
                    'receive_complete': { status: 'completed', message: 'Swap completed' },
                    'wait_deposit_send': { status: 'pending', message: 'Waiting for deposit' },
                    'wait_exchange_push': { status: 'pending', message: 'Exchanging...' },
                    'wait_receive_send': { status: 'pending', message: 'Ready to issue crypto' },
                    'refund_complete': { status: 'refunded', message: 'Refund complete' },
                    'timeout': { status: 'failed', message: 'Timeout' },
                    'ERROR': { status: 'failed', message: 'Exchange failed' }
                };

                const statusInfo = statusMap[matchingTx.status] || { status: 'unknown', message: matchingTx.status };

                // Step 4: Parse refund reason if present
                const refundReasons = {
                    '1': 'Insufficient liquidity',
                    '2': 'Exceeding threshold error',
                    '3': 'Maintenance of the original currency',
                    '4': '⚠️ BLACKLISTED ADDRESS',
                    '5': 'Maintenance of the target currency',
                    '6': 'Amount not within range',
                    '7': 'Deposit timeout',
                    '8': '⚠️ INTERACT WITH RISKY ADDRESS'
                };

                const refundReason = matchingTx.refundReason ? refundReasons[matchingTx.refundReason] : null;
                const hasRiskFlag = matchingTx.refundReason === '4' || matchingTx.refundReason === '8';

                return {
                    orderId: matchingTx.orderId,
                    fromChain: matchingTx.fromChain,
                    toChain: matchingTx.toChain,
                    fromAmount: parseFloat(matchingTx.fromTokenAmount),
                    toAmount: parseFloat(matchingTx.toTokenAmount),
                    fromCurrency: matchingTx.fromCoinCode,
                    toCurrency: matchingTx.toCoinCode,
                    depositHash: matchingTx.hash,
                    receiveHash: matchingTx.toHash,
                    refundHash: matchingTx.refundHash,
                    fromAddress: matchingTx.fromAddress,
                    toAddress: matchingTx.toAddress,
                    status: statusInfo.status,
                    statusMessage: statusInfo.message,
                    refundReason: refundReason,
                    hasRiskFlag: hasRiskFlag,
                    createTime: matchingTx.createTime,
                    depositExplorerUrl: matchingTx.depositHashExplore,
                    receiveExplorerUrl: matchingTx.receiveHashExplore
                };

            } catch (error) {
                console.error('Error querying Bridgers API:', error);
                return null;
            }
        }

        /**
         * Query LayerZero Scan API for cross-chain message details
         * @param {string} txHash - Transaction hash on source chain
         * @returns {Promise<object|null>} - LayerZero message details or null
         */
        async function queryLayerZeroAPI(txHash) {
            try {
                console.log(`🔗 Querying LayerZero Scan API for ${txHash}...`);

                // LayerZero Scan API endpoint
                const apiUrl = `https://scan.layerzero-api.com/v1/messages/tx/${txHash}`;

                const response = await fetch(apiUrl, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                if (!response.ok) {
                    console.log(`LayerZero API returned status ${response.status}`);
                    return null;
                }

                const data = await response.json();

                // Check if we got message data
                if (!data || !data.messages || data.messages.length === 0) {
                    console.log('No LayerZero messages found for this transaction');
                    return null;
                }

                // Get the first message (most recent)
                const message = data.messages[0];

                console.log('✅ Found LayerZero message:', message);

                // Map chain IDs to chain names
                const chainIdMap = {
                    101: 'ethereum', 102: 'bsc', 106: 'avalanche', 109: 'polygon',
                    110: 'arbitrum', 111: 'optimism', 112: 'fantom', 151: 'metis',
                    177: 'kava', 181: 'mantle', 183: 'linea', 184: 'base'
                };

                const fromChain = chainIdMap[message.srcChainId] || `chain-${message.srcChainId}`;
                const toChain = chainIdMap[message.dstChainId] || `chain-${message.dstChainId}`;

                // Parse status
                const statusMap = {
                    'DELIVERED': { status: 'completed', message: 'Message delivered' },
                    'INFLIGHT': { status: 'pending', message: 'Message in transit' },
                    'FAILED': { status: 'failed', message: 'Message failed' },
                    'BLOCKED': { status: 'blocked', message: 'Message blocked' },
                    'PAYLOAD_STORED': { status: 'stored', message: 'Payload stored, needs retry' }
                };

                const statusInfo = statusMap[message.status] || { status: 'unknown', message: message.status };

                return {
                    orderId: message.guid || message.id,
                    fromChain: fromChain,
                    toChain: toChain,
                    fromAddress: message.srcUaAddress || '',
                    toAddress: message.dstUaAddress || '',
                    depositHash: message.srcTxHash || txHash,
                    receiveHash: message.dstTxHash || '',
                    status: statusInfo.status,
                    statusMessage: statusInfo.message,
                    protocol: 'LayerZero',
                    srcChainId: message.srcChainId,
                    dstChainId: message.dstChainId,
                    created: message.created,
                    updated: message.updated,
                    hasRiskFlag: false // LayerZero doesn't provide risk flags
                };

            } catch (error) {
                console.error('Error querying LayerZero Scan API:', error);
                return null;
            }
        }

        /**
         * Query Stargate Finance API for bridge transaction details
         * @param {string} txHash - Transaction hash on source chain
         * @returns {Promise<object|null>} - Stargate bridge details or null
         */
        async function queryStargateAPI(txHash) {
            try {
                console.log(`⭐ Querying Stargate API for ${txHash}...`);

                // Stargate uses LayerZero under the hood, so query LayerZero Scan
                // but filter for Stargate-related messages
                const lzData = await queryLayerZeroAPI(txHash);

                if (!lzData) {
                    return null;
                }

                // Enhance with Stargate-specific information
                return {
                    ...lzData,
                    protocol: 'Stargate Finance',
                    bridgeType: 'Liquidity Bridge'
                };

            } catch (error) {
                console.error('Error querying Stargate API:', error);
                return null;
            }
        }

        /**
         * Query Wormhole Scan API for cross-chain bridge transaction details
         * @param {string} fromAddress - Source wallet address
         * @param {string} txHash - Transaction hash on source chain
         * @returns {Promise<object|null>} - Wormhole bridge details or null
         */
        async function queryWormholeAPI(fromAddress, txHash) {
            try {
                console.log(`🪱 Querying Wormhole Scan API for ${txHash}...`);

                // Wormhole Scan API - Operations by address endpoint
                const apiUrl = `https://api.wormholescan.io/api/v1/operations?address=${fromAddress}&page=0&pageSize=50`;

                const response = await fetch(apiUrl, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                if (!response.ok) {
                    console.log(`Wormhole Scan API returned status ${response.status}`);
                    return null;
                }

                const data = await response.json();

                // Check if we got operations
                if (!data || !data.operations || data.operations.length === 0) {
                    console.log('No Wormhole operations found for this address');
                    return null;
                }

                // Find operation matching our transaction hash
                const txHashLower = txHash.toLowerCase();
                const matchingOp = data.operations.find(op =>
                    (op.sourceTx?.txHash && op.sourceTx.txHash.toLowerCase() === txHashLower) ||
                    (op.targetTx?.txHash && op.targetTx.txHash.toLowerCase() === txHashLower)
                );

                if (!matchingOp) {
                    console.log('No matching Wormhole operation found for this transaction');
                    return null;
                }

                console.log('✅ Found Wormhole operation:', matchingOp);

                // Map chain IDs to chain names (Wormhole chain IDs)
                const chainIdMap = {
                    1: 'solana', 2: 'ethereum', 4: 'bsc', 5: 'polygon',
                    6: 'avalanche', 10: 'fantom', 23: 'arbitrum', 24: 'optimism',
                    30: 'base'
                };

                const fromChain = chainIdMap[matchingOp.sourceChain?.chainId] || `chain-${matchingOp.sourceChain?.chainId}`;
                const toChain = chainIdMap[matchingOp.targetChain?.chainId] || `chain-${matchingOp.targetChain?.chainId}`;

                // Parse status
                const statusMap = {
                    'completed': { status: 'completed', message: 'Transfer completed' },
                    'pending': { status: 'pending', message: 'Transfer pending' },
                    'confirmed': { status: 'completed', message: 'Confirmed' }
                };

                const statusInfo = statusMap[matchingOp.status] || { status: 'unknown', message: matchingOp.status || 'Unknown' };

                return {
                    orderId: matchingOp.id,
                    fromChain: fromChain,
                    toChain: toChain,
                    fromAddress: matchingOp.sourceChain?.from || fromAddress,
                    toAddress: matchingOp.targetChain?.to || '',
                    fromAmount: matchingOp.data?.amount || 0,
                    toAmount: matchingOp.data?.amount || 0,
                    fromCurrency: matchingOp.data?.symbol || matchingOp.data?.tokenSymbol || '',
                    toCurrency: matchingOp.data?.symbol || matchingOp.data?.tokenSymbol || '',
                    depositHash: matchingOp.sourceTx?.txHash || txHash,
                    receiveHash: matchingOp.targetTx?.txHash || '',
                    status: statusInfo.status,
                    statusMessage: statusInfo.message,
                    protocol: 'Wormhole',
                    bridgeType: 'Token Bridge',
                    vaaId: matchingOp.vaa?.id || null,
                    hasRiskFlag: false // Wormhole doesn't provide risk flags
                };

            } catch (error) {
                console.error('Error querying Wormhole Scan API:', error);
                return null;
            }
        }

        /**
         * Query Synapse Protocol REST API for bridge transaction status
         * @param {string} txHash - Transaction hash on source chain
         * @returns {Promise<object|null>} - Synapse bridge details or null
         */
        async function querySynapseAPI(txHash) {
            try {
                console.log(`🔮 Querying Synapse Protocol API for ${txHash}...`);

                // Synapse REST API - bridgeTxStatus endpoint
                const apiUrl = `https://api.synapseprotocol.com/bridgeTxStatus?txHash=${txHash}`;

                const response = await fetch(apiUrl, {
                    method: 'GET',
                    headers: {
                        'Content-Type': 'application/json'
                    }
                });

                if (!response.ok) {
                    console.log(`Synapse API returned status ${response.status}`);
                    return null;
                }

                const data = await response.json();

                // Check if we got transaction data
                if (!data || !data.txn) {
                    console.log('No Synapse bridge transaction found');
                    return null;
                }

                const txn = data.txn;
                console.log('✅ Found Synapse bridge transaction:', txn);

                // Map chain IDs to chain names (Synapse uses standard chain IDs)
                const chainIdMap = {
                    1: 'ethereum', 56: 'bsc', 137: 'polygon', 42161: 'arbitrum',
                    10: 'optimism', 43114: 'avalanche', 250: 'fantom', 8453: 'base'
                };

                const fromChain = chainIdMap[txn.fromChainId] || `chain-${txn.fromChainId}`;
                const toChain = chainIdMap[txn.toChainId] || `chain-${txn.toChainId}`;

                // Parse status
                const statusMap = {
                    'completed': { status: 'completed', message: 'Bridge completed' },
                    'pending': { status: 'pending', message: 'Bridge pending' },
                    'failed': { status: 'failed', message: 'Bridge failed' }
                };

                const statusInfo = statusMap[txn.status] || { status: 'unknown', message: txn.status || 'Unknown' };

                return {
                    orderId: txn.kappa || txn.id,
                    fromChain: fromChain,
                    toChain: toChain,
                    fromAddress: txn.fromAddress || '',
                    toAddress: txn.toAddress || '',
                    fromAmount: txn.amount || 0,
                    toAmount: txn.toAmount || txn.amount || 0,
                    fromCurrency: txn.tokenSymbol || '',
                    toCurrency: txn.toTokenSymbol || txn.tokenSymbol || '',
                    depositHash: txn.fromHash || txHash,
                    receiveHash: txn.toHash || '',
                    status: statusInfo.status,
                    statusMessage: statusInfo.message,
                    protocol: 'Synapse Protocol',
                    bridgeType: 'Liquidity Network',
                    kappa: txn.kappa, // Synapse-specific identifier
                    hasRiskFlag: false // Synapse doesn't provide risk flags
                };

            } catch (error) {
                console.error('Error querying Synapse Protocol API:', error);
                return null;
            }
        }

        /**
         * Detect and store bridge provider info on an entry
         * @param {object} entry - The hop entry to check
         * @returns {object|null} - Bridge provider info if detected
         */
        function detectAndStoreBridgeProvider(entry) {
            if (!entry.toWallet || !entry.chain) return null;

            // Check if already detected
            if (entry.bridgeProvider) return entry.bridgeProvider;

            // Detect bridge provider
            const provider = detectBridgeProvider(entry.toWallet, entry.chain);

            if (provider) {
                // Store on entry
                entry.bridgeProvider = provider;
                console.log(`🌉 Detected ${provider.name} bridge on entry ${entry.id}`);
                return provider;
            }

            return null;
        }

        /**
         * Auto-trace bridge output by querying API and pre-filling dialog
         * @param {number} hopNumber - The hop number
         * @param {number} entryId - The entry ID
         */
        async function autoTraceBridge(hopNumber, entryId) {
            const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
            const entry = hop?.entries.find(e => e.id === entryId);

            if (!hop || !entry) {
                alert('Entry not found');
                return;
            }

            // Show loading indicator
            const loadingDiv = document.createElement('div');
            loadingDiv.id = 'bridgeLoadingIndicator';
            loadingDiv.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: white;
                padding: 30px;
                border-radius: 12px;
                box-shadow: 0 10px 40px rgba(0,0,0,0.2);
                z-index: 10000;
                text-align: center;
            `;
            const providerName = entry.bridgeProvider?.name || 'Bridge';
            loadingDiv.innerHTML = `
                <div style="font-size: 48px; margin-bottom: 15px;">🌉</div>
                <div style="font-size: 18px; font-weight: bold; color: #2c3e50;">Querying ${providerName} API...</div>
                <div style="color: #7f8c8d; margin-top: 10px;">Searching for bridge transaction</div>
            `;
            document.body.appendChild(loadingDiv);

            try {
                // Route to appropriate API based on provider
                let bridgeData = null;
                const provider = entry.bridgeProvider?.provider;

                if (provider === 'bridgers') {
                    bridgeData = await queryBridgersAPI(entry.fromWallet, entry.txHash);
                } else if (provider === 'layerzero') {
                    bridgeData = await queryLayerZeroAPI(entry.txHash);
                } else if (provider === 'stargate') {
                    bridgeData = await queryStargateAPI(entry.txHash);
                } else if (provider === 'wormhole') {
                    bridgeData = await queryWormholeAPI(entry.fromWallet, entry.txHash);
                } else if (provider === 'synapse') {
                    bridgeData = await querySynapseAPI(entry.txHash);
                } else {
                    // Fallback: try to detect and query
                    console.warn('Unknown bridge provider, attempting Bridgers API');
                    bridgeData = await queryBridgersAPI(entry.fromWallet, entry.txHash);
                }

                // Remove loading indicator
                loadingDiv.remove();

                if (!bridgeData) {
                    alert(`❌ Bridge transaction not found\n\nThis transaction may not have been processed by ${providerName} yet, or the transaction hash doesn't match their records.\n\nYou can still manually enter bridge details.`);
                    return;
                }

                // Check status
                if (bridgeData.status !== 'completed') {
                    const proceed = confirm(`⚠️ Bridge Status: ${bridgeData.statusMessage}\n\nThe bridge transaction is not yet complete. Would you like to see the details anyway?\n\nStatus: ${bridgeData.statusMessage}\nFrom: ${bridgeData.fromChain}\nTo: ${bridgeData.toChain}`);
                    if (!proceed) return;
                }

                // Show risk warning if flagged
                if (bridgeData.hasRiskFlag && bridgeData.refundReason) {
                    alert(`⚠️ RISK FLAG DETECTED!\n\n${bridgeData.refundReason}\n\nThis transaction was flagged by ${providerName} as risky. Proceed with caution.`);
                }

                // Store bridge data on entry
                entry.bridgeApiData = bridgeData;

                // Pre-fill bridge output dialog
                showBridgeOutputDialog(hopNumber, entryId, bridgeData);

            } catch (error) {
                loadingDiv.remove();
                console.error('Error auto-tracing bridge:', error);
                alert(`❌ Error querying bridge API\n\n${error.message}\n\nYou can still manually enter bridge details.`);
            }
        }

        /**
         * Show bridge output dialog with pre-filled data
         * @param {number} hopNumber - The hop number
         * @param {number} entryId - The entry ID
         * @param {object} bridgeData - Pre-filled bridge data (optional)
         */
        function showBridgeOutputDialog(hopNumber, entryId, bridgeData = null) {
            const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
            const entry = hop?.entries.find(e => e.id === entryId);

            if (!hop || !entry) return;

            // Store bridge data temporarily for pre-fill
            if (bridgeData) {
                window.pendingBridgeAutoFill = {
                    destinationChain: bridgeData.toChain.toLowerCase(),
                    destinationTxHash: bridgeData.receiveHash || '',
                    destinationWallet: bridgeData.toAddress || '',
                    destinationAmount: bridgeData.toAmount || 0,
                    destinationAsset: bridgeData.toCurrency || '',
                    explorerUrl: bridgeData.receiveExplorerUrl || '',
                    status: bridgeData.statusMessage || '',
                    hasRiskFlag: bridgeData.hasRiskFlag || false,
                    refundReason: bridgeData.refundReason || null
                };
            }

            // Call the existing function to show the bridge output dialog
            logBridgeOutput(hopNumber, entryId);
        }

        function saveUndoState(description) {
            try {
                // Deep clone the current investigation state
                // Use structured clone if available (more efficient for large objects)
                let clonedInvestigation;
                if (typeof structuredClone === 'function') {
                    // Modern browsers support structuredClone (faster and handles more types)
                    clonedInvestigation = structuredClone(investigation);
                } else {
                    // Fallback to JSON method
                    clonedInvestigation = JSON.parse(JSON.stringify(investigation));
                }

                const state = {
                    timestamp: new Date().toISOString(),
                    description: description,
                    investigation: clonedInvestigation
                };

                undoHistory.push(state);

                // Keep history size manageable and clean up old references
                if (undoHistory.length > MAX_UNDO_HISTORY) {
                    const removed = undoHistory.shift();
                    // Clear the reference to help garbage collection
                    if (removed) {
                        removed.investigation = null;
                    }
                }

                updateUndoButton();
            } catch (error) {
                console.error('Failed to save undo state:', error);
                // If we can't save undo state, continue operation but log error
            }
        }
        
        function performUndo() {
            if (undoHistory.length === 0) {
                alert('No actions to undo.');
                return;
            }
            
            const lastState = undoHistory.pop();
            
            // Restore the investigation state
            investigation = JSON.parse(JSON.stringify(lastState.investigation));
            
            // Re-render everything
            renderAll();
            updateUndoButton();
            
            alert(`Undone: ${lastState.description}`);
        }
        
        function updateUndoButton() {
            const undoButton = document.getElementById('undoButton');
            if (undoButton) {
                if (undoHistory.length > 0) {
                    const lastAction = undoHistory[undoHistory.length - 1];
                    undoButton.disabled = false;
                    undoButton.title = `Undo: ${lastAction.description}`;
                } else {
                    undoButton.disabled = true;
                    undoButton.title = 'No actions to undo';
                }
            }
        }
        
        // Navigation functions
        function showNavigationMenu() {
            const menuHTML = `
                <div id="navigationModal" class="modal" style="display: block;">
                    <div class="modal-content" style="max-width: 600px;">
                        <div class="modal-header" style="position: relative;">
                            <h2>Navigate to...</h2>
                            <button class="close-btn" onclick="closeNavigationMenu()" 
                                    style="position: absolute; right: 15px; top: 15px; width: 40px; height: 40px; 
                                           font-size: 28px; background: #e74c3c; color: white; border: none; 
                                           border-radius: 50%; cursor: pointer; display: flex; align-items: center; 
                                           justify-content: center; box-shadow: 0 2px 5px rgba(0,0,0,0.2); 
                                           transition: all 0.3s ease; font-weight: bold;"
                                    onmouseover="this.style.background='#c0392b'; this.style.transform='scale(1.1)'" 
                                    onmouseout="this.style.background='#e74c3c'; this.style.transform='scale(1)'"
                                    title="Close Navigation (ESC)">×</button>
                        </div>
                        <div style="max-height: 400px; overflow-y: auto;">
                            <h3 style="margin-top: 20px;">Quick Navigation</h3>
                            <div style="display: grid; gap: 10px; margin-bottom: 20px;">
                                <button class="btn" onclick="navigateTo('victims'); closeNavigationMenu();">
                                    👥 Victims & Transactions
                                </button>
                                <button class="btn" onclick="navigateTo('traces'); closeNavigationMenu();">
                                    Trace Documentation
                                </button>
                            </div>
                            
                            <h3>Hops</h3>
                            ${investigation.hops.length === 0 ? 
                                '<p style="color: #666;">No hops created yet</p>' :
                                investigation.hops.map(hop => `
                                    <div style="background: #f8f9fa; padding: 10px; margin-bottom: 10px; border-radius: 6px;">
                                        <div style="display: flex; justify-content: space-between; align-items: center;">
                                            <strong>Hop ${hop.hopNumber}</strong>
                                            <button class="btn btn-sm" onclick="navigateToHop(${hop.hopNumber}); closeNavigationMenu();">
                                                Go to Hop
                                            </button>
                                        </div>
                                        ${hop.entries.length > 0 ? `
                                            <div style="margin-top: 10px; padding-left: 20px;">
                                                ${hop.entries.map(entry => `
                                                    <div style="display: flex; justify-content: space-between; align-items: center; margin: 5px 0;">
                                                        <span style="font-size: 14px;">
                                                            Entry ${entry.id}: ${entry.notation || 'No notation'} 
                                                            ${parseFloat(entry.amount) > 0 ? `(${entry.amount} ${entry.currency})` : ''}
                                                        </span>
                                                        <button class="btn btn-sm" style="padding: 2px 8px; font-size: 12px;" 
                                                                onclick="navigateToEntry(${hop.hopNumber}, ${entry.id}); closeNavigationMenu();">
                                                            Edit
                                                        </button>
                                                    </div>
                                                `).join('')}
                                            </div>
                                        ` : '<p style="font-size: 14px; color: #666; margin-left: 20px;">No entries yet</p>'}
                                    </div>
                                `).join('')
                            }
                        </div>
                        <div style="padding: 20px; border-top: 2px solid #e8f0fe; text-align: center; background: #f8f9fa;">
                            <button class="btn" onclick="closeNavigationMenu()" 
                                    style="background: #95a5a6; color: white; padding: 10px 30px; font-size: 16px;">
                                Close Navigation
                            </button>
                            <div style="margin-top: 10px; font-size: 12px; color: #666;">
                                Tip: Press ESC to close quickly
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            createCenteredModal('navigationModal', menuHTML);
            
            // Add ESC key listener
            const escHandler = (e) => {
                if (e.key === 'Escape') {
                    closeNavigationMenu();
                    document.removeEventListener('keydown', escHandler);
                }
            };
            document.addEventListener('keydown', escHandler);
        }
        
        function closeNavigationMenu() {
            const modal = document.getElementById('navigationModal');
            if (modal) modal.remove();
        }
        
        function navigateTo(tab) {
            switchTab(tab);
            const tabButton = document.querySelector(`[onclick="switchTab('${tab}')"]`);
            if (tabButton) tabButton.click();
            updateBreadcrumbs();
        }
        
        function navigateToHop(hopNumber) {
            // Switch to traces tab
            navigateTo('traces');

            // Scroll to and highlight the hop
            setTimeout(() => {
                const hopElement = document.querySelector(`#hopContent_${hopNumber}`);
                if (hopElement) {
                    // Expand the hop if collapsed
                    window.hopCollapseState[hopNumber] = false;
                    hopElement.style.display = 'block';

                    // Scroll into view
                    hopElement.scrollIntoView({ behavior: 'smooth', block: 'center' });

                    // Highlight briefly
                    const hopContainer = hopElement.closest('.hop-container');
                    if (hopContainer) {
                        hopContainer.style.transition = 'background-color 0.3s';
                        hopContainer.style.backgroundColor = '#fffbcc';
                        setTimeout(() => {
                            hopContainer.style.backgroundColor = '';
                        }, 2000);
                    }
                }
            }, 100);
        }
        
        function navigateToEntry(hopNumber, entryId) {
            // First navigate to the hop
            navigateToHop(hopNumber);
            
            // Then expand and highlight the entry
            setTimeout(() => {
                const entryKey = `${hopNumber}_${entryId}`;
                
                // Expand the entry
                window.entryCollapseState[entryKey] = false;
                const content = document.getElementById(`entryContent_${entryKey}`);
                const summary = document.getElementById(`entrySummary_${entryKey}`);
                
                if (content && summary) {
                    content.style.display = 'block';
                    summary.style.display = 'none';
                    
                    // Scroll to entry
                    content.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    
                    // Highlight the entry
                    const entryContainer = content.closest('div[style*="background"]');
                    if (entryContainer) {
                        entryContainer.style.transition = 'transform 0.3s, box-shadow 0.3s';
                        entryContainer.style.transform = 'scale(1.02)';
                        entryContainer.style.boxShadow = '0 4px 20px rgba(52, 152, 219, 0.3)';
                        setTimeout(() => {
                            entryContainer.style.transform = '';
                            entryContainer.style.boxShadow = '';
                        }, 2000);
                    }
                }
            }, 200);
        }
        
        function updateBreadcrumbs() {
            const breadcrumbsEl = document.getElementById('breadcrumbs');
            if (!breadcrumbsEl) return;
            
            let breadcrumbs = [];
            
            // Get current tab
            const activeTab = document.querySelector('.nav-tab.active');
            if (activeTab) {
                breadcrumbs.push(activeTab.textContent);
            }
            
            // Add case info if available
            if (investigation.caseId) {
                breadcrumbs.unshift(`Case: ${investigation.caseId}`);
            }
            
            breadcrumbsEl.innerHTML = breadcrumbs.join(' › ');
        }
        
        // Reopen a completed hop for editing
        function reopenHop(hopNumber) {
            event.stopPropagation(); // Prevent hop collapse toggle

            const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
            if (!hop) return;

            // Mark hop as not completed to allow editing
            hop.completed = false;
            hop.isCollapsed = false;
            window.hopCollapseState[hop.hopNumber] = false;

            // Check for dependent hops
            const dependentHops = investigation.hops.filter(h => h.hopNumber > hop.hopNumber);
            
            if (dependentHops.length > 0) {
                // Build detailed warning about impacts
                let impactSummary = `⚠️ WARNING: Editing Hop ${hop.hopNumber} will impact downstream hops!\n\n`;
                impactSummary += `Affected hops: ${dependentHops.map(h => `Hop ${h.hopNumber}`).join(', ')}\n\n`;
                
                // Check which threads from this hop are used downstream
                const threadsFromThisHop = [];
                hop.entries.forEach(entry => {
                    const amount = parseAmount(entry.amount);
                    if (entry.notation && amount > 0) {
                        const threadId = entry.notation;
                        threadsFromThisHop.push({
                            threadId: threadId,
                            amount: amount,
                            currency: entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency
                        });
                    }
                });
                
                // Find which downstream entries use these threads
                let affectedEntries = [];
                dependentHops.forEach(downstreamHop => {
                    downstreamHop.entries.forEach(entry => {
                        const usesThreads = threadsFromThisHop.some(thread => 
                            entry.sourceThreadId === thread.threadId ||
                            (entry.multipleSourceThreads && entry.multipleSourceThreads.includes(thread.threadId))
                        );
                        
                        if (usesThreads) {
                            affectedEntries.push({
                                hop: downstreamHop.hopNumber,
                                entry: entry.notation || `Entry ${entry.id}`,
                                amount: entry.amount,
                                currency: entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency
                            });
                        }
                    });
                });
                
                if (affectedEntries.length > 0) {
                    impactSummary += `Entries that will need updating:\n`;
                    affectedEntries.forEach(ae => {
                        impactSummary += `• Hop ${ae.hop}, ${ae.entry}: ${ae.amount} ${ae.currency}\n`;
                    });
                }
                
                impactSummary += `\nChanges to Hop ${hop.hopNumber} may require you to:\n`;
                impactSummary += `• Update thread amounts in downstream hops\n`;
                impactSummary += `• Reassign source threads if entries are removed\n`;
                impactSummary += `• Recalculate ART for all affected hops\n\n`;
                impactSummary += `Do you want to continue?`;
                
                if (!confirm(impactSummary)) {
                    return;
                }
            } else {
                // No downstream hops affected
                if (!confirm(`Are you sure you want to reopen Hop ${hop.hopNumber} for editing?\n\nThis will allow you to add or modify entries.`)) {
                    return;
                }
            }
            
            // Save undo state with full context
            saveUndoState(`Reopen Hop ${hop.hopNumber} for editing`);
            
            // Mark hop as not finalized
            hop.isFinalized = false;
            
            // Mark all downstream hops as needing validation
            dependentHops.forEach(h => {
                h.needsValidation = true;
            });
            
            // Re-render to show edit controls
            renderHops();
            saveToStorage();
            
            // Expand the hop
            // hopNumber is already available as the function parameter
            window.hopCollapseState[hopNumber] = false;
            const hopContent = document.getElementById(`hopContent_${hopNumber}`);
            if (hopContent) {
                hopContent.style.display = 'block';

                // Scroll to the hop
                setTimeout(() => {
                    const hopContainer = hopContent.closest('.hop-container');
                    if (hopContainer) {
                        hopContainer.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }, 100);
            }
            
            if (dependentHops.length > 0) {
                alert(`Hop ${hop.hopNumber} is now open for editing.\n\nWARNING: Changes here will affect Hops ${dependentHops.map(h => h.hopNumber).join(', ')}.\n\nAfter making changes, you'll need to validate and update the downstream hops.`);
            } else {
                alert(`Hop ${hop.hopNumber} is now open for editing.`);
            }
        }
        // Validate and update a hop after upstream changes
        function validateAndUpdateHop(hopNumber) {
            const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
            if (!hop) return;
            
            // Find the previous hop to check available threads
            const previousHopNumber = hop.hopNumber - 1;
            const availableThreads = getAvailableSourcesForHop(hop.hopNumber, null);
            
            let validationReport = `Validation Report for Hop ${hop.hopNumber}\n\n`;
            let hasIssues = false;
            let fixableIssues = [];
            
            // Check each entry in this hop
            hop.entries.forEach(entry => {
                if (entry.entryType === 'trace') {
                    let entryIssues = [];
                    
                    // Check single source thread
                    if (entry.sourceThreadId) {
                        const threadAvailable = availableThreads.find(t => t.threadId === entry.sourceThreadId);
                        if (!threadAvailable) {
                            entryIssues.push(`Source thread ${entry.sourceThreadId} no longer exists`);
                            hasIssues = true;
                        } else if (threadAvailable.availableAmount < parseAmount(entry.amount)) {
                            entryIssues.push(`Source thread ${entry.sourceThreadId} only has ${threadAvailable.availableAmount} available (needs ${entry.amount})`);
                            hasIssues = true;
                            fixableIssues.push({
                                entryId: entry.id,
                                issue: 'insufficient_amount',
                                currentAmount: parseAmount(entry.amount),
                                availableAmount: threadAvailable.availableAmount
                            });
                        }
                    }
                    
                    // Check multiple source threads
                    if (entry.multipleSourceThreads && entry.multipleSourceThreads.length > 0) {
                        entry.multipleSourceThreads.forEach(threadId => {
                            const threadAvailable = availableThreads.find(t => t.threadId === threadId);
                            if (!threadAvailable) {
                                entryIssues.push(`Source thread ${threadId} no longer exists`);
                                hasIssues = true;
                            }
                        });
                        
                        // Check individual assignments
                        if (entry.individualSourceAssignments) {
                            Object.entries(entry.individualSourceAssignments).forEach(([threadId, amount]) => {
                                const threadAvailable = availableThreads.find(t => t.threadId === threadId);
                                if (threadAvailable && threadAvailable.availableAmount < amount) {
                                    entryIssues.push(`Thread ${threadId} only has ${threadAvailable.availableAmount} available (assigned ${amount})`);
                                    hasIssues = true;
                                }
                            });
                        }
                    }
                    
                    if (entryIssues.length > 0) {
                        validationReport += `Entry ${entry.notation || entry.id}:\n`;
                        entryIssues.forEach(issue => {
                            validationReport += `  • ${issue}\n`;
                        });
                        validationReport += '\n';
                    }
                }
            });
            
            if (!hasIssues) {
                hop.needsValidation = false;
                renderHops();
                saveToStorage();
                alert(`Hop ${hop.hopNumber} validated successfully!\n\nAll source threads are valid and have sufficient amounts.`);
                return;
            }
            
            // Show validation report and options
            validationReport += `\nOptions:\n`;
            validationReport += `1. Manually fix each issue by editing the affected entries\n`;
            validationReport += `2. Auto-adjust amounts to match available threads\n`;
            validationReport += `3. Cancel and leave as-is\n`;
            
            const choice = prompt(validationReport + '\nEnter your choice (1, 2, or 3):');
            
            if (choice === '2') {
                // Auto-adjust amounts
                saveUndoState(`Auto-adjust amounts in Hop ${hop.hopNumber}`);
                
                fixableIssues.forEach(fix => {
                    const entry = hop.entries.find(e => e.id === fix.entryId);
                    if (entry && fix.issue === 'insufficient_amount') {
                        entry.amount = fix.availableAmount.toString();
                    }
                });
                
                hop.needsValidation = false;
                renderHops();
                saveToStorage();
                
                alert(`Hop ${hop.hopNumber} has been auto-adjusted.\n\nAmounts have been reduced to match available thread values.`);
            } else if (choice === '1') {
                // Open hop for manual editing
                reopenHop(hopNumber);
            }
        }
        
        function initializeCompleteIntegration(data = investigation) {
    console.log('Initializing complete integration...');
    
    // Initialize Phase 3 fields if missing
    if (!data.availableThreads) {
        data.availableThreads = {};
    }
    if (!data.threadAssignments) {
        data.threadAssignments = {};
    }
    if (!data.sourceChainData) {
        data.sourceChainData = {};
    }
    if (data.enhancedNotationEnabled === undefined) {
        data.enhancedNotationEnabled = true;
    }
    
    // Initialize Part 4 fields if missing
    if (!data.validationHistory) {
        data.validationHistory = [];
    }
    if (!data.lastValidationTimestamp) {
        data.lastValidationTimestamp = null;
    }
    if (!data.threadValidationErrors) {
        data.threadValidationErrors = [];
    }
    if (!data.sourceChainReports) {
        data.sourceChainReports = [];
    }
    if (!data.integrationVersion) {
        data.integrationVersion = '4.0';
    }
    
    // Initialize standard fields if missing
    if (!data.conversions) {
        data.conversions = [];
    }
    if (!data.redWalletIndex) {
        data.redWalletIndex = [];
    }
    if (!data.universalWalletIndex) {
        data.universalWalletIndex = [];
    }
    if (!data.confirmedRootTotalsByCurrency) {
        data.confirmedRootTotalsByCurrency = {};
    }
    if (!data.currentART) {
        data.currentART = {};
    }
    if (data.rootTotalConfirmed === undefined) {
        data.rootTotalConfirmed = false;
    }
    if (data.confirmedRootTotal === undefined) {
        data.confirmedRootTotal = 0;
    }
    if (!data.created) {
        data.created = new Date().toISOString();
    }
    
    console.log('Complete integration initialized');
}
async function handleLoadFile() {
    console.log('Load file button clicked');

    // Try to use File System Access API if available
    if ('showOpenFilePicker' in window) {
        try {
            const [handle] = await window.showOpenFilePicker({
                types: [{
                    description: 'BATS Investigation Files',
                    accept: { 'application/json': ['.bats', '.json'] }
                }],
                multiple: false
            });

            // Store the file handle for future saves
            fileHandle = handle;

            // Read the file
            const file = await handle.getFile();
            const content = await file.text();

            // Process the file content (reuse existing logic)
            processLoadedFile(content);
            return;
        } catch (error) {
            if (error.name === 'AbortError') {
                console.log('User cancelled file selection');
                return;
            }
            console.error('File System Access API error:', error);
            // Fall back to traditional method
        }
    }

    // Fall back to traditional file input method
    const fileInput = document.getElementById('fileInput');
    if (fileInput) {
        console.log('File input found, triggering click');
        fileInput.click();
    } else {
        console.error('File input element not found');
        alert('Error: File input not found. Please refresh the page and try again.');
    }
}
        function validateEnhancedDataStructure() {
    const errors = [];
    
    if (!investigation.availableThreads) {
        errors.push('Missing availableThreads property');
    }
    if (!investigation.threadAssignments) {
        errors.push('Missing threadAssignments property');
    }
    if (!investigation.sourceChainData) {
        errors.push('Missing sourceChainData property');
    }
    
    investigation.hops.forEach((hop, hopIndex) => {
        hop.entries.forEach((entry, entryIndex) => {
            if (!Array.isArray(entry.sourceChain)) {
                errors.push(`Hop ${hopIndex + 1}, Entry ${entryIndex + 1}: Missing or invalid sourceChain`);
            }
            if (typeof entry.displayNotation !== 'string') {
                errors.push(`Hop ${hopIndex + 1}, Entry ${entryIndex + 1}: Missing displayNotation`);
            }
        });
    });
    
    return errors;
}

function renderHopEntry(entry, hop) {
    const isWriteoff = entry.entryType === 'writeoff';
    const isColdStorage = entry.entryType === 'cold_storage';
    const isTrace = entry.entryType === 'trace';
    
    // Get available source threads for this hop - pass null to get all currencies
    const availableSourceThreads = getAvailableSourcesForHop(entry.hopNumber, null);
    
    // Build source options with real-time amounts
    const sourceOptions = availableSourceThreads.map(source => {
        const dateStr = source.datetime ? 
            ` (${formatDateTimeForReport(source.datetime, source.timezone)})` : '';
        return `<option value="${source.threadId}" 
                ${entry.sourceThreadId === source.threadId ? 'selected' : ''}
                title="${source.displayText}${dateStr}">
            ${source.displayText} - ${source.availableAmount.toLocaleString()} ${source.currency} available${dateStr}
        </option>`;
    }).join('');
    
    // Calculate max amount for input field
    let maxAmount = 0;
    if (entry.multipleSourceThreads && entry.multipleSourceThreads.length > 0) {
        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
        entry.multipleSourceThreads.forEach(sourceId => {
            maxAmount += getMaxAssignableAmount(sourceId, currency);
        });
    } else if (entry.sourceThreadId) {
        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
        maxAmount = getMaxAssignableAmount(entry.sourceThreadId, currency);
    }
    
    // Visual flow indicators
    const isFinalized = entry.isFinalized || false;
    const hasAmount = parseFloat(entry.amount) > 0;
    const hasRequiredData = (isTrace && entry.txHash && entry.fromWallet && entry.toWallet) || 
                           (isWriteoff && hasAmount) || 
                           (isColdStorage && hasAmount);
    
    return `
        <div style="background: ${isFinalized ? '#f0f8ff' : hasRequiredData ? '#f8fdff' : '#fffbf0'}; 
                    border: 2px solid ${isFinalized ? '#4a90e2' : hasRequiredData ? '#5cb85c' : '#f0ad4e'}; 
                    border-left-width: 8px;
                    border-radius: 8px; 
                    padding: 20px; 
                    margin-bottom: 15px; 
                    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                    position: relative;
                    transition: all 0.3s ease;">
            
            <!-- Flow Arrow Indicator -->
            ${hasRequiredData && isTrace ? `
                <div style="position: absolute; right: -25px; top: 50%; transform: translateY(-50%); 
                            width: 40px; height: 40px; background: #5cb85c; border-radius: 50%;
                            display: flex; align-items: center; justify-content: center;
                            box-shadow: 0 2px 5px rgba(0,0,0,0.2);">
                    <span style="color: white; font-size: 20px;">→</span>
                </div>
            ` : ''}
            
            <div class="trace-header" style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 15px;">
                <div>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span class="trace-notation" style="font-size: 18px; font-weight: bold; color: #2c3e50;">
                            ${entry.notation || `Entry ${entry.id}`}
                        </span>
                        <span style="background: ${isWriteoff ? '#9e9e9e' : isColdStorage ? '#3498db' : '#5cb85c'}; 
                                   color: white; 
                                   padding: 4px 12px; 
                                   border-radius: 20px; 
                                   font-size: 12px; 
                                   font-weight: 600;">
                            ${entryTypes[entry.entryType]}
                        </span>
                    </div>
                    
                    <!-- Status Indicators -->
                    <div style="margin-top: 8px; display: flex; gap: 8px; flex-wrap: wrap;">
                        ${hasAmount ? 
                            `<span style="background: #27ae60; color: white; padding: 3px 10px; border-radius: 12px; font-size: 11px; display: inline-flex; align-items: center; gap: 4px;">
                                <span style="font-size: 14px;">✓</span> ${parseFloat(entry.amount).toLocaleString()} ${entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency || ''}
                            </span>` : 
                            `<span style="background: #e74c3c; color: white; padding: 3px 10px; border-radius: 12px; font-size: 11px;">⚠️ No amount</span>`}
                        
                        ${isTrace && entry.txHash ? 
                            `<span style="background: #3498db; color: white; padding: 3px 10px; border-radius: 12px; font-size: 11px;">📋 Tx: ${entry.txHash.substring(0, 8)}...</span>` : ''}
                        
                        ${entry.toWalletType ? 
                            `<span style="background: ${getWalletColor(entry.toWalletType)}; color: white; padding: 3px 10px; border-radius: 12px; font-size: 11px;">
                                ${walletTypes[entry.toWalletType] || entry.toWalletType}
                            </span>` : ''}
                    </div>
                </div>
                <div style="display: flex; gap: 8px;">
                    ${isTrace && !isFinalized ? `<button class="btn btn-primary" onclick="reopenHopWizard(${hop.hopNumber}, ${entry.id})" style="padding: 8px 15px;">🔄 Wizard</button>` : ''}
                    ${hasRequiredData && !isFinalized ? `<button class="btn btn-success" onclick="toggleEntryCollapse('${hop.hopNumber}_${entry.id}')" style="padding: 8px 15px;">✓ Finalize</button>` : ''}
                    <button class="btn btn-danger" onclick="removeHopEntry(${hop.hopNumber}, ${entry.id})" style="padding: 8px 15px;">✕</button>
                </div>
            </div>
            
            ${isTrace ? `
                <div class="form-group" style="background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%); padding: 20px; border-radius: 8px; border: 2px solid #2196f3; margin-bottom: 15px;">
                    <label style="font-weight: bold; color: #0d47a1; font-size: 16px;">Transaction Hash (Start Here)</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <input type="text"
                               id="txHash_${hop.hopNumber}_${entry.id}"
                               value="${entry.txHash || ''}"
                               placeholder="Paste transaction hash to auto-fill details"
                               onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'txHash', this.value)"
                               style="flex: 1; font-size: 16px; padding: 14px; border: 2px solid #2196f3;">
                        <button type="button"
                                class="btn btn-primary"
                                onclick="lookupHopTransaction(${hop.hopNumber}, ${entry.id})"
                                style="background: #2196f3; color: white; padding: 14px 20px; font-size: 16px; font-weight: bold;">
                            🔍 Auto-fill
                        </button>
                    </div>
                    <div style="font-size: 12px; color: #0d47a1; margin-top: 8px;">
                        Enter transaction hash above to automatically populate amount, wallets, and timestamp
                    </div>
                </div>
            ` : ''}
            
            <div class="form-group">
                <label>Entry Type</label>
                <select onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'entryType', this.value)">
                    ${Object.entries(entryTypes).map(([key, value]) => 
                        `<option value="${key}" ${entry.entryType === key ? 'selected' : ''}>${value}</option>`
                    ).join('')}
                </select>
                ${isColdStorage ? `
                    <div style="background: #e8f4f8; border: 1px solid #3498db; border-radius: 4px; padding: 10px; margin-top: 8px; font-size: 12px;">
                        <strong>Cold Storage:</strong> Funds remain in current wallet, classified as BLUE (cold storage). 
                        This accounts for the amount in ART without requiring further tracing.
                    </div>
                ` : ''}
            </div>
            
            ${!isWriteoff ? `
                <div class="form-group">
                    <label>Source Thread Selection ${availableSourceThreads.length > 1 ? '(Multiple allowed)' : ''}</label>
                    ${availableSourceThreads.length > 1 ? `
                        <!-- Multiple Source Thread Selection -->
                        <div style="background: #f8f9fa; border: 1px solid #ddd; border-radius: 4px; padding: 15px;">
                            <div style="margin-bottom: 10px; font-weight: bold;">Select source threads and allocate amounts:</div>
                            ${availableSourceThreads.map(source => {
                                const isSelected = entry.multipleSourceThreads && entry.multipleSourceThreads.includes(source.threadId);
                                const proposedAmount = entry.individualSourceAssignments && entry.individualSourceAssignments[source.threadId] || 0;
                                
                                return `
                                    <div style="margin-bottom: 12px;">
                                        <!-- Source Selection Row -->
                                        <div style="padding: 8px; background: white; border-radius: 3px; border: 1px solid ${isSelected ? '#3498db' : '#ddd'};">
                                            <input type="checkbox" 
                                                value="${source.threadId}" 
                                                ${isSelected ? 'checked' : ''}
                                                onchange="updateMultipleSourceSelection(${hop.hopNumber}, ${entry.id})"
                                                style="margin-right: 10px; vertical-align: middle;"> 
                                            <span style="font-weight: bold; color: #2c3e50;">${source.displayText} - ${source.availableAmount.toLocaleString()} ${source.currency} available</span>
                                        </div>
                                        
                                        <!-- Amount Input Row (only show if selected) -->
                                        ${isSelected ? `
                                            <div style="margin-top: 6px; margin-left: 30px; display: flex; align-items: center; gap: 8px;">
                                                <span style="font-size: 12px; color: #666; min-width: 80px;">Allocate:</span>
                                                <input type="number" 
                                                    step="${getCurrencyStep(source.currency)}" 
                                                    min="0" 
                                                    max="${source.availableAmount}"
                                                    value="${proposedAmount}"
                                                    style="width: 120px; padding: 4px 6px; border: 1px solid #ddd; border-radius: 3px;"
                                                    onchange="updateIndividualSourceAssignment(${hop.hopNumber}, ${entry.id}, '${source.threadId}', this.value)"
                                                    placeholder="0.00">
                                                <button type="button" 
                                                        onclick="assignMaxToIndividualSource(${hop.hopNumber}, ${entry.id}, '${source.threadId}')"
                                                        style="padding: 4px 8px; font-size: 11px; background: #3498db; color: white; border: none; border-radius: 3px; cursor: pointer;">
                                                    Max
                                                </button>
                                                <span style="font-size: 11px; color: #666;">
                                                    (${(source.availableAmount - proposedAmount).toLocaleString()} would remain)
                                                </span>
                                            </div>
                                        ` : ''}
                                    </div>
                                `;
                            }).join('')}
                            
                            <!-- Preview for multiple sources -->
                            <div id="multipleSourcePreview_${hop.hopNumber}_${entry.id}"></div>
                        </div>
                    ` : `
                        <!-- Single Source Thread Selection -->
                        <select id="sourceSelect_${hop.hopNumber}_${entry.id}" 
                                onchange="handleSourceSelection(${hop.hopNumber}, ${entry.id}, this.value)">
                            <option value="">Select source thread...</option>
                            ${sourceOptions}
                        </select>
                        ${entry.sourceThreadId ? `
                            <div style="margin-top: 8px; padding: 10px; background: #e8f4f8; border-radius: 4px;">
                                <strong>Selected:</strong> ${entry.sourceThreadId}<br>
                                <small style="color: #666;">You can allocate any portion of the available amount</small>
                            </div>
                        ` : ''}
                    `}
                </div>
            ` : ''}
            
            ${isTrace && availableSourceThreads.length > 0 ? `
            <!-- Smart Allocation Button -->
            <div class="form-group" style="text-align: center; margin: 20px 0;">
                <button type="button" 
                        class="btn btn-confirm"
                        onclick="openSmartAllocationModal(${hop.hopNumber}, ${entry.id})"
                        style="background: linear-gradient(135deg, #27ae60 0%, #219a52 100%); padding: 12px 30px;">
                    🎯 Smart Amount Allocation - Auto-Calculate Source Usage
                </button>
                <div style="font-size: 11px; color: #666; margin-top: 8px;">
                    ${availableSourceThreads.length > 1 
                        ? `You have ${availableSourceThreads.length} fund sources. This tool helps split the transaction amount across them.`
                        : `Calculate how much of the available ${availableSourceThreads[0]?.availableAmount.toLocaleString()} ${availableSourceThreads[0]?.currency} to use`
                    }
                </div>
                <div style="background: #e8f5e8; border: 1px solid #27ae60; border-radius: 4px; padding: 8px; margin-top: 8px; font-size: 11px;">
                    <strong>💡 When to use:</strong> You know the transaction amount from the blockchain, but need help determining 
                    which victim funds were used. The tool follows FIFO (First In, First Out) to match real blockchain behavior.
                </div>
            </div>
            ` : ''}
            
            <div class="form-group">
                <label>${isWriteoff ? 'Write-off Amount' : isColdStorage ? 'Cold Storage Amount' : 'Trace Amount'}</label>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="number" step="${getCurrencyStep(entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency)}" 
                           id="assignAmount_${hop.hopNumber}_${entry.id}"
                           value="${entry.amount || ''}"
                           max="${maxAmount}"
                           onchange="updateAssignmentAmount(${hop.hopNumber}, ${entry.id}, this.value)">
                    <button type="button" class="btn btn-secondary" 
                            onclick="${isWriteoff ? 'assignMaxWriteoffAmount' : 'assignMaxAmount'}(${hop.hopNumber}, ${entry.id})"
                            ${!isWriteoff && !entry.sourceThreadId ? 'disabled' : ''}>
                        ${isWriteoff ? 'Balance ART' : 'Max'}
                    </button>
                </div>
                <div style="font-size: 11px; color: #666; margin-top: 5px;">
                    ${isWriteoff ? 'Amount to write off from ART' : isColdStorage ? 'Amount remaining in cold storage' : 'Amount to trace forward'}
                    ${!isWriteoff && !isColdStorage && entry.sourceThreadId && maxAmount > 0 ? 
                        `<br><span style="color: #3498db;">💡 You can allocate any amount up to ${maxAmount.toLocaleString()} ${entry.currency || 'units'}</span>` : ''
                    }
                    ${!isWriteoff && entry.sourceThreadId ? 
                        `<br><span style="background: #e8f0fe; padding: 4px 8px; border-radius: 3px; display: inline-block; margin-top: 5px;">
                            <strong>Max button:</strong> Quickly allocates ALL available funds from selected source(s). 
                            Use when you want to trace the entire amount forward.
                        </span>` : ''
                    }
                </div>
                <div id="assignmentPreview_${hop.hopNumber}_${entry.id}" 
                     style="font-size: 12px; margin-top: 5px;"></div>
            </div>

            <div class="form-group">
                <label>Notation Builder</label>
                <div style="display: flex; align-items: center; gap: 5px; font-family: monospace; font-weight: bold;">
                    <span>V</span>
                    <input type="text" style="width: 60px; text-align: center;" 
                           placeholder="1" 
                           value="${entry.victimNumbers || ''}"
                           onchange="updateNotationField(${hop.hopNumber}, ${entry.id}, 'victims', this.value)">
                    <span>-T</span>
                    <input type="text" style="width: 80px; text-align: center;" 
                           placeholder="1,2,3" 
                           value="${entry.transactionNumbers || ''}"
                           onchange="updateNotationField(${hop.hopNumber}, ${entry.id}, 'transactions', this.value)">
                    <span>-H${entry.hopNumber}${isWriteoff ? '-WO' : isColdStorage ? '-CS' : ''}</span>
                </div>
                <div style="font-size: 12px; color: #666; margin-top: 5px;">
                    Preview: <span id="notation_preview_${hop.hopNumber}_${entry.id}" style="font-family: monospace; font-weight: bold;">${entry.notation || 'Enter V and T numbers'}</span>
                </div>
            </div>
            
            <div class="form-group">
                <label>Currency</label>
                <div style="padding: 10px; background: #f8f9fa; border: 1px solid #ddd; border-radius: 4px;">
                    <strong>${entry.currency ? (entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency) : '---'}</strong>
                    ${entry.sourceThreadId ? `
                        <div style="font-size: 11px; color: #666; margin-top: 5px;">
                            Currency inherited from source thread: ${entry.sourceThreadId}
                        </div>
                    ` : `
                        <div style="font-size: 11px; color: #e74c3c; margin-top: 5px;">
                            ⚠️ Select a source thread to set currency
                        </div>
                    `}
                </div>
                ${entry.toWalletType === 'brown' ? `
                    <div style="margin-top: 10px; padding: 10px; background: #fff3cd; border: 1px solid #ffc107; border-radius: 4px;">
                        <strong>Asset Conversion Detected</strong><br>
                        <small>Brown wallet allows currency conversion. Use the conversion modal to change currency.</small>
                    </div>
                ` : ''}
            </div>
            
            ${isTrace ? `
                <div class="form-group">
                    <label>To Wallet Address</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <div class="wallet-autocomplete-container" style="flex: 1;">
                            <input type="text" 
                                   id="toWallet_${hop.hopNumber}_${entry.id}"
                                   value="${entry.toWallet || ''}" 
                                   placeholder="Select existing or enter new wallet address"
                                   onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'toWallet', this.value)"
                                   oninput="handleWalletAutocomplete(this, ${hop.hopNumber}, ${entry.id})"
                                   onblur="checkWalletEntity(this.value, ${hop.hopNumber}, ${entry.id})"
                                   autocomplete="off"
                                   list="walletList_${hop.hopNumber}_${entry.id}"
                                   style="width: 100%;">
                            <div id="autocomplete_${hop.hopNumber}_${entry.id}" class="wallet-autocomplete-dropdown"></div>
                        </div>
                        <datalist id="walletList_${hop.hopNumber}_${entry.id}">
                            ${(investigation.universalWalletIndex || []).map(wallet => `
                                <option value="${wallet.address}">
                                    ${wallet.permanentId} - ${wallet.address.substring(0, 20)}...
                                </option>
                            `).join('')}
                        </datalist>
                        <button type="button" class="btn btn-secondary" style="padding: 6px 12px; font-size: 12px;"
                                onclick="showWalletSelector(${hop.hopNumber}, ${entry.id})">
                            📋 Browse
                        </button>
                    </div>
                    <div style="font-size: 11px; color: #666; margin-top: 5px;">
                        Type to search existing wallets or enter a new address
                    </div>
                    <div id="entityInfo_${hop.hopNumber}_${entry.id}" style="display: none; margin-top: 10px; padding: 10px; background: #f3e6ff; border: 2px solid #9b59b6; border-radius: 4px;">
                        <!-- Entity information will be displayed here -->
                    </div>
                </div>
                <div class="form-group">
                    <label>To Wallet Classification</label>
                    <select onchange="updateHopEntryWalletType(${hop.hopNumber}, ${entry.id}, this.value)">
                        <option value="">Select classification...</option>
                        ${Object.entries(walletTypes).filter(([key]) => key !== 'red').map(([key, value]) => 
                            `<option value="${key}" ${entry.toWalletType === key ? 'selected' : ''}>${value}</option>`
                        ).join('')}
                    </select>
                </div>
                <!-- Transaction hash moved to top of form -->
                <div class="form-group">
                    <label>Timestamp with Timezone</label>
                    <div class="datetime-timezone">
                        <input type="datetime-local" 
                               id="timestamp_${hop.hopNumber}_${entry.id}"
                               value="${entry.timestamp || ''}" 
                               onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'timestamp', this.value)">
                        <select onchange="onTimezoneChange('timestamp_${hop.hopNumber}_${entry.id}', 'hop', ${hop.hopNumber}, ${entry.id})">
                            ${Object.entries(timezones).map(([key, value]) => 
                                `<option value="${key}" ${entry.timezone === key ? 'selected' : ''}>${value}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
            ` : ''}
            
            ${isColdStorage ? `
                <div class="form-group">
                    <label>Current Wallet Address</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <input type="text" 
                               id="toWallet_${hop.hopNumber}_${entry.id}"
                               list="walletList_${hop.hopNumber}_${entry.id}"
                               value="${entry.toWallet || entry.fromWallet || ''}" 
                               placeholder="Select existing or enter new wallet address"
                               onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'toWallet', this.value)"
                               style="flex: 1;">
                        <button type="button" class="btn btn-secondary" style="padding: 6px 12px; font-size: 12px;"
                                onclick="showWalletSelector(${hop.hopNumber}, ${entry.id})">
                            📋 Browse
                        </button>
                    </div>
                    <div style="font-size: 11px; color: #666; margin-top: 5px;">
                        Wallet where ${formatNumber(entry.amount || '0')} ${entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency} remains in cold storage
                    </div>
                </div>
                <div class="form-group">
                    <label>Cold Storage Classification</label>
                    <select onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'toWalletType', this.value)">
                        <option value="blue" ${entry.toWalletType === 'blue' ? 'selected' : ''}>BLUE - Cold Storage</option>
                    </select>
                    <div style="font-size: 11px; color: #666; margin-top: 5px;">
                        Cold storage is automatically classified as BLUE wallet type
                    </div>
                </div>
            ` : ''}
            
            ${isWriteoff && !isFinalized ? `
                <div class="form-group">
                    <label>Write-off Category</label>
                    <select onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'category', this.value)">
                        <option value="">Select category...</option>
                        ${Object.entries(writeoffCategories).map(([key, value]) =>
                            `<option value="${key}" ${entry.category === key ? 'selected' : ''}>${value}</option>`
                        ).join('')}
                    </select>
                </div>
                <div class="form-group" style="grid-column: span 2;">
                    <label>Justification</label>
                    <textarea rows="3" placeholder="Detailed explanation for abandoning this trace path..."
                              onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'justification', this.value)">${entry.justification || ''}</textarea>
                </div>
            ` : isWriteoff && isFinalized ? `
                <div style="background: #f5f5f5; padding: 15px; border-radius: 6px; margin-top: 10px;">
                    <h4 style="color: #e74c3c; margin: 0 0 10px 0;">📝 Write-off Details</h4>
                    <div style="display: grid; gap: 10px;">
                        <div><strong>Category:</strong> ${writeoffCategories[entry.category] || entry.category || 'Unspecified'}</div>
                        <div><strong>Justification:</strong> ${entry.justification || 'No justification provided'}</div>
                        <div><strong>Amount:</strong> ${parseFloat(entry.amount).toLocaleString()} ${entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency}</div>
                        ${entry.notation ? `<div><strong>Notation:</strong> ${entry.notation}</div>` : ''}
                    </div>
                </div>
            ` : isColdStorage ? `
                <div class="form-group" style="grid-column: span 2;">
                    <label>Cold Storage Notes</label>
                    <textarea rows="2" placeholder="Details about why funds remain in cold storage..." 
                              onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'notes', this.value)">${entry.notes || ''}</textarea>
                </div>
            ` : `
                <div class="form-group" style="grid-column: span 2;">
                    <label>Notes</label>
                    <textarea rows="2" placeholder="PIFO application, convergence notes, etc." 
                              onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'notes', this.value)">${entry.notes || ''}</textarea>
                </div>
            `}
            
            <!-- Log Entry Button (only show if not finalized) -->
            ${!isFinalized ? `
                <div style="margin-top: 20px; text-align: center; border-top: 2px solid #e8f0fe; padding-top: 20px;">
                    <button class="btn btn-confirm" onclick="logAndCollapseEntry(${hop.hopNumber}, ${entry.id})"
                            style="padding: 12px 30px; font-size: 16px; background: #27ae60;">
                        ✅ Log Entry
                    </button>
                    <p style="margin-top: 10px; font-size: 12px; color: #666;">
                        This will save and collapse the entry. You can click the header to expand it again.
                    </p>
                </div>
            ` : ''}
        </div>
    `;
}
function initializeEnhancedInvestigation() {
    if (!investigation.availableThreads) {
        investigation.availableThreads = {};
    }
    if (!investigation.threadAssignments) {
        investigation.threadAssignments = {};
    }
    if (!investigation.sourceChainData) {
        investigation.sourceChainData = {};
    }
    if (!investigation.enhancedNotationEnabled) {
        investigation.enhancedNotationEnabled = true;
    }
}

function migrateToEnhancedStructure() {
    initializeEnhancedInvestigation();
    
    investigation.hops.forEach(hop => {
        hop.entries.forEach(entry => {
            if (!entry.sourceChain) entry.sourceChain = [];
            if (!entry.displayNotation) entry.displayNotation = '';
            if (!entry.summaryNotation) entry.summaryNotation = '';
            if (!entry.victimNumbers) entry.victimNumbers = '';
            if (!entry.transactionNumbers) entry.transactionNumbers = '';
            if (!entry.availableSourceAmount) entry.availableSourceAmount = 0;
            if (!entry.sourceThreadId) entry.sourceThreadId = '';
            if (!entry.sourceThreadData) entry.sourceThreadData = null;
            if (!entry.assignmentPercentage) entry.assignmentPercentage = 0;
            if (!entry.generatedNotation) entry.generatedNotation = '';
            if (entry.isConvergence === undefined) entry.isConvergence = false;
            if (!entry.convergenceData) entry.convergenceData = null;
        });
    });
    
    console.log('Investigation migrated to enhanced structure');
    saveToStorage();
}
// =================================
// PHASE 2: CORE THREAD TRACKING FUNCTIONS
// =================================

// Generate unique internal ID for threads
function generateInternalThreadId(notation, currency, forceUnique = false) {
    // For bridge outputs and swaps, we want deterministic IDs based on notation
    // so that multiple bridge outputs with same notation update the same thread
    if (forceUnique) {
        // Original behavior for when we truly need unique IDs
        const timestamp = Date.now();
        const random = Math.random().toString(36).substring(2, 8);
        return `${notation}_${currency}_${timestamp}_${random}`;
    } else {
        // Deterministic ID based on notation and currency only
        // This allows bridge outputs to find and update existing threads
        return `${notation}_${currency}`;
    }
}

// Check if we're using the legacy system (threads indexed by notation)
function isLegacyThreadSystem() {
    if (!investigation.availableThreads) return false;

    // Check if any thread lacks internalId - indicates legacy system
    for (const currency in investigation.availableThreads) {
        for (const key in investigation.availableThreads[currency]) {
            const thread = investigation.availableThreads[currency][key];
            if (!thread.internalId) return true;
        }
    }
    return false;
}

// Migrate from legacy notation-based system to dual-layer system
function migrateThreadsToDualLayer() {
    if (!isLegacyThreadSystem()) {
        console.log('Already using dual-layer system');
        return;
    }

    console.log('Migrating to dual-layer thread system...');
    const newThreads = {};

    // Migrate existing threads
    for (const currency in investigation.availableThreads) {
        newThreads[currency] = {};

        for (const notation in investigation.availableThreads[currency]) {
            const thread = investigation.availableThreads[currency][notation];

            // Generate internal ID if missing
            if (!thread.internalId) {
                thread.internalId = generateInternalThreadId(notation, currency);
                thread.notation = notation;
            }

            // Re-index by internal ID
            newThreads[currency][thread.internalId] = thread;
        }
    }

    investigation.availableThreads = newThreads;
    console.log('Thread migration complete');
}

// Consolidate duplicate threads with the same notation
function consolidateDuplicateThreads() {
    if (!investigation.availableThreads) return 0;

    console.log('Consolidating duplicate threads...');
    let duplicatesFound = 0;

    for (const currency in investigation.availableThreads) {
        const threads = investigation.availableThreads[currency];
        const threadsByNotation = {};
        const threadsToDelete = [];

        // Group threads by notation
        for (const threadId in threads) {
            const thread = threads[threadId];
            if (!thread.notation) continue;

            if (!threadsByNotation[thread.notation]) {
                threadsByNotation[thread.notation] = [];
            }
            threadsByNotation[thread.notation].push({ id: threadId, thread });
        }

        // Consolidate duplicates
        for (const notation in threadsByNotation) {
            const duplicates = threadsByNotation[notation];
            if (duplicates.length > 1) {
                console.log(`Found ${duplicates.length} threads with notation ${notation} in ${currency}`);
                duplicatesFound += duplicates.length - 1;

                // Keep the thread with highest amount or most recent
                let keepThread = duplicates[0];
                for (let i = 1; i < duplicates.length; i++) {
                    if (duplicates[i].thread.totalAmount > keepThread.thread.totalAmount) {
                        threadsToDelete.push(keepThread.id);
                        keepThread = duplicates[i];
                    } else {
                        threadsToDelete.push(duplicates[i].id);
                    }
                }

                // Update the kept thread to use deterministic ID
                const deterministicId = generateInternalThreadId(notation, currency, false);
                if (keepThread.id !== deterministicId) {
                    threads[deterministicId] = keepThread.thread;
                    keepThread.thread.internalId = deterministicId;
                    threadsToDelete.push(keepThread.id);
                }
            }
        }

        // Delete duplicate threads
        for (const threadId of threadsToDelete) {
            delete threads[threadId];
        }
    }

    if (duplicatesFound > 0) {
        console.log(`Consolidated ${duplicatesFound} duplicate threads`);
        showNotification(`✅ Consolidated ${duplicatesFound} duplicate threads`, 'success', 3000);
    }

    return duplicatesFound;
}

// Helper function to get thread by notation
function getThreadByNotation(notation) {
    if (!notation || !investigation.availableThreads) return null;

    // Search through all currencies
    for (const currency in investigation.availableThreads) {
        for (const threadId in investigation.availableThreads[currency]) {
            const thread = investigation.availableThreads[currency][threadId];
            if (thread.notation === notation) {
                return thread;
            }
        }
    }

    return null;
}

// 2.1 Build Available Threads Index
function buildAvailableThreadsIndex() {
    // Check if we need to migrate existing data
    if (investigation.availableThreads && isLegacyThreadSystem()) {
        migrateThreadsToDualLayer();
        // After migration, the existing threads are preserved, so return
        // The rest of the function only needs to run if we're rebuilding from scratch
        return;
    }

    // CRITICAL FIX: Preserve manually created swap and bridge output threads
    // Store existing swap/bridge output threads before rebuilding
    const existingSwapOutputs = {};
    if (investigation.availableThreads) {
        for (const currency in investigation.availableThreads) {
            for (const threadKey in investigation.availableThreads[currency]) {
                const thread = investigation.availableThreads[currency][threadKey];
                // Preserve swap output threads and bridge output threads that were manually created
                if (thread.sourceType === 'swap_output' || thread.swapConverted ||
                    thread.sourceType === 'bridge_output' || thread.bridgeConverted) {
                    if (!existingSwapOutputs[currency]) {
                        existingSwapOutputs[currency] = {};
                    }
                    existingSwapOutputs[currency][threadKey] = thread;
                }
            }
        }
    }

    investigation.availableThreads = {};

    // Restore preserved swap output threads
    for (const currency in existingSwapOutputs) {
        if (!investigation.availableThreads[currency]) {
            investigation.availableThreads[currency] = {};
        }
        for (const threadKey in existingSwapOutputs[currency]) {
            investigation.availableThreads[currency][threadKey] = existingSwapOutputs[currency][threadKey];
        }
    }

    // Start with ALL victim transactions (RED wallets) from ALL victims
    investigation.victims.forEach(victim => {
        victim.transactions.forEach(transaction => {
            if (parseFloat(transaction.amount) > 0 && transaction.receivingWallet) {
                const currency = transaction.currency === 'CUSTOM' ?
                    transaction.customCurrency : transaction.currency;
                const notation = `V${victim.id}-T${transaction.id}`;
                const internalId = generateInternalThreadId(notation, currency);

                if (!investigation.availableThreads[currency]) {
                    investigation.availableThreads[currency] = {};
                }

                // Index by internal ID, but store notation for display
                investigation.availableThreads[currency][internalId] = {
                    // Dual-layer tracking
                    notation: notation,              // Human-readable (V-T-H)
                    internalId: internalId,          // Unique identifier

                    // Standard fields
                    totalAmount: roundAmount(parseFloat(transaction.amount)),
                    availableAmount: roundAmount(parseFloat(transaction.amount)),
                    assignments: [],
                    sourceWallet: transaction.receivingWallet,
                    sourceType: 'victim_transaction',
                    hopLevel: 0,
                    createdAt: transaction.datetime || new Date().toISOString(),
                    isActive: true,
                    parentThreads: [],
                    childThreads: [],
                    currency: currency,
                    victimId: victim.id,
                    transactionId: transaction.id,

                    // Chain tracking - store blockchain info internally
                    chainId: transaction.chain || null,  // Store the blockchain type
                    chainName: transaction.chain ? (window.blockchainAPIs?.[transaction.chain]?.name || transaction.chain) : null
                };
            }
        });
    });
    
    // First, collect ALL swapped thread IDs across ALL hops (global)
    const globalSwappedThreadIds = new Set();
    investigation.hops.forEach(hop => {
        hop.entries.forEach(entry => {
            if (entry.entryType === 'swap') {
                if (entry.sourceThreadId) {
                    globalSwappedThreadIds.add(entry.sourceThreadId);
                } else if (entry.multipleSourceThreads) {
                    entry.multipleSourceThreads.forEach(id => globalSwappedThreadIds.add(id));
                }
            }
        });
    });

    // Process ALL hop entries to update available threads
    investigation.hops.forEach(hop => {
        // Also collect swapped thread IDs within this hop (for backward compatibility)
        const swappedThreadIds = new Set();
        hop.entries.forEach(entry => {
            if (entry.entryType === 'swap') {
                if (entry.sourceThreadId) {
                    swappedThreadIds.add(entry.sourceThreadId);
                } else if (entry.multipleSourceThreads) {
                    entry.multipleSourceThreads.forEach(id => swappedThreadIds.add(id));
                }
            }
        });

        // IMPORTANT: Process swaps FIRST, then traces
        // This ensures swaps replace threads before traces try to use them

        // First pass: Process all swaps to update thread currencies
        hop.entries.forEach(entry => {
            if (entry.entryType === 'swap' && entry.swapDetails) {
                // Check if this swap has already been processed
                if (!entry._swapProcessed) {
                    // For swap entries, we need to handle the currency conversion
                    // The output replaces the input thread with new currency
                    console.log(`Processing swap entry in hop ${hop.hopNumber}:`, entry);
                    // Make sure the entry has the hop number
                    if (!entry.hopNumber) {
                        entry.hopNumber = hop.hopNumber;
                    }
                    updateThreadAvailabilityFromSwap(entry);
                    // Mark as processed to prevent duplicate processing
                    entry._swapProcessed = true;
                } else {
                    console.log('Skipping already processed swap entry:', entry.id);
                }
            }
        });

        // Second pass: Process traces and change entries (after swaps have updated threads)
        hop.entries.forEach(entry => {
            // Handle change entries - create same-hop threads
            if (entry.entryType === 'change' && parseFloat(entry.amount) > 0 && entry.notation) {
                console.log(`Processing change entry: ${entry.notation} with ${entry.amount} ${entry.currency}`);

                // Change entries create threads at the SAME hop level (like swaps)
                // They consume the source thread and create a new thread available for the current hop
                const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;

                if (!investigation.availableThreads[currency]) {
                    investigation.availableThreads[currency] = {};
                }

                // Generate internal ID for the change thread
                const newInternalId = generateInternalThreadId(entry.notation, currency);

                // Inherit chain from parent threads if not set on entry
                let chainId = entry.chain || null;
                let chainName = entry.chain ? (window.blockchainAPIs?.[entry.chain]?.name || entry.chain) : null;

                if (!chainId) {
                    // Try to inherit from parent threads
                    const parentIds = entry.multipleSourceInternalIds || [entry.sourceThreadInternalId];
                    for (const parentId of parentIds) {
                        // Look through all currencies for parent thread
                        for (const curr in investigation.availableThreads) {
                            const parentThread = investigation.availableThreads[curr]?.[parentId];
                            if (parentThread && parentThread.chainId) {
                                chainId = parentThread.chainId;
                                chainName = parentThread.chainName;
                                console.log(`Change entry inherited chain ${chainId} from parent thread`);
                                break;
                            }
                        }
                        if (chainId) break;
                    }
                }

                // Create the change thread at the same hop level
                investigation.availableThreads[currency][newInternalId] = {
                    notation: entry.notation,
                    internalId: newInternalId,
                    totalAmount: roundAmount(parseFloat(entry.amount)),
                    availableAmount: roundAmount(parseFloat(entry.amount)),
                    assignments: [],
                    sourceWallet: entry.toWallet,
                    sourceType: 'change_output',
                    hopLevel: hop.hopNumber - 1, // Same hop level as source
                    createdAt: entry.timestamp || new Date().toISOString(),
                    isActive: true,
                    currency: currency,
                    isChange: true,
                    parentInternalIds: entry.multipleSourceInternalIds || [entry.sourceThreadInternalId],
                    parentNotations: entry.multipleSourceThreads || [entry.sourceThreadId],

                    // Chain tracking - inherit from entry or parent
                    chainId: chainId,
                    chainName: chainName
                };

                console.log(`Created change thread ${entry.notation} in ${currency} with ${entry.amount} at hop level ${hop.hopNumber - 1}`);
            }
            // Handle write-off entries - they consume threads but don't create new ones
            else if (entry.entryType === 'writeoff' && parseFloat(entry.amount) > 0) {
                const writeoffCurrency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                console.log(`Processing write-off entry: ${entry.notation} for ${entry.amount} ${writeoffCurrency}`);

                // Write-offs consume source threads just like terminal entries
                if (entry.individualSourceAssignments && typeof entry.individualSourceAssignments === 'object') {
                    Object.entries(entry.individualSourceAssignments).forEach(([threadId, allocatedAmount]) => {
                        // Find the thread and deduct the allocated amount
                        for (const curr in investigation.availableThreads) {
                            const thread = investigation.availableThreads[curr][threadId];
                            if (thread) {
                                const amountUsed = parseFloat(allocatedAmount) || 0;
                                console.log(`Write-off: Deducting ${amountUsed} from thread ${threadId} (had ${thread.availableAmount} available)`);

                                // Use proper rounding to avoid floating point errors
                                thread.availableAmount = roundAmount(Math.max(0, thread.availableAmount - amountUsed));

                                // Mark as exhausted if less than 0.01 remains
                                if (thread.availableAmount < 0.01) {
                                    thread.availableAmount = 0;
                                    thread.fullyExhausted = true;
                                    thread.exhaustedByWriteoff = entry.notation;
                                    console.log(`Thread ${threadId} fully exhausted by write-off`);
                                } else {
                                    console.log(`Thread ${threadId} has ${thread.availableAmount} remaining after write-off`);
                                }
                            }
                        }
                    });
                }
            }
            // Handle regular trace entries
            else if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0 && entry.notation) {
                // Don't create thread if this trace has been swapped (check both local and global)
                if (!swappedThreadIds.has(entry.notation) && !globalSwappedThreadIds.has(entry.notation)) {
                    // Don't create output threads for terminal wallets (purple, gray, blue) UNLESS they're bridges
                    const isTerminal = (entry.toWalletType === 'purple' && !entry.isBridge) ||
                                     entry.toWalletType === 'gray' ||
                                     entry.toWalletType === 'blue' ||
                                     (entry.isTerminalWallet === true && !entry.isBridge);

                    if (isTerminal) {
                        console.log(`Skipping thread creation for terminal wallet (${entry.toWalletType}): ${entry.notation}`);

                        // For terminal wallets, deduct the allocated amounts from source threads
                        // Only mark as fully exhausted if the entire thread was actually used
                        if (entry.individualSourceAssignments && typeof entry.individualSourceAssignments === 'object') {
                            Object.entries(entry.individualSourceAssignments).forEach(([threadId, allocatedAmount]) => {
                                // Find the thread and deduct the allocated amount
                                for (const currency in investigation.availableThreads) {
                                    const thread = investigation.availableThreads[currency][threadId];
                                    if (thread) {
                                        const amountUsed = parseFloat(allocatedAmount) || 0;
                                        console.log(`Terminal wallet: Deducting ${amountUsed} from thread ${threadId} (had ${thread.availableAmount} available)`);

                                        // Use proper rounding to avoid floating point errors
                                        thread.availableAmount = roundAmount(Math.max(0, thread.availableAmount - amountUsed));

                                        // Only mark as fully exhausted if less than 0.01 remains
                                        if (thread.availableAmount < 0.01) {
                                            thread.availableAmount = 0;
                                            thread.fullyExhausted = true;
                                            thread.exhaustedByTerminal = entry.notation;
                                            console.log(`Thread ${threadId} fully exhausted by terminal wallet`);
                                        } else {
                                            console.log(`Thread ${threadId} has ${thread.availableAmount} remaining after terminal wallet`);
                                            // These remainders represent bridge/swap fees or slippage - always write them off
                                            if (thread.availableAmount > 0.01) { // Any remainder above dust
                                                console.log(`Auto-creating write-off for bridge/swap fees: ${thread.availableAmount} ${thread.currency || entry.currency}`);

                                                // Find the hop this entry belongs to
                                                const hop = investigation.hops.find(h => h.entries.some(e => e.id === entry.id));
                                                if (hop) {
                                                    // Get next entry ID for this hop
                                                    const maxId = Math.max(0, ...hop.entries.map(e => parseInt(e.id) || 0));
                                                    const nextId = maxId + 1;

                                                    // Create a write-off entry for the fee
                                                    const feeWriteOff = {
                                                        id: nextId,
                                                        entryType: 'writeoff',
                                                        notation: `${thread.notation || threadId}-FEE`,
                                                        amount: thread.availableAmount.toString(),
                                                        currency: thread.currency || entry.currency,
                                                        customCurrency: thread.currency === 'CUSTOM' ? thread.customCurrency : '',
                                                        notes: `Auto-generated write-off for bridge/DEX fees. Parent transaction: ${entry.transactionHash}`,
                                                        timestamp: entry.timestamp,
                                                        hopNumber: hop.hopNumber,
                                                        sourceThreadInternalId: threadId,
                                                        isAutoFeeWriteOff: true,
                                                        isComplete: true,  // Mark as complete so it appears collapsed
                                                        isCollapsed: true,  // Start collapsed
                                                        category: 'bridge_fee',  // Set category
                                                        justification: 'Bridge/DEX fees and slippage'
                                                    };

                                                    // Add the write-off entry to the hop
                                                    hop.entries.push(feeWriteOff);

                                                    // Consume the remaining thread amount
                                                    thread.availableAmount = 0;
                                                    thread.fullyExhausted = true;
                                                    thread.exhaustedByFeeWriteOff = feeWriteOff.notation;
                                                    thread.isActive = false;  // Mark as inactive so it won't show in available threads

                                                    console.log(`Created automatic fee write-off: ${feeWriteOff.notation} for ${feeWriteOff.amount} ${feeWriteOff.currency}`);
                                                }
                                            }
                                        }
                                    }
                                }
                            });
                        }
                    } else {
                        // updateThreadAvailabilityFromHop will handle bridge output check internally
                        updateThreadAvailabilityFromHop(entry);
                    }
                } else {
                    console.log(`Skipping thread creation for swapped trace: ${entry.notation}`);
                }
            }
        });
    });

    console.log('Available threads index built for ALL victims:', investigation.availableThreads);

    // Note: We don't consolidate threads anymore as bridge outputs can have same notation
}

// 2.2 Update Thread Availability from Hop Entry
function updateThreadAvailabilityFromHop(entry) {
    // CRITICAL FIX: Don't create threads for bridge entries that have already been logged
    // Bridge outputs are created manually in confirmBridgeOutput with the converted currency
    if (entry.isBridge && entry.bridgeOutputLogged && entry.bridgeDetails) {
        console.log(`Skipping thread creation for logged bridge entry: ${entry.notation} (output thread already created in ${entry.bridgeDetails.destinationAsset})`);
        return;
    }

    // Skip terminal wallets - they don't create output threads (UNLESS they're unlogged bridges)
    if ((entry.toWalletType === 'purple' && !entry.isBridge) ||
        entry.toWalletType === 'gray' ||
        entry.toWalletType === 'blue' ||
        (entry.isTerminalWallet && !entry.isBridge)) {
        console.log(`Not creating output thread for terminal wallet entry: ${entry.notation}`);
        return;
    }

    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    const amount = parseFloat(entry.amount);

    if (!investigation.availableThreads[currency]) {
        investigation.availableThreads[currency] = {};
    }

    // Create internal ID for this new thread
    const notation = entry.notation;
    const internalId = generateInternalThreadId(notation, currency);

    // Try to get chain info - for bridges use destination chain, otherwise use entry chain or inherit
    let chainId = entry.chain || null;
    let chainName = entry.chain ? (window.blockchainAPIs?.[entry.chain]?.name || entry.chain) : null;

    // If this is a bridge entry, use the destination chain
    if (entry.isBridge && entry.bridgeDetails?.destinationChain) {
        chainId = entry.bridgeDetails.destinationChain;
        chainName = window.blockchainAPIs?.[chainId]?.name || chainId;
        console.log(`Using bridge destination chain: ${chainId}`);
    } else if (!chainId) {
        // Try to inherit from parent threads
        const parentIds = entry.sourceThreadInternalId ? [entry.sourceThreadInternalId] :
                         (entry.multipleSourceInternalIds || []);
        for (const parentId of parentIds) {
            // Look through all currencies for parent thread
            for (const curr in investigation.availableThreads) {
                const parentThread = investigation.availableThreads[curr]?.[parentId];
                if (parentThread && parentThread.chainId) {
                    chainId = parentThread.chainId;
                    chainName = parentThread.chainName;
                    console.log(`Inherited chain ${chainId} from parent thread ${parentId}`);
                    break;
                }
            }
            if (chainId) break;
        }
    }

    investigation.availableThreads[currency][internalId] = {
        // Dual-layer tracking
        notation: notation,                 // Human-readable
        internalId: internalId,            // Unique identifier

        // Standard fields
        totalAmount: roundAmount(amount),
        availableAmount: roundAmount(amount),  // This thread's full amount is available
        assignments: [],
        sourceWallet: entry.toWallet,
        sourceType: 'hop_output',
        hopLevel: entry.hopNumber,
        createdAt: entry.timestamp || new Date().toISOString(),
        isActive: true,
        parentInternalIds: entry.sourceThreadInternalId ? [entry.sourceThreadInternalId] :
                          (entry.multipleSourceInternalIds || []),
        childThreads: [],
        currency: currency,

        // Chain tracking - inherit from entry or parent
        chainId: chainId,
        chainName: chainName
    };

    // Don't modify availableAmount - getMaxAssignableAmount calculates it dynamically based on assignments
}

// Handle swap entries to create threads with the output currency
function updateThreadAvailabilityFromSwap(entry) {
    const inputCurrency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    // Fix: Get output currency and amount from swapDetails
    const outputCurrency = entry.swapDetails?.toCurrency || entry.outputCurrency;
    const inputAmount = parseFloat(entry.amount);
    const outputAmount = parseFloat(entry.swapDetails?.toAmount || entry.outputAmount || 0);

    console.log(`Processing swap: ${inputAmount} ${inputCurrency} → ${outputAmount} ${outputCurrency}`);
    console.log(`Swap entry details:`, entry);

    if (!outputCurrency || !outputAmount) {
        console.error('Swap is missing output currency or amount!');
        console.log('Entry swapDetails:', entry.swapDetails);
        return;
    }

    // For dual-layer: Get internal IDs of source threads
    const sourceInternalIds = entry.sourceThreadInternalId ? [entry.sourceThreadInternalId] :
                             (entry.multipleSourceInternalIds || []);

    // Also get notation for backward compatibility
    const sourceNotations = entry.sourceThreadId ? [entry.sourceThreadId] :
                           (entry.multipleSourceThreads || []);

    if (sourceInternalIds.length === 0 && sourceNotations.length === 0) {
        console.error('No source threads found for swap');
        return;
    }

    // Find ALL threads that match our source notations/IDs in the input currency
    let threadsToProcess = [];
    let totalAvailableInput = 0;

    // Search by both internal ID and notation
    if (investigation.availableThreads[inputCurrency]) {
        for (const key in investigation.availableThreads[inputCurrency]) {
            const thread = investigation.availableThreads[inputCurrency][key];

            // Check if this thread matches any of our source threads
            let isMatch = false;
            let matchedNotation = null;

            // Check by internal ID
            if (sourceInternalIds.includes(key) || sourceInternalIds.includes(thread.internalId)) {
                isMatch = true;
                matchedNotation = thread.notation || sourceNotations[0];
            }
            // Check by notation
            else if (sourceNotations.includes(thread.notation) || sourceNotations.includes(key)) {
                isMatch = true;
                matchedNotation = thread.notation || sourceNotations[0];
            }
            // Legacy check - key might be the notation itself
            else if (sourceNotations.some(n => key.includes(n))) {
                isMatch = true;
                matchedNotation = sourceNotations.find(n => key.includes(n));
            }

            if (isMatch) {
                const available = thread.totalAmount; // Use total amount for swaps
                console.log(`Found matching thread: ${key} with ${available} ${inputCurrency}`);

                threadsToProcess.push({
                    key: key,
                    internalId: thread.internalId || key,
                    notation: matchedNotation || thread.notation || key,
                    thread: thread,
                    available: available
                });
                totalAvailableInput += available;
            }
        }
    }

    if (threadsToProcess.length === 0) {
        console.error(`No threads found in ${inputCurrency} for swap. Looking for:`, sourceNotations);
        return;
    }

    // Determine if this is a partial swap
    const isPartialSwap = totalAvailableInput > inputAmount;

    if (isPartialSwap) {
        console.log(`Partial swap: Using ${inputAmount} of ${totalAvailableInput} ${inputCurrency}`);

        // For partial swaps, keep remainder in original currency
        threadsToProcess.forEach(item => {
            const consumedRatio = inputAmount / totalAvailableInput;
            const consumedAmount = roundAmount(item.available * consumedRatio);
            const remainingAmount = roundAmount(item.available - consumedAmount);

            if (remainingAmount > 0.01) { // Keep if more than dust
                item.thread.totalAmount = roundAmount(remainingAmount);
                item.thread.availableAmount = roundAmount(remainingAmount);
                console.log(`Thread ${item.notation} keeps ${remainingAmount} ${inputCurrency}`);
            } else {
                // Remove if dust amount
                delete investigation.availableThreads[inputCurrency][item.key];
                console.log(`Removed thread ${item.key} from ${inputCurrency} (dust)`);
            }
        });
    } else {
        // Full swap - remove ALL matching threads from input currency
        threadsToProcess.forEach(item => {
            delete investigation.availableThreads[inputCurrency][item.key];
            console.log(`Removed thread ${item.key} from ${inputCurrency}`);
        });
    }

    // Create thread(s) in output currency
    if (outputAmount > 0) {
        if (!investigation.availableThreads[outputCurrency]) {
            investigation.availableThreads[outputCurrency] = {};
        }

        // Check if we should create a single consolidated output thread
        // This happens when swapping commingled funds (multiple source threads)
        const shouldConsolidate = threadsToProcess.length > 1;

        if (shouldConsolidate) {
            // Create a single consolidated output thread for commingled swaps
            const consolidatedNotations = threadsToProcess.map(item => item.notation);
            const consolidatedNotation = consolidatedNotations.join(' ');
            const newInternalId = generateInternalThreadId(consolidatedNotation, outputCurrency);

            // Check if this consolidated thread already exists
            let exists = false;
            for (const key in investigation.availableThreads[outputCurrency]) {
                const thread = investigation.availableThreads[outputCurrency][key];
                if (thread.notation === consolidatedNotation && thread.sourceType === 'swap_output') {
                    console.log(`Consolidated swap output thread already exists, skipping`);
                    exists = true;
                    break;
                }
            }

            if (!exists) {
                investigation.availableThreads[outputCurrency][newInternalId] = {
                    // Dual-layer identifiers
                    notation: consolidatedNotation,
                    internalId: newInternalId,

                    // Full output amount - NOT proportionally split
                    totalAmount: roundAmount(outputAmount),
                    availableAmount: roundAmount(outputAmount),

                    // Tracking
                    assignments: [],
                    sourceWallet: entry.toWallet || entry.swapDetails?.dexAddress || '',
                    sourceType: 'swap_output',
                    hopLevel: entry.hopNumber || 1,
                    createdAt: entry.timestamp || new Date().toISOString(),
                    isActive: true,
                    isConsolidated: true,

                    // Parent tracking - all source threads
                    parentInternalIds: threadsToProcess.map(item => item.internalId),
                    parentNotations: threadsToProcess.map(item => item.notation),

                    // Currency and swap details
                    currency: outputCurrency,
                    swapDetails: {
                        fromCurrency: inputCurrency,
                        fromAmount: inputAmount,
                        toCurrency: outputCurrency,
                        toAmount: outputAmount,
                        provider: entry.swapDetails?.providerName || 'Unknown',
                        isPartial: isPartialSwap,
                        isConsolidated: true,
                        sourceThreadCount: threadsToProcess.length
                    },

                    // Chain tracking
                    chainId: entry.swapDetails?.toChain || entry.chain || threadsToProcess[0].thread.chainId || null,
                    chainName: entry.swapDetails?.toChain ?
                        (window.blockchainAPIs?.[entry.swapDetails.toChain]?.name || entry.swapDetails.toChain) :
                        (entry.chain ? (window.blockchainAPIs?.[entry.chain]?.name || entry.chain) :
                         (threadsToProcess[0].thread.chainId ?
                          (window.blockchainAPIs?.[threadsToProcess[0].thread.chainId]?.name || threadsToProcess[0].thread.chainId) : null))
                };

                console.log(`Created consolidated swap output thread: ${consolidatedNotation} with ${outputAmount} ${outputCurrency}`);
            }
        } else {
            // Single source thread - create individual output thread
            threadsToProcess.forEach(item => {
            const notation = item.notation;

            // Check if this swap output already exists (prevent duplicates)
            let existingOutputThread = null;
            for (const key in investigation.availableThreads[outputCurrency]) {
                const thread = investigation.availableThreads[outputCurrency][key];
                if (thread.notation === notation && thread.sourceType === 'swap_output') {
                    existingOutputThread = { key, thread };
                    console.log(`Swap output thread ${notation} already exists in ${outputCurrency}, skipping creation`);
                    break;
                }
            }

            // If thread already exists, skip creation
            if (existingOutputThread) {
                console.log(`Skipping duplicate swap output creation for ${notation} in ${outputCurrency}`);
                return;
            }

            const newInternalId = generateInternalThreadId(notation, outputCurrency);

            // For single source thread, use full output amount
            // Only use proportional split if there were originally multiple threads
            const outputPortion = threadsToProcess.length === 1 ? outputAmount :
                                 (outputAmount * (item.available / totalAvailableInput));

            investigation.availableThreads[outputCurrency][newInternalId] = {
                // Dual-layer identifiers
                notation: notation,
                internalId: newInternalId,

                // Amounts
                totalAmount: roundAmount(outputPortion),
                availableAmount: roundAmount(outputPortion),

                // Tracking
                assignments: [],
                sourceWallet: entry.toWallet || entry.swapDetails?.dexAddress || '',
                sourceType: 'swap_output',
                hopLevel: entry.hopNumber || 1,
                createdAt: entry.timestamp || new Date().toISOString(),
                isActive: true,

                // Parent tracking
                parentInternalIds: [item.internalId],
                parentNotations: [item.notation],

                // Currency and swap details
                currency: outputCurrency,
                swapDetails: {
                    fromCurrency: inputCurrency,
                    fromAmount: item.available,
                    toCurrency: outputCurrency,
                    toAmount: outputPortion,
                    provider: entry.swapDetails?.providerName || 'Unknown',
                    isPartial: isPartialSwap
                },

                // Chain tracking for bridges/swaps
                // If this is a bridge, the chain changes. Otherwise inherit from parent
                chainId: entry.swapDetails?.toChain || entry.chain || item.thread.chainId || null,
                chainName: entry.swapDetails?.toChain ?
                    (window.blockchainAPIs?.[entry.swapDetails.toChain]?.name || entry.swapDetails.toChain) :
                    (entry.chain ? (window.blockchainAPIs?.[entry.chain]?.name || entry.chain) :
                     (item.thread.chainId ? (window.blockchainAPIs?.[item.thread.chainId]?.name || item.thread.chainId) : null))
            };

            console.log(`✅ Created swap output thread ${notation} in ${outputCurrency}: ${outputPortion} (ID: ${newInternalId})`);
            console.log(`Thread details:`, investigation.availableThreads[outputCurrency][newInternalId]);
        });
        }
    }

    console.log('Swap thread conversion complete');
}

// Universal threads database is the single source of truth

function getAvailableSourcesForHop(hopNumber, targetCurrency) {
    console.log(` Getting available sources for Hop ${hopNumber}, Currency filter: ${targetCurrency || 'ALL'}`);

    // Don't rebuild on every read - index is maintained when data changes
    // buildAvailableThreadsIndex(); // REMOVED for performance - only rebuild when data changes

    console.log('Available threads database:', investigation.availableThreads);

    const availableSources = [];

    // Simply consult the universal threads database
    for (const currency in investigation.availableThreads) {
        // Skip if filtering by currency and this doesn't match
        if (targetCurrency && currency !== targetCurrency) continue;

        for (const threadKey in investigation.availableThreads[currency]) {
            const thread = investigation.availableThreads[currency][threadKey];

            // Filter by hop level appropriately
            if (hopNumber === 1) {
                // Hop 1: Show victim threads AND same-hop conversions (swap/bridge outputs)
                if (thread.sourceType !== 'victim_transaction' &&
                    thread.sourceType !== 'swap_output' &&
                    thread.sourceType !== 'bridge_output' &&
                    thread.sourceType !== 'change_output') {
                    continue;
                }
                // For conversion outputs, only show if they're from hop 1
                if ((thread.sourceType === 'swap_output' ||
                     thread.sourceType === 'bridge_output' ||
                     thread.sourceType === 'change_output') &&
                    thread.hopLevel !== 1 && thread.hopLevel !== 0) {
                    continue;
                }
            } else {
                // Other hops: Show threads from previous hop or same-hop conversions
                // Include victim threads that still have available amounts (partial traces)
                if (thread.sourceType === 'victim_transaction') {
                    // Allow victim threads if they still have available funds
                    if (thread.availableAmount <= 0.01) continue;
                } else {
                    // Check hop level - should be from previous hop or same hop (for swaps/bridges)
                    const expectedHopLevel = hopNumber - 1;
                    if (thread.hopLevel !== expectedHopLevel && thread.hopLevel !== hopNumber) {
                        // Skip unless it's a same-hop conversion (swap/bridge/change)
                        if (thread.sourceType !== 'swap_output' &&
                            thread.sourceType !== 'bridge_output' &&
                            thread.sourceType !== 'change_output') {
                            continue;
                        }
                    }
                }
            }

            // Calculate available amount using internal ID or notation
            const availableAmount = getMaxAssignableAmount(
                thread.internalId || threadKey,
                currency
            );

            // Only include threads with meaningful available amount (more than dust)
            if (availableAmount > 0.01) {
                // Use notation for display, internal ID for tracking
                const notation = thread.notation || threadKey;
                let displayText = notation;

                // Add partial trace indicator if applicable
                const partialIndicator = thread.wasPartialTrace ?
                    ` [${(thread.proportionalMultiplier * 100).toFixed(1)}% TRACE]` : '';

                if (thread.sourceType === 'victim_transaction') {
                    displayText = `${notation} (RED Wallet)${partialIndicator}`;
                } else if (thread.sourceType === 'bridge_output') {
                    displayText = `${notation} (Bridge Output - ${currency})${partialIndicator}`;
                } else if (thread.sourceType === 'swap_output') {
                    displayText = `${notation} (Swap Output - ${currency})${partialIndicator}`;
                } else if (thread.sourceType === 'change_output') {
                    displayText = `${notation} (Change - ${currency})${partialIndicator}`;
                }

                availableSources.push({
                    // Dual-layer support
                    threadId: notation,  // For backward compatibility and display
                    internalId: thread.internalId || threadKey,  // For precise tracking

                    // Display and metadata
                    displayText: displayText,
                    availableAmount: availableAmount,
                    currency: currency,
                    sourceWallet: thread.sourceWallet,
                    sourceType: thread.sourceType || 'hop_output',
                    hopLevel: thread.hopLevel || 0,
                    datetime: thread.createdAt || null,
                    timezone: 'UTC',

                    // Chain information for transaction lookups
                    chainId: thread.chainId || null,
                    chainName: thread.chainName || null
                });
            }
        }
    }

    console.log(` Final available sources from database (${availableSources.length}):`, availableSources);

    // Sort by notation for consistent display
    return availableSources.sort((a, b) => a.threadId.localeCompare(b.threadId));
}

// DEPRECATED - Complex hop traversal logic - replaced by database approach
function getAvailableSourcesForHop_OLD(hopNumber, targetCurrency) {
    console.log('DEPRECATED FUNCTION CALLED');

    const availableSources = [];

    if (hopNumber === 1) {
        // First hop: ALL victim transactions (RED wallets) from ALL victims, ALL currencies
        console.log(`📋 Checking ${investigation.victims.length} victims for available transactions`);
        
        investigation.victims.forEach(victim => {
            victim.transactions.forEach(transaction => {
                console.log(`Checking V${victim.id}-T${transaction.id}: Amount=${transaction.amount}, Wallet=${transaction.receivingWallet}, Currency=${transaction.currency}`);
                
                if (parseFloat(transaction.amount) > 0 && transaction.receivingWallet && transaction.receivingWallet.trim() !== '') {
                    const currency = transaction.currency === 'CUSTOM' ? transaction.customCurrency : transaction.currency;
                    
                    console.log(`Transaction currency: ${currency}, Target filter: ${targetCurrency || 'NONE'}`);
                    
                    // Only filter by currency if targetCurrency is specified
                    if (!targetCurrency || currency === targetCurrency) {
                        const threadId = `V${victim.id}-T${transaction.id}`;
                        
                        // Use the REAL-TIME availability calculation
                        const currentAvailable = getMaxAssignableAmount(threadId, currency);
                        
                        console.log(`Thread ${threadId}: Available ${currentAvailable} ${currency} from real-time calculation`);
                        
                        if (currentAvailable > 0) {
                            const source = {
                                threadId: threadId,
                                displayText: `${threadId} (RED Wallet)`,
                                availableAmount: currentAvailable,
                                currency: currency, // ENSURE CURRENCY IS INCLUDED
                                sourceWallet: transaction.receivingWallet,
                                sourceType: 'victim_transaction',
                                hopLevel: 0,
                                datetime: transaction.datetime || null,
                                timezone: transaction.timezone || 'UTC'
                            };
                            
                            console.log(` Adding source:`, source);
                            availableSources.push(source);
                        } else {
                            console.log(` Skipping ${threadId}: No availability remaining`);
                        }
                    }
                }
            });
        });
    } else {
        // Subsequent hops: Check both previous hop outputs AND current hop swaps
        const previousHopNumber = hopNumber - 1;
        console.log(`📋 Checking hops for available sources (previous: ${previousHopNumber}, current: ${hopNumber})`);

        // First, collect ALL swapped thread IDs across relevant hops
        const globalSwappedThreadIds = new Set();
        investigation.hops.forEach(hop => {
            if (hop.hopNumber === previousHopNumber || hop.hopNumber === hopNumber) {
                hop.entries.forEach(entry => {
                    if (entry.entryType === 'swap') {
                        if (entry.sourceThreadId) {
                            globalSwappedThreadIds.add(entry.sourceThreadId);
                        } else if (entry.multipleSourceThreads) {
                            entry.multipleSourceThreads.forEach(id => globalSwappedThreadIds.add(id));
                        }
                    }
                });
            }
        });

        // Process previous hop entries
        investigation.hops.forEach(hop => {
            if (hop.hopNumber === previousHopNumber) {
                console.log(`Processing previous hop ${previousHopNumber} entries`);

                hop.entries.forEach(entry => {
                    if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0 && entry.notation) {
                        // Skip this trace entry if it's been swapped
                        if (globalSwappedThreadIds.has(entry.notation)) {
                            console.log(`Skipping trace thread ${entry.notation} - has been swapped`);
                            return;
                        }

                        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;

                        if (!targetCurrency || currency === targetCurrency) {
                            const threadId = entry.notation;
                            const currentAvailable = getMaxAssignableAmount(threadId, currency);

                            if (currentAvailable > 0) {
                                availableSources.push({
                                    threadId: threadId,
                                    displayText: `${threadId}`,
                                    availableAmount: currentAvailable,
                                    currency: currency,
                                    sourceWallet: entry.toWallet,
                                    sourceType: 'hop_output',
                                    hopLevel: previousHopNumber,
                                    datetime: entry.timestamp || null,
                                    timezone: entry.timezone || 'UTC'
                                });
                            }
                        }
                    } else if (entry.entryType === 'swap' && entry.outputAmount && parseFloat(entry.outputAmount) > 0 && entry.notation) {
                        // Handle swap entries from previous hop
                        const currency = entry.outputCurrency;

                        if (!targetCurrency || currency === targetCurrency) {
                            const threadId = entry.notation;
                            const currentAvailable = getMaxAssignableAmount(threadId, currency);

                            if (currentAvailable > 0) {
                                availableSources.push({
                                    threadId: threadId,
                                    displayText: `${threadId} (swapped to ${currency})`,
                                    availableAmount: currentAvailable,
                                    currency: currency,
                                    sourceWallet: entry.toWallet,
                                    sourceType: 'swap_output',
                                    hopLevel: previousHopNumber,
                                    datetime: entry.timestamp || null,
                                    timezone: entry.timezone || 'UTC'
                                });
                            }
                        }
                    }
                });
            }

            // ALSO check current hop for swap outputs (same-hop swaps)
            if (hop.hopNumber === hopNumber) {
                console.log(`Checking current hop ${hopNumber} for swap outputs`);

                hop.entries.forEach(entry => {
                    if (entry.entryType === 'swap' && entry.outputAmount && parseFloat(entry.outputAmount) > 0 && entry.notation) {
                        const currency = entry.outputCurrency;
                        console.log(`Found swap in current hop: ${entry.notation} with ${entry.outputAmount} ${currency}`);

                        if (!targetCurrency || currency === targetCurrency) {
                            const threadId = entry.notation;
                            const currentAvailable = getMaxAssignableAmount(threadId, currency);

                            if (currentAvailable > 0) {
                                availableSources.push({
                                    threadId: threadId,
                                    displayText: `${threadId} (swapped to ${currency})`,
                                    availableAmount: currentAvailable,
                                    currency: currency,
                                    sourceWallet: entry.toWallet,
                                    sourceType: 'swap_output',
                                    hopLevel: hopNumber, // Same hop level
                                    datetime: entry.timestamp || null,
                                    timezone: entry.timezone || 'UTC'
                                });
                                console.log(`Added swap output from current hop: ${threadId}`);
                            }
                        }
                    }
                });
            }
        });
    }
    
    console.log(` Final available sources (${availableSources.length}):`, availableSources);
    
    return availableSources.sort((a, b) => a.threadId.localeCompare(b.threadId));
}

// 2.4 Get Wallet Type Display Name
function getWalletTypeDisplayName(walletAddress) {
    // Try to find wallet in universal wallet index
    const wallet = investigation.universalWalletIndex?.find(w => w.address === walletAddress);
    if (wallet) {
        return wallet.permanentId;
    }
    
    // Fallback to abbreviated address
    if (walletAddress && walletAddress.length > 10) {
        return walletAddress.substring(0, 6) + '...' + walletAddress.substring(walletAddress.length - 4);
    }
    
    return walletAddress || 'Unknown';
}

// 2.5 Get Maximum Assignable Amount - Function moved to line 6710 with enhanced functionality

// 2.8 Calculate Total Assigned Amount by Currency
function calculateTotalAssignedAmount(currency) {
    let totalAssigned = 0;
    
    if (!investigation.availableThreads[currency]) {
        return 0;
    }
    
    Object.values(investigation.availableThreads[currency]).forEach(thread => {
        thread.assignments.forEach(assignment => {
            if (assignment.isActive) {
                totalAssigned += assignment.amount;
            }
        });
    });
    
    return totalAssigned;
}

// 2.9 Get Thread Chain History
function getThreadChainHistory(threadId, currency) {
    const chain = [];
    
    if (!investigation.availableThreads[currency] || !investigation.availableThreads[currency][threadId]) {
        return chain;
    }
    
    const thread = investigation.availableThreads[currency][threadId];
    chain.push({
        threadId: threadId,
        amount: thread.totalAmount,
        hopLevel: thread.hopLevel,
        sourceType: thread.sourceType
    });
    
    // Trace back through parent threads
    thread.parentThreads.forEach(parentId => {
        const parentChain = getThreadChainHistory(parentId, currency);
        chain.unshift(...parentChain);
    });
    
    return chain;
}

// 2.10 Enhanced getCurrentART with Thread Tracking
function getCurrentARTWithThreads() {
    const artByCurrency = {};
    
    // Start with root totals by currency from victims
    investigation.victims.forEach(victim => {
        victim.transactions.forEach(transaction => {
            if (parseFloat(transaction.amount) > 0) {
                const currency = transaction.currency === 'CUSTOM' ? transaction.customCurrency : transaction.currency;
                if (!artByCurrency[currency]) {
                    artByCurrency[currency] = {
                        rootTotal: 0,
                        writeoffs: 0,
                        adjustedTotal: 0,
                        assignedAmount: 0,
                        unassignedAmount: 0
                    };
                }
                artByCurrency[currency].rootTotal += parseFloat(transaction.amount);
            }
        });
    });
    
    // Subtract write-offs from hop entries by currency
    investigation.hops.forEach(hop => {
        hop.entries.forEach(entry => {
            if (entry.entryType === 'writeoff' && parseFloat(entry.amount) > 0) {
                const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                if (artByCurrency[currency]) {
                    artByCurrency[currency].writeoffs += parseFloat(entry.amount);
                }
            }
        });
    });
    
    // Calculate adjusted totals and assigned amounts
    Object.keys(artByCurrency).forEach(currency => {
        const art = artByCurrency[currency];
        art.adjustedTotal = art.rootTotal - art.writeoffs;
        art.assignedAmount = calculateTotalAssignedAmount(currency);
        art.unassignedAmount = art.adjustedTotal - art.assignedAmount;
    });
    
    return artByCurrency;
}
// =================================
// PHASE 3: ENHANCED UI COMPONENTS
// =================================

// 3.1 Enhanced Notation Field Functions
function updateNotationField(hopNumber, entryId, field, value) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    
    if (field === 'victims') {
        entry.victimNumbers = value;
    } else if (field === 'transactions') {
        entry.transactionNumbers = value;
    }
    
    // Generate the notation preview
    generateNotationPreview(hopNumber, entryId);
    saveToStorage();
}

function generateNotationPreview(hopNumber, entryId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    
    if (!entry.victimNumbers || !entry.transactionNumbers) {
        entry.notation = '';
        const previewElement = document.getElementById(`notation_preview_${hopNumber}_${entryId}`);
        if (previewElement) {
            previewElement.textContent = 'Enter victim and transaction numbers';
        }
        return;
    }
    
    // Generate V-T-H notation with suffix for writeoffs and cold storage
    let notation = `V${entry.victimNumbers}-T${entry.transactionNumbers}-H${entry.hopNumber}`;
    
    // Add suffix based on entry type
    if (entry.entryType === 'writeoff') {
        notation += '-WO';
    } else if (entry.entryType === 'cold_storage') {
        notation += '-CS';
    }
    
    entry.notation = notation;
    entry.generatedNotation = notation;
    
    // Update preview element
    const previewElement = document.getElementById(`notation_preview_${hopNumber}_${entryId}`);
    if (previewElement) {
        previewElement.textContent = notation;
    }
    
    // If we have source and amount, update the full display notation
    if ((entry.sourceThreadId || (entry.multipleSourceThreads && entry.multipleSourceThreads.length > 0)) && entry.amount) {
        updateFullNotationDisplay(hopNumber, entryId);
    }
}

// 3.2 Source Selection Handler
function handleSourceSelection(hopNumber, entryId, sourceThreadId) {
    console.log(` Handling source selection: ${sourceThreadId} for hop ${hopNumber} entry ${entryId}`);
    
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    
    if (!hop || !entry) {
        console.error('❌ Could not find hop or entry:', { hopNumber, entryId });
        return;
    }
    
    // Clear previous assignments
    entry.sourceThreadId = sourceThreadId;
    entry.multipleSourceThreads = [];
    entry.isConvergence = false;
    entry.individualSourceAssignments = {};
    
    if (sourceThreadId) {
        // Get the source thread details to determine its currency
        const availableSources = getAvailableSourcesForHop(hop.hopNumber, null);
        const selectedSource = availableSources.find(s => s.threadId === sourceThreadId);
        
        if (selectedSource) {
            // Auto-update the currency to match the source thread
            const sourceCurrency = selectedSource.currency;
            
            // Check if it's a custom currency
            const isCustomCurrency = !Object.keys(currencies).includes(sourceCurrency);
            
            if (isCustomCurrency) {
                entry.currency = 'CUSTOM';
                entry.customCurrency = sourceCurrency;
            } else {
                entry.currency = sourceCurrency;
                entry.customCurrency = '';
            }
            
            // Update the currency dropdown in the UI
            const currencySelect = document.querySelector(`select[onchange="updateHopEntry(${hopNumber}, ${entryId}, 'currency', this.value)"]`);
            if (currencySelect) {
                currencySelect.value = entry.currency;
            }
            
            // Show/hide custom currency input if needed
            const customCurrencyDiv = document.getElementById(`customEntryCurrency_${hopNumber}_${entryId}`);
            if (customCurrencyDiv) {
                if (isCustomCurrency) {
                    customCurrencyDiv.classList.remove('custom-currency-input');
                    const customInput = customCurrencyDiv.querySelector('input');
                    if (customInput) {
                        customInput.value = sourceCurrency;
                    }
                } else {
                    customCurrencyDiv.classList.add('custom-currency-input');
                }
            }
            
            console.log(`💱 Auto-updated currency to: ${sourceCurrency} (${isCustomCurrency ? 'custom' : 'standard'})`);
        }
        
        // Now use the updated currency from the source thread
        const currency = selectedSource.currency;
        const maxAmount = getMaxAssignableAmount(sourceThreadId, currency, entryId, hopNumber);
        
        console.log(`💡 Max available for ${sourceThreadId}: ${maxAmount} ${currency}`);
        
        // Update max amount for input
        const amountInput = document.getElementById(`assignAmount_${hopNumber}_${entryId}`);
        if (amountInput) {
            amountInput.max = maxAmount;
            
            // Only auto-fill if current amount exceeds new max (to prevent invalid amounts)
            if (parseFloat(entry.amount) > maxAmount) {
                entry.amount = maxAmount.toString();
                amountInput.value = maxAmount;
            }
            // Don't auto-fill otherwise - let user decide how much to assign
        }
        
        // Update source thread data
        if (investigation.availableThreads[currency] && investigation.availableThreads[currency][sourceThreadId]) {
            entry.sourceThreadData = investigation.availableThreads[currency][sourceThreadId];
            entry.availableSourceAmount = maxAmount;
        }
        
        // Auto-generate notation from source thread
        autoGenerateNotationFromSource(hopNumber, entryId, sourceThreadId);
        
        updateAssignmentPreview(hopNumber, entryId);
        updateFullNotationDisplay(hopNumber, entryId);
    } else {
        // Clear selection
        const amountInput = document.getElementById(`assignAmount_${hopNumber}_${entryId}`);
        if (amountInput) {
            amountInput.max = 0;
            amountInput.value = '';
        }
        entry.amount = '';
        entry.sourceThreadData = null;
        entry.availableSourceAmount = 0;
        
        clearNotationFields(hopNumber, entryId);
    }
    
    saveToStorage();
    
    // CRITICAL: Force refresh of ALL entries to show updated availability
    refreshAllSourceAvailability(hopNumber);
}
function refreshAllSourceAvailability(currentHopId) {
    console.log(`Refreshing source availability for all entries in hop ${currentHopId}`);
    
    // Find the current hop
    const currentHop = investigation.hops.find(h => h.hopNumber === currentHopId);
    if (!currentHop) return;
    
    // Update each entry's source dropdown with real-time availability
    currentHop.entries.forEach(entry => {
        if (entry.entryType === 'trace') {
            const sourceSelect = document.getElementById(`sourceSelect_${currentHop.id}_${entry.id}`);
            if (sourceSelect) {
                const selectedValue = sourceSelect.value;
                const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                
                // Get fresh availability data - get all currencies since we auto-set based on selection
                const availableSourceThreads = getAvailableSourcesForHop(currentHop.hopNumber, null);
                
                // Rebuild options with current availability
                let newOptions = '<option value="">Select source thread...</option>';
                availableSourceThreads.forEach(source => {
                    const realTimeAvailable = getMaxAssignableAmount(source.threadId, null);
                    const isSelected = selectedValue === source.threadId ? 'selected' : '';
                    const availabilityText = realTimeAvailable > 0 ? 
                        `${realTimeAvailable.toLocaleString()} ${source.currency} available` : 
                        'FULLY ASSIGNED';
                    const isDisabled = realTimeAvailable <= 0 && selectedValue !== source.threadId ? 'disabled' : '';
                    
                    newOptions += `<option value="${source.threadId}" ${isSelected} ${isDisabled}>
                        ${source.displayText} - ${availabilityText}
                    </option>`;
                });
                
                sourceSelect.innerHTML = newOptions;
                
                // If current selection is now unavailable, show warning
                if (selectedValue && getMaxAssignableAmount(selectedValue, null) <= 0 && entry.amount && parseFloat(entry.amount) > 0) {
                    const warningDiv = document.getElementById(`assignmentPreview_${currentHop.id}_${entry.id}`);
                    if (warningDiv) {
                        warningDiv.innerHTML = '<div style="color: #e74c3c; font-weight: bold;">⚠️ Source thread is now fully assigned!</div>';
                    }
                }
            }
        }
    });
}

// 3.3 Assignment Amount Handler
function updateAssignmentAmount(hopNumber, entryId, amount) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    if (!hop) {
        console.error('Hop not found:', hopNumber);
        return;
    }
    
    const entry = hop.entries.find(e => e.id === entryId);
    if (!entry) {
        console.error('Entry not found:', entryId);
        return;
    }
    
    entry.amount = amount;
    
    if (entry.sourceThreadData) {
        entry.assignmentPercentage = (parseFloat(amount) / entry.sourceThreadData.totalAmount) * 100;
    }
    
    updateAssignmentPreview(hopNumber, entryId);
    updateFullNotationDisplay(hopNumber, entryId);
    saveToStorage();
    
    // CRITICAL: Refresh availability after amount changes
    refreshAllSourceAvailability(hopNumber);
    buildAvailableThreadsIndex(); // Rebuild thread index when amounts change
    
    // Auto-collapse entry if amount is set and valid
    if (parseFloat(amount) > 0) {
        const entryKey = `${hopNumber}_${entryId}`;
        window.entryCollapseState[entryKey] = true;
        const content = document.getElementById(`entryContent_${entryKey}`);
        const summary = document.getElementById(`entrySummary_${entryKey}`);
        if (content && summary) {
            content.style.display = 'none';
            summary.style.display = 'block';
        }
    }
}

// 3.4 Assignment Preview Updater
function updateAssignmentPreview(hopNumber, entryId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    const previewElement = document.getElementById(`assignmentPreview_${hopNumber}_${entryId}`);
    
    if (!previewElement || !entry.sourceThreadId || !entry.amount) {
        if (previewElement) previewElement.innerHTML = '';
        return;
    }
    
    const amount = parseFloat(entry.amount);
    const maxAmount = getMaxAssignableAmount(entry.sourceThreadId, null, entryId, hopNumber); // Real-time calculation, let it find the currency
    
    // Get the actual currency from the source thread
    let currency = '';
    const availableSources = getAvailableSourcesForHop(hop.hopNumber, null);
    const sourceThread = availableSources.find(s => s.threadId === entry.sourceThreadId);
    if (sourceThread) {
        currency = sourceThread.currency;
    }
    const remaining = maxAmount + amount; // Total available if this assignment wasn't made
    const afterAssignment = remaining - amount;
    
    // Validate assignment with real-time data
    const validation = validateThreadAssignment(entry.sourceThreadId, amount, null, entryId, hopNumber);
    
    let previewHTML = '';
    if (validation.valid) {
        previewHTML = `
            <div style="color: #27ae60; background: #d4f8d4; padding: 8px; border-radius: 4px; margin-top: 5px;">
                ✓ Assigning ${amount.toLocaleString()} ${currency} from ${entry.sourceThreadId}
                <br><small style="color: #666;">
                    Available before: ${remaining.toLocaleString()} | After: ${afterAssignment.toLocaleString()} ${currency}
                    ${afterAssignment === 0 ? ' (FULLY ALLOCATED)' : ''}
                </small>
            </div>
        `;
        if (entry.assignmentPercentage) {
            previewHTML += `<div style="font-size: 11px; color: #666; margin-top: 3px;">Using ${entry.assignmentPercentage.toFixed(1)}% of source thread</div>`;
        }
    } else {
        previewHTML = `
            <div style="color: #e74c3c; background: #fdf2f2; padding: 8px; border-radius: 4px; margin-top: 5px;">
                ⚠ ${validation.error}
                <br><small style="color: #666;">Currently available: ${maxAmount.toLocaleString()} ${currency}</small>
            </div>
        `;
    }
    
    previewElement.innerHTML = previewHTML;
}

// 3.5 Assign Maximum Amount
function assignMaxAmount(hopNumber, entryId) {
    console.log(` assignMaxAmount called for hop ${hopNumber}, entry ${entryId}`);
    
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    if (!hop) {
        console.error('Hop not found:', hopNumber);
        return;
    }
    
    const entry = hop.entries.find(e => e.id === entryId);
    if (!entry) {
        console.error('Entry not found:', entryId);
        return;
    }
    
    console.log('Entry state:', {
        sourceThreadId: entry.sourceThreadId,
        multipleSourceThreads: entry.multipleSourceThreads,
        currentAmount: entry.amount
    })
    
    let maxAmount = 0;
    let currency = '';
    
    // Check if multiple sources are selected
    if (entry.multipleSourceThreads && entry.multipleSourceThreads.length > 0) {
        // First, validate that all sources have the same currency
        const availableSources = getAvailableSourcesForHop(hop.hopNumber, null);
        const currencies = new Set();
        
        entry.multipleSourceThreads.forEach(sourceId => {
            const source = availableSources.find(s => s.threadId === sourceId);
            if (source) {
                currencies.add(source.currency);
            }
        });
        
        if (currencies.size > 1) {
            alert(`ERROR:  Cannot mix different asset types!\n\nSelected threads contain: ${Array.from(currencies).join(', ')}\n\nPlease select threads with the same currency only.`);
            return;
        }
        
        // Calculate total from multiple sources using real-time availability
        entry.multipleSourceThreads.forEach(sourceId => {
            const availableAmount = getMaxAssignableAmount(sourceId, null);
            maxAmount += availableAmount;
            
            // Get currency from source thread
            const source = availableSources.find(s => s.threadId === sourceId);
            if (source && !currency) {
                currency = source.currency;
            }
            
            console.log(`Source ${sourceId}: ${availableAmount} available`);
        });
        console.log(`Total from ${entry.multipleSourceThreads.length} sources: ${maxAmount}`);
    } else if (entry.sourceThreadId) {
        // Single source selected
        maxAmount = getMaxAssignableAmount(entry.sourceThreadId, null, entry.id, hop.hopNumber);
        
        // Get currency from source thread
        const availableSources = getAvailableSourcesForHop(hop.hopNumber, null);
        const source = availableSources.find(s => s.threadId === entry.sourceThreadId);
        if (source) {
            currency = source.currency;
        }
        
        console.log(`Single source ${entry.sourceThreadId}: ${maxAmount} ${currency} available`);
    } else {
        alert('Please select source thread(s) first.');
        return;
    }
    
    // Update entry amount
    entry.amount = maxAmount.toString();
    
    // Update the input field - force update even if element seems unresponsive
    const amountInput = document.getElementById(`assignAmount_${hopNumber}_${entryId}`);
    if (amountInput) {
        console.log(`Updating amount input to ${maxAmount}`);
        amountInput.value = maxAmount;
        // Force a change event to ensure updates propagate
        amountInput.dispatchEvent(new Event('change', { bubbles: true }));
    } else {
        console.error(`Could not find amount input: assignAmount_${hopNumber}_${entryId}`);
    }
    
    // Trigger the amount update handler to ensure all related updates occur
    updateAssignmentAmount(hopNumber, entryId, maxAmount.toString());
    
    // Update appropriate preview based on source type
    if (entry.multipleSourceThreads && entry.multipleSourceThreads.length > 0) {
        updateMultipleSourcePreview(hopNumber, entryId);
        updateFullNotationDisplayMultiple(hopNumber, entryId);
    } else {
        updateAssignmentPreview(hopNumber, entryId);
        updateFullNotationDisplay(hopNumber, entryId);
    }
    
    saveToStorage();
}

// 3.6 Full Notation Display Updater
function updateFullNotationDisplay(hopNumber, entryId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    const previewElement = document.getElementById(`notationPreview_${hopNumber}_${entryId}`);
    
    if (!previewElement) return;
    
    if (!entry.sourceThreadId || !entry.amount || !entry.notation) {
        previewElement.innerHTML = 'Select source, amount, and complete notation to generate full display';
        return;
    }
    
    const amount = parseFloat(entry.amount);
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    
    // Generate source chain notation
    const sourceChainEntry = {
        sourceNotation: entry.sourceThreadId,
        amount: amount,
        currency: currency,
        percentage: entry.assignmentPercentage || 100
    };
    
    // Create display notation
    const displayNotation = `${entry.sourceThreadId}(${amount.toLocaleString()}) ${entry.notation}`;
    const summaryNotation = `${entry.notation} (${amount.toLocaleString()} ${currency})`;
    
    // Update entry with generated notations
    entry.displayNotation = displayNotation;
    entry.summaryNotation = summaryNotation;
    entry.sourceChain = [sourceChainEntry];
    
    // Update preview display
    previewElement.innerHTML = `
        <div style="margin-bottom: 8px;"><strong>Display:</strong> ${displayNotation}</div>
        <div style="margin-bottom: 8px;"><strong>Summary:</strong> ${summaryNotation}</div>
        <div style="font-size: 11px; color: #666;">Source Chain: ${entry.sourceThreadId} ${entry.notation}</div>
    `;
}

// 3.7 Enhanced Hop Entry Renderer (replaces renderHopEntry)
function renderEnhancedHopEntry(entry) {
    const isWriteoff = entry.entryType === 'writeoff';
    const isColdStorage = entry.entryType === 'cold_storage';
    
    // Get available source wallets for this hop
    const availableSourceWallets = getAvailableSourcesForHop(entry.hopNumber, entry.currency);
    const sourceOptions = availableSourceWallets.map(source => 
        `<option value="${source.threadId}" ${entry.sourceThreadId === source.threadId ? 'selected' : ''}>
            ${source.displayText} - ${source.availableAmount.toLocaleString()} ${source.currency} available
        </option>`
    ).join('');

    return `
        <div style="background: white; border: 2px solid #e8f0fe; border-radius: 8px; padding: 20px; margin-bottom: 15px;">
            <div class="trace-header">
                <div>
                    <span class="trace-notation">Entry ${entry.id} - ${entryTypes[entry.entryType]}</span>
                    ${entry.notation ? `<br><small style="color: #666;">${entry.notation}</small>` : ''}
                </div>
                <button class="btn btn-danger" onclick="removeHopEntry(${hop.hopNumber}, ${entry.id})">Remove</button>
            </div>
            
            <div class="form-group">
                <label>Entry Type</label>
                <select onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'entryType', this.value)">
                    ${Object.entries(entryTypes).map(([key, value]) => 
                        `<option value="${key}" ${entry.entryType === key ? 'selected' : ''}>${value}</option>`
                    ).join('')}
                </select>
            </div>
            
            ${!isWriteoff ? `
                <div class="form-group">
                    <label>Source Thread Selection</label>
                    <select id="sourceSelect_${hop.hopNumber}_${entry.id}" 
                            onchange="handleSourceSelection(${hop.hopNumber}, ${entry.id}, this.value)">
                        <option value="">Select source thread...</option>
                        ${sourceOptions}
                    </select>
                    ${entry.sourceThreadId ? `
                        <div style="margin-top: 8px; font-size: 11px; color: #666;">
                            <strong>Source:</strong> ${entry.sourceThreadId}
                        </div>
                    ` : ''}
                </div>
                
               <div class="form-group">
                    <label>New Thread Total</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <input type="number" step="0.01" 
                               id="assignAmount_${hop.hopNumber}_${entry.id}"
                               value="${entry.amount || ''}"
                               max="${entry.sourceThreadId ? getMaxAssignableAmount(entry.sourceThreadId, entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency) : 0}"
                               onchange="updateAssignmentAmount(${hop.hopNumber}, ${entry.id}, this.value)">
                        <button type="button" class="btn btn-secondary" 
                                onclick="assignMaxAmount(${hop.hopNumber}, ${entry.id})"
                                ${!entry.sourceThreadId ? 'disabled' : ''}>Max</button>
                    </div>
                    <div id="assignmentPreview_${hop.hopNumber}_${entry.id}" 
                         style="font-size: 12px; margin-top: 5px;"></div>
                </div>
            ` : ''}

            <div class="form-group">
                <label>Notation Builder</label>
                <div style="display: flex; align-items: center; gap: 5px; font-family: monospace; font-weight: bold;">
                    <span>V</span>
                    <input type="text" style="width: 60px; text-align: center;" 
                           placeholder="1" 
                           value="${entry.victimNumbers || ''}"
                           onchange="updateNotationField(${hop.hopNumber}, ${entry.id}, 'victims', this.value)">
                    <span>-T</span>
                    <input type="text" style="width: 80px; text-align: center;" 
                           placeholder="1,2,3" 
                           value="${entry.transactionNumbers || ''}"
                           onchange="updateNotationField(${hop.hopNumber}, ${entry.id}, 'transactions', this.value)">
                    <span>-H${entry.hopNumber}</span>
                </div>
                <div style="font-size: 12px; color: #666; margin-top: 5px;">
                    Preview: <span id="notation_preview_${hop.hopNumber}_${entry.id}" style="font-family: monospace; font-weight: bold;">${entry.notation || 'Enter V and T numbers'}</span>
                </div>
            </div>
            
            ${!isWriteoff ? `
                <div class="form-group">
                    <label>Full Notation Display</label>
                    <div id="notationPreview_${hop.hopNumber}_${entry.id}" 
                         style="font-family: monospace; padding: 10px; background: #f8f9fa; border-radius: 4px; min-height: 60px;">
                        ${entry.displayNotation || 'Complete source selection and notation to generate full display'}
                    </div>
                </div>
            ` : ''}

            <div class="form-group">
                <label>Currency</label>
                <select onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'currency', this.value)">
                    <option value="USD" ${entry.currency === 'USD' ? 'selected' : ''}>US Dollar</option>
                    <option value="BTC" ${entry.currency === 'BTC' ? 'selected' : ''}>Bitcoin</option>
                    <option value="ETH" ${entry.currency === 'ETH' ? 'selected' : ''}>Ethereum</option>
                    <option value="USDT" ${entry.currency === 'USDT' ? 'selected' : ''}>Tether</option>
                    <option value="USDC" ${entry.currency === 'USDC' ? 'selected' : ''}>USD Coin</option>
                    <option value="TRX" ${entry.currency === 'TRX' ? 'selected' : ''}>TRON</option>
                    <option value="SOL" ${entry.currency === 'SOL' ? 'selected' : ''}>Solana</option>
                    <option value="ADA" ${entry.currency === 'ADA' ? 'selected' : ''}>Cardano</option>
                    <option value="DAI" ${entry.currency === 'DAI' ? 'selected' : ''}>DAI</option>
                    <option value="BNB" ${entry.currency === 'BNB' ? 'selected' : ''}>BNB</option>
                    <option value="MATIC" ${entry.currency === 'MATIC' ? 'selected' : ''}>MATIC</option>
                    <option value="AVAX" ${entry.currency === 'AVAX' ? 'selected' : ''}>AVAX</option>
                    <option value="HYPE" ${entry.currency === 'HYPE' ? 'selected' : ''}>HYPE</option>
                    <option value="MNT" ${entry.currency === 'MNT' ? 'selected' : ''}>MNT</option>
                    <option value="CUSTOM" ${entry.currency === 'CUSTOM' ? 'selected' : ''}>Custom Currency</option>
                </select>
            </div>
            
            <div class="form-group ${entry.currency === 'CUSTOM' ? '' : 'custom-currency-input'}" 
                 id="customEntryCurrency_${hop.hopNumber}_${entry.id}">
                <label>Custom Currency Symbol</label>
                <input type="text" value="${entry.customCurrency || ''}" 
                       placeholder="e.g., DOGE, SHIB"
                       onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'customCurrency', this.value)">
            </div>
            
            ${!isWriteoff && !isColdStorage ? `
                <div class="form-group">
                    <label>To Wallet Address</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <div class="wallet-autocomplete-container" style="flex: 1;">
                            <input type="text" 
                                   id="toWallet_${hop.hopNumber}_${entry.id}"
                                   value="${entry.toWallet || ''}" 
                                   placeholder="Select existing or enter new wallet address"
                                   onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'toWallet', this.value)"
                                   oninput="handleWalletAutocomplete(this, ${entry.hopNumber}, ${entry.id})"
                                   autocomplete="off"
                                   list="walletList_${hop.hopNumber}_${entry.id}"
                                   style="width: 100%;">
                            <div id="autocomplete_${hop.hopNumber}_${entry.id}" class="wallet-autocomplete-dropdown"></div>
                        </div>
                        <datalist id="walletList_${hop.hopNumber}_${entry.id}">
                            ${(investigation.universalWalletIndex || []).map(wallet => `
                                <option value="${wallet.address}">
                                    ${wallet.permanentId} - ${wallet.address.substring(0, 20)}...
                                </option>
                            `).join('')}
                        </datalist>
                        <button type="button" class="btn btn-secondary" style="padding: 6px 12px; font-size: 12px;"
                                onclick="showWalletSelector(${hop.hopNumber}, ${entry.id})">
                            📋 Browse
                        </button>
                    </div>
                    <div style="font-size: 11px; color: #666; margin-top: 5px;">
                        Type to search existing wallets or enter a new address
                    </div>
                </div>
                <div class="form-group">
                    <label>To Wallet Classification</label>
                    <select onchange="updateHopEntryWalletType(${hop.hopNumber}, ${entry.id}, this.value)">
                        <option value="">Select classification...</option>
                        ${Object.entries(walletTypes).filter(([key]) => key !== 'red').map(([key, value]) => 
                            `<option value="${key}" ${entry.toWalletType === key ? 'selected' : ''}>${value}</option>`
                        ).join('')}
                    </select>
                </div>
                <div class="form-group">
                    <label>Transaction Hash</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <input type="text" 
                               id="txHash_${hop.hopNumber}_${entry.id}"
                               value="${entry.txHash || ''}" 
                               placeholder="Blockchain transaction hash"
                               onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'txHash', this.value)"
                               style="flex: 1;">
                        <button type="button" 
                                class="btn btn-secondary" 
                                onclick="openBlockchainLookup(${hop.hopNumber}, ${entry.id})"
                                style="background: #3498db; color: white; padding: 8px 15px; font-size: 14px;">
                            Lookup
                        </button>
                    </div>
                </div>
                <div class="form-group">
                    <label>Timestamp with Timezone</label>
                    <div class="datetime-timezone">
                        <input type="datetime-local" 
                               id="timestamp_${hop.hopNumber}_${entry.id}"
                               value="${entry.timestamp || ''}" 
                               onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'timestamp', this.value)">
                        <select onchange="onTimezoneChange('timestamp_${hop.hopNumber}_${entry.id}', 'hop', ${hop.hopNumber}, ${entry.id})">
                            ${Object.entries(timezones).map(([key, value]) => 
                                `<option value="${key}" ${entry.timezone === key ? 'selected' : ''}>${value}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
            ` : ''}
            
            ${isWriteoff ? `
                <div class="form-group">
                    <label>Write-off Category</label>
                    <select onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'category', this.value)">
                        <option value="">Select category...</option>
                        ${Object.entries(writeoffCategories).map(([key, value]) => 
                            `<option value="${key}" ${entry.category === key ? 'selected' : ''}>${value}</option>`
                        ).join('')}
                    </select>
                </div>
                <div class="form-group" style="grid-column: span 2;">
                    <label>Justification</label>
                    <textarea rows="2" placeholder="Detailed explanation for abandoning this trace path..." 
                              onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'justification', this.value)">${entry.justification || ''}</textarea>
                </div>
            ` : `
                <div class="form-group" style="grid-column: span 2;">
                    <label>Notes</label>
                    <textarea rows="2" placeholder="PIFO application, convergence notes, etc." 
                              onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'notes', this.value)">${entry.notes || ''}</textarea>
                </div>
            `}
        </div>
    `;
}


// ADD THESE FUNCTIONS TO HANDLE COMMINGLING/MULTIPLE SOURCES

// Enhanced Source Selection Handler for Multiple Sources
function handleMultipleSourceSelection(hopNumber, entryId, selectedSources) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    
    // Store multiple source threads
    entry.multipleSourceThreads = selectedSources;
    entry.isConvergence = selectedSources.length > 1;
    
    if (selectedSources.length > 0) {
        // Calculate total available amount from all selected sources
        let totalAvailable = 0;
        selectedSources.forEach(sourceId => {
            const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
            const maxAmount = getMaxAssignableAmount(sourceId, currency, entry.id, hop.hopNumber);
            totalAvailable += maxAmount;
        });
        
        // Update max amount for input
        const amountInput = document.getElementById(`assignAmount_${hopNumber}_${entryId}`);
        if (amountInput) {
            amountInput.max = totalAvailable;
            
            // Auto-fill with total available if no amount set
            if (!entry.amount || parseFloat(entry.amount) === 0) {
                entry.amount = totalAvailable.toString();
                amountInput.value = totalAvailable;
            }
        }
        
        updateMultipleSourcePreview(hopNumber, entryId);
        updateFullNotationDisplay(hopNumber, entryId);
    }
    
    saveToStorage();
}

// Update Multiple Source Preview
function renderEnhancedSourceSelection(entry) {
    const availableSourceThreads = getAvailableSourcesForHop(entry.hopNumber, null);
    
    // If only one source available, use single selection
    if (availableSourceThreads.length <= 1) {
        const sourceOptions = availableSourceThreads.map(source => 
            `<option value="${source.threadId}" ${entry.sourceThreadId === source.threadId ? 'selected' : ''}>
                ${source.displayText} - ${source.availableAmount.toLocaleString()} ${source.currency} available
            </option>`
        ).join('');
        
        return `
            <div class="form-group">
                <label>Source Thread Selection</label>
                <select id="sourceSelect_${hop.hopNumber}_${entry.id}" 
                        onchange="handleSourceSelection(${hop.hopNumber}, ${entry.id}, this.value)">
                    <option value="">Select source thread...</option>
                    ${sourceOptions}
                </select>
            </div>
        `;
    }
    
    // Multiple sources available - show checkboxes for commingling
    return `
        <div class="form-group">
            <label>Source Thread Selection (Multiple sources for commingling)</label>
            <div style="background: #f8f9fa; border: 1px solid #ddd; border-radius: 4px; padding: 15px;">
                <div style="margin-bottom: 10px; font-weight: bold;">Select one or more source threads:</div>
                ${availableSourceThreads.map(source => `
                    <label style="display: block; margin: 8px 0; cursor: pointer;">
                        <input type="checkbox" 
                               value="${source.threadId}" 
                               ${entry.multipleSourceThreads && entry.multipleSourceThreads.includes(source.threadId) ? 'checked' : ''}
                               onchange="updateMultipleSourceSelection(${hop.hopNumber}, ${entry.id})"> 
                        ${source.displayText} - ${source.availableAmount.toLocaleString()} ${source.currency} available
                    </label>
                `).join('')}
            </div>
            <div id="multipleSourcePreview_${hop.hopNumber}_${entry.id}"></div>
        </div>
    `;
}

// Update Multiple Source Selection
// REPLACE YOUR updateMultipleSourceSelection FUNCTION WITH THIS FIXED VERSION

function updateMultipleSourceSelection(hopNumber, entryId) {
    const checkboxes = document.querySelectorAll(`input[type="checkbox"][onchange*="${hopNumber}, ${entryId}"]`);
    const selectedSources = Array.from(checkboxes)
        .filter(cb => cb.checked)
        .map(cb => cb.value);
    
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    
    // Check if we were already in multiple source mode
    const wasMultipleMode = entry.multipleSourceThreads && entry.multipleSourceThreads.length > 0;
    
    // Store multiple source threads
    entry.multipleSourceThreads = selectedSources;
    entry.isConvergence = selectedSources.length > 1;
    
    // Only switch to single source mode if we weren't already in multiple mode
    // This preserves the multiple source UI even when only one thread is selected
    if (!wasMultipleMode && selectedSources.length === 1) {
        // Starting fresh with single selection - use single source mode
        entry.sourceThreadId = selectedSources[0];
        entry.multipleSourceThreads = [];
    } else if (wasMultipleMode) {
        // We were in multiple mode - stay in multiple mode even with 1 selection
        entry.sourceThreadId = '';
    } else {
        // No sources selected
        entry.sourceThreadId = '';
    }
    
    if (selectedSources.length > 0) {
        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
        
        // Initialize individual assignments for newly selected sources
        if (!entry.individualSourceAssignments) {
            entry.individualSourceAssignments = {};
        }
        
        // Add any new sources with 0 assignment
        selectedSources.forEach(sourceId => {
            if (!(sourceId in entry.individualSourceAssignments)) {
                entry.individualSourceAssignments[sourceId] = 0;
            }
        });
        
        // Remove any unselected sources
        Object.keys(entry.individualSourceAssignments).forEach(sourceId => {
            if (!selectedSources.includes(sourceId)) {
                delete entry.individualSourceAssignments[sourceId];
            }
        });
        
        // Calculate total available and assigned amounts
        let totalAvailable = 0;
        let totalAssigned = 0;
        
        selectedSources.forEach(sourceId => {
            const maxAmount = getMaxAssignableAmount(sourceId, currency, entry.id, hop.hopNumber);
            totalAvailable += maxAmount;
            totalAssigned += entry.individualSourceAssignments[sourceId] || 0;
        });
        
        console.log(`Total available from ${selectedSources.length} sources: ${totalAvailable} ${currency}`);
        console.log(`Total assigned: ${totalAssigned} ${currency}`);
        
        // Update main amount field with total assigned
        entry.amount = totalAssigned.toString();
        
        // Update max amount for input
        const amountInput = document.getElementById(`assignAmount_${hopNumber}_${entryId}`);
        if (amountInput) {
            amountInput.max = totalAvailable;
            amountInput.value = totalAssigned;
        }
        
        // AUTO-GENERATE NOTATION FROM MULTIPLE SOURCE THREADS
        autoGenerateNotationFromMultipleSources(hopNumber, entryId, selectedSources);
        
        // Show the granular control interface immediately
        updateMultipleSourcePreview(hopNumber, entryId);
        updateFullNotationDisplayMultiple(hopNumber, entryId);
    } else {
        // No sources selected - clear everything
        const amountInput = document.getElementById(`assignAmount_${hopNumber}_${entryId}`);
        if (amountInput) {
            amountInput.max = 0;
            amountInput.value = '';
        }
        entry.amount = '';
        entry.multipleSourceThreads = [];
        entry.isConvergence = false;
        entry.sourceThreadId = '';
        entry.individualSourceAssignments = {};
        
        // Clear notation fields
        clearNotationFields(hopNumber, entryId);
        
        // Clear the preview
        const previewElement = document.getElementById(`multipleSourcePreview_${hopNumber}_${entryId}`);
        if (previewElement) {
            previewElement.innerHTML = '';
        }
    }
    
    saveToStorage();
    // Don't re-render the entire hop list - this causes entries to collapse while user is working
    // Just update the preview which is sufficient for the user to continue working
    // renderHops();
}
// ALSO ADD THIS NEW FUNCTION TO PROPERLY VALIDATE MULTIPLE SOURCE ASSIGNMENTS

function validateMultipleSourceAssignment(entry) {
    if (!entry.multipleSourceThreads || entry.multipleSourceThreads.length === 0) {
        return { valid: false, error: 'No source threads selected' };
    }
    
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    const amount = parseFloat(entry.amount);
    
    if (isNaN(amount) || amount <= 0) {
        return { valid: false, error: 'Amount must be a positive number' };
    }
    
    // Calculate total available from all selected sources using REAL-TIME calculation
    let totalAvailable = 0;
    entry.multipleSourceThreads.forEach(sourceId => {
        totalAvailable += getMaxAssignableAmount(sourceId, currency);
    });
    
    if (amount > totalAvailable) {
        return { 
            valid: false, 
            error: `Amount ${amount.toLocaleString()} exceeds total available ${totalAvailable.toLocaleString()} ${currency}` 
        };
    }
    
    return { valid: true, totalAvailable: totalAvailable };
}


function updateMultipleSourcePreview(hopNumber, entryId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    const previewElement = document.getElementById(`multipleSourcePreview_${hopNumber}_${entryId}`);
    
    if (!previewElement || !entry.multipleSourceThreads || entry.multipleSourceThreads.length === 0) {
        if (previewElement) previewElement.innerHTML = '';
        return;
    }
    
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    
    // Initialize individual assignments if not exists
    if (!entry.individualSourceAssignments) {
        entry.individualSourceAssignments = {};
        entry.multipleSourceThreads.forEach(sourceId => {
            entry.individualSourceAssignments[sourceId] = 0;
        });
    }
    
    let totalAvailable = 0;
    let totalAssigned = 0;
    let sourceInputsHTML = '';
    
    entry.multipleSourceThreads.forEach(sourceId => {
        const maxAmount = getMaxAssignableAmount(sourceId, currency, entry.id, entry.hopNumber);
        const assignedAmount = entry.individualSourceAssignments[sourceId] || 0;
        const remaining = maxAmount - assignedAmount;
        
        totalAvailable += maxAmount;
        totalAssigned += assignedAmount;
        
        sourceInputsHTML += `
            <div style="display: flex; align-items: center; gap: 10px; margin: 8px 0; padding: 8px; background: white; border-radius: 4px; border: 1px solid #ddd;">
                <div style="flex: 1; font-weight: bold; color: #2c3e50;">
                    ${sourceId}
                </div>
                <div style="display: flex; align-items: center; gap: 5px;">
                    <input type="number" 
                           step="0.01" 
                           min="0" 
                           max="${maxAmount}"
                           value="${assignedAmount}"
                           style="width: 100px; padding: 4px;"
                           onchange="updateIndividualSourceAssignment(${hopNumber}, ${entryId}, '${sourceId}', this.value)"
                           placeholder="0">
                    <span style="font-size: 11px; color: #666;">/ ${maxAmount.toLocaleString()}</span>
                    <button type="button" 
                            onclick="assignMaxToIndividualSource(${hopNumber}, ${entryId}, '${sourceId}')"
                            style="padding: 2px 6px; font-size: 11px; background: #95a5a6; color: white; border: none; border-radius: 3px; cursor: pointer;">
                        Max
                    </button>
                </div>
                <div style="font-size: 11px; color: ${remaining === 0 ? '#e74c3c' : '#27ae60'};">
                    ${remaining === 0 ? 'DEPLETED' : `${remaining.toLocaleString()} left`}
                </div>
            </div>
        `;
    });
    
    // Update main amount field with total assigned
    entry.amount = totalAssigned.toString();
    const mainAmountInput = document.getElementById(`assignAmount_${hopNumber}_${entryId}`);
    if (mainAmountInput) {
        mainAmountInput.value = totalAssigned;
    }
    
    const isValid = totalAssigned <= totalAvailable && totalAssigned > 0;
    
    let previewHTML = `
        <div style="background: #f8f9fa; border: 1px solid #ddd; border-radius: 4px; padding: 15px; margin-top: 10px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <div style="font-weight: bold; color: #2c3e50;">
                    Individual Source Assignments:
                </div>
                <div style="display: flex; gap: 5px;">
                    <button type="button" 
                            onclick="distributeProportionally(${hopNumber}, ${entryId})"
                            style="padding: 4px 8px; font-size: 11px; background: #3498db; color: white; border: none; border-radius: 3px; cursor: pointer;">
                        Distribute Proportionally
                    </button>
                    <button type="button" 
                            onclick="depleteInOrder(${hopNumber}, ${entryId})"
                            style="padding: 4px 8px; font-size: 11px; background: #e67e22; color: white; border: none; border-radius: 3px; cursor: pointer;">
                        Deplete In Order
                    </button>
                    <button type="button" 
                            onclick="clearAllAssignments(${hopNumber}, ${entryId})"
                            style="padding: 4px 8px; font-size: 11px; background: #95a5a6; color: white; border: none; border-radius: 3px; cursor: pointer;">
                        Clear All
                    </button>
                </div>
            </div>
            
            ${sourceInputsHTML}
            
            <div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid #ddd;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <strong>Total Available:</strong> ${totalAvailable.toLocaleString()} ${currency}
                    </div>
                    <div style="color: ${isValid ? '#27ae60' : '#e74c3c'}; font-weight: bold;">
                        <strong>Total Assigned:</strong> ${totalAssigned.toLocaleString()} ${currency}
                        ${!isValid && totalAssigned > totalAvailable ? ' (EXCEEDS AVAILABLE!)' : ''}
                        ${totalAssigned === 0 ? ' (No assignments)' : ''}
                    </div>
                </div>
            </div>
        </div>
    `;
    
    previewElement.innerHTML = previewHTML;
}
// Enhanced Full Notation Display for Multiple Sources
function updateFullNotationDisplayMultiple(hopNumber, entryId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    const previewElement = document.getElementById(`notationPreview_${hopNumber}_${entryId}`);
    
    if (!previewElement) return;
    
    const amount = parseFloat(entry.amount);
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    
    if (entry.multipleSourceThreads && entry.multipleSourceThreads.length > 1) {
        // Multiple sources - show convergence notation
        const sourceNotations = entry.multipleSourceThreads.map(sourceId => {
            const sourceAmount = getMaxAssignableAmount(sourceId, currency);
            return `${sourceId}(${formatNumber(sourceAmount)})`;
        });
        
        const displayNotation = `${sourceNotations.join(' + ')} ${entry.notation}`;
        const summaryNotation = `${entry.notation} (${formatNumber(amount)} ${currency} from ${entry.multipleSourceThreads.length} sources)`;
        
        // Update entry with generated notations
        entry.displayNotation = displayNotation;
        entry.summaryNotation = summaryNotation;
        entry.sourceChain = entry.multipleSourceThreads.map(sourceId => ({
            sourceNotation: sourceId,
            amount: getMaxAssignableAmount(sourceId, currency),
            currency: currency,
            percentage: (getMaxAssignableAmount(sourceId, currency) / amount) * 100
        }));
        
        previewElement.innerHTML = `
            <div style="margin-bottom: 8px;"><strong>Display:</strong> ${displayNotation}</div>
            <div style="margin-bottom: 8px;"><strong>Summary:</strong> ${summaryNotation}</div>
            <div style="font-size: 11px; color: #666;">Convergence: ${entry.multipleSourceThreads.join(' + ')} ${entry.notation}</div>
        `;
    } else if (entry.sourceThreadId) {
        // Single source - use existing logic
        updateFullNotationDisplay(hopNumber, entryId);
    } else {
        previewElement.innerHTML = 'Select source(s) and complete notation to generate full display';
    }
}
// =================================
// PHASE 1: ENHANCED DATA STRUCTURES
// =================================
        // STEP 4.1: REPLACE YOUR EXISTING entryTypes OBJECT WITH THIS:

        const entryTypes = {
            'trace': 'Outgoing Transaction',
            'cold_storage': 'Mark as Cold Storage'
        };


        // currencies already defined earlier with more complete information including decimals

        // timezones already defined earlier
        const writeoffCategories = {
            'dust': 'Dust - Below threshold',
            'dilution': 'Dilution - Too diluted to trace',
            'obfuscation': 'Obfuscation - Privacy services',
            'operational': 'Operational - Resource constraints'
        };

        // Format number with commas while preserving full decimal precision
        function formatNumber(value) {
            if (!value || isNaN(value)) return '0';
            
            const parts = value.toString().split('.');
            const integerPart = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ',');
            
            if (parts.length === 2) {
                return integerPart + '.' + parts[1];
            }
            return integerPart;
        }

        // Toggle file dropdown menu
        function toggleFileMenu() {
            const dropdown = document.getElementById('fileDropdown');
            if (dropdown) {
                dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
            }
        }

        // Close file dropdown when clicking outside - will be initialized after DOM loads

        // Security Status Display Function
        function displaySecurityStatus() {
            const protocol = window.location.protocol;
            const container = document.querySelector('.container');
            
            if (protocol === 'file:') {
                // Add warning banner for file:// protocol
                const warningBanner = document.createElement('div');
                warningBanner.style.cssText = `
                    background: #fff3cd;
                    border: 2px solid #ffc107;
                    color: #856404;
                    padding: 15px;
                    margin-bottom: 20px;
                    border-radius: 8px;
                    display: flex;
                    align-items: center;
                    gap: 10px;
                `;
                warningBanner.innerHTML = `
                    <span style="font-size: 24px;">⚠️</span>
                    <div>
                        <strong>Limited Functionality - File Protocol Detected</strong><br>
                        <small>You're running B.A.T.S. from a local file. For full functionality including custom save locations and API features, please serve this file over HTTPS. 
                        <a href="training.html#deployment" target="_blank" style="color: #856404; text-decoration: underline;">Learn more about deployment options</a></small>
                    </div>
                `;
                container.insertBefore(warningBanner, container.firstChild);
            } else if (protocol === 'https:') {
                // Add secure connection indicator
                const secureIndicator = document.createElement('div');
                secureIndicator.style.cssText = `
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    background: #d4edda;
                    border: 1px solid #c3e6cb;
                    color: #155724;
                    padding: 8px 15px;
                    border-radius: 6px;
                    font-size: 12px;
                    display: flex;
                    align-items: center;
                    gap: 5px;
                    z-index: 1000;
                    opacity: 0.9;
                `;
                secureIndicator.innerHTML = `
                    <span style="color: #28a745;">🔒</span> Secure Connection
                `;
                document.body.appendChild(secureIndicator);
                
                // Auto-hide after 5 seconds
                setTimeout(() => {
                    secureIndicator.style.transition = 'opacity 0.5s';
                    secureIndicator.style.opacity = '0';
                    setTimeout(() => secureIndicator.remove(), 500);
                }, 5000);
            }
        }

        // Make sure these functions are globally accessible
        window.switchTab = switchTab;
        window.toggleFileMenu = toggleFileMenu;
        window.openPKConverter = openPKConverter;
        window.closePKConverterModal = closePKConverterModal;
        window.openAddressFinder = openAddressFinder;
        window.closeAddressFinderModal = closeAddressFinderModal;

        // Clean up memory on page unload
        window.addEventListener('beforeunload', () => {
            // Clear undo history to free memory
            if (typeof undoHistory !== 'undefined' && undoHistory && undoHistory.length > 0) {
                undoHistory.forEach(state => {
                    if (state && state.investigation) {
                        state.investigation = null;
                    }
                });
                undoHistory.length = 0;
            }
        });

        document.addEventListener('DOMContentLoaded', function() {
    console.log('Initializing B.A.T.S. application...');

    // Display security status
    displaySecurityStatus();

    // Check if user is entering app or should see landing page
    const urlParams = new URLSearchParams(window.location.search);
    const enterApp = urlParams.get('app') === 'true';
    const hasExistingCase = investigation.caseId || (investigation.victims && investigation.victims.length > 0);

    if (enterApp || hasExistingCase) {
        // User is entering the app or has existing work
        initializeApp();
        window.appInitialized = true;

        // If entering from landing page, show app UI and welcome message
        if (enterApp && !hasExistingCase) {
            showAppUI();
            switchTab('casedetails');

            // Show intro for new users only
            if (!localStorage.getItem('bats_intro_shown')) {
                setTimeout(() => {
                    alert('Welcome to B.A.T.S. Documentation\n\n' +
                          'Step 1: Fill in your case details\n' +
                          'Step 2: Add victim information and transactions\n' +
                          'Step 3: Document fund traces using V-T-H notation\n' +
                          'Step 4: Generate your investigation report\n\n' +
                          'Remember: Use your blockchain analysis tools alongside B.A.T.S. for actual tracing.');
                    localStorage.setItem('bats_intro_shown', 'true');
                }, 500);
            }
        } else if (hasExistingCase) {
            // Show app UI for existing cases
            showAppUI();
        }
    } else {
        // Show landing page
        showLandingPage();
    }
});

function initializeApp() {
    try {
        // Enhanced structure initialization
        initializeCompleteIntegration();

        // Build thread tracking index
        buildAvailableThreadsIndex();

        // Original initialization
        loadFromStorage();
        renderAll();
        updateWorkflowSteps();
        setupConversionModalListeners();

        // Show app UI
        showAppUI();

        // Show Victims tab by default to avoid white screen
        switchTab('victims');

        // Check onboarding state on load
        setTimeout(() => {
            checkOnboardingState();
        }, 100);
        
        // Setup event listeners for case info with better error handling
        const caseIdInput = document.getElementById('caseId');
        const investigatorInput = document.getElementById('investigator');
        const caseTypeInput = document.getElementById('caseType');
        
        if (caseIdInput) {
            caseIdInput.addEventListener('change', function() {
                try {
                    investigation.caseId = this.value;
                    saveToStorage();
                } catch (error) {
                    console.error('Error saving case ID:', error);
                }
            });
        }
        if (investigatorInput) {
            investigatorInput.addEventListener('change', function() {
                try {
                    investigation.investigator = this.value;
                    saveToStorage();
                } catch (error) {
                    console.error('Error saving investigator:', error);
                }
            });
        }
        if (caseTypeInput) {
            caseTypeInput.addEventListener('change', function() {
                try {
                    investigation.caseType = this.value;
                    saveToStorage();
                } catch (error) {
                    console.error('Error saving case type:', error);
                }
            });
        }
        
        // Add case synopsis handler
        const caseSynopsisInput = document.getElementById('caseSynopsis');
        if (caseSynopsisInput) {
            caseSynopsisInput.addEventListener('change', function() {
                try {
                    investigation.caseSynopsis = this.value;
                    saveToStorage();
                } catch (error) {
                    console.error('Error saving case synopsis:', error);
                }
            });
        }
        
        // Close file dropdown when clicking outside
        document.addEventListener('click', function(event) {
            const dropdown = document.getElementById('fileDropdown');
            const fileButton = event.target.closest('button[onclick="toggleFileMenu()"]');
            
            if (dropdown && !fileButton && !dropdown.contains(event.target)) {
                dropdown.style.display = 'none';
            }
        });
        
        console.log(' B.A.T.S. application initialized successfully');

    } catch (error) {
        console.error('❌ Error initializing B.A.T.S. application:', error);
        alert('There was an error initializing the application. Please refresh the page and try again.');
    }
}
function updateFormFieldsFromInvestigation() {
    console.log('Updating form fields from investigation data...');
    
    // Update the form fields
    const caseIdField = document.getElementById('caseId');
    const investigatorField = document.getElementById('investigator');
    const caseTypeField = document.getElementById('caseType');
    const caseSynopsisField = document.getElementById('caseSynopsis');
    
    if (caseIdField) {
        caseIdField.value = investigation.caseId || '';
    }
    if (investigatorField) {
        investigatorField.value = investigation.investigator || '';
    }
    if (caseTypeField) {
        caseTypeField.value = investigation.caseType || '';
    }
    if (caseSynopsisField) {
        caseSynopsisField.value = investigation.caseSynopsis || '';
    }
    
    
    console.log('Form fields updated');
}

        function updateWorkflowSteps() {
            // Reset all steps
            document.querySelectorAll('.step-item').forEach(step => {
                step.classList.remove('completed', 'active');
            });

            // Step 1: Investigation Setup
            const step1 = document.getElementById('step1');
            if (investigation.caseId && investigation.investigator && investigation.caseType) {
                step1.classList.add('completed');
            } else {
                step1.classList.add('active');
                return;
            }

            // Step 2: Add Victims
            const step2 = document.getElementById('step2');
            if (investigation.victims.length > 0) {
                step2.classList.add('completed');
            } else {
                step2.classList.add('active');
                return;
            }

            // Step 3: Confirm Root Total
            const step3 = document.getElementById('step3');
            if (investigation.rootTotalConfirmed) {
                step3.classList.add('completed');
            } else {
                step3.classList.add('active');
                return;
            }

            // Step 4: Document Traces
            const step4 = document.getElementById('step4');
            if (investigation.hops.length > 0) {
                step4.classList.add('completed');
            }
            step4.classList.add('active');

            // Steps 5 & 6 are always available once root total is confirmed
            if (investigation.rootTotalConfirmed) {
                document.getElementById('step5').classList.add('active');
                document.getElementById('step6').classList.add('active');
            }

            // Show/hide generate root total section
            updateGenerateRootSection();
        }

        function updateGenerateRootSection() {
            const generateSection = document.getElementById('generateRootSection');
            const hasTransactions = investigation.victims.some(v => 
                v.transactions.some(t => t.amount && parseFloat(t.amount) > 0)
            );
            
            if (hasTransactions && !investigation.rootTotalConfirmed) {
                generateSection.style.display = 'block';
                
                // Check if file has been saved to show appropriate button
                if (savedFilePath) {
                    document.getElementById('saveRequiredMessage').style.display = 'none';
                    document.getElementById('generateRootBtn').style.display = 'block';
                } else {
                    document.getElementById('saveRequiredMessage').style.display = 'block';
                    document.getElementById('generateRootBtn').style.display = 'none';
                }
            } else {
                generateSection.style.display = 'none';
            }
        }

        function switchWalletIndex(indexType) {
            // Hide all wallet index content
            document.querySelectorAll('.wallet-index-content').forEach(content => {
                content.style.display = 'none';
            });
            
            // Show selected index
            document.getElementById(indexType + 'WalletIndexContent').style.display = 'block';
            
            // Render the appropriate index
            if (indexType === 'universal') {
                renderUniversalWalletIndex();
            } else if (indexType === 'red') {
                renderRedWalletIndex();
            } else if (indexType === 'purple') {
                renderPurpleWalletIndex();
            } else if (indexType === 'blue') {
                renderBlueWalletIndex();
            }
        }

        // Setup tab-specific actions
        window.tabActions = {
            'summary': () => {
                if (typeof renderSummary !== 'undefined') renderSummary();
                if (typeof updateCaseConclusionStats !== 'undefined') updateCaseConclusionStats();
            },
            'walletindexes': () => {
                if (typeof renderUniversalWalletIndex !== 'undefined') {
                    renderUniversalWalletIndex();
                    renderRedWalletIndex();
                    renderPurpleWalletIndex();
                    renderBlueWalletIndex();
                }
            },
            'victims': () => {
                if (typeof renderVictims !== 'undefined') renderVictims();
            },
            'casedetails': () => {
                if (typeof updateCaseStats !== 'undefined') updateCaseStats();
            },
            'flowdiagram': () => {
                if (investigation.hops && investigation.hops.length > 0) {
                    // Initialize the graph visualization
                    if (typeof initializeGraphVisualization === 'function') {
                        console.log('Initializing graph visualization from flowdiagram tab action');
                        initializeGraphVisualization();
                    } else {
                        console.error('initializeGraphVisualization function not found');
                    }
                    const controls = document.getElementById('flowDiagramControls');
                    if (controls) controls.style.display = 'block';
                } else {
                    const controls = document.getElementById('flowDiagramControls');
                    if (controls) controls.style.display = 'none';
                    const svg = document.getElementById('flowDiagramSVG');
                    if (svg) svg.innerHTML = '<text x="50%" y="50%" text-anchor="middle" fill="#999">No trace data available. Complete at least one hop to generate flow diagram.</text>';
                }
            },
            'reports': () => {
                updateCoverPage();
                // Update narrative editor content
                const narrativeEditor = document.getElementById('narrativeEditor');
                if (narrativeEditor) {
                    narrativeEditor.innerHTML = investigation.narrativeReport || 'Enter your narrative report here...';
                }
                // Generate other reports if not already generated
                if (document.getElementById('report-victims-content')?.innerHTML === '') {
                    generateVictimIndexReport();
                }
                if (document.getElementById('report-redwallet-content')?.innerHTML === '') {
                    generateRedWalletIndexReport();
                }
                if (document.getElementById('report-terminal-content')?.innerHTML === '') {
                    generateTerminalIndexReport();
                }
            },
            'traces': () => {
                if (typeof renderHops !== 'undefined') renderHops();
            }
        };
        
        // switchTab is already defined globally earlier

        function addVictim() {
            const victimId = investigation.victims.length + 1;
            const victim = {
                id: victimId,
                isCompleted: false,  // Initialize completion state
                name: '',  // Initialize name
                transactions: [{
                    id: 1,
                    txHash: '',  // Initialize txHash
                    amount: '',
                    currency: 'USD',
                    customCurrency: '',
                    receivingWallet: '',
                    datetime: '',
                    timezone: 'UTC',
                    notes: ''
                }]
            };
            investigation.victims.push(victim);
            renderVictims();
            saveToStorage();
            updateWorkflowSteps();
        }

        function addTransaction(victimId) {
            const victim = investigation.victims.find(v => v.id === victimId);
            const transactionId = victim.transactions.length + 1;
            victim.transactions.push({
                id: transactionId,
                txHash: '',
                amount: '',
                currency: 'USD',
                customCurrency: '',
                receivingWallet: '',
                datetime: '',
                timezone: 'UTC',
                notes: ''
            });
            renderVictims();
            saveToStorage();
            updateWorkflowSteps();
        }
        
        // Check if a transaction hash already exists across all victims
        function checkTransactionDuplicate(txHash, excludeVictimId, excludeTransactionId) {
            if (!txHash || txHash.trim() === '') return null;
            
            const normalizedHash = txHash.trim().toLowerCase();
            
            for (const victim of investigation.victims) {
                for (const transaction of victim.transactions) {
                    // Skip the current transaction being edited
                    if (victim.id === excludeVictimId && transaction.id === excludeTransactionId) {
                        continue;
                    }
                    
                    if (transaction.txHash && transaction.txHash.trim().toLowerCase() === normalizedHash) {
                        return {
                            victimId: victim.id,
                            transactionId: transaction.id,
                            victimName: victim.name || `Victim ${victim.id}`
                        };
                    }
                }
            }
            
            return null;
        }

        function sortTransactionsChronologically() {
            // Sort all transactions across all victims by datetime
            investigation.victims.forEach(victim => {
                // Sort this victim's transactions by datetime
                victim.transactions.sort((a, b) => {
                    // Handle empty dates - put them at the end
                    if (!a.datetime && !b.datetime) return 0;
                    if (!a.datetime) return 1;
                    if (!b.datetime) return -1;
                    
                    // Convert to comparable dates considering timezone
                    const dateA = new Date(a.datetime + ' ' + (a.timezone || 'UTC'));
                    const dateB = new Date(b.datetime + ' ' + (b.timezone || 'UTC'));
                    
                    return dateA - dateB;
                });
                
                // Re-assign transaction IDs based on new order
                victim.transactions.forEach((transaction, index) => {
                    transaction.id = index + 1;
                });
            });
            
            // Save the reordered data
            saveToStorage();
        }
        
        function fixVictimTransactionOrder(victimId) {
            const victim = investigation.victims.find(v => v.id === victimId);
            if (!victim) return;
            
            // Count transactions with dates
            const transactionsWithDates = victim.transactions.filter(t => t.datetime && t.datetime.trim() !== '').length;
            const totalTransactions = victim.transactions.length;
            
            if (transactionsWithDates === 0) {
                alert('No transactions have dates. Please add dates to transactions before sorting.');
                return;
            }
            
            if (transactionsWithDates < totalTransactions) {
                if (!confirm(`${totalTransactions - transactionsWithDates} transaction(s) are missing dates and will be placed at the end. Continue?`)) {
                    return;
                }
            }
            
            // Save undo state
            saveUndoState(`Fix transaction order for Victim ${victimId}`);
            
            // Sort this victim's transactions by datetime
            victim.transactions.sort((a, b) => {
                // Handle empty dates - put them at the end
                if (!a.datetime && !b.datetime) return 0;
                if (!a.datetime) return 1;
                if (!b.datetime) return -1;
                
                // Convert to UTC timestamps for accurate comparison
                const timestampA = convertToUTC(a.datetime, a.timezone || 'UTC');
                const timestampB = convertToUTC(b.datetime, b.timezone || 'UTC');
                
                return timestampA - timestampB;
            });
            
            // Re-assign transaction IDs based on new order
            victim.transactions.forEach((transaction, index) => {
                transaction.id = index + 1;
            });
            
            // If root total was confirmed, we need to rebuild indexes
            if (investigation.rootTotalConfirmed) {
                buildUniversalWalletIndex();
                buildRedWalletIndex();
                buildAvailableThreadsIndex();
            }
            
            // Re-render
            renderVictims();
            saveToStorage();
            updateWorkflowSteps();
            
            alert(` Transaction order fixed for Victim ${victimId}.\n\nTransactions have been renumbered in chronological order (T1, T2, T3, etc.).`);
        }

        function renderVictims() {
    const container = document.getElementById('victimsList');
    container.innerHTML = '';

    // Show/hide instructions based on victim count
    const instructionsDiv = document.getElementById('victimInstructions');
    if (instructionsDiv) {
        if (investigation.victims.length > 0) {
            instructionsDiv.style.display = 'none';
        } else {
            instructionsDiv.style.display = 'block';
        }
    }

    // CONDITIONAL: Only enforce chronological sorting for PIFO method
    if (investigation.tracingMethod === 'PIFO') {
        sortTransactionsChronologically();
    }

    investigation.victims.forEach(victim => {
        const victimDiv = document.createElement('div');
        victimDiv.className = 'trace-entry';
        
        // Check for chronology errors in this victim's transactions
        const chronologyError = validateTransactionChronology(victim);
        
        // Check if victim is completed (minimized)
        const isMinimized = victim.isCompleted || false;
        
        // Calculate victim total losses by currency
        const totalsByCurrency = {};
        victim.transactions.forEach(t => {
            if (parseFloat(t.amount) > 0) {
                const currency = t.currency === 'CUSTOM' ? t.customCurrency : t.currency;
                if (!totalsByCurrency[currency]) {
                    totalsByCurrency[currency] = 0;
                }
                totalsByCurrency[currency] += parseFloat(t.amount);
            }
        });

        // Format totals display
        const totalsDisplay = Object.entries(totalsByCurrency)
            .map(([currency, amount]) => `${formatNumber(amount)} ${currency}`)
            .join(' | ');

        // Count valid transactions
        const validTransactions = victim.transactions.filter(t =>
            parseFloat(t.amount) > 0 && t.receivingWallet && t.receivingWallet.trim() !== ''
        ).length;

        victimDiv.innerHTML = `
            <div class="trace-header" style="background: ${isMinimized ? '#e8f5e9' : '#fff3e0'}; border: 2px solid ${isMinimized ? '#4caf50' : '#ff9800'};">
                <h3>Victim ${victim.id} ${isMinimized ? `✓ - ${validTransactions} transaction${validTransactions !== 1 ? 's' : ''}, Total Loss: ${totalsDisplay}` : ''}</h3>
                <div>
                    ${!isMinimized ? `<button class="btn btn-success" onclick="completeVictim(${victim.id})" 
                        ${validTransactions === 0 ? 'disabled' : ''} 
                        title="${validTransactions === 0 ? 'Add at least one valid transaction first' : 'Mark this victim as complete'}">
                        ✓ Complete Victim
                    </button>` : 
                    `<button class="btn btn-secondary" onclick="reopenVictim(${victim.id})">
                        Edit
                    </button>`}
                    <button class="btn btn-danger" onclick="removeVictim(${victim.id})">Remove</button>
                </div>
            </div>
            ${!isMinimized ? `
                ${chronologyError ? `
                    <div style="background: #f8d7da; color: #721c24; padding: 15px; margin: 10px 0; border-radius: 4px; border: 1px solid #f5c6cb;">
                        <div style="display: flex; justify-content: space-between; align-items: start;">
                            <div style="flex: 1;">
                                <strong>⚠️ Chronological Order Warning:</strong><br>
                                ${chronologyError.replace(/\n/g, '<br>')}<br><br>
                                <em style="font-size: 12px;">Transactions must be numbered in chronological order for PIFO (Proceeds In First Out) compliance.</em>
                            </div>
                            <button class="btn btn-sm btn-warning" onclick="fixVictimTransactionOrder(${victim.id})" 
                                    style="background: #f39c12; color: white; white-space: nowrap; margin-left: 15px;">
                                🔧 Fix Order
                            </button>
                        </div>
                    </div>
                ` : ''}
                ${victim.transactions.map(transaction => {
                const hasAmount = parseFloat(transaction.amount) > 0;
                const hasWallet = transaction.receivingWallet && transaction.receivingWallet.trim() !== '';
                const isIncomplete = hasAmount && !hasWallet;
                
                return `
                    <div style="background: ${isIncomplete ? '#fff3cd' : 'white'}; padding: 15px; border-radius: 8px; margin-bottom: 10px; border: ${isIncomplete ? '2px solid #ffc107' : '1px solid #e8f0fe'};">
                        ${isIncomplete ? '<div style="color: #856404; font-weight: bold; margin-bottom: 10px;">⚠️ Missing receiving wallet address!</div>' : ''}
                        <div class="trace-notation">V${victim.id}-T${transaction.id}</div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 10px;">
                            <div class="form-group" style="grid-column: span 2; background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%); padding: 20px; border-radius: 8px; border: 2px solid #2196f3; margin-bottom: 15px;">
                                <label style="font-weight: bold; color: #0d47a1; font-size: 16px;">Transaction Hash (Start Here)</label>
                                <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
                                    <input type="text"
                                           id="txHash_victim_${victim.id}_${transaction.id}"
                                           value="${transaction.txHash || ''}"
                                           placeholder="Paste transaction hash to auto-fill details"
                                           onchange="updateTransaction(${victim.id}, ${transaction.id}, 'txHash', this.value)"
                                           style="flex: 1; font-size: 16px; padding: 14px; border: 2px solid #2196f3;">
                                    <button type="button" class="btn btn-sm btn-primary"
                                            onclick="lookupVictimTransaction(${victim.id}, ${transaction.id})"
                                            style="padding: 10px 20px; font-size: 16px; background: #2196f3;">
                                        🔍 Lookup
                                    </button>
                                </div>
                                <div style="display: flex; gap: 10px; align-items: center;">
                                    <label style="color: #0d47a1; margin-right: 10px;">Chain:</label>
                                    <select id="chain_victim_${victim.id}_${transaction.id}"
                                            onchange="updateTransaction(${victim.id}, ${transaction.id}, 'chain', this.value)"
                                            style="flex: 1; padding: 8px; border: 2px solid #2196f3; border-radius: 4px; background: white;">
                                        <option value="">Auto-detect</option>
                                        <option value="bitcoin">Bitcoin</option>
                                        <option value="ethereum">Ethereum</option>
                                        <option value="bsc">BNB Chain</option>
                                        <option value="polygon">Polygon</option>
                                        <option value="arbitrum">Arbitrum</option>
                                        <option value="optimism">Optimism</option>
                                        <option value="base">Base</option>
                                        <option value="avalanche">Avalanche</option>
                                        <option value="hyperevm">HyperEVM</option>
                                        <option value="linea">Linea</option>
                                        <option value="scroll">Scroll</option>
                                        <option value="mantle">Mantle</option>
                                        <option value="blast">Blast</option>
                                        <option value="zksync">zkSync</option>
                                        <option value="gnosis">Gnosis</option>
                                        <option value="unichain">Unichain</option>
                                        <option value="sonic">Sonic</option>
                                        <option value="abstract">Abstract</option>
                                        <option value="memecore">Memecore</option>
                                        <option value="sophon">Sophon</option>
                                        <option value="berachain">Berachain</option>
                                        <option value="tron">Tron</option>
                                        <option value="xrp">XRP (Ripple)</option>
                                        <option value="thorchain">THORChain</option>
                                        <option value="sui">Sui</option>
                                        <option value="solana">Solana</option>
                                    </select>
                                </div>
                                <div style="font-size: 12px; color: #0d47a1; margin-top: 8px;">Paste the transaction hash and click Lookup to automatically fetch transaction details</div>
                            </div>
                            <div class="form-group">
                                <label>Amount</label>
                                <input type="number" 
                                       id="amount_victim_${victim.id}_${transaction.id}"
                                       step="${getCurrencyStep(transaction.currency)}" 
                                       value="${transaction.amount}" 
                                       onchange="updateTransaction(${victim.id}, ${transaction.id}, 'amount', this.value)"
                                       title="${transaction.currency} supports ${getCurrencyDecimals(transaction.currency)} decimal places">
                            </div>
                            <div class="form-group">
                                <label>Currency</label>
                                <select id="currency_victim_${victim.id}_${transaction.id}"
                                        onchange="updateTransactionCurrency(${victim.id}, ${transaction.id}, this.value)">
                                    <option value="USD" ${transaction.currency === 'USD' ? 'selected' : ''}>US Dollar</option>
                                    <option value="BTC" ${transaction.currency === 'BTC' ? 'selected' : ''}>Bitcoin</option>
                                    <option value="ETH" ${transaction.currency === 'ETH' ? 'selected' : ''}>Ethereum</option>
                                    <option value="USDT" ${transaction.currency === 'USDT' ? 'selected' : ''}>Tether</option>
                                    <option value="USDC" ${transaction.currency === 'USDC' ? 'selected' : ''}>USD Coin</option>
                                    <option value="TRX" ${transaction.currency === 'TRX' ? 'selected' : ''}>TRON</option>
                                    <option value="SOL" ${transaction.currency === 'SOL' ? 'selected' : ''}>Solana</option>
                                    <option value="ADA" ${transaction.currency === 'ADA' ? 'selected' : ''}>Cardano</option>
                                    <option value="DAI" ${transaction.currency === 'DAI' ? 'selected' : ''}>DAI</option>
                                    <option value="BNB" ${transaction.currency === 'BNB' ? 'selected' : ''}>BNB</option>
                                    <option value="MATIC" ${transaction.currency === 'MATIC' ? 'selected' : ''}>MATIC</option>
                                    <option value="AVAX" ${transaction.currency === 'AVAX' ? 'selected' : ''}>AVAX</option>
                                    <option value="HYPE" ${transaction.currency === 'HYPE' ? 'selected' : ''}>HYPE</option>
                                    <option value="MNT" ${transaction.currency === 'MNT' ? 'selected' : ''}>MNT</option>
                                    <option value="CUSTOM" ${transaction.currency === 'CUSTOM' ? 'selected' : ''}>Custom Currency</option>
                                </select>
                            </div>
                            <div class="form-group" style="grid-column: span 2;">
                                <label style="color: ${isIncomplete ? '#dc3545' : 'inherit'}; font-weight: ${isIncomplete ? 'bold' : 'normal'};">
                                    Receiving Wallet Address (RED Wallet) ${isIncomplete ? '- REQUIRED' : ''}
                                </label>
                                <input type="text" 
                                       id="receivingWallet_victim_${victim.id}_${transaction.id}"
                                       value="${transaction.receivingWallet || ''}" 
                                       placeholder="Wallet address that received victim's funds"
                                       style="border-color: ${isIncomplete ? '#dc3545' : '#e8f0fe'};"
                                       onchange="updateTransaction(${victim.id}, ${transaction.id}, 'receivingWallet', this.value)">
                            </div>
                            <div class="form-group ${transaction.currency === 'CUSTOM' ? '' : 'custom-currency-input'}" 
                                 id="customCurrency_${victim.id}_${transaction.id}">
                                <label>Custom Currency Symbol</label>
                                <input type="text" value="${transaction.customCurrency || ''}" 
                                       placeholder="e.g., DOGE, SHIB"
                                       onchange="updateTransaction(${victim.id}, ${transaction.id}, 'customCurrency', this.value)">
                            </div>
                            <div class="form-group">
                                <label>Date & Time with Timezone</label>
                                <div class="datetime-timezone">
                                    <input type="datetime-local" 
                                           id="datetime_victim_${victim.id}_${transaction.id}"
                                           value="${transaction.datetime}" 
                                           onchange="updateTransaction(${victim.id}, ${transaction.id}, 'datetime', this.value)">
                                    <select id="timezone_victim_${victim.id}_${transaction.id}"
                                            onchange="onTimezoneChange('datetime_victim_${victim.id}_${transaction.id}', 'victim', ${victim.id}, ${transaction.id})">
                                        ${Object.entries(timezones).map(([key, value]) => 
                                            `<option value="${key}" ${transaction.timezone === key ? 'selected' : ''}>${value}</option>`
                                        ).join('')}
                                    </select>
                                </div>
                            </div>
                            <div class="form-group" style="grid-column: span 2;">
                                <label>Notes</label>
                                <input type="text" value="${transaction.notes}" 
                                       placeholder="Payment description, method, etc."
                                       onchange="updateTransaction(${victim.id}, ${transaction.id}, 'notes', this.value)">
                            </div>
                        </div>
                    </div>
                `.trim();
            }).join('')}` : ''}
            ${!isMinimized ? `
                <button class="btn btn-add-transaction" onclick="addTransaction(${victim.id})">+ Add Transaction</button>
                <button class="btn btn-secondary" onclick="openBulkTransactionModal(${victim.id})">📋 Bulk Add Transactions</button>
                <div style="text-align: center; margin-top: 20px; padding-top: 20px; border-top: 2px solid #e0e0e0;">
                    <button class="btn btn-success" onclick="completeVictim(${victim.id})" 
                        ${validTransactions === 0 ? 'disabled' : ''} 
                        title="${validTransactions === 0 ? 'Add at least one valid transaction first' : 'Mark this victim as complete'}"
                        style="padding: 12px 30px; font-size: 16px;">
                        ✓ Complete Victim
                    </button>
                </div>
            ` : `
                <div style="padding: 15px; background: white; border-radius: 6px; margin-top: 10px;">
                    <h4 style="margin-bottom: 10px; color: #2c3e50;">Transaction Summary:</h4>
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr style="background: #f8f9fa;">
                                <th style="padding: 8px; text-align: left; border: 1px solid #ddd;">V-T</th>
                                <th style="padding: 8px; text-align: left; border: 1px solid #ddd;">Date</th>
                                <th style="padding: 8px; text-align: right; border: 1px solid #ddd;">Amount</th>
                                <th style="padding: 8px; text-align: left; border: 1px solid #ddd;">Asset</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${victim.transactions.filter(t => parseFloat(t.amount) > 0).map(transaction => `
                                <tr>
                                    <td style="padding: 8px; border: 1px solid #ddd;">V${victim.id}-T${transaction.id}</td>
                                    <td style="padding: 8px; border: 1px solid #ddd;">${transaction.datetime || 'N/A'}</td>
                                    <td style="padding: 8px; text-align: right; border: 1px solid #ddd;">${formatNumber(transaction.amount)}</td>
                                    <td style="padding: 8px; border: 1px solid #ddd;">${transaction.currency === 'CUSTOM' ? transaction.customCurrency : transaction.currency}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                        <tfoot>
                            <tr style="background: #e8f4f8; font-weight: bold;">
                                <td colspan="2" style="padding: 8px; border: 1px solid #ddd;">Total Loss:</td>
                                <td colspan="2" style="padding: 8px; border: 1px solid #ddd;">${totalsDisplay || '0'}</td>
                            </tr>
                        </tfoot>
                    </table>
                </div>
            `}
        `;
        container.appendChild(victimDiv);
    });
    
    // Update Add New Victim button visibility
    const addVictimSection = document.getElementById('addVictimSection');
    if (addVictimSection) {
        // Always show the Add New Victim button - no restrictions
        addVictimSection.innerHTML = `
            <button class="btn" onclick="addVictim()"
                    style="font-size: 1rem; padding: 10px 25px; background: #3498db; color: white;">
                + Add ${investigation.victims.length > 0 ? 'Another' : 'New'} Victim
            </button>
        `;
    }
    
    updateGenerateRootSection();
}

        function updateTransactionCurrency(victimId, transactionId, currency) {
            updateTransaction(victimId, transactionId, 'currency', currency);
            
            const customInput = document.getElementById(`customCurrency_${victimId}_${transactionId}`);
            if (currency === 'CUSTOM') {
                customInput.style.display = 'block';
                customInput.classList.remove('custom-currency-input');
            } else {
                customInput.style.display = 'none';
                customInput.classList.add('custom-currency-input');
            }
            
            // Update the amount input step based on new currency
            const amountInput = document.querySelector(`input[onchange*="updateTransaction(${victimId}, ${transactionId}, 'amount'"]`);
            if (amountInput) {
                amountInput.step = getCurrencyStep(currency);
                
                // Show currency info tooltip
                const decimals = getCurrencyDecimals(currency);
                amountInput.title = `${currencies[currency]?.name || currency} supports ${decimals} decimal places`;
            }
            
            // Trigger recalculation of any dependent calculations
            updateWorkflowSteps();
            saveToStorage();
            
            // Log for debugging currency issues
            console.log(`Currency updated for victim ${victimId}, transaction ${transactionId}: ${currency}`);
        }

        function generateRootTotal() {
    // Check if file has been saved
    if (!savedFilePath) {
        document.getElementById('saveRequiredMessage').style.display = 'block';
        document.getElementById('generateRootBtn').style.display = 'none';
        return;
    }
    
    // NEW VALIDATION: Check for missing wallet addresses before generating root total
    const missingWallets = [];
    investigation.victims.forEach(victim => {
        victim.transactions.forEach(transaction => {
            if (parseFloat(transaction.amount) > 0 && (!transaction.receivingWallet || transaction.receivingWallet.trim() === '')) {
                missingWallets.push(`V${victim.id}-T${transaction.id}`);
            }
        });
    });
    
    if (missingWallets.length > 0) {
        alert(`ERROR:  Cannot generate root total: Missing receiving wallet addresses for the following transactions:\n\n${missingWallets.join(', ')}\n\nPlease add receiving wallet addresses for all transactions with amounts before confirming your root total.`);
        return;
    }

    // CONDITIONAL: Check chronological order ONLY for PIFO method
    const chronologyErrors = [];
    if (investigation.tracingMethod === 'PIFO') {
        investigation.victims.forEach(victim => {
            const error = validateTransactionChronology(victim);
            if (error) {
                chronologyErrors.push(error);
            }
        });

        if (chronologyErrors.length > 0) {
            const shouldFix = confirm(`❌ Transaction chronology errors detected!\n\n${chronologyErrors.join('\n\n')}\n\nTransactions must be in chronological order for PIFO compliance.\n\nWould you like to automatically fix the order for all victims?\n\nClick OK to reorder all transactions chronologically.\nClick Cancel to fix manually.`);

            if (shouldFix) {
                // Fix order for all victims with errors
                investigation.victims.forEach(victim => {
                    const error = validateTransactionChronology(victim);
                    if (error) {
                        fixVictimTransactionOrder(victim.id);
                    }
                });

                // Try to generate root total again - using longer delay to avoid race conditions
                setTimeout(() => generateRootTotal(), 500);
                return;
            } else {
                return;
            }
        }
    } else if (investigation.tracingMethod === 'LIBR') {
        // LIBR: Chronological order is informational, not enforced
        console.log('LIBR method selected - chronological ordering is optional for victim transactions');
    }
    
    const totalsByCurrency = {};
    
    // Calculate totals by currency
    investigation.victims.forEach(victim => {
        victim.transactions.forEach(transaction => {
            if (parseFloat(transaction.amount) > 0) {
                const currency = transaction.currency === 'CUSTOM' ? transaction.customCurrency : transaction.currency;
                if (!totalsByCurrency[currency]) {
                    totalsByCurrency[currency] = 0;
                }
                totalsByCurrency[currency] += parseFloat(transaction.amount);
            }
        });
    });
    
    if (Object.keys(totalsByCurrency).length === 0) {
        alert('Please add at least one victim transaction with an amount before generating root total.');
        return;
    }

    // Display totals by currency
    let totalDisplay = '';
    Object.entries(totalsByCurrency).forEach(([currency, amount]) => {
        totalDisplay += `<div style="font-size: 1.8rem; font-weight: bold; color: #27ae60; margin: 10px 0;">${amount.toLocaleString()} ${currency}</div>`;
    });
    
    document.getElementById('totalRootAmount').innerHTML = totalDisplay;
    
    // Add visual progress bars for root total
    let progressBars = '<div style="background: white; padding: 20px; border-radius: 8px; margin: 15px 0; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">';
    progressBars += '<h4 style="margin-bottom: 15px; color: #2c3e50;">📊 Investigation Progress Overview</h4>';
    progressBars += '<p style="color: #666; margin-bottom: 15px; font-size: 14px;">These bars will track your progress as you trace funds through the investigation.</p>';
    
    Object.entries(totalsByCurrency).forEach(([currency, total]) => {
        progressBars += `
            <div style="margin-bottom: 20px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <strong style="font-size: 16px;">${currency}</strong>
                    <span style="font-size: 14px; color: #666;">
                        ${total.toLocaleString()} total
                    </span>
                </div>
                
                <!-- Progress Bar Preview -->
                <div style="position: relative; height: 35px; background: #f5f5f5; border-radius: 20px; overflow: hidden; box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);">
                    <!-- Starting state - all red (unaccounted) -->
                    <div style="position: absolute; left: 0; top: 0; height: 100%; width: 100%; background: #e74c3c;"
                         title="All funds currently unaccounted">
                    </div>
                    
                    <!-- Label -->
                    <div style="position: absolute; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; pointer-events: none;">
                        <span style="color: white; font-size: 12px; font-weight: bold; text-shadow: 1px 1px 2px rgba(0,0,0,0.3);">
                            100% Unaccounted
                        </span>
                    </div>
                </div>
                
                <!-- Legend Preview -->
                <div style="display: flex; gap: 20px; margin-top: 10px; font-size: 12px; flex-wrap: wrap;">
                    <span style="display: flex; align-items: center; gap: 5px;">
                        <span style="width: 14px; height: 14px; background: #27ae60; border-radius: 3px;"></span>
                        Will show traced funds
                    </span>
                    <span style="display: flex; align-items: center; gap: 5px;">
                        <span style="width: 14px; height: 14px; background: #9b59b6; border-radius: 3px;"></span>
                        Will show exchange/VASP
                    </span>
                    <span style="display: flex; align-items: center; gap: 5px;">
                        <span style="width: 14px; height: 14px; background: #3498db; border-radius: 3px;"></span>
                        Will show cold storage
                    </span>
                    <span style="display: flex; align-items: center; gap: 5px;">
                        <span style="width: 14px; height: 14px; background: #95a5a6; border-radius: 3px;"></span>
                        Will show write-offs
                    </span>
                </div>
            </div>
        `;
    });
    
    progressBars += '</div>';
    
    let breakdown = progressBars;
    breakdown += '<div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 15px 0; border: 1px solid #ddd;">';
    breakdown += '<h4 style="margin-bottom: 15px; color: #2c3e50;">📋 Transaction Breakdown by Currency:</h4>';
    
    investigation.victims.forEach(victim => {
        breakdown += `<div style="margin-bottom: 15px; padding: 10px; background: white; border-radius: 6px; border-left: 4px solid #3498db;">`;
        breakdown += `<div style="font-weight: bold; color: #2c3e50; margin-bottom: 8px;">👤 Victim ${victim.id}:</div>`;
        victim.transactions.forEach(transaction => {
            if (parseFloat(transaction.amount) > 0) {
                const currency = transaction.currency === 'CUSTOM' ? transaction.customCurrency : transaction.currency;
                const timeDisplay = transaction.datetime ? 
                    `${transaction.datetime} ${transaction.timezone}` : 
                    'No timestamp';
                breakdown += `<div style="margin-left: 20px; margin-bottom: 5px; color: #34495e;">`;
                breakdown += `<strong>V${victim.id}-T${transaction.id}:</strong> ${parseFloat(transaction.amount).toLocaleString()} ${currency}`;
                breakdown += `<br><small style="color: #7f8c8d;">VASP: ${transaction.receivingWallet}</small>`;
                breakdown += `<br><small style="color: #7f8c8d;">⏰ ${timeDisplay}</small>`;
                if (transaction.notes) {
                    breakdown += `<br><small style="color: #7f8c8d;">📝 ${transaction.notes}</small>`;
                }
                breakdown += `</div>`;
            }
        });
        breakdown += `</div>`;
    });
    breakdown += '</div>';
    
    document.getElementById('rootTotalBreakdown').innerHTML = breakdown;
    showModal('rootTotalModal');
}

        function confirmAndProceed() {
            try {
                console.log('Starting confirmAndProceed...');
                
                investigation.rootTotalConfirmed = true;
                
                // Store confirmed root totals by currency
                investigation.confirmedRootTotalsByCurrency = {};
                investigation.victims.forEach(victim => {
                    victim.transactions.forEach(transaction => {
                        if (parseFloat(transaction.amount) > 0) {
                            const currency = transaction.currency === 'CUSTOM' ? transaction.customCurrency : transaction.currency;
                            if (!investigation.confirmedRootTotalsByCurrency[currency]) {
                                investigation.confirmedRootTotalsByCurrency[currency] = 0;
                            }
                            investigation.confirmedRootTotalsByCurrency[currency] += parseFloat(transaction.amount);
                        }
                    });
                });
                
                console.log('Root totals by currency:', investigation.confirmedRootTotalsByCurrency);
                
                // Keep legacy confirmedRootTotal for backward compatibility (sum of all)
                investigation.confirmedRootTotal = Object.values(investigation.confirmedRootTotalsByCurrency).reduce((sum, amount) => sum + amount, 0);
                
                // Initialize currentART with the confirmed root totals
                investigation.currentART = {...investigation.confirmedRootTotalsByCurrency};
                
                console.log('Total root amount:', investigation.confirmedRootTotal);
                console.log('Current ART:', investigation.currentART);
                
                // Build Universal Wallet Index and Red Wallet Index from victim transactions
                console.log('Building wallet indexes...');
                buildUniversalWalletIndex();
                buildRedWalletIndex();
                
                // Close modal first
                console.log('Closing modal...');
                closeModal();
                
                // Update various statuses
                console.log('Updating statuses...');
                updateValidationStatus();
                updateWorkflowSteps();
                updateGenerateRootSection();
                saveToStorage();
                
                // Auto-save investigation
                console.log('Auto-saving investigation...');
                saveInvestigation();
            
            // Switch to victims tab where hops are rendered
            try {
                switchTab('victims');

                // Scroll to hops section
                setTimeout(() => {
                    const hopsSection = document.getElementById('hops-section');
                    if (hopsSection) {
                        hopsSection.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    }
                }, 200);

                // Force re-render hops to show ready state
                renderHops();

                // Show success message with clear next steps based on methodology
                setTimeout(() => {
                    if (investigation.tracingMethod === 'LIBR') {
                        // LIBR workflow: Show Red Wallets Dashboard
                        alert('✅ Root Total Confirmed!\n\n' +
                              'Your investigation baseline has been established.\n\n' +
                              '🔶 LIBR METHODOLOGY:\n' +
                              'The Red Wallets Dashboard will now open.\n\n' +
                              'Click "Analyze Wallet Balance" for each red wallet to determine if tracing is required.');

                        // Small delay to let alert close
                        setTimeout(() => {
                            showRedWalletsDashboard();
                        }, 500);
                    } else {
                        // PIFO workflow: Standard message
                        alert('✅ Root Total Confirmed!\n\n' +
                              'Your investigation baseline has been established.\n\n' +
                              '🎯 NEXT STEP:\n' +
                              'Scroll down to the "Trace Documentation" section below.\n' +
                              'Click "Create Hop 1" to start tracking where the funds went from the RED wallets.\n\n' +
                              'Hop 1 = First movement of funds AFTER leaving the RED wallets');
                    }
                }, 300);
            } catch (error) {
                console.error('Error switching to victims tab:', error);
                alert('Root total confirmed, but there was an error switching tabs. Please manually scroll down to "Trace Documentation" to continue.');
            }
            
            } catch (error) {
                console.error('Error in confirmAndProceed:', error);
                alert(`An error occurred while confirming the root total:\n\n${error.message}\n\nPlease check the console for more details.`);
                
                // Try to save what we can
                try {
                    investigation.rootTotalConfirmed = true;
                    saveToStorage();
                } catch (saveError) {
                    console.error('Error saving after error:', saveError);
                }
            }
        }

        function buildRedWalletIndex() {
            investigation.redWalletIndex = [];

            // Ensure universal index is up to date first
            if (!investigation.universalWalletIndex || investigation.universalWalletIndex.length === 0) {
                buildUniversalWalletIndex();
            }

            investigation.victims.forEach(victim => {
                victim.transactions.forEach(transaction => {
                    const amount = parseAmount(transaction.amount);
                    if (amount > 0 && transaction.receivingWallet) {
                        const currency = transaction.currency === 'CUSTOM' ? transaction.customCurrency : transaction.currency;
                        const walletAddress = transaction.receivingWallet.trim();

                        // Find corresponding wallet ID from universal index
                        let walletId = '';
                        const universalEntry = investigation.universalWalletIndex.find(w => w.address === walletAddress);
                        if (universalEntry) {
                            walletId = universalEntry.permanentId;
                        } else {
                            // If not found, rebuild universal index and try again
                            console.warn(`Wallet ${walletAddress} not found in universal index, rebuilding...`);
                            buildUniversalWalletIndex();
                            const retryEntry = investigation.universalWalletIndex.find(w => w.address === walletAddress);
                            if (retryEntry) {
                                walletId = retryEntry.permanentId;
                            }
                        }

                        const redEntry = {
                            id: investigation.redWalletIndex.length + 1,
                            vtNotation: `V${victim.id}-T${transaction.id}`,
                            walletId: walletId,
                            walletAddress: walletAddress,
                            depositDate: transaction.datetime,
                            timezone: transaction.timezone,
                            amount: amount,
                            currency: currency,
                            notes: transaction.notes || '',
                            investigativeNotes: '' // For additional investigative findings
                        };

                        investigation.redWalletIndex.push(redEntry);
                    }
                });
            });
        }

        // REPLACE the existing renderRedWalletIndex() function with this:

function renderPurpleWalletIndex() {
    const container = document.getElementById('purpleWalletIndexList');
    
    // Filter only purple wallets from the universal index
    const purpleWallets = (investigation.universalWalletIndex || []).filter(wallet => 
        wallet.permanentType === 'purple'
    );
    
    if (purpleWallets.length === 0) {
        container.innerHTML = `
            <div class="no-traces-message">
                <h3>No Exchange Wallets Identified</h3>
                <p>No PURPLE (exchange) wallets have been identified yet. These are typically identified during trace documentation when funds reach known exchanges.</p>
            </div>
        `;
        return;
    }
    
    let tableHTML = `
        <table style="width: 100%; border-collapse: collapse;">
            <thead>
                <tr style="background: #f8f9fa;">
                    <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Exchange ID</th>
                    <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Exchange Name</th>
                    <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Wallet Address</th>
                    <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">First Seen</th>
                    <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Total Received</th>
                    <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Notes</th>
                </tr>
            </thead>
            <tbody>
    `;
    
    purpleWallets.forEach(wallet => {
        // Calculate total received by this wallet from hop entries
        const receivedAmounts = {};
        investigation.hops.forEach(hop => {
            hop.entries.forEach(entry => {
                if (entry.toWallet === wallet.address && entry.amount) {
                    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                    if (!receivedAmounts[currency]) {
                        receivedAmounts[currency] = 0;
                    }
                    receivedAmounts[currency] += parseFloat(entry.amount);
                }
            });
        });
        
        const totalDisplay = Object.entries(receivedAmounts)
            .map(([currency, amount]) => `${amount.toLocaleString()} ${currency}`)
            .join(', ') || 'No deposits tracked';
        
        tableHTML += `
            <tr>
                <td style="border: 1px solid #ddd; padding: 12px;">
                    <div class="wallet-display purple" style="margin: 0;">${wallet.permanentId}</div>
                </td>
                <td style="border: 1px solid #ddd; padding: 12px;">
                    <input type="text" value="${wallet.exchangeName || ''}" 
                           placeholder="Enter exchange name..."
                           style="width: 100%; padding: 4px; border: 1px solid #ddd; border-radius: 3px;"
                           onchange="updateWalletExchangeName('${wallet.address}', this.value)">
                </td>
                <td style="border: 1px solid #ddd; padding: 12px; font-family: monospace; font-size: 11px;">${wallet.address}</td>
                <td style="border: 1px solid #ddd; padding: 12px;">${wallet.firstSeenHop || 'Unknown'}</td>
                <td style="border: 1px solid #ddd; padding: 12px;">${totalDisplay}</td>
                <td style="border: 1px solid #ddd; padding: 12px;">
                    <textarea placeholder="Legal service notes, subpoena info, etc." 
                              style="width: 100%; min-height: 60px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;"
                              onchange="updateWalletNotes('${wallet.address}', this.value)">${wallet.notes || ''}</textarea>
                </td>
            </tr>
        `;
    });
    
    tableHTML += `
            </tbody>
        </table>
    `;
    
    container.innerHTML = tableHTML;
}

function renderBlueWalletIndex() {
    const container = document.getElementById('blueWalletIndexList');
    
    // Filter only blue wallets from the universal index
    const blueWallets = (investigation.universalWalletIndex || []).filter(wallet => 
        wallet.permanentType === 'blue'
    );
    
    if (blueWallets.length === 0) {
        container.innerHTML = `
            <div class="no-traces-message">
                <h3>No Cold Storage Wallets Identified</h3>
                <p>No BLUE (cold storage) wallets have been identified yet. These are identified when funds remain stationary at the end of a hop.</p>
            </div>
        `;
        return;
    }
    
    let tableHTML = `
        <table style="width: 100%; border-collapse: collapse;">
            <thead>
                <tr style="background: #f8f9fa;">
                    <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Wallet ID</th>
                    <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Wallet Address</th>
                    <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Amount Held</th>
                    <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Last Activity</th>
                    <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Status</th>
                    <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Monitoring Notes</th>
                </tr>
            </thead>
            <tbody>
    `;
    
    blueWallets.forEach(wallet => {
        // Find cold storage entries for this wallet
        const coldStorageAmounts = {};
        let lastActivity = '';
        
        investigation.hops.forEach(hop => {
            hop.entries.forEach(entry => {
                if (entry.entryType === 'cold_storage' && entry.toWallet === wallet.address && entry.amount) {
                    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                    if (!coldStorageAmounts[currency]) {
                        coldStorageAmounts[currency] = 0;
                    }
                    coldStorageAmounts[currency] += parseFloat(entry.amount);
                    
                    if (entry.timestamp) {
                        lastActivity = `${entry.timestamp} ${entry.timezone || 'UTC'}`;
                    }
                }
            });
        });
        
        const amountDisplay = Object.entries(coldStorageAmounts)
            .map(([currency, amount]) => `${amount.toLocaleString()} ${currency}`)
            .join(', ') || 'No amount recorded';
        
        tableHTML += `
            <tr>
                <td style="border: 1px solid #ddd; padding: 12px;">
                    <div class="wallet-display blue" style="margin: 0;">${wallet.permanentId}</div>
                </td>
                <td style="border: 1px solid #ddd; padding: 12px; font-family: monospace; font-size: 11px;">${wallet.address}</td>
                <td style="border: 1px solid #ddd; padding: 12px; font-weight: bold;">${amountDisplay}</td>
                <td style="border: 1px solid #ddd; padding: 12px;">${lastActivity || 'Unknown'}</td>
                <td style="border: 1px solid #ddd; padding: 12px;">
                    <select onchange="updateWalletStatus('${wallet.address}', this.value)"
                            style="width: 100%; padding: 4px; border: 1px solid #ddd; border-radius: 3px;">
                        <option value="monitoring" ${wallet.status === 'monitoring' ? 'selected' : ''}>🔍 Monitoring</option>
                        <option value="moved" ${wallet.status === 'moved' ? 'selected' : ''}>➡️ Funds Moved</option>
                        <option value="seized" ${wallet.status === 'seized' ? 'selected' : ''}>🔒 Seized</option>
                        <option value="abandoned" ${wallet.status === 'abandoned' ? 'selected' : ''}>❌ Abandoned</option>
                    </select>
                </td>
                <td style="border: 1px solid #ddd; padding: 12px;">
                    <textarea placeholder="Movement alerts, monitoring status, etc." 
                              style="width: 100%; min-height: 60px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;"
                              onchange="updateWalletNotes('${wallet.address}', this.value)">${wallet.notes || ''}</textarea>
                </td>
            </tr>
        `;
    });
    
    tableHTML += `
            </tbody>
        </table>
    `;
    
    container.innerHTML = tableHTML;
}

function renderRedWalletIndex() {
    const container = document.getElementById('redWalletIndexList');
    
    if (investigation.redWalletIndex.length === 0) {
        container.innerHTML = `
            <div class="no-traces-message">
                <h3>Red Wallet Index Not Available</h3>
                <p>${!investigation.rootTotalConfirmed ? 
                    'Please complete victim setup to generate the Red Wallet Index. Note: Full functionality requires confirming the root total.' : 
                    'No victim transactions found. Please add victim transactions first.'}</p>
                <button class="btn btn-confirm" onclick="switchTab('victims'); document.querySelector('[onclick=\\"switchTab(\\'victims\\')\\"]').click();">← Back to Victims & Transactions</button>
            </div>
        `;
        return;
    }
    
    // Group red wallet entries by victim
    const entriesByVictim = {};
    investigation.redWalletIndex.forEach(entry => {
        const victimMatch = entry.vtNotation.match(/^V(\d+)/);
        if (victimMatch) {
            const victimId = victimMatch[1];
            if (!entriesByVictim[victimId]) {
                entriesByVictim[victimId] = [];
            }
            entriesByVictim[victimId].push(entry);
        }
    });
    
    let tablesHTML = '';
    
    // Create a table for each victim
    Object.entries(entriesByVictim).forEach(([victimId, entries]) => {
        // Calculate totals for this victim
        const totalsByCurrency = {};
        entries.forEach(entry => {
            if (!totalsByCurrency[entry.currency]) {
                totalsByCurrency[entry.currency] = 0;
            }
            totalsByCurrency[entry.currency] += entry.amount;
        });
        
        const totalsDisplay = Object.entries(totalsByCurrency)
            .map(([currency, amount]) => `${amount.toLocaleString()} ${currency}`)
            .join(' | ');
        
        tablesHTML += `
            <div style="background: white; border-radius: 8px; padding: 20px; margin-bottom: 30px; box-shadow: 0 2px 10px rgba(0,0,0,0.08);">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 2px solid #e8f0fe;">
                    <div>
                        <h3 style="margin: 0; color: #2c3e50; font-size: 1.5rem;">👤 Victim ${victimId} - Red Wallet Deposits</h3>
                        <div style="margin-top: 8px; color: #666; font-size: 14px;">
                            <strong>Total Deposits:</strong> ${totalsDisplay} | <strong>Transactions:</strong> ${entries.length}
                        </div>
                    </div>
                    <button class="btn btn-success" onclick="exportVictimTableToExcel(${victimId})" style="background: #27ae60;">
                        📊 Export Victim ${victimId} to Excel
                    </button>
                </div>
                
                <table id="victimTable_${victimId}" style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr style="background: #f8f9fa;">
                            <th style="border: 1px solid #ddd; padding: 12px; text-align: left; font-weight: bold;">V-T Notation</th>
                            <th style="border: 1px solid #ddd; padding: 12px; text-align: left; font-weight: bold;">Wallet ID</th>
                            <th style="border: 1px solid #ddd; padding: 12px; text-align: left; font-weight: bold;">Deposit Date</th>
                            <th style="border: 1px solid #ddd; padding: 12px; text-align: left; font-weight: bold;">Amount</th>
                            <th style="border: 1px solid #ddd; padding: 12px; text-align: left; font-weight: bold;">Currency</th>
                            <th style="border: 1px solid #ddd; padding: 12px; text-align: left; font-weight: bold;">Wallet Address</th>
                            <th style="border: 1px solid #ddd; padding: 12px; text-align: left; font-weight: bold;">Notes</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${entries.map(entry => {
                            const dateDisplay = entry.depositDate ? 
                                formatDateTimeForReport(entry.depositDate, entry.timezone) : 
                                'Not specified';
                            
                            return `
                                <tr>
                                    <td style="border: 1px solid #ddd; padding: 12px; font-weight: bold; color: #e74c3c;">${entry.vtNotation}</td>
                                    <td style="border: 1px solid #ddd; padding: 12px;">
                                        <div class="wallet-display red" style="margin: 0;">${entry.walletId || 'Not assigned'}</div>
                                    </td>
                                    <td style="border: 1px solid #ddd; padding: 12px; font-size: 12px;">${dateDisplay}</td>
                                    <td style="border: 1px solid #ddd; padding: 12px; font-weight: bold;">${entry.amount.toLocaleString()}</td>
                                    <td style="border: 1px solid #ddd; padding: 12px;">${entry.currency}</td>
                                    <td style="border: 1px solid #ddd; padding: 12px; font-family: monospace; font-size: 11px; word-break: break-all; max-width: 200px;">${entry.walletAddress}</td>
                                    <td style="border: 1px solid #ddd; padding: 12px;">
                                        <div style="margin-bottom: 8px; font-size: 12px; color: #666;">
                                            <strong>Transaction Notes:</strong> ${entry.notes || 'None'}
                                        </div>
                                        <textarea placeholder="Add investigative notes..." 
                                                  style="width: 100%; min-height: 60px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;"
                                                  onchange="updateRedWalletIndexNotes(${entry.id}, this.value)">${entry.investigativeNotes || ''}</textarea>
                                    </td>
                                </tr>
                            `;
                        }).join('')}
                    </tbody>
                </table>
            </div>
        `;
    });
    
    // Add export all button at the top
    const headerHTML = `
        <div style="background: #e8f4f8; border: 2px solid #3498db; border-radius: 8px; padding: 20px; margin-bottom: 20px; text-align: center;">
            <h4 style="color: #2c3e50; margin-bottom: 15px;">📋 Red Wallet Index - Organized by Victim</h4>
            <p style="color: #2c3e50; margin-bottom: 15px;">Each victim's deposits are shown in separate tables below. Export individual victim data or all data using the buttons.</p>
            <button class="btn btn-success" onclick="exportAllVictimTablesToExcel()" style="background: #27ae60; margin-right: 10px;">
                📊 Export All Victims to Excel
            </button>
            <button class="btn" onclick="exportRedWalletIndexCSV()" style="background: #3498db;">
                Export Summary CSV
            </button>
        </div>
    `;
    
    container.innerHTML = headerHTML + tablesHTML;
}

// Helper functions for wallet updates
function updateWalletExchangeName(address, exchangeName) {
    const wallet = investigation.universalWalletIndex.find(w => w.address === address);
    if (wallet) {
        wallet.exchangeName = exchangeName;
        saveToStorage();
    }
}

function updateWalletStatus(address, status) {
    const wallet = investigation.universalWalletIndex.find(w => w.address === address);
    if (wallet) {
        wallet.status = status;
        saveToStorage();
    }
}

// Export wallet index function
function exportWalletIndex(indexType) {
    let wallets = [];
    let filename = '';
    let headers = '';
    
    if (indexType === 'universal') {
        wallets = investigation.universalWalletIndex || [];
        filename = `Universal_Wallet_Index_${investigation.caseId}_${new Date().toISOString().split('T')[0]}.csv`;
        headers = 'Wallet ID,Type,Address,First Seen,Notes\n';
    } else if (indexType === 'red') {
        // Export red wallet index data
        exportRedWalletIndexCSV();
        return;
    } else if (indexType === 'purple') {
        wallets = (investigation.universalWalletIndex || []).filter(w => w.permanentType === 'purple');
        filename = `Purple_Exchange_Wallets_${investigation.caseId}_${new Date().toISOString().split('T')[0]}.csv`;
        headers = 'Exchange ID,Exchange Name,Address,First Seen,Total Received,Notes\n';
    } else if (indexType === 'blue') {
        wallets = (investigation.universalWalletIndex || []).filter(w => w.permanentType === 'blue');
        filename = `Blue_Cold_Storage_Wallets_${investigation.caseId}_${new Date().toISOString().split('T')[0]}.csv`;
        headers = 'Wallet ID,Address,Amount Held,Status,Notes\n';
    }
    
    if (wallets.length === 0) {
        alert('No wallets found in this index.');
        return;
    }
    
    let csvContent = headers;
    
    wallets.forEach(wallet => {
        if (indexType === 'universal') {
            csvContent += `${escapeCSVCell(wallet.permanentId)},${escapeCSVCell(wallet.permanentType)},${escapeCSVCell(wallet.address)},${escapeCSVCell(wallet.firstSeenHop || 'Unknown')},${escapeCSVCell(wallet.notes || '')}\n`;
        } else if (indexType === 'purple') {
            // Calculate total received
            const receivedAmounts = {};
            investigation.hops.forEach(hop => {
                hop.entries.forEach(entry => {
                    if (entry.toWallet === wallet.address && entry.amount) {
                        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                        if (!receivedAmounts[currency]) {
                            receivedAmounts[currency] = 0;
                        }
                        receivedAmounts[currency] += parseFloat(entry.amount);
                    }
                });
            });
            const totalDisplay = Object.entries(receivedAmounts)
                .map(([currency, amount]) => `${amount.toLocaleString()} ${currency}`)
                .join('; ') || 'None';
            
            csvContent += `${escapeCSVCell(wallet.permanentId)},${escapeCSVCell(wallet.exchangeName || '')},${escapeCSVCell(wallet.address)},${escapeCSVCell(wallet.firstSeenHop || 'Unknown')},${escapeCSVCell(totalDisplay)},${escapeCSVCell(wallet.notes || '')}\n`;
        } else if (indexType === 'blue') {
            // Calculate cold storage amounts
            const coldStorageAmounts = {};
            investigation.hops.forEach(hop => {
                hop.entries.forEach(entry => {
                    if (entry.entryType === 'cold_storage' && entry.toWallet === wallet.address && entry.amount) {
                        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                        if (!coldStorageAmounts[currency]) {
                            coldStorageAmounts[currency] = 0;
                        }
                        coldStorageAmounts[currency] += parseFloat(entry.amount);
                    }
                });
            });
            const amountDisplay = Object.entries(coldStorageAmounts)
                .map(([currency, amount]) => `${amount.toLocaleString()} ${currency}`)
                .join('; ') || 'None';
            
            csvContent += `${escapeCSVCell(wallet.permanentId)},${escapeCSVCell(wallet.address)},${escapeCSVCell(amountDisplay)},${escapeCSVCell(wallet.status || 'monitoring')},${escapeCSVCell(wallet.notes || '')}\n`;
        }
    });
    
    // Download the file
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

// ADD these new functions for Excel export functionality:

function exportVictimTableToExcel(victimId) {
    // Get entries for this specific victim
    const victimEntries = investigation.redWalletIndex.filter(entry => 
        entry.vtNotation.startsWith(`V${victimId}-`)
    );
    
    if (victimEntries.length === 0) {
        alert(`No data found for Victim ${victimId}`);
        return;
    }
    
    // Create CSV content
    let csvContent = 'V-T Notation,Wallet ID,Deposit Date,Amount,Currency,Wallet Address,Transaction Notes,Investigative Notes\n';
    
    victimEntries.forEach(entry => {
        const dateDisplay = entry.depositDate ? formatDateTimeForReport(entry.depositDate, entry.timezone) : 'Not specified';
        const walletId = entry.walletId || 'Not assigned';
        const transactionNotes = (entry.notes || '').replace(/"/g, '""');
        const investigativeNotes = (entry.investigativeNotes || '').replace(/"/g, '""');
        
        csvContent += `"${entry.vtNotation}","${walletId}","${dateDisplay}","${entry.amount}","${entry.currency}","${entry.walletAddress}","${transactionNotes}","${investigativeNotes}"\n`;
    });
    
    // Calculate totals for the filename
    const totalsByCurrency = {};
    victimEntries.forEach(entry => {
        if (!totalsByCurrency[entry.currency]) {
            totalsByCurrency[entry.currency] = 0;
        }
        totalsByCurrency[entry.currency] += entry.amount;
    });
    
    const totalsText = Object.entries(totalsByCurrency)
        .map(([currency, amount]) => `${amount.toLocaleString()}${currency}`)
        .join('_');
    
    const filename = `Victim_${victimId}_Red_Wallets_${totalsText}_${investigation.caseId || 'Case'}_${new Date().toISOString().slice(0,10)}.csv`;
    downloadFile(csvContent, filename, 'text/csv');
}
// ADD this function to your JavaScript section:

function exportUniversalWalletIndex() {
    if (!investigation.universalWalletIndex || investigation.universalWalletIndex.length === 0) {
        alert('No universal wallet data to export');
        return;
    }
    
    // Create CSV content with comprehensive wallet data
    let csvContent = 'Wallet ID,Permanent Classification,Current Status,Wallet Address,First Seen,Total Amount,Currencies,Status History,Exposure Chain Summary,Notes\n';
    
    // Sort wallets by type then by ID (same as display)
    const sortedWallets = [...investigation.universalWalletIndex].sort((a, b) => {
        if (a.permanentType !== b.permanentType) {
            const typeOrder = ['red', 'pink', 'yellow', 'orange', 'brown', 'black', 'blue', 'purple', 'gray', 'green'];
            return typeOrder.indexOf(a.permanentType) - typeOrder.indexOf(b.permanentType);
        }
        return a.permanentId.localeCompare(b.permanentId);
    });
    
    sortedWallets.forEach(wallet => {
        // Format currencies as "BTC: 1.5, USD: 5000"
        const currenciesText = Object.entries(wallet.currencies || {})
            .map(([currency, amount]) => `${currency}: ${amount.toLocaleString()}`)
            .join('; ');
        
        // Format status history
        const statusHistory = (wallet.statusHistory || []).join(' ');
        
        // Format exposure chain summary
        const exposureChainSummary = (wallet.exposureChain || [])
            .map(exp => `${exp.notation}(${exp.amount.toLocaleString()} ${exp.currency})`)
            .join('; ');
        
        // Clean and escape text fields
        const walletId = wallet.permanentId || wallet.id || '';
        const permanentClassification = walletTypes[wallet.permanentType] || wallet.permanentType || '';
        const currentStatus = wallet.currentStatus !== wallet.permanentType ? 
            `${walletTypes[wallet.currentStatus] || wallet.currentStatus} (Currently)` : 
            permanentClassification;
        const address = wallet.address || '';
        const firstSeen = wallet.firstSeen ? 
            (wallet.firstSeenTimezone ? formatDateTimeForReport(wallet.firstSeen, wallet.firstSeenTimezone) : wallet.firstSeen + ' UTC') : '';
        const totalAmount = wallet.totalAmount ? wallet.totalAmount.toLocaleString() : '0';
        const notes = (wallet.notes || '').replace(/"/g, '""').replace(/\n/g, ' ');
        
        csvContent += `"${walletId}","${permanentClassification}","${currentStatus}","${address}","${firstSeen}","${totalAmount}","${currenciesText}","${statusHistory}","${exposureChainSummary}","${notes}"\n`;
    });
    
    const filename = `Universal_Wallet_Index_${investigation.caseId || 'Case'}_${new Date().toISOString().slice(0,10)}.csv`;
    downloadFile(csvContent, filename, 'text/csv');
}

function exportAllVictimTablesToExcel() {
    if (investigation.redWalletIndex.length === 0) {
        alert('No red wallet data to export');
        return;
    }
    
    // Create comprehensive CSV with victim grouping
    let csvContent = 'Victim ID,V-T Notation,Wallet ID,Deposit Date,Amount,Currency,Wallet Address,Transaction Notes,Investigative Notes\n';
    
    // Group by victim and add victim ID column
    const entriesByVictim = {};
    investigation.redWalletIndex.forEach(entry => {
        const victimMatch = entry.vtNotation.match(/^V(\d+)/);
        if (victimMatch) {
            const victimId = victimMatch[1];
            if (!entriesByVictim[victimId]) {
                entriesByVictim[victimId] = [];
            }
            entriesByVictim[victimId].push(entry);
        }
    });
    
    Object.entries(entriesByVictim).forEach(([victimId, entries]) => {
        entries.forEach(entry => {
            const dateDisplay = entry.depositDate ? formatDateTimeForReport(entry.depositDate, entry.timezone) : 'Not specified';
            const walletId = entry.walletId || 'Not assigned';
            const transactionNotes = (entry.notes || '').replace(/"/g, '""');
            const investigativeNotes = (entry.investigativeNotes || '').replace(/"/g, '""');
            
            csvContent += `"${victimId}","${entry.vtNotation}","${walletId}","${dateDisplay}","${entry.amount}","${entry.currency}","${entry.walletAddress}","${transactionNotes}","${investigativeNotes}"\n`;
        });
    });
    
    const filename = `All_Victims_Red_Wallets_${investigation.caseId || 'Case'}_${new Date().toISOString().slice(0,10)}.csv`;
    downloadFile(csvContent, filename, 'text/csv');
}

function exportRedWalletIndexCSV() {
    // Create summary CSV (original format)
    let csvContent = 'V-T Notation,Wallet ID,Deposit Date,Amount,Currency,Wallet Address,Transaction Notes,Investigative Notes\n';
    
    investigation.redWalletIndex.forEach(entry => {
        const dateDisplay = entry.depositDate ? formatDateTimeForReport(entry.depositDate, entry.timezone) : 'Not specified';
        const walletId = entry.walletId || 'Not assigned';
        const transactionNotes = (entry.notes || '').replace(/"/g, '""');
        const investigativeNotes = (entry.investigativeNotes || '').replace(/"/g, '""');
        
        csvContent += `"${entry.vtNotation}","${walletId}","${dateDisplay}","${entry.amount}","${entry.currency}","${entry.walletAddress}","${transactionNotes}","${investigativeNotes}"\n`;
    });
    
    const filename = `Red_Wallet_Index_Summary_${investigation.caseId || 'Case'}_${new Date().toISOString().slice(0,10)}.csv`;
    downloadFile(csvContent, filename, 'text/csv');
}
        function updateRedWalletIndexNotes(entryId, notes) {
            const entry = investigation.redWalletIndex.find(e => e.id === entryId);
            if (entry) {
                entry.investigativeNotes = notes;
                saveToStorage();
            }
        }

        function buildUniversalWalletIndex() {
            investigation.universalWalletIndex = [];
            const walletMap = new Map();
            const colorCounters = {
                red: 1, pink: 1, yellow: 1, orange: 1, brown: 1,
                black: 1, blue: 1, purple: 1, gray: 1, green: 1
            };
            
            // Start with RED wallets from victim transactions
            investigation.victims.forEach(victim => {
                victim.transactions.forEach(transaction => {
                    if (parseFloat(transaction.amount) > 0 && transaction.receivingWallet) {
                        const address = transaction.receivingWallet.trim();
                        
                        if (!walletMap.has(address)) {
                            const walletEntry = {
                                id: `RED ${colorCounters.red}`,
                                permanentId: `RED ${colorCounters.red}`,
                                address: address,
                                permanentType: 'red',
                                currentStatus: 'red',
                                totalAmount: 0,
                                currencies: {},
                                exposureChain: [],
                                firstSeen: `V${victim.id}-T${transaction.id}`,
                                statusHistory: ['red'],
                                isDestination: false,
                                isSource: true,
                                notes: ''
                            };
                            walletMap.set(address, walletEntry);
                            colorCounters.red++;
                        }
                        
                        const wallet = walletMap.get(address);
                        const currency = transaction.currency === 'CUSTOM' ? transaction.customCurrency : transaction.currency;
                        const amount = parseFloat(transaction.amount);
                        
                        if (!wallet.currencies[currency]) {
                            wallet.currencies[currency] = 0;
                        }
                        wallet.currencies[currency] += amount;
                        wallet.totalAmount += amount;
                        
                        // Add exposure chain
                        wallet.exposureChain.push({
                            notation: `V${victim.id}-T${transaction.id}`,
                            amount: amount,
                            currency: currency,
                            type: 'victim_payment'
                        });
                    }
                });
            });
            
            // Process hop entries to build complete wallet index
            investigation.hops.forEach(hop => {
                hop.entries.forEach(entry => {
                    if (entry.entryType === 'trace' && entry.toWallet && parseFloat(entry.amount) > 0) {
                        const address = entry.toWallet.trim();
                        const walletType = entry.toWalletType || 'black';
                        
                        if (!walletMap.has(address)) {
                            // New wallet - BLUE wallets get temporary classification, others get permanent
                            const permanentType = walletType === 'blue' ? 'temporary' : walletType;
                            const walletId = walletType === 'blue' ? 
                                'BLUE (Temporary)' : 
                                `${permanentType.toUpperCase()} ${colorCounters[permanentType]}`;
                            
                            const walletEntry = {
                                id: walletId,
                                permanentId: walletType === 'blue' ? 'BLUE (Temporary)' : `${permanentType.toUpperCase()} ${colorCounters[permanentType]}`,
                                address: address,
                                permanentType: permanentType,
                                currentStatus: walletType,
                                totalAmount: 0,
                                currencies: {},
                                exposureChain: [],
                                firstSeen: entry.notation,
                                statusHistory: [walletType],
                                isDestination: true,
                                isSource: false,
                                notes: ''
                            };
                            walletMap.set(address, walletEntry);
                            
                            // Only increment counter for permanent types
                            if (walletType !== 'blue') {
                                colorCounters[permanentType]++;
                            }
                        } else {
                            // Existing wallet - check if we need to update permanent classification
                            const wallet = walletMap.get(address);
                            
                            // Check if wallet classification should be updated
                            if (wallet.permanentType !== walletType) {
                                // Check if this is an allowed progression
                                if (canChangeWalletClassification(wallet.permanentType, walletType)) {
                                    // For automatic classifications during hop building, skip manual auth
                                    const oldType = wallet.permanentType;
                                    
                                    // Record the automatic change
                                    if (!wallet.classificationHistory) {
                                        wallet.classificationHistory = [];
                                    }
                                    
                                    wallet.classificationHistory.push({
                                        timestamp: new Date().toISOString(),
                                        fromType: oldType,
                                        toType: walletType,
                                        justification: `Automatic classification: ${walletType === 'yellow' ? 'Multiple traces converged at this wallet' : walletType === 'brown' ? 'Asset conversion detected' : 'Behavioral pattern detected'}`,
                                        investigator: investigation.investigator || 'System'
                                    });
                                    
                                    // Update the classification
                                    wallet.permanentType = walletType;
                                    wallet.permanentId = `${walletType.toUpperCase()} ${colorCounters[walletType]}`;
                                    colorCounters[walletType]++;
                                    
                                    // Add to status history
                                    if (!wallet.statusHistory.includes(`Auto-reclassified from ${oldType} to ${walletType}`)) {
                                        wallet.statusHistory.push(`Auto-reclassified from ${oldType} to ${walletType}`);
                                    }
                                }
                            }
                            // Always update current status
                            if (wallet.currentStatus !== walletType) {
                                wallet.currentStatus = walletType;
                                if (!wallet.statusHistory.includes(walletType)) {
                                    wallet.statusHistory.push(walletType);
                                }
                            }
                        }
                        
                        const wallet = walletMap.get(address);
                        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                        const amount = parseFloat(entry.amount);
                        
                        if (!wallet.currencies[currency]) {
                            wallet.currencies[currency] = 0;
                        }
                        wallet.currencies[currency] += amount;
                        wallet.totalAmount += amount;
                        
                        // Add exposure chain
                        wallet.exposureChain.push({
                            notation: entry.notation,
                            amount: amount,
                            currency: currency,
                            type: 'trace_movement',
                            hopNumber: entry.hopNumber
                        });
                        
                        wallet.isDestination = true;
                    }
                });
            });
            
            // Convert map to array
            investigation.universalWalletIndex = Array.from(walletMap.values());
        }

        function renderUniversalWalletIndex() {
            const container = document.getElementById('universalWalletIndexList');
            
            if (!investigation.universalWalletIndex || investigation.universalWalletIndex.length === 0) {
                container.innerHTML = `
                    <div class="no-traces-message">
                        <h3>Universal Wallet Index Empty</h3>
                        <p>The wallet index will be populated as you add victim transactions and trace hops. You can also manually add wallet entries for reference.</p>
                    </div>
                `;
                return;
            }
            
            // Add export button header
            const headerHTML = `
                <div style="background: #e8f4f8; border: 2px solid #3498db; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <h4 style="color: #2c3e50; margin-bottom: 10px;">📋 Universal Wallet Index</h4>
                            <p style="color: #2c3e50; margin: 0;">Complete catalog of all wallets with permanent classifications and investigative notes.</p>
                        </div>
                        <button class="btn btn-success" onclick="exportUniversalWalletIndex()" style="background: #27ae60;">
                            📊 Export to Excel
                        </button>
                    </div>
                </div>
            `;
            
            let tableHTML = `
                <div style="background: white; border-radius: 8px; padding: 20px; box-shadow: 0 2px 10px rgba(0,0,0,0.08);">
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr style="background: #f8f9fa;">
                                <th style="border: 1px solid #ddd; padding: 12px; text-align: left; font-weight: bold;">Wallet ID</th>
                                <th style="border: 1px solid #ddd; padding: 12px; text-align: left; font-weight: bold;">Classification</th>
                                <th style="border: 1px solid #ddd; padding: 12px; text-align: left; font-weight: bold;">Wallet Address</th>
                                <th style="border: 1px solid #ddd; padding: 12px; text-align: left; font-weight: bold;">First Seen</th>
                                <th style="border: 1px solid #ddd; padding: 12px; text-align: left; font-weight: bold;">Notes</th>
                                <th style="border: 1px solid #ddd; padding: 12px; text-align: left; font-weight: bold;">Actions</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            // Sort by wallet type then by ID
            const sortedWallets = [...investigation.universalWalletIndex].sort((a, b) => {
                if (a.permanentType !== b.permanentType) {
                    const typeOrder = ['red', 'pink', 'yellow', 'orange', 'brown', 'black', 'blue', 'purple', 'gray', 'green'];
                    return typeOrder.indexOf(a.permanentType) - typeOrder.indexOf(b.permanentType);
                }
                return a.permanentId.localeCompare(b.permanentId);
            });
            
            sortedWallets.forEach(wallet => {
                const statusIndicator = wallet.currentStatus !== wallet.permanentType ? 
                    ` <span style="background: ${getWalletColor(wallet.currentStatus)}; color: white; padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 8px;">CURRENTLY ${wallet.currentStatus.toUpperCase()}</span>` : '';
                
                tableHTML += `
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 12px;">
                            <div class="wallet-display ${wallet.permanentType}" style="margin: 0;">
                                ${wallet.permanentId}${statusIndicator}
                            </div>
                        </td>
                        <td style="border: 1px solid #ddd; padding: 12px;">
                            ${walletTypes[wallet.permanentType] || wallet.permanentType.toUpperCase()}
                        </td>
                        <td style="border: 1px solid #ddd; padding: 12px; font-family: monospace; font-size: 11px; word-break: break-all; max-width: 250px;">
                            ${wallet.address}
                        </td>
                        <td style="border: 1px solid #ddd; padding: 12px; font-size: 12px;">
                            ${wallet.firstSeen}
                        </td>
                        <td style="border: 1px solid #ddd; padding: 12px;">
                            <textarea placeholder="Add notes about this wallet..." 
                                      style="width: 100%; min-height: 60px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;"
                                      onchange="updateUniversalWalletNotes('${wallet.address}', this.value)">${wallet.notes}</textarea>
                        </td>
                        <td style="border: 1px solid #ddd; padding: 12px; text-align: center;">
                            <button class="btn btn-danger" style="padding: 6px 12px; font-size: 12px;" 
                                    onclick="removeWalletFromIndex('${wallet.address}')">Remove</button>
                        </td>
                    </tr>
                `;
            });
            
            tableHTML += `
                        </tbody>
                    </table>
                </div>
            `;
            
            container.innerHTML = headerHTML + tableHTML;
        }

        function updateUniversalWalletNotes(address, notes) {
            const wallet = investigation.universalWalletIndex.find(w => w.address === address);
            if (wallet) {
                wallet.notes = notes;
                saveToStorage();
            }
        }

        function removeWalletFromIndex(address) {
            if (confirm('Are you sure you want to remove this wallet from the index? This will not affect trace data.')) {
                investigation.universalWalletIndex = investigation.universalWalletIndex.filter(w => w.address !== address);
                renderUniversalWalletIndex();
                saveToStorage();
            }
        }

        function addManualWallet() {
            const address = prompt('Enter wallet address:');
            if (!address || !address.trim()) return;
            
            const walletType = prompt('Enter wallet classification (red, black, blue, etc.):');
            if (!walletType || !walletTypes[walletType.toLowerCase()]) {
                alert('Invalid wallet type. Please use: red, pink, yellow, orange, brown, black, blue, purple, gray, green');
                return;
            }
            
            const type = walletType.toLowerCase();
            
            // Check if wallet already exists
            if (investigation.universalWalletIndex.find(w => w.address === address.trim())) {
                alert('This wallet address already exists in the index.');
                return;
            }
            
            // Find next available ID for this type
            const existingIds = investigation.universalWalletIndex
                .filter(w => w.permanentType === type)
                .map(w => parseInt(w.permanentId.split(' ')[1]) || 0);
            const nextId = existingIds.length > 0 ? Math.max(...existingIds) + 1 : 1;
            
            const walletEntry = {
                id: `${type.toUpperCase()} ${nextId}`,
                permanentId: `${type.toUpperCase()} ${nextId}`,
                address: address.trim(),
                permanentType: type,
                currentStatus: type,
                totalAmount: 0,
                currencies: {},
                exposureChain: [],
                firstSeen: 'Manual Entry',
                statusHistory: [type],
                isDestination: false,
                isSource: false,
                notes: ''
            };
            
            investigation.universalWalletIndex.push(walletEntry);
            renderUniversalWalletIndex();
            saveToStorage();
        }

        function getCurrentART() {
            // Calculate ART by currency for the NEXT hop
            const artByCurrency = {};
            
            // If no hops exist, start with root totals
            if (investigation.hops.length === 0) {
                investigation.victims.forEach(victim => {
                    victim.transactions.forEach(transaction => {
                        if (parseFloat(transaction.amount) > 0) {
                            const currency = transaction.currency === 'CUSTOM' ? transaction.customCurrency : transaction.currency;
                            if (!artByCurrency[currency]) {
                                artByCurrency[currency] = 0;
                            }
                            artByCurrency[currency] += parseFloat(transaction.amount);
                        }
                    });
                });
            } else {
                // Get the last hop
                const lastHop = investigation.hops[investigation.hops.length - 1];
                
                // Start with the last hop's starting ART
                const lastHopStartingART = lastHop.artAtStartByCurrency || {};
                Object.entries(lastHopStartingART).forEach(([currency, amount]) => {
                    artByCurrency[currency] = amount;
                });
                
                // Add any new currencies from traces in the last hop
                lastHop.entries.forEach(entry => {
                    if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0) {
                        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                        if (!artByCurrency.hasOwnProperty(currency)) {
                            artByCurrency[currency] = 0;
                        }
                    }
                });
                
                // For each currency, calculate what remains for the next hop
                Object.keys(artByCurrency).forEach(currency => {
                    let tracedAmount = 0;
                    let writeoffAmount = 0;

                    lastHop.entries.forEach(entry => {
                        const entryCurrency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                        if (entryCurrency === currency && parseFloat(entry.amount) > 0) {
                            // Trace and cold storage entries reduce ART for next hop
                            if (['trace', 'cold_storage', 'vasp_arrival'].includes(entry.entryType)) {
                                tracedAmount += parseFloat(entry.amount);
                            }
                            // Write-offs permanently reduce the ART (as requested: "reduce the art at the close of the hop")
                            else if (entry.entryType === 'writeoff') {
                                writeoffAmount += parseFloat(entry.amount);
                                tracedAmount += parseFloat(entry.amount); // Also count as traced
                            }
                        }
                    });
                    
                    // What's left for the next hop
                    artByCurrency[currency] = (artByCurrency[currency] || 0) - tracedAmount;
                    
                    // Remove currencies with zero or negative amounts
                    if (artByCurrency[currency] <= 0) {
                        delete artByCurrency[currency];
                    }
                });
                
                // Add amounts from trace outputs that continue to next hop
                // CRITICAL FIX: Only add back NON-TERMINAL traces
                // Terminal wallets don't create threads for the next hop
                lastHop.entries.forEach(entry => {
                    if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0) {
                        // CRITICAL: Skip bridges with logged outputs - they consumed the original currency
                        if (entry.isBridge && entry.bridgeOutputLogged) {
                            console.log(`Skipping bridge ${entry.notation} from ART - consumed ${entry.currency} and created ${entry.bridgeDetails?.destinationAsset}`);
                            return; // Don't add this back to ART
                        }

                        // CRITICAL FIX: Skip terminal wallets - they don't create threads for next hop
                        if (entry.isTerminalWallet || entry.toWalletType === 'purple' || entry.toWalletType === 'gray') {
                            console.log(`Skipping terminal wallet ${entry.notation} from ART - funds arrived at terminal`);
                            return; // Don't add this back to ART
                        }

                        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                        if (!artByCurrency[currency]) {
                            artByCurrency[currency] = 0;
                        }
                        artByCurrency[currency] += parseFloat(entry.amount);
                    }
                });
            }
            
            return artByCurrency;
        }

        function getAvailableSourceWallets(hopNumber) {
            if (!investigation.universalWalletIndex) {
                buildUniversalWalletIndex();
            }
            
            if (hopNumber === 1) {
                // First hop: only RED wallets
                return investigation.universalWalletIndex.filter(wallet => wallet.permanentType === 'red');
            } else {
                // Subsequent hops: wallets that were destinations in previous hops
                const previousHopNumber = hopNumber - 1;
                const availableWallets = [];
                
                investigation.hops.forEach(hop => {
                    if (hop.hopNumber === previousHopNumber) {
                        hop.entries.forEach(entry => {
                            if (entry.entryType === 'trace' && entry.toWallet) {
                                const wallet = investigation.universalWalletIndex.find(w => w.address === entry.toWallet);
                                if (wallet && !availableWallets.find(w => w.address === wallet.address)) {
                                    availableWallets.push({
                                        ...wallet,
                                        lastAmount: entry.amount,
                                        lastCurrency: entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency,
                                        lastNotation: entry.notation
                                    });
                                }
                            }
                        });
                    }
                });
                
                return availableWallets;
            }
        }

        function closeModal() {
            hideModal('rootTotalModal');
        }
        
        // Generic modal show/hide functions for centered display
        function showModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.classList.add('show');
            }
        }
        
        function hideModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.classList.remove('show');
            }
        }
        
        // Helper to create a modal with proper centered styling
        function createCenteredModal(modalId, content) {
            // Remove existing modal if present
            const existingModal = document.getElementById(modalId);
            if (existingModal) {
                existingModal.remove();
            }
            
            // Create modal with show class for centered display
            let modalHTML = content;
            
            // Replace all variations of modal display styles
            modalHTML = modalHTML.replace(
                /<div id="[^"]*" class="modal" style="display:\s*block[^"]*">/g,
                function(match) {
                    const idMatch = match.match(/id="([^"]*)"/);
                    const modalIdFromMatch = idMatch ? idMatch[1] : modalId;
                    return `<div id="${modalIdFromMatch}" class="modal show">`;
                }
            );
            
            // Add to body
            document.body.insertAdjacentHTML('beforeend', modalHTML);
        }

        // ====================================
        // WALLET EXPLORER FUNCTIONALITY
        // ====================================

        // Global state for wallet explorer
        let walletExplorerState = {
            address: '',
            blockchain: '',
            allTransactions: [],
            filteredTransactions: [],
            currentPage: 1,
            itemsPerPage: 50,
            selectedAsset: '',
            assets: {}
        };

        // Open wallet explorer modal
        function openWalletExplorer(address = '', blockchain = '') {
            // Pre-fill if called with parameters
            if (address) document.getElementById('walletExplorerAddress').value = address;
            if (blockchain) document.getElementById('walletExplorerBlockchain').value = blockchain;

            // Reset state
            resetWalletExplorer();

            // Show modal
            showModal('walletExplorerModal');

            // If both address and blockchain provided, auto-search
            if (address && blockchain) {
                setTimeout(() => searchWalletHistory(), 300);
            }
        }

        // Close wallet explorer
        function closeWalletExplorer() {
            hideModal('walletExplorerModal');
            resetWalletExplorer();
        }

        // Reset wallet explorer state
        function resetWalletExplorer() {
            walletExplorerState = {
                address: '',
                blockchain: '',
                allTransactions: [],
                filteredTransactions: [],
                currentPage: 1,
                itemsPerPage: 50,
                selectedAsset: '',
                assets: {}
            };

            // Hide all sections
            document.getElementById('walletExplorerLoading').style.display = 'none';
            document.getElementById('walletExplorerAssetSummary').style.display = 'none';
            document.getElementById('walletExplorerTransactions').style.display = 'none';
            document.getElementById('walletExplorerEmpty').style.display = 'none';
        }

        // Search wallet history
        async function searchWalletHistory() {
            const address = document.getElementById('walletExplorerAddress').value.trim();
            const blockchain = document.getElementById('walletExplorerBlockchain').value;

            if (!address) {
                alert('Please enter a wallet address');
                return;
            }

            if (!blockchain) {
                alert('Please select a blockchain');
                return;
            }

            // Check cache first
            const cacheKey = 'bats_wallet_history_' + address + '_' + blockchain + '_' + Date.now();
            const cached = checkWalletCache(address, blockchain);

            if (cached) {
                console.log('Using cached wallet history');
                processWalletData(cached);
                return;
            }

            // Show loading
            document.getElementById('walletExplorerAssetSummary').style.display = 'none';
            document.getElementById('walletExplorerTransactions').style.display = 'none';
            document.getElementById('walletExplorerEmpty').style.display = 'none';
            document.getElementById('walletExplorerLoading').style.display = 'block';

            try {
                // Get wallet history from API
                const transactions = await getWalletHistory(address, blockchain);

                if (!transactions || transactions.length === 0) {
                    document.getElementById('walletExplorerLoading').style.display = 'none';
                    document.getElementById('walletExplorerEmpty').style.display = 'block';
                    return;
                }

                // Cache the results
                cacheWalletHistory(address, blockchain, transactions);

                // Process and display
                processWalletData(transactions);

            } catch (error) {
                console.error('Wallet history lookup error:', error);
                document.getElementById('walletExplorerLoading').style.display = 'none';
                alert('Error loading wallet history: ' + error.message);
            }
        }

        // Check wallet cache
        function checkWalletCache(address, blockchain) {
            const cacheKey = 'bats_wallet_' + address + '_' + blockchain;
            const cached = sessionStorage.getItem(cacheKey);

            if (!cached) return null;

            try {
                const data = JSON.parse(cached);
                const age = Date.now() - data.timestamp;

                // Cache valid for 5 minutes (300000ms)
                if (age < 300000) {
                    return data.transactions;
                } else {
                    sessionStorage.removeItem(cacheKey);
                    return null;
                }
            } catch (e) {
                return null;
            }
        }

        // Cache wallet history
        function cacheWalletHistory(address, blockchain, transactions) {
            const cacheKey = 'bats_wallet_' + address + '_' + blockchain;
            const data = {
                timestamp: Date.now(),
                transactions: transactions
            };

            try {
                sessionStorage.setItem(cacheKey, JSON.stringify(data));
            } catch (e) {
                console.warn('Failed to cache wallet history:', e);
            }
        }

        // Process wallet data
        function processWalletData(transactions) {
            document.getElementById('walletExplorerLoading').style.display = 'none';

            walletExplorerState.allTransactions = transactions;
            walletExplorerState.address = document.getElementById('walletExplorerAddress').value.trim();
            walletExplorerState.blockchain = document.getElementById('walletExplorerBlockchain').value;

            // Aggregate assets
            aggregateAssets(transactions);

            // Display asset summary
            displayAssetSummary();
        }

        // Aggregate assets from transactions
        function aggregateAssets(transactions) {
            const assets = {};

            transactions.forEach(tx => {
                const asset = tx.asset || 'Unknown';

                if (!assets[asset]) {
                    assets[asset] = {
                        name: asset,
                        balance: 0,
                        txCount: 0,
                        transactions: []
                    };
                }

                assets[asset].txCount++;
                assets[asset].transactions.push(tx);

                // Calculate balance (will be refined when asset is selected)
                if (tx.type === 'IN') {
                    assets[asset].balance += tx.amount;
                } else if (tx.type === 'OUT') {
                    assets[asset].balance -= tx.amount;
                }
            });

            // Filter out assets with 0 balance
            walletExplorerState.assets = Object.fromEntries(
                Object.entries(assets).filter(([key, val]) => val.balance !== 0 || val.txCount > 0)
            );
        }

        // Display asset summary
        function displayAssetSummary() {
            const assetListDiv = document.getElementById('walletExplorerAssetList');
            const assetSelector = document.getElementById('walletExplorerAssetSelector');

            // Clear previous
            assetListDiv.innerHTML = '';
            assetSelector.innerHTML = '<option value="">Choose an asset...</option>';

            const assets = Object.values(walletExplorerState.assets);

            if (assets.length === 0) {
                document.getElementById('walletExplorerEmpty').style.display = 'block';
                return;
            }

            // Create asset cards
            assets.forEach(asset => {
                const card = document.createElement('div');
                card.className = 'wallet-asset-card';
                card.innerHTML = `
                    <h4>${asset.name}</h4>
                    <div class="asset-balance">${asset.balance.toFixed(6)}</div>
                    <div class="asset-tx-count">${asset.txCount} transactions</div>
                `;
                card.onclick = () => selectAsset(asset.name);
                assetListDiv.appendChild(card);

                // Add to selector
                const option = document.createElement('option');
                option.value = asset.name;
                option.textContent = `${asset.name} (${asset.txCount} txs, Balance: ${asset.balance.toFixed(6)})`;
                assetSelector.appendChild(option);
            });

            document.getElementById('walletExplorerAssetSummary').style.display = 'block';
        }

        // Select asset
        function selectAsset(assetName) {
            document.getElementById('walletExplorerAssetSelector').value = assetName;
            displayAssetTransactions();
        }

        // Display asset transactions
        function displayAssetTransactions() {
            const assetName = document.getElementById('walletExplorerAssetSelector').value;

            if (!assetName) {
                document.getElementById('walletExplorerTransactions').style.display = 'none';
                return;
            }

            walletExplorerState.selectedAsset = assetName;
            const asset = walletExplorerState.assets[assetName];

            if (!asset) return;

            // Sort transactions chronologically (newest first for display, but calculate balance from oldest)
            const sortedTxs = [...asset.transactions].sort((a, b) => b.timestamp - a.timestamp);

            // Calculate running balance (from oldest to newest)
            const txsForBalance = [...asset.transactions].sort((a, b) => a.timestamp - b.timestamp);
            let runningBalance = 0;
            const balanceMap = {};

            // Check if too large
            const tooLarge = txsForBalance.length > 10000;

            if (!tooLarge) {
                txsForBalance.forEach(tx => {
                    if (tx.type === 'IN') {
                        runningBalance += tx.amount;
                    } else {
                        runningBalance -= tx.amount;
                    }
                    balanceMap[tx.hash] = runningBalance;
                });
            }

            // Show/hide balance warning
            document.getElementById('walletExplorerBalanceWarning').style.display = tooLarge ? 'block' : 'none';

            // Set filtered transactions
            walletExplorerState.filteredTransactions = sortedTxs;
            walletExplorerState.balanceMap = balanceMap;
            walletExplorerState.currentPage = 1;

            // Display transactions
            renderTransactionTable();

            document.getElementById('walletExplorerTransactions').style.display = 'block';
        }

        // Render transaction table
        function renderTransactionTable() {
            const tbody = document.getElementById('walletExplorerTableBody');
            tbody.innerHTML = '';

            const transactions = walletExplorerState.filteredTransactions;
            const start = (walletExplorerState.currentPage - 1) * walletExplorerState.itemsPerPage;
            const end = start + walletExplorerState.itemsPerPage;
            const pageTransactions = transactions.slice(start, end);

            pageTransactions.forEach(tx => {
                const row = document.createElement('tr');
                row.className = 'wallet-tx-row ' + (tx.type === 'IN' ? 'wallet-tx-in' : 'wallet-tx-out');

                const date = new Date(tx.timestamp).toLocaleString();
                const typeIcon = tx.type === 'IN' ? '🟢' : '🔴';
                const amountPrefix = tx.type === 'IN' ? '+' : '-';
                const balance = walletExplorerState.balanceMap && walletExplorerState.balanceMap[tx.hash]
                    ? walletExplorerState.balanceMap[tx.hash].toFixed(6)
                    : '—';

                const entityLabel = tx.entityLabel ? `<span class="wallet-entity-label">${tx.entityLabel}</span>` : '';

                row.innerHTML = `
                    <td style="padding: 12px;">${date}</td>
                    <td style="padding: 12px;">${typeIcon} ${tx.type}</td>
                    <td style="padding: 12px; text-align: right; font-weight: 600;">${amountPrefix}${tx.amount.toFixed(6)} ${tx.asset}</td>
                    <td style="padding: 12px; text-align: right;">${balance}</td>
                    <td style="padding: 12px; font-family: monospace; font-size: 0.9rem;">
                        ${tx.counterparty.substring(0, 10)}...${tx.counterparty.substring(tx.counterparty.length - 8)}
                        ${entityLabel}
                    </td>
                    <td style="padding: 12px; text-align: center;">
                        <button class="wallet-explorer-action-btn btn-primary" onclick="addWalletTransactionToInvestigation('${tx.hash}')">
                            ${getWalletActionButtonLabel()}
                        </button>
                        <a href="${tx.explorerUrl}" target="_blank" class="wallet-explorer-external-link">🔗</a>
                    </td>
                `;

                tbody.appendChild(row);
            });

            updatePagination();
        }

        // Update pagination
        function updatePagination() {
            const totalPages = Math.ceil(walletExplorerState.filteredTransactions.length / walletExplorerState.itemsPerPage);
            const currentPage = walletExplorerState.currentPage;

            document.getElementById('walletExplorerPageInfo').textContent = `Page ${currentPage} of ${totalPages}`;
            document.getElementById('walletExplorerPrevPage').disabled = currentPage === 1;
            document.getElementById('walletExplorerNextPage').disabled = currentPage === totalPages;
        }

        // Pagination functions
        function previousWalletPage() {
            if (walletExplorerState.currentPage > 1) {
                walletExplorerState.currentPage--;
                renderTransactionTable();
            }
        }

        function nextWalletPage() {
            const totalPages = Math.ceil(walletExplorerState.filteredTransactions.length / walletExplorerState.itemsPerPage);
            if (walletExplorerState.currentPage < totalPages) {
                walletExplorerState.currentPage++;
                renderTransactionTable();
            }
        }

        // Filter transactions by date range
        function filterWalletTransactions() {
            const fromDate = document.getElementById('walletExplorerDateFrom').value;
            const toDate = document.getElementById('walletExplorerDateTo').value;

            if (!walletExplorerState.selectedAsset) return;

            const asset = walletExplorerState.assets[walletExplorerState.selectedAsset];
            let transactions = [...asset.transactions];

            if (fromDate) {
                const fromTimestamp = new Date(fromDate).getTime();
                transactions = transactions.filter(tx => tx.timestamp >= fromTimestamp);
            }

            if (toDate) {
                const toTimestamp = new Date(toDate).getTime() + 86400000; // Add 1 day
                transactions = transactions.filter(tx => tx.timestamp < toTimestamp);
            }

            // Sort newest first
            transactions.sort((a, b) => b.timestamp - a.timestamp);

            walletExplorerState.filteredTransactions = transactions;
            walletExplorerState.currentPage = 1;

            renderTransactionTable();
        }

        // Clear date filter
        function clearDateFilter() {
            document.getElementById('walletExplorerDateFrom').value = '';
            document.getElementById('walletExplorerDateTo').value = '';
            filterWalletTransactions();
        }

        // Get context-aware button label
        function getWalletActionButtonLabel() {
            // Check if in victim setup mode
            const victimSection = document.getElementById('victimSetup');
            if (victimSection && victimSection.style.display !== 'none') {
                return '➕ Log Victim Transaction';
            }

            // Check if building hops
            const currentHop = getCurrentHop();
            if (currentHop) {
                return '➕ Add to Hop ' + currentHop;
            }

            return '➕ Add to Investigation';
        }

        // Add transaction to investigation
        async function addWalletTransactionToInvestigation(txHash) {
            try {
                // Close wallet explorer
                closeWalletExplorer();

                // Populate the transaction lookup field
                const hashInput = document.getElementById('transactionHash');
                if (hashInput) {
                    hashInput.value = txHash;
                }

                // Trigger lookup
                await lookupVictimTransaction();

            } catch (error) {
                console.error('Error adding transaction:', error);
                alert('Error adding transaction: ' + error.message);
            }
        }

        // ====================================
        // WALLET HISTORY API INTEGRATION
        // ====================================

        /**
         * Get wallet transaction history from blockchain APIs
         * Returns standardized transaction format
         */
        async function getWalletHistory(address, blockchain) {
            console.log(`Fetching wallet history for ${address} on ${blockchain}`);

            switch (blockchain) {
                case 'ethereum':
                case 'base':
                case 'arbitrum':
                case 'optimism':
                case 'polygon':
                case 'bsc':
                case 'avalanche':
                    return await getEthereumWalletHistory(address, blockchain);

                case 'bitcoin':
                    return await getBitcoinWalletHistory(address);

                case 'tron':
                    return await getTronWalletHistory(address);

                case 'solana':
                    return await getSolanaWalletHistory(address);

                case 'sui':
                    return await getSuiWalletHistory(address);

                case 'ripple':
                    throw new Error('XRP wallet history not yet implemented');

                default:
                    throw new Error('Unsupported blockchain: ' + blockchain);
            }
        }

        /**
         * Get Ethereum/EVM wallet history
         */
        async function getEthereumWalletHistory(address, blockchain) {
            const config = blockchainAPIs[blockchain];
            if (!config) {
                throw new Error('Unknown blockchain: ' + blockchain);
            }

            const apiKey = window.apiKeys?.etherscan || config.apiKey || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8';

            // Extract base URL properly (e.g., https://api.etherscan.io)
            const urlObj = new URL(config.apiUrl);
            const baseUrl = `${urlObj.protocol}//${urlObj.host}`;

            // Get normal transactions
            const normalTxUrl = `${baseUrl}/api?module=account&action=txlist&address=${address}&startblock=0&endblock=99999999&sort=desc&apikey=${apiKey}`;
            console.log('Fetching normal transactions:', normalTxUrl);

            const normalResponse = await fetch(normalTxUrl);
            const normalData = await normalResponse.json();

            if (normalData.status !== '1') {
                console.warn('No normal transactions found');
            }

            const normalTxs = normalData.result && Array.isArray(normalData.result) ? normalData.result : [];

            // Get ERC-20 token transfers
            const tokenTxUrl = `${baseUrl}/api?module=account&action=tokentx&address=${address}&startblock=0&endblock=99999999&sort=desc&apikey=${apiKey}`;
            console.log('Fetching token transactions:', tokenTxUrl);

            const tokenResponse = await fetch(tokenTxUrl);
            const tokenData = await tokenResponse.json();

            if (tokenData.status !== '1') {
                console.warn('No token transactions found');
            }

            const tokenTxs = tokenData.result && Array.isArray(tokenData.result) ? tokenData.result : [];

            // Combine and normalize
            const allTransactions = [];

            // Process normal transactions
            normalTxs.forEach(tx => {
                const isIncoming = tx.to && tx.to.toLowerCase() === address.toLowerCase();
                const amount = parseFloat(tx.value) / 1e18; // Wei to ETH

                // Only include if amount > 0
                if (amount > 0) {
                    allTransactions.push({
                        hash: tx.hash,
                        timestamp: parseInt(tx.timeStamp) * 1000,
                        type: isIncoming ? 'IN' : 'OUT',
                        asset: config.nativeCurrency || 'ETH',
                        amount: amount,
                        counterparty: isIncoming ? tx.from : tx.to,
                        entityLabel: null, // Will be enhanced later
                        explorerUrl: `${config.explorerUrl || 'https://etherscan.io'}/tx/${tx.hash}`
                    });
                }
            });

            // Process token transactions
            tokenTxs.forEach(tx => {
                const isIncoming = tx.to && tx.to.toLowerCase() === address.toLowerCase();
                const decimals = parseInt(tx.tokenDecimal) || 18;
                const amount = parseFloat(tx.value) / Math.pow(10, decimals);

                allTransactions.push({
                    hash: tx.hash,
                    timestamp: parseInt(tx.timeStamp) * 1000,
                    type: isIncoming ? 'IN' : 'OUT',
                    asset: tx.tokenSymbol || tx.tokenName || 'Token',
                    amount: amount,
                    counterparty: isIncoming ? tx.from : tx.to,
                    entityLabel: null,
                    explorerUrl: `${config.explorerUrl || 'https://etherscan.io'}/tx/${tx.hash}`
                });
            });

            // Sort by timestamp (newest first)
            allTransactions.sort((a, b) => b.timestamp - a.timestamp);

            console.log(`Found ${allTransactions.length} total transactions`);

            return allTransactions;
        }

        /**
         * Get Bitcoin wallet history using mempool.space API
         */
        async function getBitcoinWalletHistory(address) {
            console.log('Fetching Bitcoin wallet history from mempool.space');

            // Mempool.space API endpoint
            const apiUrl = `https://mempool.space/api/address/${address}/txs`;

            const response = await fetch(apiUrl);
            if (!response.ok) {
                throw new Error('Failed to fetch Bitcoin transactions');
            }

            const transactions = await response.json();

            if (!transactions || transactions.length === 0) {
                return [];
            }

            const allTransactions = [];

            // Process each transaction
            transactions.forEach(tx => {
                // Determine if this is incoming or outgoing
                // Check if address appears in outputs (incoming) or inputs (outgoing)
                let isIncoming = false;
                let isOutgoing = false;
                let amount = 0;
                let counterparty = '';

                // Check outputs for incoming transactions
                tx.vout?.forEach(output => {
                    if (output.scriptpubkey_address === address) {
                        isIncoming = true;
                        amount += output.value;
                    } else if (isIncoming && !counterparty) {
                        // If we're receiving, the sender is in inputs
                        counterparty = output.scriptpubkey_address || 'Unknown';
                    }
                });

                // Check inputs for outgoing transactions
                tx.vin?.forEach(input => {
                    if (input.prevout?.scriptpubkey_address === address) {
                        isOutgoing = true;
                        amount += input.prevout.value;
                    } else if (isOutgoing && !counterparty) {
                        // If we're sending, the recipient is in outputs
                        counterparty = input.prevout?.scriptpubkey_address || 'Unknown';
                    }
                });

                // Find counterparty address
                if (isIncoming) {
                    // For incoming, counterparty is the sender (first input)
                    counterparty = tx.vin?.[0]?.prevout?.scriptpubkey_address || 'Unknown';
                } else if (isOutgoing) {
                    // For outgoing, counterparty is the first output that's not us
                    const recipientOutput = tx.vout?.find(o => o.scriptpubkey_address !== address);
                    counterparty = recipientOutput?.scriptpubkey_address || 'Unknown';
                }

                // Convert satoshis to BTC
                const btcAmount = amount / 100000000;

                if (btcAmount > 0 && (isIncoming || isOutgoing)) {
                    allTransactions.push({
                        hash: tx.txid,
                        timestamp: tx.status?.block_time ? tx.status.block_time * 1000 : Date.now(),
                        type: isIncoming ? 'IN' : 'OUT',
                        asset: 'BTC',
                        amount: btcAmount,
                        counterparty: counterparty,
                        entityLabel: null,
                        explorerUrl: `https://mempool.space/tx/${tx.txid}`
                    });
                }
            });

            // Sort by timestamp (newest first)
            allTransactions.sort((a, b) => b.timestamp - a.timestamp);

            console.log(`Found ${allTransactions.length} Bitcoin transactions`);

            return allTransactions;
        }

        /**
         * Get Tron wallet history using TronGrid API
         */
        async function getTronWalletHistory(address) {
            console.log('Fetching Tron wallet history from TronGrid');

            const apiKey = window.apiKeys?.trongrid || localStorage.getItem('bats_trongrid_api_key') || '';
            const baseUrl = 'https://api.trongrid.io';

            const allTransactions = [];

            // Get TRX transactions
            const trxUrl = `${baseUrl}/v1/accounts/${address}/transactions?limit=200`;
            const headers = apiKey ? { 'TRON-PRO-API-KEY': apiKey } : {};

            try {
                const trxResponse = await fetch(trxUrl, { headers });
                const trxData = await trxResponse.json();

                if (trxData.data && Array.isArray(trxData.data)) {
                    trxData.data.forEach(tx => {
                        // Parse TRX transfers
                        if (tx.raw_data && tx.raw_data.contract) {
                            tx.raw_data.contract.forEach(contract => {
                                if (contract.type === 'TransferContract') {
                                    const value = contract.parameter?.value;
                                    if (value && value.amount) {
                                        const isIncoming = value.to_address === address ||
                                                         Buffer.from(value.to_address, 'hex').toString() === address;
                                        const amount = value.amount / 1000000; // Sun to TRX

                                        if (amount > 0) {
                                            allTransactions.push({
                                                hash: tx.txID,
                                                timestamp: tx.block_timestamp || Date.now(),
                                                type: isIncoming ? 'IN' : 'OUT',
                                                asset: 'TRX',
                                                amount: amount,
                                                counterparty: isIncoming ? value.owner_address : value.to_address,
                                                entityLabel: null,
                                                explorerUrl: `https://tronscan.org/#/transaction/${tx.txID}`
                                            });
                                        }
                                    }
                                }
                            });
                        }
                    });
                }
            } catch (error) {
                console.warn('Error fetching TRX transactions:', error);
            }

            // Get TRC-20 token transfers
            const tokenUrl = `${baseUrl}/v1/accounts/${address}/transactions/trc20?limit=200`;

            try {
                const tokenResponse = await fetch(tokenUrl, { headers });
                const tokenData = await tokenResponse.json();

                if (tokenData.data && Array.isArray(tokenData.data)) {
                    tokenData.data.forEach(tx => {
                        const isIncoming = tx.to === address;
                        const decimals = parseInt(tx.token_info?.decimals) || 6;
                        const amount = parseFloat(tx.value) / Math.pow(10, decimals);

                        if (amount > 0) {
                            allTransactions.push({
                                hash: tx.transaction_id,
                                timestamp: tx.block_timestamp || Date.now(),
                                type: isIncoming ? 'IN' : 'OUT',
                                asset: tx.token_info?.symbol || tx.token_info?.name || 'TRC20',
                                amount: amount,
                                counterparty: isIncoming ? tx.from : tx.to,
                                entityLabel: null,
                                explorerUrl: `https://tronscan.org/#/transaction/${tx.transaction_id}`
                            });
                        }
                    });
                }
            } catch (error) {
                console.warn('Error fetching TRC-20 transactions:', error);
            }

            // Sort by timestamp (newest first)
            allTransactions.sort((a, b) => b.timestamp - a.timestamp);

            console.log(`Found ${allTransactions.length} Tron transactions`);

            return allTransactions;
        }

        /**
         * Get Solana wallet history using Solana JSON-RPC
         */
        async function getSolanaWalletHistory(address) {
            console.log('Fetching Solana wallet history');

            const rpcUrl = window.apiKeys?.solana || localStorage.getItem('bats_solana_rpc') || 'https://api.mainnet-beta.solana.com';

            const allTransactions = [];

            // Step 1: Get transaction signatures (limit to 100 for performance)
            const signaturesResponse = await fetch(rpcUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    jsonrpc: '2.0',
                    id: 1,
                    method: 'getSignaturesForAddress',
                    params: [address, { limit: 100 }]
                })
            });

            const signaturesData = await signaturesResponse.json();

            if (!signaturesData.result || signaturesData.result.length === 0) {
                console.log('No Solana transactions found');
                return [];
            }

            console.log(`Found ${signaturesData.result.length} Solana transaction signatures`);

            // Step 2: Fetch details for each transaction (in batches to avoid overwhelming API)
            const batchSize = 20;
            for (let i = 0; i < signaturesData.result.length && i < 100; i += batchSize) {
                const batch = signaturesData.result.slice(i, i + batchSize);

                for (const sig of batch) {
                    try {
                        const txResponse = await fetch(rpcUrl, {
                            method: 'POST',
                            headers: { 'Content-Type': 'application/json' },
                            body: JSON.stringify({
                                jsonrpc: '2.0',
                                id: 1,
                                method: 'getTransaction',
                                params: [sig.signature, { encoding: 'jsonParsed', maxSupportedTransactionVersion: 0 }]
                            })
                        });

                        const txData = await txResponse.json();

                        if (txData.result && txData.result.meta) {
                            const tx = txData.result;
                            const meta = tx.meta;

                            // Parse SOL transfers from balance changes
                            if (meta.postBalances && meta.preBalances) {
                                const accountKeys = tx.transaction.message.accountKeys;

                                accountKeys.forEach((account, idx) => {
                                    const accountAddress = typeof account === 'string' ? account : account.pubkey;

                                    if (accountAddress === address) {
                                        const preBalance = meta.preBalances[idx];
                                        const postBalance = meta.postBalances[idx];
                                        const diff = postBalance - preBalance;

                                        if (diff !== 0) {
                                            const amount = Math.abs(diff) / 1000000000; // Lamports to SOL
                                            const isIncoming = diff > 0;

                                            // Find counterparty (first non-system account that's not us)
                                            let counterparty = 'Unknown';
                                            for (let j = 0; j < accountKeys.length; j++) {
                                                const otherAccount = typeof accountKeys[j] === 'string' ? accountKeys[j] : accountKeys[j].pubkey;
                                                if (otherAccount !== address && !otherAccount.startsWith('11111111')) {
                                                    counterparty = otherAccount;
                                                    break;
                                                }
                                            }

                                            if (amount > 0.00001) { // Filter dust
                                                allTransactions.push({
                                                    hash: sig.signature,
                                                    timestamp: (sig.blockTime || 0) * 1000,
                                                    type: isIncoming ? 'IN' : 'OUT',
                                                    asset: 'SOL',
                                                    amount: amount,
                                                    counterparty: counterparty,
                                                    entityLabel: null,
                                                    explorerUrl: `https://solscan.io/tx/${sig.signature}`
                                                });
                                            }
                                        }
                                    }
                                });
                            }

                            // Parse SPL token transfers
                            if (meta.postTokenBalances && meta.preTokenBalances) {
                                const tokenChanges = {};

                                // Calculate token balance changes
                                meta.postTokenBalances.forEach(post => {
                                    const pre = meta.preTokenBalances.find(p => p.accountIndex === post.accountIndex);
                                    const preAmount = pre ? parseFloat(pre.uiTokenAmount.uiAmountString || '0') : 0;
                                    const postAmount = parseFloat(post.uiTokenAmount.uiAmountString || '0');
                                    const diff = postAmount - preAmount;

                                    if (diff !== 0) {
                                        const accountKeys = tx.transaction.message.accountKeys;
                                        const account = accountKeys[post.accountIndex];
                                        const accountAddress = typeof account === 'string' ? account : account.pubkey;

                                        // Check if this token account belongs to our address
                                        if (post.owner === address) {
                                            tokenChanges[post.mint] = {
                                                diff: diff,
                                                symbol: post.uiTokenAmount.symbol || 'SPL',
                                                decimals: post.uiTokenAmount.decimals
                                            };
                                        }
                                    }
                                });

                                // Create transactions for token changes
                                Object.entries(tokenChanges).forEach(([mint, change]) => {
                                    if (Math.abs(change.diff) > 0.00001) {
                                        allTransactions.push({
                                            hash: sig.signature,
                                            timestamp: (sig.blockTime || 0) * 1000,
                                            type: change.diff > 0 ? 'IN' : 'OUT',
                                            asset: change.symbol,
                                            amount: Math.abs(change.diff),
                                            counterparty: 'Token Program',
                                            entityLabel: null,
                                            explorerUrl: `https://solscan.io/tx/${sig.signature}`
                                        });
                                    }
                                });
                            }
                        }
                    } catch (error) {
                        console.warn(`Error fetching Solana tx ${sig.signature}:`, error);
                    }
                }

                // Small delay between batches to avoid rate limiting
                if (i + batchSize < signaturesData.result.length) {
                    await new Promise(resolve => setTimeout(resolve, 200));
                }
            }

            // Sort by timestamp (newest first)
            allTransactions.sort((a, b) => b.timestamp - a.timestamp);

            console.log(`Parsed ${allTransactions.length} Solana transactions`);

            return allTransactions;
        }

        /**
         * Get Sui wallet history using Sui JSON-RPC
         */
        async function getSuiWalletHistory(address) {
            console.log('Fetching Sui wallet history');

            const rpcUrl = 'https://fullnode.mainnet.sui.io';
            const allTransactions = [];

            // Step 1: Query transaction blocks for the address (limit to 50 for performance)
            const response = await fetch(rpcUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    jsonrpc: '2.0',
                    id: 1,
                    method: 'suix_queryTransactionBlocks',
                    params: [
                        {
                            filter: {
                                FromAddress: address
                            },
                            options: {
                                showInput: true,
                                showEffects: true,
                                showEvents: false,
                                showObjectChanges: false,
                                showBalanceChanges: false
                            }
                        },
                        null, // cursor
                        50,   // limit
                        true  // descending order
                    ]
                })
            });

            const data = await response.json();

            if (!data.result || !data.result.data || data.result.data.length === 0) {
                // Try as ToAddress
                const toResponse = await fetch(rpcUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        jsonrpc: '2.0',
                        id: 1,
                        method: 'suix_queryTransactionBlocks',
                        params: [
                            {
                                filter: {
                                    ToAddress: address
                                },
                                options: {
                                    showInput: true,
                                    showEffects: true,
                                    showEvents: false,
                                    showObjectChanges: false,
                                    showBalanceChanges: false
                                }
                            },
                            null,
                            50,
                            true
                        ]
                    })
                });

                const toData = await toResponse.json();

                if (!toData.result || !toData.result.data || toData.result.data.length === 0) {
                    console.log('No Sui transactions found');
                    return [];
                }

                // Process incoming transactions
                toData.result.data.forEach(tx => {
                    const parsed = parseSuiTransaction(tx, address, 'IN');
                    if (parsed) allTransactions.push(parsed);
                });
            } else {
                // Process outgoing transactions
                data.result.data.forEach(tx => {
                    const parsed = parseSuiTransaction(tx, address, 'OUT');
                    if (parsed) allTransactions.push(parsed);
                });

                // Also get incoming transactions
                const toResponse = await fetch(rpcUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        jsonrpc: '2.0',
                        id: 1,
                        method: 'suix_queryTransactionBlocks',
                        params: [
                            {
                                filter: {
                                    ToAddress: address
                                },
                                options: {
                                    showInput: true,
                                    showEffects: true,
                                    showEvents: false,
                                    showObjectChanges: false,
                                    showBalanceChanges: false
                                }
                            },
                            null,
                            50,
                            true
                        ]
                    })
                });

                const toData = await toResponse.json();

                if (toData.result && toData.result.data) {
                    toData.result.data.forEach(tx => {
                        const parsed = parseSuiTransaction(tx, address, 'IN');
                        if (parsed) allTransactions.push(parsed);
                    });
                }
            }

            // Remove duplicates based on digest
            const uniqueTransactions = [];
            const seenDigests = new Set();

            allTransactions.forEach(tx => {
                if (!seenDigests.has(tx.hash)) {
                    seenDigests.add(tx.hash);
                    uniqueTransactions.push(tx);
                }
            });

            // Sort by timestamp (newest first)
            uniqueTransactions.sort((a, b) => b.timestamp - a.timestamp);

            console.log(`Found ${uniqueTransactions.length} Sui transactions`);

            return uniqueTransactions;
        }

        /**
         * Parse a single Sui transaction
         */
        function parseSuiTransaction(tx, address, defaultDirection) {
            if (!tx || !tx.transaction) return null;

            const txData = tx.transaction.data;
            const digest = tx.digest;

            // Get timestamp
            const timestamp = tx.timestampMs ? parseInt(tx.timestampMs) : Date.now();

            // Parse ProgrammableTransaction
            if (txData.transaction && txData.transaction.kind === 'ProgrammableTransaction') {
                const inputs = txData.transaction.inputs || [];
                const transactions = txData.transaction.transactions || [];
                const sender = txData.sender;

                // Look for TransferObjects transaction
                const transferTx = transactions.find(t => t.TransferObjects);

                if (transferTx && inputs.length > 0) {
                    // Find amount (u64 input)
                    const amountInput = inputs.find(inp => inp.valueType === 'u64');
                    // Find recipient (address input)
                    const recipientInput = inputs.find(inp => inp.valueType === 'address');

                    if (amountInput && recipientInput) {
                        const amount = parseInt(amountInput.value) / 1000000000; // MIST to SUI
                        const recipient = recipientInput.value;

                        // Determine direction
                        const isOutgoing = sender === address;
                        const type = isOutgoing ? 'OUT' : 'IN';
                        const counterparty = isOutgoing ? recipient : sender;

                        if (amount > 0) {
                            return {
                                hash: digest,
                                timestamp: timestamp,
                                type: type,
                                asset: 'SUI',
                                amount: amount,
                                counterparty: counterparty,
                                entityLabel: null,
                                explorerUrl: `https://suiscan.xyz/mainnet/tx/${digest}`
                            };
                        }
                    }
                }
            }

            return null;
        }

        function calculateRootTotal() {
            // This should return totals by currency, not a single sum
            const totalsByCurrency = {};
            investigation.victims.forEach(v => {
                v.transactions.forEach(t => {
                    const amount = parseAmount(t.amount);
                    if (amount > 0) {
                        const currency = t.currency === 'CUSTOM' ? t.customCurrency : t.currency;
                        if (!totalsByCurrency[currency]) {
                            totalsByCurrency[currency] = 0;
                        }
                        // Use safe addition for currency amounts
                        totalsByCurrency[currency] = addCurrencyAmounts(
                            totalsByCurrency[currency],
                            amount,
                            currency
                        );
                    }
                });
            });
            return totalsByCurrency;
        }
        
        // Custom centered alert function
        function showAlert(message, type = 'info') {
            const alertId = 'customAlert_' + Date.now();
            const iconMap = {
                'success': '✅',
                'error': '❌',
                'warning': '⚠️',
                'info': 'ℹ️'
            };
            
            const alertHTML = `
                <div id="${alertId}" class="modal show">
                    <div class="modal-content" style="max-width: 500px;">
                        <div style="text-align: center; padding: 20px;">
                            <div style="font-size: 48px; margin-bottom: 20px;">${iconMap[type] || iconMap.info}</div>
                            <div style="white-space: pre-wrap; line-height: 1.6; color: #2c3e50;">${message}</div>
                            <button class="btn btn-confirm" onclick="document.getElementById('${alertId}').remove()" 
                                    style="margin-top: 20px; padding: 10px 30px;">
                                OK
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', alertHTML);
            
            // Focus the OK button
            setTimeout(() => {
                const okBtn = document.querySelector(`#${alertId} button`);
                if (okBtn) okBtn.focus();
            }, 100);
        }

        function getCurrentHop() {
            if (!investigation.hops || investigation.hops.length === 0) {
                return null;
            }

            const maxHop = Math.max(...investigation.hops.map(h => h.hopNumber || 0));
            return maxHop;
        }

        function getNextHopNumber() {
            if (investigation.hops.length === 0) {
                return 1;
            }

            const maxHop = Math.max(...investigation.hops.map(h => h.hopNumber || 0));
            return maxHop + 1;
        }


// ADD THIS FUNCTION RIGHT AFTER getNextHopNumber():
function addNewHop() {
    console.log(' Adding new hop...');

    if (!investigation.rootTotalConfirmed) {
        alert('Please confirm your root total before adding hops.');
        return;
    }

    // LIBR methodology: Show Red Wallets Dashboard instead of creating hop
    if (investigation.tracingMethod === 'LIBR') {
        console.log('🔶 [LIBR] Opening Red Wallets Dashboard...');
        showRedWalletsDashboard();
        return;
    }

    // PIFO methodology: Continue with normal hop creation
    // Check if there are any active threads to trace
    const availableThreads = getAvailableSourcesForHop(getNextHopNumber(), null);
    const activeThreads = availableThreads.filter(t => t.availableAmount > 0.01); // Ignore tiny remainders

    if (activeThreads.length === 0) {
        // Check if all funds went to terminal wallets
        // First, calculate total funds that need to be traced
        let totalToTrace = {};
        let totalTerminal = {};

        // Sum up all root totals by currency
        if (investigation.rootTotalsByCurrency) {
            Object.entries(investigation.rootTotalsByCurrency).forEach(([currency, amount]) => {
                totalToTrace[currency] = amount;
                totalTerminal[currency] = 0;
            });
        }

        // Sum up all terminal wallet amounts
        investigation.hops.forEach(hop => {
            hop.entries.forEach(entry => {
                if (entry.isTerminalWallet || entry.toWalletType === 'purple' || entry.toWalletType === 'gray') {
                    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                    const amount = parseFloat(entry.amount) || 0;
                    if (!totalTerminal[currency]) totalTerminal[currency] = 0;
                    totalTerminal[currency] += amount;
                }
            });
        });

        // Check if ALL funds have reached terminal wallets
        let allFundsTerminal = true;
        for (const currency in totalToTrace) {
            const traced = totalTerminal[currency] || 0;
            const total = totalToTrace[currency];
            if (Math.abs(total - traced) > 0.01) { // Allow tiny rounding differences
                allFundsTerminal = false;
                break;
            }
        }

        if (allFundsTerminal) {
            alert('All funds have reached terminal wallets. The investigation is complete.\n\nNo new hop can be created as there are no active threads to trace.');

            // Show completion section if it exists
            const completeSectionEl = document.getElementById('completeInvestigationSection');
            const addHopBtnEl = document.getElementById('addHopBtn');
            if (completeSectionEl) completeSectionEl.style.display = 'block';
            if (addHopBtnEl) addHopBtnEl.style.display = 'none';
            return;
        }

        alert('No available threads to trace. Please check your previous hop entries.');
        return;
    }
    
    // Validate previous hops are complete (with option to proceed)
    for (let hop of investigation.hops) {
        const validation = typeof validateHopCompletionByCurrency === 'function' ? 
            validateHopCompletionByCurrency(hop.hopNumber) : 
            validateHopCompletion(hop.hopNumber);
            
        if (!validation.valid && validation.errors && validation.errors.length > 0) {
            const shouldProceed = confirm(
                `Hop ${hop.hopNumber} has validation errors:\n${validation.errors.join('\n')}\n\nDo you want to proceed anyway? This may cause mathematical inconsistencies.`
            );
            if (!shouldProceed) {
                return;
            }
        }
    }
    
    const hopNumber = getNextHopNumber();
    const currentART = getCurrentART();
    
    // Create new hop with proper structure
    const hop = {
        hopNumber: hopNumber,
        entries: [],
        artAtStartByCurrency: currentART,
        artAtStart: Object.values(currentART).reduce((sum, amount) => sum + amount, 0), // Legacy support
        completed: false
    };
    
    console.log(`Creating hop ${hopNumber} with starting ART:`, currentART);
    
    investigation.hops.push(hop);
    
    // Rebuild thread index after adding hop
    buildAvailableThreadsIndex();
    
    renderHops();
    saveToStorage();
    updateWorkflowSteps();
    
    console.log(` Hop ${hopNumber} created successfully`);
}

// ADD this export function to your JavaScript section:

        // Track collapse state
        window.hopCollapseState = window.hopCollapseState || {};
        window.entryCollapseState = window.entryCollapseState || {};
        
        // Toggle hop collapse state
        function toggleHopCollapse(hopNumber) {
            window.hopCollapseState[hopNumber] = !window.hopCollapseState[hopNumber];
            const content = document.getElementById(`hopContent_${hopNumber}`);
            const arrow = event.currentTarget.querySelector('span');

            if (window.hopCollapseState[hopNumber]) {
                content.style.display = 'none';
                arrow.style.transform = 'rotate(0deg)';
            } else {
                content.style.display = 'block';
                arrow.style.transform = 'rotate(90deg)';
            }
        }
        
        // Toggle entry collapse state
        function toggleEntryCollapse(entryId) {
            window.entryCollapseState[entryId] = !window.entryCollapseState[entryId];
            const content = document.getElementById(`entryContent_${entryId}`);
            const summary = document.getElementById(`entrySummary_${entryId}`);
            
            if (window.entryCollapseState[entryId]) {
                content.style.display = 'none';
                summary.style.display = 'block';
            } else {
                content.style.display = 'block';
                summary.style.display = 'none';
            }
        }
        
        // Log entry and collapse
        function logAndCollapseEntry(hopNumber, entryId) {
            // Find the entry
            const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
            const entry = hop.entries.find(e => e.id === entryId);
            
            console.log('Log entry debug:', {
                hopNumber, entryId,
                sourceThreadId: entry.sourceThreadId,
                multipleSourceThreads: entry.multipleSourceThreads,
                notation: entry.notation,
                victimNumbers: entry.victimNumbers,
                transactionNumbers: entry.transactionNumbers,
                amount: entry.amount,
                currency: entry.currency
            });
            
            // Validate entry has required data
            if (!entry.amount || parseFloat(entry.amount) <= 0) {
                alert('Please enter an amount before logging the entry.');
                return;
            }
            
            // Try to auto-generate notation if missing but source is selected
            if (!entry.notation || entry.notation.trim() === '') {
                if (entry.sourceThreadId) {
                    console.log('🔧 Attempting to auto-generate notation from single source:', entry.sourceThreadId);
                    autoGenerateNotationFromSource(hopNumber, entryId, entry.sourceThreadId);
                } else if (entry.multipleSourceThreads && entry.multipleSourceThreads.length > 0) {
                    console.log('🔧 Attempting to auto-generate notation from multiple sources:', entry.multipleSourceThreads);
                    autoGenerateNotationFromMultipleSources(hopNumber, entryId, entry.multipleSourceThreads);
                }
            }
            
            if (!entry.notation || entry.notation.trim() === '') {
                alert('Please enter a notation before logging the entry.\n\nIf you have selected a source thread, the notation should auto-fill. Try manually entering the victim and transaction numbers.');
                return;
            }
            
            // Save undo state before logging
            saveUndoState(`Log entry ${entry.notation} in Hop ${hop.hopNumber}`);
            
            // Save to storage
            saveToStorage();
            
            // Set entry as collapsed
            const entryKey = `${hopNumber}_${entryId}`;
            window.entryCollapseState[entryKey] = true;
            
            // Update UI to show collapsed state
            const content = document.getElementById(`entryContent_${entryKey}`);
            const summary = document.getElementById(`entrySummary_${entryKey}`);
            
            if (content && summary) {
                content.style.display = 'none';
                summary.style.display = 'block';
            }
            
            // Update the hop to refresh ART calculations
            updateInvestigationCompletionStatus();
            
            // Show success message
            const amount = parseFloat(entry.amount);
            const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
            alert(` Entry logged successfully!\n\n${entry.notation}: ${amount.toLocaleString()} ${currency}`);
        }
        
        // Render collapsible hop entry
        function renderCollapsibleHopEntry(entry, entryIndex, hop) {
            // Initialize collapse state
            const entryKey = `${hop.hopNumber}_${entry.id}`;
            if (window.entryCollapseState[entryKey] === undefined) {
                // For finalized entries (especially write-offs), default to collapsed
                // For other entries, default to expanded
                const isFinalized = entry.isFinalized || false;
                const hasAmount = parseFloat(entry.amount) > 0;
                // Collapse if: finalized OR (write-off with amount)
                window.entryCollapseState[entryKey] = isFinalized || (entry.entryType === 'writeoff' && hasAmount);
            }
            const isCollapsed = window.entryCollapseState[entryKey];

            // Get entry type info
            const entryTypeLabel = entryTypes[entry.entryType] || entry.entryType;
            const amount = parseFloat(entry.amount) || 0;
            const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;

            // Get hop number and ART amount
            const hopNumber = hop.hopNumber;
            
            // Get the ART amount for this currency at this hop
            let artAmount = 0;
            let displayCurrency = currency;

            // For swap entries, show both input and output
            if (entry.entryType === 'swap' && entry.swapDetails) {
                // For swaps, show input amount and currency
                displayCurrency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                if (hop && hop.artAtStartByCurrency && displayCurrency) {
                    artAmount = hop.artAtStartByCurrency[displayCurrency] || 0;
                }
            } else {
                // For regular entries, get ART for the entry's currency
                if (hop && hop.artAtStartByCurrency && currency) {
                    artAmount = hop.artAtStartByCurrency[currency] || 0;
                }
            }
            
            // Calculate thread number within hop (sequential numbering for entries with notation)
            let threadNumber = null;
            if (entry.notation && parseFloat(entry.amount) > 0) {
                const hopEntriesWithNotation = hop.entries.filter(e => e.notation && parseFloat(e.amount) > 0);
                threadNumber = hopEntriesWithNotation.findIndex(e => e.id === entry.id) + 1;
            }
            
            // Get source thread information
            let sourceThreadsInfo = '';
            if (entry.sourceThreadId) {
                // Single source thread
                const sourceMatch = entry.sourceThreadId.match(/^(V\d+-T\d+)-H(\d+)$/);
                if (sourceMatch) {
                    const [, vtPath, sourceHopNumber] = sourceMatch;
                    sourceThreadsInfo = `from ${vtPath} (H${sourceHopNumber})`;
                }
            } else if (entry.multipleSourceThreads && entry.multipleSourceThreads.length > 0) {
                // Multiple source threads
                const sourceThreads = entry.multipleSourceThreads.map(threadId => {
                    const sourceMatch = threadId.match(/^(V\d+-T\d+)-H(\d+)$/);
                    if (sourceMatch) {
                        const [, vtPath, sourceHopNumber] = sourceMatch;
                        return `${vtPath} (H${sourceHopNumber})`;
                    }
                    return threadId;
                });
                sourceThreadsInfo = `from ${sourceThreads.join(', ')}`;
            }
            
            // Entry background color and border based on type - color-coded with thicker borders
            let entryBgColor = '#f8f8f8'; // Very light gray as default
            let entryBorderColor = '#27ae60'; // Green border for traced to next hop (default)

            // Determine border color and background based on wallet type and entry type
            if (entry.entryType === 'writeoff' || entry.entryType === 'abandoned') {
                entryBgColor = '#fafafa'; // Very light gray for writeoffs/abandoned
                entryBorderColor = '#7f8c8d'; // Gray border for abandoned
            } else if (entry.entryType === 'cold_storage' || entry.toWalletType === 'blue') {
                entryBgColor = '#e8f4fd'; // Very light blue for cold storage
                entryBorderColor = '#3498db'; // Blue border for cold wallet
            } else if (entry.toWalletType === 'purple' || entry.toWalletType === 'PURPLE') {
                entryBgColor = '#f5ebff'; // Very light purple for exchange deposits
                entryBorderColor = '#9b59b6'; // Purple border for exchange
            } else if (entry.toWalletType === 'brown' || entry.isBridge || entry.entryType === 'swap') {
                entryBgColor = '#fff9f0'; // Very light brown/tan for conversion wallets
                entryBorderColor = '#8b4513'; // Brown border for conversion wallet/bridge
            } else if (entry.toWalletType === 'gray') {
                entryBgColor = '#fafafa'; // Very light gray
                entryBorderColor = '#7f8c8d'; // Gray border
            } else {
                // Default green for regular traces that continue to next hop
                entryBgColor = '#f0fff0'; // Very light green
                entryBorderColor = '#27ae60'; // Green border for traced to next hop
            }

            return `
                <div id="entry_${hop.hopNumber}_${entry.id}" style="background: ${entryBgColor}; border: 4px solid ${entryBorderColor}; border-radius: 8px; margin-bottom: 10px; overflow: hidden;">
                    <div style="padding: ${isCollapsed ? '8px' : '15px'};">
                        <!-- Collapsed state header -->
                        <div id="entrySummary_${entryKey}" style="display: ${isCollapsed ? 'block' : 'none'}; background: rgba(255,255,255,0.7); padding: 6px 10px; border-radius: 6px;">
                            <div style="cursor: pointer;" onclick="toggleEntryCollapse('${entryKey}')">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <div style="display: flex; align-items: center; gap: 10px;">
                                            <span style="transform: rotate(0deg); transition: transform 0.3s; display: inline-block; font-size: 16px;">▶</span>
                                            <span style="font-weight: bold; color: #2c3e50;">
                                                Hop ${hopNumber} Entry ${entry.id}${threadNumber ? ` (Thread ${threadNumber})` : ''}
                                            </span>
                                            <span style="color: ${entry.entryType === 'writeoff' ? '#e74c3c' : '#7f8c8d'}; font-size: 12px; font-weight: ${entry.entryType === 'writeoff' ? 'bold' : 'normal'};">
                                                ${entry.entryType === 'writeoff' ? '📝 WRITE-OFF' : entryTypeLabel}
                                            </span>
                                            ${entry.entryType === 'writeoff' ? `
                                                <span style="background: #ffebee; color: #c62828; padding: 2px 6px; border-radius: 4px; font-size: 11px;">
                                                    ${entry.category ? entry.category.toUpperCase() : 'UNSPECIFIED'}
                                                </span>
                                            ` : ''}
                                            ${entry.notation ? `
                                                <span style="color: #666; font-size: 11px; font-style: italic;">
                                                    (${entry.notation})
                                                </span>
                                            ` : ''}
                                            ${(() => {
                                                // Detect bridge provider
                                                const bridgeProvider = detectAndStoreBridgeProvider(entry);
                                                if (bridgeProvider) {
                                                    return `
                                                        <span style="background: #8b4513; color: white; padding: 2px 6px; border-radius: 4px; font-size: 11px;">
                                                            🌉 ${bridgeProvider.name} DETECTED
                                                        </span>
                                                    `;
                                                } else if (entry.isBridge) {
                                                    return `
                                                        <span style="background: #8b4513; color: white; padding: 2px 6px; border-radius: 4px; font-size: 11px;">
                                                            🌉 BRIDGE${entry.exchangeAttribution?.name ? `: ${entry.exchangeAttribution.name}` : ''}
                                                        </span>
                                                    `;
                                                }
                                                return '';
                                            })()}
                                            ${(entry.toWalletType === 'purple' || entry.toWalletType === 'PURPLE') && !entry.bridgeOutputLogged && !detectAndStoreBridgeProvider(entry) ? `
                                                <span style="background: #9b59b6; color: white; padding: 2px 6px; border-radius: 4px; font-size: 11px;">
                                                    ${entry.isSmartContract ?
                                    `SMART CONTRACT${entry.exchangeAttribution?.name ? `: ${entry.exchangeAttribution.name}` : ''}` :
                                    `TERMINAL${entry.exchangeAttribution?.name ? `: ${entry.exchangeAttribution.name}` : ''}`}
                                                </span>
                                            ` : ''}
                                        </div>
                                        ${sourceThreadsInfo ? `
                                            <div style="margin-left: 26px; margin-top: 4px;">
                                                <span style="color: #666; font-size: 11px; font-style: italic;">
                                                    ${sourceThreadsInfo}
                                                </span>
                                            </div>
                                        ` : ''}
                                        ${entry.entryType === 'writeoff' && (entry.toWallet || entry.transactionHash) ? `
                                            <div style="margin-left: 26px; margin-top: 4px;">
                                                <span style="color: #666; font-size: 11px;">
                                                    ${entry.toWallet ? `Wallet: ${entry.toWallet.substring(0, 8)}...${entry.toWallet.substring(entry.toWallet.length - 6)}` : ''}
                                                    ${entry.transactionHash ? `TX: ${entry.transactionHash.substring(0, 8)}...` : ''}
                                                </span>
                                            </div>
                                        ` : ''}
                                    </div>
                                    <div style="text-align: right;">
                                        ${amount > 0 ? (
                                            entry.entryType === 'writeoff' ? `
                                                <span style="font-weight: bold; color: #e74c3c;">
                                                    -${amount.toLocaleString()} ${currency}
                                                </span>
                                                <div style="font-size: 11px; color: #7f8c8d;">
                                                    ${entry.category || 'Written off'}${entry.justification ? `: ${entry.justification.substring(0, 50)}${entry.justification.length > 50 ? '...' : ''}` : ''}
                                                </div>
                                            ` : entry.entryType === 'swap' && entry.swapDetails ? `
                                                <span style="font-weight: bold; color: #27ae60;">
                                                    ${amount.toLocaleString()} ${displayCurrency} → ${parseFloat(entry.outputAmount || 0).toLocaleString()} ${entry.outputCurrency || ''}
                                                </span>
                                            ` : `
                                                <span style="font-weight: bold; color: #27ae60;">
                                                    ${amount.toLocaleString()} ${currency} / ${artAmount.toLocaleString()} ${currency}
                                                </span>
                                            `
                                        ) : `
                                            <span style="color: #e74c3c; font-size: 12px;">
                                                Not logged
                                            </span>
                                        `}
                                    </div>
                                </div>
                            </div>
                            <!-- Action buttons in collapsed view -->
                            <div style="display: flex; gap: 10px; margin-top: 10px; justify-content: flex-start; flex-wrap: wrap;">
                                ${(() => {
                                    const bridgeProvider = entry.bridgeProvider || detectAndStoreBridgeProvider(entry);
                                    if (bridgeProvider && entry.entryType === 'trace' && !entry.bridgeOutputLogged) {
                                        return `
                                            <button class="btn btn-sm" style="background: #e67e22; color: white; border: 1px solid #d35400; font-weight: bold;"
                                                    onclick="event.stopPropagation(); autoTraceBridge(${hop.hopNumber}, ${entry.id})"
                                                    title="Automatically fetch bridge details from ${bridgeProvider.name} API">
                                                🔍 Auto-Trace ${bridgeProvider.name}
                                            </button>
                                        `;
                                    }
                                    return '';
                                })()}
                                ${((entry.toWalletType === 'purple' || entry.toWalletType === 'PURPLE') ||
                                   (entry.toWalletType === 'brown' && entry.exchangeAttribution?.isSmartContract) ||
                                   (entry.toWalletType === 'brown' && entry.isBridge)) &&
                                   entry.entryType === 'trace' && !entry.bridgeOutputLogged ? `
                                    <button class="btn btn-sm" style="background: #27ae60; color: white; border: 1px solid #229954;"
                                            onclick="event.stopPropagation(); logBridgeOutput(${hop.hopNumber}, ${entry.id})"
                                            title="${entry.exchangeAttribution?.isSmartContract || entry.isBridge ?
                                                'Log the output from this smart contract (DEX/Bridge)' :
                                                'Log the output transaction from this terminal wallet (CEX or Bridge)'}">
                                        🌉 Log Bridge/Swap
                                    </button>
                                ` : ''}
                                <button class="btn btn-sm btn-danger" onclick="event.stopPropagation(); removeHopEntry(${hop.hopNumber}, ${entry.id})">
                                    🗑️ Delete
                                </button>
                            </div>
                        </div>
                        
                        <!-- Expanded state -->
                        <div id="entryContent_${entryKey}" style="display: ${isCollapsed ? 'none' : 'block'};">
                            <!-- Expanded header - clickable to collapse -->
                            <div style="cursor: pointer; margin-bottom: 10px; background: rgba(255,255,255,0.7); padding: 10px; border-radius: 6px;" onclick="toggleEntryCollapse('${entryKey}')">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <div style="display: flex; align-items: center; gap: 10px;">
                                            <span style="transform: rotate(90deg); transition: transform 0.3s; display: inline-block; font-size: 16px;">▶</span>
                                            <span style="font-weight: bold; color: #2c3e50;">
                                                Hop ${hopNumber} Entry ${entry.id}${threadNumber ? ` (Thread ${threadNumber})` : ''}
                                            </span>
                                            <span style="color: #7f8c8d; font-size: 12px;">
                                                ${entryTypeLabel}
                                            </span>
                                            ${(() => {
                                                // Detect bridge provider
                                                const bridgeProvider = detectAndStoreBridgeProvider(entry);
                                                if (bridgeProvider) {
                                                    return `
                                                        <span style="background: #8b4513; color: white; padding: 2px 6px; border-radius: 4px; font-size: 11px;">
                                                            🌉 ${bridgeProvider.name} DETECTED
                                                        </span>
                                                    `;
                                                } else if (entry.isBridge) {
                                                    return `
                                                        <span style="background: #8b4513; color: white; padding: 2px 6px; border-radius: 4px; font-size: 11px;">
                                                            🌉 BRIDGE${entry.exchangeAttribution?.name ? `: ${entry.exchangeAttribution.name}` : ''}
                                                        </span>
                                                    `;
                                                } else if ((entry.toWalletType === 'purple' || entry.toWalletType === 'PURPLE') && !entry.bridgeOutputLogged) {
                                                    return `
                                                        <span style="background: #9b59b6; color: white; padding: 2px 6px; border-radius: 4px; font-size: 11px;">
                                                            ${entry.isSmartContract ?
                                                                `SMART CONTRACT${entry.exchangeAttribution?.name ? `: ${entry.exchangeAttribution.name}` : ''}` :
                                                                `TERMINAL${entry.exchangeAttribution?.name ? `: ${entry.exchangeAttribution.name}` : ''}`}
                                                        </span>
                                                    `;
                                                }
                                                return '';
                                            })()}
                                            <span style="color: #666; font-size: 11px;">
                                                (Click to collapse)
                                            </span>
                                        </div>
                                        ${sourceThreadsInfo ? `
                                            <div style="margin-left: 26px; margin-top: 4px;">
                                                <span style="color: #666; font-size: 11px; font-style: italic;">
                                                    ${sourceThreadsInfo}
                                                </span>
                                            </div>
                                        ` : ''}
                                        ${entry.entryType === 'writeoff' && (entry.toWallet || entry.transactionHash) ? `
                                            <div style="margin-left: 26px; margin-top: 4px;">
                                                <span style="color: #666; font-size: 11px;">
                                                    ${entry.toWallet ? `Wallet: ${entry.toWallet.substring(0, 8)}...${entry.toWallet.substring(entry.toWallet.length - 6)}` : ''}
                                                    ${entry.transactionHash ? `TX: ${entry.transactionHash.substring(0, 8)}...` : ''}
                                                </span>
                                            </div>
                                        ` : ''}
                                    </div>
                                    <div style="text-align: right;">
                                        ${amount > 0 ? (
                                            entry.entryType === 'swap' && entry.swapDetails ? `
                                                <span style="font-weight: bold; color: #27ae60;">
                                                    ${amount.toLocaleString()} ${displayCurrency} → ${parseFloat(entry.outputAmount || 0).toLocaleString()} ${entry.outputCurrency || ''}
                                                </span>
                                            ` : `
                                                <span style="font-weight: bold; color: #27ae60;">
                                                    ${amount.toLocaleString()} ${currency} / ART
                                                </span>
                                            `
                                        ) : `
                                            <span style="color: #e74c3c; font-size: 12px;">
                                                Not logged yet
                                            </span>
                                        `}
                                    </div>
                                </div>
                            </div>
                            <!-- Entry form content - not clickable -->
                            <div style="background: #f8f8f8; padding: 15px; border-radius: 6px; cursor: default;" onclick="event.stopPropagation();">
                                ${renderHopEntry(entry, hop)}
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }
        
        // Pagination variables
        let currentHopPage = 1;
        let hopsPerPage = 20;
        
        // Dashboard Functions
        function updateDashboard() {
            // Only update dashboard if elements exist (they were removed with old tabs)
            const victimsEl = document.getElementById('dashStatVictims');
            const hopsEl = document.getElementById('dashStatHops');
            const threadsEl = document.getElementById('dashStatThreads');
            const terminalEl = document.getElementById('dashStatTerminal');

            if (victimsEl) victimsEl.textContent = investigation.victims.length;
            if (hopsEl) hopsEl.textContent = investigation.hops.length;

            if (threadsEl || terminalEl) {
                const threadStatus = checkAllThreadsTerminated();
                if (threadsEl) threadsEl.textContent = threadStatus.activeThreads.length;
                if (terminalEl) terminalEl.textContent = threadStatus.activeThreads.filter(t =>
                    ['gray', 'purple', 'blue'].includes(t.toWalletType)
                ).length;
            }
            
            // Update ART progress bars if element exists
            if (document.getElementById('artProgressBars')) {
                updateARTProgressBars();
            }

            // Update thread status bar if element exists
            if (document.getElementById('threadStatusBar')) {
                updateThreadStatusBar(threadStatus);
            }

            // Update hop jump menu if element exists
            if (document.getElementById('hopJumpMenu')) {
                updateHopJumpMenu();
            }
        }
        
        function updateThreadStatusBar(threadStatus) {
            const container = document.getElementById('threadStatusBar');
            if (!container) return; // Exit if element doesn't exist
            
            container.innerHTML = '';
            
            if (!investigation.rootTotalConfirmed) {
                container.innerHTML = '<p style="color: #7f8c8d;">Confirm root total to see thread status</p>';
                return;
            }
            
            if (!threadStatus || threadStatus.activeThreads.length === 0) {
                container.innerHTML = '<p style="color: #7f8c8d;">No active threads yet</p>';
                return;
            }
            
            // Group threads by currency
            const threadsByCurrency = {};
            threadStatus.activeThreads.forEach(thread => {
                if (!threadsByCurrency[thread.currency]) {
                    threadsByCurrency[thread.currency] = [];
                }
                threadsByCurrency[thread.currency].push(thread);
            });
            
            // Create a visual bar for each currency
            Object.entries(threadsByCurrency).forEach(([currency, threads]) => {
                const barContainer = document.createElement('div');
                barContainer.style.cssText = 'margin-bottom: 15px;';
                
                // Currency label
                const label = document.createElement('div');
                label.style.cssText = 'font-weight: bold; margin-bottom: 5px; color: #2c3e50;';
                label.textContent = `${currency} Threads (${threads.length})`;
                barContainer.appendChild(label);
                
                // Thread bar
                const barBg = document.createElement('div');
                barBg.style.cssText = 'background: #e0e0e0; border-radius: 8px; height: 30px; position: relative; overflow: hidden;';
                
                // Calculate total amount for this currency
                const totalAmount = threads.reduce((sum, t) => sum + t.amount, 0);
                
                // Add segments for each thread
                let currentPosition = 0;
                threads.forEach((thread, index) => {
                    const percentage = (thread.amount / totalAmount) * 100;
                    const segment = document.createElement('div');
                    
                    // Use wallet color for terminal wallets, green for active threads
                    const isTerminal = ['purple', 'blue', 'gray'].includes(thread.toWalletType);
                    const segmentColor = isTerminal ? getWalletColor(thread.toWalletType) : '#27ae60';
                    
                    segment.style.cssText = `
                        position: absolute;
                        left: ${currentPosition}%;
                        width: ${percentage}%;
                        height: 100%;
                        background: ${segmentColor};
                        border-right: 1px solid white;
                        cursor: pointer;
                        transition: opacity 0.2s;
                    `;
                    
                    // Add hover effect and tooltip
                    segment.title = `${thread.path}: ${thread.amount.toLocaleString()} ${currency}\nTo: ${thread.toWallet}\nType: ${walletTypes[thread.toWalletType] || thread.toWalletType}`;
                    segment.onmouseover = () => { segment.style.opacity = '0.8'; };
                    segment.onmouseout = () => { segment.style.opacity = '1'; };
                    
                    barBg.appendChild(segment);
                    currentPosition += percentage;
                });
                
                barContainer.appendChild(barBg);
                
                // Legend for this currency
                const legend = document.createElement('div');
                legend.style.cssText = 'margin-top: 5px; font-size: 12px; color: #666;';
                
                const terminalCount = threads.filter(t => ['purple', 'blue', 'gray'].includes(t.toWalletType)).length;
                const activeCount = threads.length - terminalCount;
                
                const legendItems = [];
                if (activeCount > 0) {
                    legendItems.push(`<span style="color: #27ae60;">● ${activeCount} Active</span>`);
                }
                
                // Count by terminal type
                const purpleCount = threads.filter(t => t.toWalletType === 'purple').length;
                const blueCount = threads.filter(t => t.toWalletType === 'blue').length;
                const grayCount = threads.filter(t => t.toWalletType === 'gray').length;
                
                if (purpleCount > 0) {
                    legendItems.push(`<span style="color: #9b59b6;">● ${purpleCount} Exchange</span>`);
                }
                if (blueCount > 0) {
                    legendItems.push(`<span style="color: #3498db;">● ${blueCount} Cold Storage</span>`);
                }
                if (grayCount > 0) {
                    legendItems.push(`<span style="color: #95a5a6;">● ${grayCount} Obfuscated</span>`);
                }
                
                legend.innerHTML = legendItems.join(' | ');
                barContainer.appendChild(legend);
                
                container.appendChild(barContainer);
            });
        }
        
        function updateARTProgressBars() {
            const container = document.getElementById('artProgressBars');
            if (!container) return; // Exit if element doesn't exist
            container.innerHTML = '';

            if (!investigation.rootTotalConfirmed) {
                container.innerHTML = '<p style="color: #7f8c8d;">Confirm root total to see ART progress</p>';
                return;
            }

            // Get ALL available currencies from threads (includes converted currencies)
            const allCurrencies = {};

            // Start with root total from victim transactions
            const rootTotal = investigation.victims.reduce((acc, victim) => {
                victim.transactions.forEach(t => {
                    const currency = t.currency === 'CUSTOM' ? t.customCurrency : t.currency;
                    const amount = parseFloat(t.amount) || 0;
                    if (currency && amount > 0) {
                        acc[currency] = (acc[currency] || 0) + amount;
                    }
                });
                return acc;
            }, {});

            // Add currencies from available threads (includes swap/bridge outputs)
            if (investigation.availableThreads) {
                for (const currency in investigation.availableThreads) {
                    if (!allCurrencies[currency]) {
                        allCurrencies[currency] = { total: 0, available: 0, isConverted: !rootTotal[currency] };
                    }

                    // Sum up total amounts in this currency
                    for (const threadKey in investigation.availableThreads[currency]) {
                        const thread = investigation.availableThreads[currency][threadKey];
                        allCurrencies[currency].total += thread.totalAmount || 0;
                        allCurrencies[currency].available += thread.availableAmount || 0;
                    }
                }
            }

            // Merge root totals into allCurrencies
            for (const currency in rootTotal) {
                if (!allCurrencies[currency]) {
                    allCurrencies[currency] = { total: 0, available: 0, isConverted: false };
                }
                allCurrencies[currency].rootAmount = rootTotal[currency];
            }

            // Get current ART by currency
            const currentART = getCurrentART();

            // Create progress bars for each currency
            Object.entries(allCurrencies).forEach(([currency, data]) => {
                // For root currencies, show traditional progress
                if (data.rootAmount) {
                    const total = data.rootAmount;
                    const current = currentART[currency] || 0;
                    const traced = total - current;
                    const percentage = total > 0 ? (traced / total * 100).toFixed(1) : 0;

                    const progressBar = `
                        <div class="progress-bar-container">
                            <div class="progress-bar-label">
                                <span><strong>${currency}</strong></span>
                                <span>${traced.toLocaleString()} / ${total.toLocaleString()} (${percentage}%)</span>
                            </div>
                            <div class="progress-bar-bg">
                                <div class="progress-bar-fill" style="width: ${percentage}%"></div>
                            </div>
                        </div>
                    `;
                    container.innerHTML += progressBar;
                } else if (data.total > 0) {
                    // For converted currencies (from swaps/bridges), show what needs to be traced
                    const total = data.total;
                    const traced = total - data.available;
                    const percentage = total > 0 ? (traced / total * 100).toFixed(1) : 0;

                    const progressBar = `
                        <div class="progress-bar-container">
                            <div class="progress-bar-label">
                                <span><strong>${currency}</strong> <em style="color: #8b4513; font-size: 0.9em;">(converted)</em></span>
                                <span>${traced.toLocaleString()} / ${total.toLocaleString()} (${percentage}%)</span>
                            </div>
                            <div class="progress-bar-bg" style="background: #fff8f4;">
                                <div class="progress-bar-fill" style="width: ${percentage}%; background: #8b4513;"></div>
                            </div>
                        </div>
                    `;
                    container.innerHTML += progressBar;
                }
            });

            // If no currencies to display
            if (Object.keys(allCurrencies).length === 0) {
                container.innerHTML = '<p style="color: #7f8c8d;">No ART data to display</p>';
            }
        }
        
        function updateHopJumpMenu() {
            const menu = document.getElementById('hopJumpMenu');
            if (!menu) return; // Exit if element doesn't exist
            menu.innerHTML = '<option value="">Jump to Hop...</option>';
            
            investigation.hops.forEach(hop => {
                const option = document.createElement('option');
                option.value = hop.hopNumber;
                option.textContent = `Hop ${hop.hopNumber}${hop.completed ? ' ✓' : ''}`;
                menu.appendChild(option);
            });
        }
        
        function toggleDashboard() {
            const content = document.getElementById('dashboardContent');
            const button = document.getElementById('dashboardToggle');
            
            if (content.style.display === 'none') {
                content.style.display = 'block';
                button.textContent = 'Hide Dashboard';
            } else {
                content.style.display = 'none';
                button.textContent = 'Show Dashboard';
            }
        }
        
        function jumpToHop(hopNumber) {
            if (!hopNumber) return;
            
            const hopElement = document.querySelector(`[data-hop-id="${hopNumber}"]`);
            if (hopElement) {
                hopElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                // Flash the hop for visibility
                hopElement.style.transition = 'background-color 0.3s';
                hopElement.style.backgroundColor = '#fff3cd';
                setTimeout(() => {
                    hopElement.style.backgroundColor = '';
                }, 1000);
            }
        }
        
        let searchTimeout;
        function globalSearchDebounce() {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(globalSearch, 300);
        }
        
        function globalSearch() {
            const query = document.getElementById('globalSearch').value.toLowerCase();
            if (!query) {
                // Clear highlights
                document.querySelectorAll('.search-highlight').forEach(el => {
                    el.classList.remove('search-highlight');
                });
                return;
            }
            
            // Search in hops and entries
            let found = false;
            investigation.hops.forEach(hop => {
                hop.entries.forEach(entry => {
                    const searchableText = [
                        entry.toWallet,
                        entry.fromWallet,
                        entry.txHash,
                        entry.amount,
                        entry.notation
                    ].filter(Boolean).join(' ').toLowerCase();
                    
                    if (searchableText.includes(query)) {
                        found = true;
                        // Highlight the entry
                        const entryElement = document.querySelector(`[data-entry-id="${hop.hopNumber}-${entry.id}"]`);
                        if (entryElement) {
                            entryElement.classList.add('search-highlight');
                            if (!found) {
                                entryElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            }
                        }
                    }
                });
            });
        }
        
        function showThreadFilter() {
            // This will be implemented with the visualization tools
            alert('Thread filter coming soon! This will allow you to filter the view to specific V-T threads.');
        }
        
        function showAnalysisTools() {
            const modalHTML = `
                <div id="analysisModal" class="modal" style="display: block;">
                    <div class="modal-content" style="max-width: 800px;">
                        <div class="modal-header">
                            <h2>📊 Investigation Analysis Tools</h2>
                            <button class="close-btn" onclick="closeAnalysisModal()">×</button>
                        </div>
                        
                        <div style="padding: 20px;">
                            <div class="nav-tabs">
                                <button class="nav-tab active" onclick="switchAnalysisTab('wallet-frequency')">Wallet Frequency</button>
                                <button class="nav-tab" onclick="switchAnalysisTab('pattern-detection')">Pattern Detection</button>
                                <button class="nav-tab" onclick="switchAnalysisTab('terminal-summary')">Terminal Summary</button>
                            </div>
                            
                            <div id="wallet-frequency-tab" class="analysis-tab-content active">
                                <h3>Wallet Frequency Analysis</h3>
                                <div id="walletFrequencyContent"></div>
                            </div>
                            
                            <div id="pattern-detection-tab" class="analysis-tab-content" style="display: none;">
                                <h3>Transaction Pattern Detection</h3>
                                <div id="patternDetectionContent"></div>
                            </div>
                            
                            <div id="terminal-summary-tab" class="analysis-tab-content" style="display: none;">
                                <h3>Terminal Wallet Summary</h3>
                                <div id="terminalSummaryContent"></div>
                            </div>
                        </div>
                        
                        <div class="modal-footer" style="text-align: center; padding: 20px; border-top: 1px solid #eee;">
                            <button class="btn btn-secondary" onclick="closeAnalysisModal()" style="padding: 10px 30px;">
                                Close Analysis
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            createCenteredModal('analysisModal', modalHTML);
            analyzeInvestigation();
        }
        
        function closeAnalysisModal() {
            const modal = document.getElementById('analysisModal');
            if (modal) modal.remove();
        }
        
        function switchAnalysisTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.analysis-tab-content').forEach(tab => {
                tab.style.display = 'none';
            });
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected tab
            document.getElementById(`${tabName}-tab`).style.display = 'block';
            event.target.classList.add('active');
        }
        
        function analyzeInvestigation() {
            // Wallet Frequency Analysis
            const walletFrequency = {};
            investigation.hops.forEach(hop => {
                hop.entries.forEach(entry => {
                    if (entry.toWallet) {
                        walletFrequency[entry.toWallet] = (walletFrequency[entry.toWallet] || 0) + 1;
                    }
                });
            });
            
            const frequentWallets = Object.entries(walletFrequency)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);
            
            let walletFreqHTML = '<table style="width: 100%; border-collapse: collapse;">';
            walletFreqHTML += '<tr><th style="text-align: left; padding: 10px; border-bottom: 2px solid #ddd;">Wallet Address</th>';
            walletFreqHTML += '<th style="text-align: right; padding: 10px; border-bottom: 2px solid #ddd;">Appearances</th></tr>';
            
            frequentWallets.forEach(([wallet, count]) => {
                walletFreqHTML += `<tr>
                    <td style="padding: 8px; border-bottom: 1px solid #eee; font-family: monospace; font-size: 12px;">
                        ${wallet.substring(0, 20)}...
                    </td>
                    <td style="padding: 8px; border-bottom: 1px solid #eee; text-align: right;">
                        ${count}
                    </td>
                </tr>`;
            });
            walletFreqHTML += '</table>';
            
            document.getElementById('walletFrequencyContent').innerHTML = walletFreqHTML;
            
            // Pattern Detection
            const patterns = detectPatterns();
            let patternHTML = '<div style="margin-top: 20px;">';
            patterns.forEach(pattern => {
                patternHTML += `<div style="background: #f8f9fa; border-left: 4px solid #3498db; padding: 15px; margin-bottom: 10px;">
                    <strong>${pattern.type}</strong>: ${pattern.description}
                </div>`;
            });
            patternHTML += '</div>';
            
            document.getElementById('patternDetectionContent').innerHTML = patternHTML;
            
            // Enhanced Terminal Summary with exchange details
            const terminalWallets = getTerminalWallets();
            let terminalHTML = '<div style="margin-top: 20px;">';

            // Add export button for terminal wallet report
            terminalHTML += `
                <div style="margin-bottom: 20px;">
                    <button class="btn btn-primary" onclick="exportTerminalWalletReport()" style="margin-right: 10px;">
                        📊 Export Terminal Wallet Report
                    </button>
                    <button class="btn btn-secondary" onclick="copyTerminalWalletReport()">
                        📋 Copy Report to Clipboard
                    </button>
                </div>
            `;

            Object.entries(terminalWallets).forEach(([type, wallets]) => {
                if (wallets.length === 0) return;

                terminalHTML += `<h4>${type} Wallets (${wallets.length})</h4>`;

                if (type === 'Purple (Exchange)' && wallets.length > 0) {
                    // Enhanced display for exchange wallets
                    terminalHTML += '<div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px;">';
                    terminalHTML += '<table style="width: 100%; border-collapse: collapse;">';
                    terminalHTML += `
                        <thead>
                            <tr style="border-bottom: 2px solid #dee2e6;">
                                <th style="padding: 10px; text-align: left;">Exchange</th>
                                <th style="padding: 10px; text-align: left;">Amount</th>
                                <th style="padding: 10px; text-align: left;">Wallet</th>
                                <th style="padding: 10px; text-align: left;">Timestamp</th>
                                <th style="padding: 10px; text-align: left;">Hop</th>
                                <th style="padding: 10px; text-align: left;">Source</th>
                            </tr>
                        </thead>
                        <tbody>
                    `;

                    wallets.forEach(w => {
                        terminalHTML += `
                            <tr style="border-bottom: 1px solid #dee2e6;">
                                <td style="padding: 10px;">
                                    <strong style="color: #9b59b6;">${w.exchangeName || 'Unknown'}</strong>
                                </td>
                                <td style="padding: 10px;">
                                    ${w.amount.toLocaleString()} ${w.currency}
                                </td>
                                <td style="padding: 10px; font-family: monospace; font-size: 11px;">
                                    ${w.wallet.substring(0, 15)}...${w.wallet.substring(w.wallet.length - 10)}
                                </td>
                                <td style="padding: 10px; font-size: 12px;">
                                    ${w.timestamp ? new Date(w.timestamp).toLocaleString() : 'N/A'}
                                </td>
                                <td style="padding: 10px;">
                                    ${w.hopNumber ? `Hop ${w.hopNumber}` : 'N/A'}
                                </td>
                                <td style="padding: 10px; font-size: 11px;">
                                    ${w.detectionSource || 'Manual'}
                                </td>
                            </tr>
                        `;
                    });

                    terminalHTML += '</tbody></table></div>';

                    // Summary statistics
                    const totalByExchange = {};
                    wallets.forEach(w => {
                        const key = `${w.exchangeName || 'Unknown'}_${w.currency}`;
                        if (!totalByExchange[key]) {
                            totalByExchange[key] = {
                                exchange: w.exchangeName || 'Unknown',
                                currency: w.currency,
                                total: 0,
                                count: 0
                            };
                        }
                        totalByExchange[key].total += w.amount;
                        totalByExchange[key].count++;
                    });

                    terminalHTML += '<div style="background: #e1bee7; padding: 15px; border-radius: 8px; margin-bottom: 20px;">';
                    terminalHTML += '<h5>📊 Exchange Summary:</h5>';
                    Object.values(totalByExchange).forEach(summary => {
                        terminalHTML += `
                            <div style="margin: 10px 0;">
                                <strong>${summary.exchange}:</strong>
                                ${summary.total.toLocaleString()} ${summary.currency}
                                (${summary.count} transaction${summary.count > 1 ? 's' : ''})
                            </div>
                        `;
                    });
                    terminalHTML += '</div>';

                } else {
                    // Standard display for other terminal types
                    terminalHTML += '<ul>';
                    wallets.forEach(w => {
                        terminalHTML += `<li style="margin-bottom: 5px;">
                            <strong>${w.wallet}</strong>: ${w.amount.toLocaleString()} ${w.currency}
                        </li>`;
                    });
                    terminalHTML += '</ul>';
                }
            });
            terminalHTML += '</div>';

            document.getElementById('terminalSummaryContent').innerHTML = terminalHTML;
        }
        
        // Export terminal wallet report
        function exportTerminalWalletReport() {
            const terminals = getTerminalWallets();
            const exchangeWallets = terminals['Purple (Exchange)'] || [];

            if (exchangeWallets.length === 0) {
                alert('No terminal wallet arrivals to export.');
                return;
            }

            // Prepare CSV data
            const csvData = [];
            csvData.push({
                'Date/Time (UTC)': 'Date/Time (UTC)',
                'Exchange': 'Exchange',
                'Amount': 'Amount',
                'Currency': 'Currency',
                'Receiving Wallet': 'Receiving Wallet',
                'Sending Wallet': 'Sending Wallet',
                'Transaction Hash': 'Transaction Hash',
                'Hop Number': 'Hop Number',
                'Detection Source': 'Detection Source',
                'Case ID': 'Case ID',
                'Investigator': 'Investigator'
            });

            exchangeWallets.forEach(wallet => {
                csvData.push({
                    'Date/Time (UTC)': wallet.timestamp ? formatDateTimeForReport(wallet.timestamp, 'UTC') : 'N/A',
                    'Exchange': wallet.exchangeName || 'Unknown Exchange',
                    'Amount': wallet.amount.toLocaleString(),
                    'Currency': wallet.currency,
                    'Receiving Wallet': wallet.wallet,
                    'Sending Wallet': wallet.fromWallet || 'N/A',
                    'Transaction Hash': wallet.txHash || 'N/A',
                    'Hop Number': wallet.hopNumber ? `Hop ${wallet.hopNumber}` : 'N/A',
                    'Detection Source': wallet.detectionSource || 'Manual',
                    'Case ID': investigation.caseId,
                    'Investigator': investigation.investigator
                });
            });

            // Generate filename with timestamp
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const filename = `Terminal_Wallet_Report_${investigation.caseId}_${timestamp}.csv`;

            exportToCSV(csvData, filename);
            showNotification(`Terminal wallet report exported as ${filename}`, 'success');
        }

        // Copy terminal wallet report to clipboard
        function copyTerminalWalletReport() {
            const terminals = getTerminalWallets();
            const exchangeWallets = terminals['Purple (Exchange)'] || [];

            if (exchangeWallets.length === 0) {
                alert('No terminal wallet arrivals to copy.');
                return;
            }

            let report = '=== TERMINAL WALLET ARRIVAL REPORT ===\n\n';
            report += `Case ID: ${investigation.caseId}\n`;
            report += `Investigator: ${investigation.investigator}\n`;
            report += `Report Generated: ${new Date().toISOString()}\n\n`;

            // Group by exchange
            const byExchange = {};
            exchangeWallets.forEach(wallet => {
                const exchange = wallet.exchangeName || 'Unknown Exchange';
                if (!byExchange[exchange]) {
                    byExchange[exchange] = [];
                }
                byExchange[exchange].push(wallet);
            });

            // Generate report for each exchange
            Object.entries(byExchange).forEach(([exchange, wallets]) => {
                report += `\n=== ${exchange.toUpperCase()} ===\n`;
                report += `Total Arrivals: ${wallets.length}\n\n`;

                wallets.forEach((wallet, index) => {
                    report += `${index + 1}. ${wallet.amount.toLocaleString()} ${wallet.currency}\n`;
                    report += `   Date/Time: ${wallet.timestamp ? new Date(wallet.timestamp).toLocaleString() : 'N/A'}\n`;
                    report += `   Receiving Wallet: ${wallet.wallet}\n`;
                    if (wallet.fromWallet) {
                        report += `   Sending Wallet: ${wallet.fromWallet}\n`;
                    }
                    if (wallet.txHash) {
                        report += `   Transaction Hash: ${wallet.txHash}\n`;
                    }
                    report += `   Hop: ${wallet.hopNumber ? wallet.hopNumber : 'N/A'}\n`;
                    report += `   Detection: ${wallet.detectionSource || 'Manual'}\n\n`;
                });
            });

            // Summary
            report += '\n=== SUMMARY ===\n';
            const totals = {};
            exchangeWallets.forEach(wallet => {
                const key = `${wallet.currency}_${wallet.exchangeName || 'Unknown'}`;
                if (!totals[key]) {
                    totals[key] = {
                        currency: wallet.currency,
                        exchange: wallet.exchangeName || 'Unknown',
                        amount: 0,
                        count: 0
                    };
                }
                totals[key].amount += wallet.amount;
                totals[key].count++;
            });

            Object.values(totals).forEach(total => {
                report += `${total.exchange}: ${total.amount.toLocaleString()} ${total.currency} (${total.count} transaction${total.count > 1 ? 's' : ''})\n`;
            });

            report += '\n=== LEGAL PROCESS REQUIREMENTS ===\n';
            report += 'The following exchanges have been identified as receiving stolen funds:\n\n';

            const uniqueExchanges = [...new Set(exchangeWallets.map(w => w.exchangeName || 'Unknown'))];
            uniqueExchanges.forEach(exchange => {
                report += `• ${exchange}\n`;
            });

            report += '\nLegal process (subpoenas, court orders, or international cooperation) may be required to:\n';
            report += '• Identify account holders at these exchanges\n';
            report += '• Freeze or recover funds\n';
            report += '• Obtain transaction records and KYC information\n';

            // Copy to clipboard
            navigator.clipboard.writeText(report).then(() => {
                showNotification('Terminal wallet report copied to clipboard', 'success');
            }).catch(err => {
                console.error('Failed to copy report:', err);
                alert('Failed to copy to clipboard. Please try exporting instead.');
            });
        }

        function detectPatterns() {
            const patterns = [];
            
            // Check for round amounts
            let roundAmounts = 0;
            investigation.hops.forEach(hop => {
                hop.entries.forEach(entry => {
                    const amount = parseFloat(entry.amount);
                    if (amount > 0 && amount % 100 === 0) {
                        roundAmounts++;
                    }
                });
            });
            
            if (roundAmounts > 5) {
                patterns.push({
                    type: 'Round Number Preference',
                    description: `${roundAmounts} transactions use round numbers (multiples of 100)`
                });
            }
            
            // Check for time patterns
            const timePatterns = {};
            investigation.victims.forEach(victim => {
                victim.transactions.forEach(t => {
                    if (t.datetime) {
                        const hour = new Date(t.datetime).getHours();
                        timePatterns[hour] = (timePatterns[hour] || 0) + 1;
                    }
                });
            });
            
            const peakHour = Object.entries(timePatterns).sort((a, b) => b[1] - a[1])[0];
            if (peakHour) {
                patterns.push({
                    type: 'Time Pattern',
                    description: `Peak activity at ${peakHour[0]}:00 hours (${peakHour[1]} transactions)`
                });
            }
            
            return patterns;
        }
        
        function getTerminalWallets() {
            const terminals = {
                'Purple (Exchange)': [],
                'Gray (Obfuscated)': [],
                'Blue (Cold Storage)': []
            };

            // First check terminal wallet index for detailed exchange info
            if (investigation.terminalWalletIndex && investigation.terminalWalletIndex.length > 0) {
                investigation.terminalWalletIndex.forEach(record => {
                    terminals['Purple (Exchange)'].push({
                        wallet: record.toWallet,
                        amount: record.amount,
                        currency: record.currency,
                        exchangeName: record.exchangeName,
                        timestamp: record.timestamp,
                        txHash: record.txHash,
                        fromWallet: record.fromWallet,
                        hopNumber: record.hopNumber,
                        detectionSource: record.detectionSource
                    });
                });
            }

            // Also check thread status for other terminal types
            const threadStatus = checkAllThreadsTerminated();
            threadStatus.activeThreads.forEach(thread => {
                if (thread.toWalletType === 'purple' &&
                    !terminals['Purple (Exchange)'].some(t => t.wallet === thread.toWallet && t.amount === thread.amount)) {
                    // Only add if not already in index
                    terminals['Purple (Exchange)'].push({
                        wallet: thread.toWallet,
                        amount: thread.amount,
                        currency: thread.currency,
                        exchangeName: 'Unknown Exchange',
                        hopNumber: thread.hopNumber
                    });
                } else if (thread.toWalletType === 'gray') {
                    terminals['Gray (Obfuscated)'].push({
                        wallet: thread.toWallet,
                        amount: thread.amount,
                        currency: thread.currency
                    });
                } else if (thread.toWalletType === 'blue') {
                    terminals['Blue (Cold Storage)'].push({
                        wallet: thread.toWallet,
                        amount: thread.amount,
                        currency: thread.currency
                    });
                }
            });
            
            return terminals;
        }
        
        // Export/Import Functions
        function exportInvestigation() {
            const exportData = {
                version: '1.0',
                exportDate: new Date().toISOString(),
                investigation: investigation
            };
            
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `BATS_Investigation_${investigation.caseId || 'export'}_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            alert(' Investigation exported successfully!');
        }
        
        function importInvestigation(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importData = JSON.parse(e.target.result);
                    
                    if (!importData.investigation) {
                        throw new Error('Invalid file format');
                    }
                    
                    if (confirm('⚠️ This will replace your current investigation. Are you sure you want to import?')) {
                        investigation = importData.investigation;
                        
                        // Reset pagination
                        currentHopPage = 1;
                        
                        // Clear collapse states
                        window.hopCollapseState = {};
                        window.entryCollapseState = {};
                        
                        // Save and re-render
                        saveToStorage();
                        location.reload(); // Reload to ensure all UI is properly initialized
                    }
                } catch (error) {
                    alert('ERROR:  Error importing file: ' + error.message);
                }
            };
            
            reader.readAsText(file);
        }
        
        // Export to CSV for specific data
        // Safe CSV cell escaping to prevent injection attacks
        function escapeCSVCell(value) {
            if (value === null || value === undefined) {
                return '';
            }

            const strValue = String(value);

            // Check for CSV injection patterns
            const injectionChars = ['=', '+', '-', '@', '\t', '\r'];
            const needsEscape = injectionChars.some(char => strValue.startsWith(char));

            // If starts with injection character, prefix with single quote
            let escaped = needsEscape ? "'" + strValue : strValue;

            // Handle quotes and commas
            if (escaped.includes('"') || escaped.includes(',') || escaped.includes('\n')) {
                // Escape quotes by doubling them
                escaped = escaped.replace(/"/g, '""');
                // Wrap in quotes
                escaped = `"${escaped}"`;
            }

            return escaped;
        }

        function exportToCSV(data, filename) {
            let csv = '';

            // Add headers
            const headers = Object.keys(data[0]);
            csv += headers.map(h => escapeCSVCell(h)).join(',') + '\n';

            // Add data
            data.forEach(row => {
                csv += headers.map(header => {
                    const value = row[header];
                    return escapeCSVCell(value);
                }).join(',') + '\n';
            });

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        // Pagination functions
        function changeHopPage(direction) {
            const totalPages = Math.ceil(investigation.hops.length / hopsPerPage);
            currentHopPage += direction;
            
            if (currentHopPage < 1) currentHopPage = 1;
            if (currentHopPage > totalPages) currentHopPage = totalPages;
            
            renderHops();
        }
        
        function updateHopsPerPage() {
            const select = document.getElementById('hopsPerPage');
            hopsPerPage = select.value === 'all' ? 'all' : parseInt(select.value);
            currentHopPage = 1; // Reset to first page
            renderHops();
        }

        function validateHopTransactionHashes(hop) {
            // Check for duplicate transaction hashes within the hop
            const txHashes = new Map();
            const duplicates = [];

            hop.entries.forEach(entry => {
                if (entry.txHash && entry.entryType !== 'writeoff') {
                    const hashLower = entry.txHash.toLowerCase();
                    if (txHashes.has(hashLower)) {
                        // Found duplicate
                        const existingEntry = txHashes.get(hashLower);
                        if (!duplicates.some(d => d.hash.toLowerCase() === hashLower)) {
                            duplicates.push({
                                hash: entry.txHash,
                                entries: [existingEntry.id, entry.id],
                                notations: [existingEntry.notation || 'Entry ' + existingEntry.id, entry.notation || 'Entry ' + entry.id]
                            });
                        }
                    } else {
                        txHashes.set(hashLower, entry);
                    }
                }
            });

            return duplicates;
        }

        function renderHops() {
            // Initialize collapse state tracking
            window.hopCollapseState = window.hopCollapseState || {};
            window.entryCollapseState = window.entryCollapseState || {};

            // Update dashboard
            updateDashboard();

            const container = document.getElementById('hopsList');
            if (!container) return; // Exit if element doesn't exist (was part of removed traces tab)
            container.innerHTML = '';

            // Add LIBR Monitoring Banner if using LIBR method
            if (investigation.tracingMethod === 'LIBR' && investigation.hops && investigation.hops.length > 0) {
                const monitoredWallets = getAllMonitoredWallets();
                if (monitoredWallets.length > 0) {
                    const totalsByCurrency = {};
                    monitoredWallets.forEach(w => {
                        if (!totalsByCurrency[w.currency]) totalsByCurrency[w.currency] = 0;
                        totalsByCurrency[w.currency] += w.remainingProceeds || 0;
                    });
                    const totalsDisplay = Object.entries(totalsByCurrency)
                        .map(([curr, amt]) => amt.toLocaleString() + ' ' + curr)
                        .join(' + ');

                    const needsReview = monitoredWallets.filter(w => getMonitoringStatus(w.lastAnalyzed).needsReview).length;

                    const bannerHtml = '<div style="background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%); border-left: 4px solid #2196f3; padding: 15px; margin-bottom: 20px; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">' +
                        '<div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 10px;">' +
                        '<div style="flex: 1; min-width: 200px;">' +
                        '<div style="font-size: 16px; font-weight: bold; color: #1565c0; margin-bottom: 5px;">👁️ LIBR Method Active</div>' +
                        '<div style="font-size: 14px; color: #666;">' +
                        '<strong>' + monitoredWallets.length + ' wallet' + (monitoredWallets.length !== 1 ? 's' : '') + ' monitored</strong> containing <strong>' + totalsDisplay + '</strong>' +
                        (needsReview > 0 ? ' <span style="color: #f57c00;">(' + needsReview + ' need' + (needsReview !== 1 ? '' : 's') + ' review ⚠️)</span>' : '') +
                        '</div>' +
                        '</div>' +
                        '<div style="display: flex; gap: 10px;">' +
                        '<button onclick="showLIBRMonitoringDashboard()" class="btn btn-primary" style="white-space: nowrap;">👁️ View Monitored Wallets</button>' +
                        '<button onclick="reanalyzeAllMonitoredWallets()" class="btn btn-secondary" style="white-space: nowrap;">🔄 Re-analyze All</button>' +
                        '</div>' +
                        '</div>' +
                        '</div>';

                    container.insertAdjacentHTML('afterbegin', bannerHtml);
                }
            }

            if (!investigation.rootTotalConfirmed) {
                container.innerHTML = `
                    <div class="no-traces-message">
                        <h3>Root Total Confirmation Required</h3>
                        <p>Please return to the "Victims & Transactions" tab and confirm your root total before documenting trace hops.</p>
                        <button class="btn btn-confirm" onclick="switchTab('victims'); document.querySelector('[onclick=\\"switchTab(\\'victims\\')\\"]').click();">← Back to Victims & Transactions</button>
                    </div>
                `;
                return;
            }

            if (investigation.hops.length === 0) {
                const currentART = getCurrentART();
                const artDisplay = Object.entries(currentART).map(([currency, amount]) => 
                    `${amount.toLocaleString()} ${currency}`
                ).join(' | ');
                
                container.innerHTML = `
                    <div class="no-traces-message" style="background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%); border: 3px solid #4caf50; padding: 40px; max-width: 900px; margin: 0 auto;">
                        <h2 style="color: #2e7d32; margin-bottom: 30px; font-size: 2rem;">🚀 Ready to Start Tracing Your Funds!</h2>
                        
                        <div style="background: white; border-radius: 12px; padding: 30px; margin-bottom: 30px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                            <h3 style="color: #1565c0; margin-bottom: 20px;">📋 What is Hop 1?</h3>
                            <p style="font-size: 1.1rem; line-height: 1.6; color: #424242; margin-bottom: 20px;">
                                <strong>Hop 1 documents where the stolen funds went IMMEDIATELY after leaving the RED wallets.</strong>
                            </p>
                            <div style="background: #f5f5f5; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                                <p style="margin: 0 0 15px 0; font-weight: bold; color: #1976d2;">You will need:</p>
                                <ul style="margin: 0; padding-left: 25px; color: #424242; line-height: 1.8;">
                                    <li>Transaction hash from each RED wallet showing outgoing funds</li>
                                    <li>Destination wallet addresses where funds were sent</li>
                                    <li>Amount and date/time of each transfer</li>
                                </ul>
                            </div>
                            <div style="background: #fff3e0; padding: 15px; border-radius: 8px; border-left: 4px solid #ff9800;">
                                <p style="margin: 0; color: #e65100;">
                                    <strong>💡 Example:</strong> If victim's funds went from RED wallet → Exchange wallet, that's your first Hop 1 entry
                                </p>
                            </div>
                        </div>
                        
                        <div class="art-display" style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 30px; font-size: 1.15rem; font-weight: bold; border: 2px solid #4caf50;">
                            <div style="color: #1b5e20; margin-bottom: 5px;">Funds Available to Trace:</div>
                            <div style="color: #2e7d32; font-size: 1.3rem;">${artDisplay}</div>
                        </div>
                        
                        <button class="btn btn-confirm" onclick="addNewHop()" style="padding: 20px 50px; font-size: 1.3rem; background: #4caf50; animation: pulse 2s infinite; border: none; border-radius: 8px; cursor: pointer; box-shadow: 0 4px 15px rgba(76,175,80,0.3);">
                            ➕ Create Hop 1 - Start Tracing
                        </button>
                        
                        <div style="margin-top: 20px; padding-top: 20px; border-top: 2px solid rgba(255,255,255,0.3);">
                            <p style="color: #1b5e20; font-size: 0.95rem; margin: 0;">
                                <strong>Need help?</strong> Each hop represents one "jump" in the blockchain. Start with Hop 1 to track where funds went from the RED wallets.
                            </p>
                        </div>
                    </div>
                `;
                return;
            }

            // Pagination logic
            const totalHops = investigation.hops.length;
            const showPagination = totalHops > 10 && hopsPerPage !== 'all';
            const paginationControls = document.getElementById('paginationControls');
            if (paginationControls) {
                paginationControls.style.display = showPagination ? 'block' : 'none';
            }

            let hopsToShow = investigation.hops;
            if (showPagination) {
                const startIndex = (currentHopPage - 1) * hopsPerPage;
                const endIndex = startIndex + hopsPerPage;
                hopsToShow = investigation.hops.slice(startIndex, endIndex);

                // Update pagination info
                const totalPages = Math.ceil(totalHops / hopsPerPage);
                const pageInfo = document.getElementById('pageInfo');
                const prevPageBtn = document.getElementById('prevPageBtn');
                const nextPageBtn = document.getElementById('nextPageBtn');

                if (pageInfo) {
                    pageInfo.textContent = `Page ${currentHopPage} of ${totalPages} (${totalHops} total hops)`;
                }
                if (prevPageBtn) {
                    prevPageBtn.disabled = currentHopPage === 1;
                }
                if (nextPageBtn) {
                    nextPageBtn.disabled = currentHopPage === totalPages;
                }
            }
            
            hopsToShow.forEach((hop, hopIndex) => {
                // Get the real hop index for alternating colors
                const realHopIndex = investigation.hops.indexOf(hop);
                const hopDiv = document.createElement('div');
                hopDiv.className = 'hop-container';
                hopDiv.setAttribute('data-hop-id', hop.hopNumber);
                
                // Calculate what's been accounted for in this hop
                // Use the thread database as the source of truth for amounts
                const availableThreads = getAvailableSourcesForHop(hop.hopNumber + 1, null);

                // Group available threads by currency for display
                const availableByCurrency = {};
                availableThreads.forEach(thread => {
                    if (!availableByCurrency[thread.currency]) {
                        availableByCurrency[thread.currency] = 0;
                    }
                    availableByCurrency[thread.currency] += thread.availableAmount;
                });

                // For "Total Accounted", show what's been traced in each entry
                // DO NOT count swaps - they are currency conversions, not traces
                const entryTotalsByCurrency = {};
                hop.entries.forEach(entry => {
                    if (parseFloat(entry.amount) > 0) {
                        // Skip swaps - they don't "account" for funds, they convert them
                        // Only count actual traces, writeoffs, cold storage
                        if (['trace', 'writeoff', 'cold_storage', 'vasp_arrival'].includes(entry.entryType)) {
                            const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                            if (!entryTotalsByCurrency[currency]) {
                                entryTotalsByCurrency[currency] = 0;
                            }
                            entryTotalsByCurrency[currency] += parseFloat(entry.amount);
                        }
                    }
                });
                
                // Check if hop is complete (all currencies balance)
                const artAtStart = hop.artAtStartByCurrency || {};

                // If artAtStartByCurrency is empty but we have a legacy artAtStart number, calculate it
                if (Object.keys(artAtStart).length === 0 && hop.artAtStart) {
                    // For legacy support - assume USD if only a number is stored
                    artAtStart['USD'] = hop.artAtStart;
                }

                let isComplete = hop.completed || false;
                let remainingDisplay = [];

                // Calculate remaining based on available threads, not just starting ART
                // This properly accounts for swaps that change currency
                // Use already fetched availableThreads from line 9836
                const remainingByCurrency = {};

                // Sum up remaining amounts by currency from available threads
                availableThreads.forEach(thread => {
                    if (thread.availableAmount > 0) {
                        if (!remainingByCurrency[thread.currency]) {
                            remainingByCurrency[thread.currency] = 0;
                        }
                        remainingByCurrency[thread.currency] += thread.availableAmount;
                    }
                });

                // Build display of remaining amounts
                Object.entries(remainingByCurrency).forEach(([currency, amount]) => {
                    if (amount >= 0.01) {
                        remainingDisplay.push(`${amount.toLocaleString()} ${currency}`);
                    }
                });

                // If no remaining threads, check if we had starting ART that wasn't traced
                if (remainingDisplay.length === 0 && Object.keys(artAtStart).length > 0) {
                    // Check for untraced amounts in original currencies
                    Object.entries(artAtStart).forEach(([currency, startAmount]) => {
                        const tracedAmount = entryTotalsByCurrency[currency] || 0;
                        const remaining = startAmount - tracedAmount;
                        if (Math.abs(remaining) >= 0.01) {
                            // Only show if not converted by swap
                            const hasSwapToOtherCurrency = hop.entries.some(e =>
                                e.entryType === 'swap' && e.currency === currency
                            );
                            if (!hasSwapToOtherCurrency) {
                                remainingDisplay.push(`${remaining.toLocaleString()} ${currency}`);
                            }
                        }
                    });
                }
                
                const artStartDisplay = typeof artAtStart === 'object' ? 
                    Object.entries(artAtStart).map(([currency, amount]) => `${amount.toLocaleString()} ${currency}`).join(' | ') :
                    `${artAtStart.toLocaleString()}`;
                
                // Initialize collapse state - completed hops start collapsed
                // Auto-collapse old hops for performance and clarity
                if (window.hopCollapseState[hop.hopNumber] === undefined) {
                    // When loading a saved investigation, collapse completed hops
                    // to reduce clutter and help users focus on current work
                    const isCurrentHop = !hop.completed && hop.entries && hop.entries.length > 0;
                    const isLastHop = hopIndex === investigation.hops.length - 1;
                    
                    // Collapse if: completed, or old hop (not in last 3), unless it's the current working hop
                    window.hopCollapseState[hop.hopNumber] = isComplete && !isCurrentHop && !isLastHop;
                }
                const isCollapsed = window.hopCollapseState[hop.hopNumber];
                
                // Different background colors for alternating hops
                const hopBgColor = realHopIndex % 2 === 0 ? '#f0f4f8' : '#e8ecf0';
                
                // Count entry summary
                const tracesCount = hop.entries.filter(e => e.entryType === 'trace').length;
                const writeoffsCount = hop.entries.filter(e => e.entryType === 'writeoff').length;
                const totalAccountedDisplay = Object.entries(entryTotalsByCurrency)
                    .map(([curr, amt]) => `${amt.toLocaleString()} ${curr}`)
                    .join(' | ');

                // Check for duplicate transaction hashes
                const duplicateHashes = validateHopTransactionHashes(hop);
                const hasDuplicates = duplicateHashes.length > 0;

                hopDiv.innerHTML = `
                    <div class="hop-container" data-hop-id="${hop.hopNumber}" style="background: ${hopBgColor}; border-radius: 12px; margin-bottom: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.08); overflow: hidden;">
                        <div class="hop-header" style="background: ${isComplete ? '#27ae60' : hasDuplicates ? '#d32f2f' : '#e67e22'}; color: white; padding: ${isCollapsed ? '12px 20px' : '20px'}; cursor: pointer;"
                             onclick="toggleHopCollapse(${hop.hopNumber})">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div style="display: flex; align-items: center; gap: 15px;">
                                    <span style="font-size: 24px; transform: rotate(${isCollapsed ? '0' : '90'}deg); transition: transform 0.3s;">
                                        ▶
                                    </span>
                                    <div>
                                        <h2 style="margin: 0; font-size: 1.5rem;">🎯 Hop ${hop.hopNumber}</h2>
                                        <div style="font-size: 14px; opacity: 0.9; margin-top: 5px;">
                                            ${isCollapsed ? `${tracesCount} traces, ${writeoffsCount} writeoffs | Total: ${totalAccountedDisplay || '0'}` : `ART at Hop Start: ${artStartDisplay}`}
                                        </div>
                                        ${hasDuplicates ? `
                                            <div style="background: rgba(255,255,255,0.2); padding: 8px 12px; border-radius: 6px; margin-top: 10px; border: 2px solid #fff;">
                                                <strong>⚠️ DUPLICATE TRANSACTION HASH DETECTED!</strong><br>
                                                ${duplicateHashes.map(dup =>
                                                    `<div style="margin-top: 5px; font-size: 12px;">
                                                        • TX ${dup.hash.substring(0, 10)}... used in: ${dup.notations.join(' & ')}
                                                    </div>`
                                                ).join('')}
                                                <div style="margin-top: 8px; font-size: 11px; font-style: italic;">
                                                    Multiple threads in the same transaction must be logged in a single entry
                                                </div>
                                            </div>
                                        ` : ''}
                                    </div>
                                </div>
                                <div style="text-align: right;">
                                    <div style="font-weight: bold; font-size: 16px;">
                                        ${hop.needsValidation ? 'Needs Validation' : isComplete ? '✅ Complete' : `⚠️ In Progress`}
                                    </div>
                                    ${hop.needsValidation ? `
                                        <div style="font-size: 12px; color: #e74c3c; margin-top: 5px;">
                                            Upstream changes detected
                                        </div>
                                    ` : ''}
                                    ${!isCollapsed && remainingDisplay.length > 0 && !isComplete ? 
                                        `<div style="font-size: 12px; opacity: 0.9; margin-top: 5px;">Remaining: ${remainingDisplay.join(' | ')}</div>` : ''
                                    }
                                    ${isComplete ? `
                                        <button class="btn btn-sm" onclick="reopenHop(${hop.hopNumber})" 
                                                style="margin-top: 8px; background: #3498db; padding: 6px 12px; font-size: 12px;">
                                            ✏️ Edit Hop
                                        </button>
                                    ` : ''}
                                    ${hop.needsValidation ? `
                                        <button class="btn btn-sm" onclick="validateAndUpdateHop(${hop.hopNumber})" 
                                                style="margin-top: 8px; background: #e74c3c; padding: 6px 12px; font-size: 12px;">
                                            Validate & Update
                                        </button>
                                    ` : ''}
                                </div>
                            </div>
                        </div>
                        
                        <div id="hopContent_${hop.hopNumber}" style="display: ${isCollapsed ? 'none' : 'block'}; padding: 20px;">
                            ${!isCollapsed ? `
                                <div style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 15px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                                        <div>
                                            <strong>ART at Hop Start:</strong><br>
                                            <span style="color: #2c3e50; font-size: 18px;">${artStartDisplay}</span>
                                        </div>
                                        <div>
                                            <strong>Current Available ART:</strong><br>
                                            <span style="color: #3498db; font-size: 18px;">${(() => {
                                                // Calculate current ART (accounts for writeoffs)
                                                const currentART = {};

                                                // Start with hop's starting ART
                                                Object.entries(artAtStart).forEach(([currency, amount]) => {
                                                    if (typeof amount === 'number') {
                                                        currentART[currency] = amount;
                                                    }
                                                });

                                                // Subtract writeoffs from current hop
                                                hop.entries.forEach(entry => {
                                                    if (entry.entryType === 'writeoff' && parseFloat(entry.amount) > 0) {
                                                        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                                                        if (currentART[currency]) {
                                                            currentART[currency] = roundAmount(currentART[currency] - parseFloat(entry.amount));
                                                        }
                                                    }
                                                });

                                                // Format for display
                                                const currentARTDisplay = Object.entries(currentART)
                                                    .filter(([currency, amount]) => amount > 0)
                                                    .map(([currency, amount]) => `${amount.toLocaleString()} ${currency}`)
                                                    .join(' | ');

                                                return currentARTDisplay || '0';
                                            })()}</span>
                                        </div>
                                        <div>
                                            <strong>Total Accounted:</strong><br>
                                            <span style="color: #27ae60; font-size: 18px;">${totalAccountedDisplay || '0'}</span>
                                        </div>
                                        ${remainingDisplay.length > 0 && !isComplete ? `
                                            <div>
                                                <strong>Remaining:</strong><br>
                                                <span style="color: #e67e22; font-size: 18px;">${remainingDisplay.join(' | ')}</span>
                                            </div>
                                        ` : ''}
                                    </div>
                                    
                                    <!-- Visual ART Progress Bars -->
                                    <div style="margin-top: 20px;">
                                        ${renderARTProgressBars(hop)}
                                    </div>
                                </div>
                            ` : ''}
                            
                            <div id="hopEntries_${hop.hopNumber}">
                                ${(hop.entries || []).map((entry, entryIndex) => renderCollapsibleHopEntry(entry, entryIndex, hop)).join('')}
                            </div>
                            
                            ${(!isComplete || (hop.entries && hop.entries.length > 0)) ? `
                                <div style="margin-top: 15px; padding: 20px; background: white; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                                    ${(() => {
                                        // First check if this hop has any entries at all
                                        const hasEntries = hop.entries && hop.entries.length > 0;

                                        // Get available threads for the CURRENT hop to see what needs to be traced
                                        const currentHopThreads = getAvailableSourcesForHop(hop.hopNumber, null);

                                        // Add total amount information to each thread
                                        // We'll keep ALL threads to check if they're rounding remainders
                                        const allThreadsInCurrentHop = currentHopThreads.filter(t => t.availableAmount > 0.000001).map(thread => {
                                            // Find the original thread to get total amount
                                            let totalAmount = thread.availableAmount;

                                            // Search in the threads database for the total
                                            for (const currency in investigation.availableThreads) {
                                                for (const threadKey in investigation.availableThreads[currency]) {
                                                    const dbThread = investigation.availableThreads[currency][threadKey];
                                                    if ((dbThread.notation === thread.threadId || dbThread.internalId === thread.internalId) && currency === thread.currency) {
                                                        totalAmount = dbThread.totalAmount || totalAmount;
                                                        break;
                                                    }
                                                }
                                            }

                                            return {
                                                ...thread,
                                                totalAmount: totalAmount
                                            };
                                        });

                                        // Separate actual unallocated threads from rounding remainders
                                        const unallocatedInCurrentHop = allThreadsInCurrentHop.filter(thread => {
                                            const remaining = thread.availableAmount;
                                            const original = thread.totalAmount || thread.availableAmount;
                                            const assigned = original - remaining;
                                            const percentAssigned = original > 0 ? (assigned / original) * 100 : 0;
                                            // Consider it a rounding remainder if >99% assigned and remainder is <1% of original
                                            const isRoundingRemainder = percentAssigned >= 99 && remaining < (original * 0.01);
                                            return !isRoundingRemainder && remaining > 0.01; // Only show actual unallocated amounts
                                        });

                                        // Check if ALL remaining amounts are just rounding remainders
                                        const onlyRoundingRemainders = allThreadsInCurrentHop.length > 0 && unallocatedInCurrentHop.length === 0;

                                        // Get available threads for the NEXT hop (created by this hop's entries)
                                        const nextHopNumber = hop.hopNumber + 1;
                                        const nextHopThreads = getAvailableSourcesForHop(nextHopNumber, null);
                                        const availableForNextHop = nextHopThreads.filter(t => t.availableAmount > 0);

                                        // Check if any threads are from swaps in the current hop
                                        const hasSwapOutputs = availableForNextHop.some(t => t.sourceType === 'swap_output' && t.hopLevel === hop.hopNumber);

                                        // Show threads available for CURRENT hop that still need assignment
                                        // BUT NOT if they're all just rounding remainders
                                        if (unallocatedInCurrentHop.length > 0 || (onlyRoundingRemainders && allThreadsInCurrentHop.length > 0)) {
                                            return `
                                                <div style="background: #fff3e0; border-left: 4px solid #ff9800; padding: 15px; margin-bottom: 20px; border-radius: 4px;">
                                                    <h4 style="margin: 0 0 10px 0; color: #e65100;">${onlyRoundingRemainders ? '✅ Hop Complete (Rounding Remainders Only)' : '📋 Available Threads for Hop ' + hop.hopNumber + ':'}</h4>
                                                    <div style="display: grid; gap: 8px;">
                                                        ${(onlyRoundingRemainders ? allThreadsInCurrentHop : unallocatedInCurrentHop).map(thread => {
                                                            // Show the remaining amount for this thread
                                                            const remaining = thread.availableAmount;
                                                            const original = thread.totalAmount || thread.availableAmount;
                                                            const assigned = original - remaining;
                                                            let percentAssigned = original > 0 ? Math.round((assigned / original) * 100) : 0;
                                                            const isRoundingRemainder = percentAssigned >= 99 && remaining < (original * 0.01);

                                                            return `
                                                                <div style="padding: 8px; background: ${isRoundingRemainder ? '#fff3e0' : 'white'}; border-radius: 4px;">
                                                                    <div style="display: flex; justify-content: space-between; align-items: center;">
                                                                        <span style="font-weight: bold; color: #2c3e50;">
                                                                            ${thread.threadId}
                                                                            ${isRoundingRemainder ? '<span style="color: #ff6b6b; font-size: 10px; margin-left: 5px;">(rounding)</span>' : ''}
                                                                        </span>
                                                                        <span style="color: ${isRoundingRemainder ? '#ff6b6b' : '#e67e22'}; font-weight: 600;">
                                                                            ${remaining.toLocaleString()} ${thread.currency}
                                                                        </span>
                                                                    </div>
                                                                    ${assigned > 0 ? `
                                                                        <div style="margin-top: 5px;">
                                                                            <div style="background: #f0f0f0; height: 6px; border-radius: 3px; overflow: hidden;">
                                                                                <div style="background: ${isRoundingRemainder ? '#4caf50' : '#ff9800'}; height: 100%; width: ${percentAssigned}%;"></div>
                                                                            </div>
                                                                            <small style="color: #999; font-size: 11px;">
                                                                                ${percentAssigned}% assigned
                                                                                ${isRoundingRemainder ? '(~' + ((remaining/original * 100).toFixed(2)) + '% remainder)' : ''}
                                                                            </small>
                                                                        </div>
                                                                    ` : ''}
                                                                </div>
                                                            `;
                                                        }).join('')}
                                                    </div>
                                                    <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #ffcc80;">
                                                        ${(() => {
                                                            // Check if all remaining threads are rounding remainders
                                                            const allRounding = unallocatedInCurrentHop.every(thread => {
                                                                const remaining = thread.availableAmount;
                                                                const original = thread.totalAmount || thread.availableAmount;
                                                                const assigned = original - remaining;
                                                                const percentAssigned = original > 0 ? Math.round((assigned / original) * 100) : 0;
                                                                return percentAssigned >= 99 && remaining < (original * 0.01);
                                                            });

                                                            if (allRounding && unallocatedInCurrentHop.length > 0) {
                                                                const totalRounding = unallocatedInCurrentHop.reduce((sum, t) => sum + t.availableAmount, 0);
                                                                const currency = unallocatedInCurrentHop[0].currency;
                                                                return `
                                                                    <div style="background: #e8f5e9; padding: 10px; border-radius: 4px; margin-bottom: 10px;">
                                                                        <div style="display: flex; justify-content: space-between; align-items: center;">
                                                                            <div>
                                                                                <strong style="color: #2e7d32;">✅ Hop Complete (Rounding Remainders Only)</strong>
                                                                                <div style="margin-top: 5px; font-size: 12px; color: #1b5e20;">
                                                                                    Total rounding remainder: ${totalRounding.toFixed(6)} ${currency}
                                                                                    <br>From ${unallocatedInCurrentHop.length} threads (< 1% each)
                                                                                </div>
                                                                            </div>
                                                                            <button onclick="writeOffAllRoundingRemainders(${hop.hopNumber})"
                                                                                    class="btn btn-warning"
                                                                                    style="font-size: 12px; padding: 5px 10px;">
                                                                                📝 Write Off All Rounding
                                                                            </button>
                                                                        </div>
                                                                    </div>
                                                                `;
                                                            } else if (unallocatedInCurrentHop.length > 0) {
                                                                return '<small style="color: #bf6000;">💡 Continue adding entries to trace these funds</small>';
                                                            } else {
                                                                return '<small style="color: #4caf50;">✅ All threads fully allocated</small>';
                                                            }
                                                        })()}
                                                    </div>
                                                </div>
                                            `;
                                        }
                                        // All threads fully traced - ready to finalize
                                        else {
                                            // Check if we actually have entries and they're all accounted for
                                            const allAccountedFor = hasEntries &&
                                                                   unallocatedInCurrentHop.length === 0 &&
                                                                   availableForNextHop.length === 0;

                                            if (allAccountedFor) {
                                                return `
                                                    <div style="background: #d4edda; border-left: 4px solid #27ae60; padding: 15px; margin-bottom: 20px; border-radius: 4px;">
                                                        <h4 style="margin: 0; color: #1e7e34;">✅ All threads fully traced!</h4>
                                                        <p style="margin: 10px 0 0 0; color: #155724;">All source funds have been accounted for. You can finalize this hop.</p>
                                                    </div>
                                                `;
                                            } else if (!hasEntries) {
                                                // No entries yet but also no available threads (shouldn't normally happen)
                                                return `
                                                    <div style="background: #f8d7da; border-left: 4px solid #dc3545; padding: 15px; margin-bottom: 20px; border-radius: 4px;">
                                                        <h4 style="margin: 0; color: #721c24;">⚠️ No threads available</h4>
                                                        <p style="margin: 10px 0 0 0; color: #721c24;">Check that previous hops have been completed correctly.</p>
                                                    </div>
                                                `;
                                            } else {
                                                // Has entries but threads still need allocation
                                                return `
                                                    <div style="background: #fff3e0; border-left: 4px solid #ff9800; padding: 15px; margin-bottom: 20px; border-radius: 4px;">
                                                        <h4 style="margin: 0; color: #e65100;">⚠️ Threads need allocation</h4>
                                                        <p style="margin: 10px 0 0 0; color: #856404;">Continue adding entries to account for all funds.</p>
                                                    </div>
                                                `;
                                            }
                                        }
                                    })()}

                                    ${!hop.completed ? `
                                        <h4 style="margin-bottom: 15px; color: #2c3e50;">Next Action:</h4>
                                        <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                                            <button class="btn btn-primary" onclick="showAddEntryWizard(${hop.hopNumber})"
                                                    style="padding: 12px 24px; background: #3498db; color: white; font-size: 16px;">
                                                + Add Entry
                                            </button>
                                            <button class="btn btn-secondary" onclick="viewAvailableThreads(${hop.hopNumber})"
                                                    style="padding: 12px 24px; font-size: 16px;">
                                                📊 View Available Threads
                                            </button>
                                            <button class="btn btn-confirm" onclick="finalizeHop(${hop.hopNumber})"
                                                    style="margin-left: auto; background: #27ae60; padding: 10px 30px;">
                                                Finalize Hop ${hop.hopNumber}
                                            </button>
                                        </div>
                                    ` : `
                                        <div style="background: #d4edda; border: 2px solid #27ae60; border-radius: 8px; padding: 20px; margin-top: 20px;">
                                            <h4 style="margin: 0 0 10px 0; color: #1e7e34;">✅ Hop ${hop.hopNumber} Completed</h4>
                                            <p style="margin: 0 0 15px 0; color: #155724;">This hop has been finalized. To make changes, you must reopen it for editing.</p>
                                            <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                                                <button class="btn btn-warning" onclick="reopenHopForEditing(${hop.hopNumber})"
                                                        style="padding: 10px 20px; background: #ff9800; color: white;">
                                                    🔓 Reopen for Editing
                                                </button>
                                                <button class="btn btn-secondary" onclick="viewAvailableThreads(${hop.hopNumber})"
                                                        style="padding: 10px 20px;">
                                                    📊 View Thread Summary
                                                </button>
                                            </div>
                                        </div>
                                    `}
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
                container.appendChild(hopDiv);
            });
            
            // Update add hop button and complete investigation section visibility
            updateInvestigationCompletionStatus();

            // Add manual completion check button if all hops are complete but UI doesn't show
            const allComplete = investigation.hops.every(h => h.completed);
            const hasHops = investigation.hops.length > 0;
            const completeSection = document.getElementById('completeInvestigationSection');

            if (allComplete && hasHops && (!completeSection || completeSection.style.display === 'none')) {
                // All hops marked complete but completion UI not showing
                // Add a manual trigger button
                const manualCompleteBtn = document.createElement('div');
                manualCompleteBtn.style.cssText = 'background: #27ae60; color: white; padding: 20px; margin: 20px; border-radius: 8px; text-align: center;';
                manualCompleteBtn.innerHTML = `
                    <h3 style="margin: 0 0 10px 0;">✅ All Hops Complete</h3>
                    <p style="margin: 0 0 15px 0;">All ${investigation.hops.length} hops have been completed. Click below to proceed to reporting.</p>
                    <button class="btn" style="background: white; color: #27ae60; padding: 12px 30px; font-size: 16px; font-weight: bold;"
                            onclick="showEnhancedCompletionModal()">
                        📄 Proceed to Reports & Visualization
                    </button>
                `;
                container.appendChild(manualCompleteBtn);
            }
        }

// Get starting ART for a specific hop
function getStartingARTForHop(hopNumber) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    if (!hop) return {};
    
    // Use the stored ART at start for this hop
    return hop.artAtStartByCurrency || {};
}

// Render visual ART progress bars
function renderARTProgressBars(hop) {
    // Get ART data for this hop
    const hopIndex = investigation.hops.findIndex(h => h.hopNumber === hop.hopNumber);
    const startingART = getStartingARTForHop(hop.hopNumber);

    // Calculate amounts by category for each currency
    const breakdown = {};

    // Initialize with starting ART
    Object.entries(startingART).forEach(([currency, amount]) => {
        if (amount > 0) {
            breakdown[currency] = {
                total: amount,
                traced: 0,
                writeoff: 0,
                coldStorage: 0,
                vasp: 0,
                swapped: 0,
                remaining: amount
            };
        }
    });

    // Process entries
    if (hop.entries) {
        hop.entries.forEach(entry => {
            const amount = parseFloat(entry.amount) || 0;

            if (entry.entryType === 'swap' && entry.swapDetails) {
                // Handle swap entries
                const inputCurrency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                const outputCurrency = entry.outputCurrency;
                const outputAmount = parseFloat(entry.outputAmount) || 0;

                // Mark input currency as swapped
                if (breakdown[inputCurrency]) {
                    breakdown[inputCurrency].swapped += amount;
                    breakdown[inputCurrency].remaining -= amount;
                }

                // Add output currency if it doesn't exist
                if (!breakdown[outputCurrency]) {
                    breakdown[outputCurrency] = {
                        total: 0,
                        traced: 0,
                        writeoff: 0,
                        coldStorage: 0,
                        vasp: 0,
                        swapped: 0,
                        remaining: 0,
                        isSwapOutput: true
                    };
                }

                // Add the swapped amount to the new currency
                breakdown[outputCurrency].total += outputAmount;
                breakdown[outputCurrency].remaining += outputAmount;

            } else if (amount > 0 && entry.currency) {
                const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;

                if (!breakdown[currency]) {
                    breakdown[currency] = {
                        total: 0,
                        traced: 0,
                        writeoff: 0,
                        coldStorage: 0,
                        vasp: 0,
                        swapped: 0,
                        remaining: 0
                    };
                }

                switch (entry.entryType) {
                    case 'trace':
                        // Check if this is a bridge with output
                        if (entry.isBridge && entry.bridgeDetails) {
                            // Mark input currency as bridged
                            breakdown[currency].swapped += amount; // Treat bridges like swaps
                            breakdown[currency].remaining -= amount;

                            // Add output currency
                            const outputCurrency = entry.bridgeDetails.destinationAsset;
                            const outputAmount = entry.bridgeDetails.destinationAmount || 0;

                            if (outputCurrency && outputAmount > 0) {
                                if (!breakdown[outputCurrency]) {
                                    breakdown[outputCurrency] = {
                                        total: 0,
                                        traced: 0,
                                        writeoff: 0,
                                        coldStorage: 0,
                                        vasp: 0,
                                        swapped: 0,
                                        remaining: 0,
                                        isBridgeOutput: true
                                    };
                                }
                                breakdown[outputCurrency].total += outputAmount;
                                breakdown[outputCurrency].remaining += outputAmount;
                            }
                        }
                        // Check if this trace goes to a VASP/exchange (purple wallet) without bridge
                        else if ((entry.toWalletType === 'purple' || entry.isTerminalWallet) && !entry.isBridge) {
                            breakdown[currency].vasp += amount;
                            breakdown[currency].remaining -= amount;
                        } else if (!entry.isBridge) {
                            breakdown[currency].traced += amount;
                            breakdown[currency].remaining -= amount;
                        }
                        break;
                    case 'writeoff':
                        breakdown[currency].writeoff += amount;
                        breakdown[currency].remaining -= amount;
                        break;
                    case 'cold_storage':
                        breakdown[currency].coldStorage += amount;
                        breakdown[currency].remaining -= amount;
                        break;
                }
            }
        });
    }
    
    // Generate progress bars
    let html = '';

    Object.entries(breakdown).forEach(([currency, data]) => {
        const total = data.total;
        if (total <= 0) return;

        // Calculate percentages
        const tracedPct = (data.traced / total) * 100;
        const writeoffPct = (data.writeoff / total) * 100;
        const coldStoragePct = (data.coldStorage / total) * 100;
        const vaspPct = (data.vasp / total) * 100;
        const swappedPct = (data.swapped / total) * 100;
        const remainingPct = Math.max(0, (data.remaining / total) * 100);
        
        html += `
            <div style="margin-bottom: 15px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                    <strong>${currency} ${data.isSwapOutput ? '(from swap)' : data.isBridgeOutput ? '(from bridge)' : ''}</strong>
                    <span style="font-size: 12px; color: #666;">
                        ${data.total.toLocaleString()} total
                        ${data.swapped > 0 ? ` (${data.swapped.toLocaleString()} converted to other currency)` : ''}
                    </span>
                </div>
                
                <!-- Progress Bar -->
                <div style="position: relative; height: 30px; background: #f5f5f5; border-radius: 15px; overflow: hidden; box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);">
                    <!-- Traced (Green) -->
                    ${tracedPct > 0 ? `
                        <div style="position: absolute; left: 0; top: 0; height: 100%; width: ${tracedPct}%; background: #27ae60; transition: width 0.3s ease;"
                             title="Traced: ${data.traced.toLocaleString()} ${currency} (${tracedPct.toFixed(1)}%)">
                        </div>
                    ` : ''}
                    
                    <!-- VASP/Exchange (Purple) -->
                    ${vaspPct > 0 ? `
                        <div style="position: absolute; left: ${tracedPct}%; top: 0; height: 100%; width: ${vaspPct}%; background: #9b59b6; transition: all 0.3s ease;"
                             title="Sent to Exchange/VASP: ${data.vasp.toLocaleString()} ${currency} (${vaspPct.toFixed(1)}%)">
                        </div>
                    ` : ''}

                    <!-- Swapped (Brown) -->
                    ${swappedPct > 0 ? `
                        <div style="position: absolute; left: ${tracedPct + vaspPct}%; top: 0; height: 100%; width: ${swappedPct}%; background: #8B4513; transition: all 0.3s ease;"
                             title="Swapped to another currency: ${data.swapped.toLocaleString()} ${currency} (${swappedPct.toFixed(1)}%)">
                        </div>
                    ` : ''}
                    
                    <!-- Write-off (Gray) -->
                    ${writeoffPct > 0 ? `
                        <div style="position: absolute; left: ${tracedPct + vaspPct + swappedPct}%; top: 0; height: 100%; width: ${writeoffPct}%; background: #95a5a6; transition: all 0.3s ease;"
                             title="Written off: ${data.writeoff.toLocaleString()} ${currency} (${writeoffPct.toFixed(1)}%)">
                        </div>
                    ` : ''}

                    <!-- Cold Storage (Blue) -->
                    ${coldStoragePct > 0 ? `
                        <div style="position: absolute; left: ${tracedPct + vaspPct + swappedPct + writeoffPct}%; top: 0; height: 100%; width: ${coldStoragePct}%; background: #3498db; transition: all 0.3s ease;"
                             title="Cold Storage: ${data.coldStorage.toLocaleString()} ${currency} (${coldStoragePct.toFixed(1)}%)">
                        </div>
                    ` : ''}

                    <!-- Remaining (Red) -->
                    ${remainingPct > 0.1 ? `
                        <div style="position: absolute; left: ${tracedPct + vaspPct + swappedPct + writeoffPct + coldStoragePct}%; top: 0; height: 100%; width: ${remainingPct}%; background: #e74c3c; transition: all 0.3s ease;"
                             title="Remaining to account: ${data.remaining.toLocaleString()} ${currency} (${remainingPct.toFixed(1)}%)">
                        </div>
                    ` : ''}
                    
                    <!-- Percentage labels -->
                    <div style="position: absolute; width: 100%; height: 100%; display: flex; align-items: center; padding: 0 10px; pointer-events: none;">
                        ${tracedPct > 15 ? `
                            <span style="color: white; font-size: 11px; font-weight: bold; text-shadow: 1px 1px 2px rgba(0,0,0,0.3);">
                                ${tracedPct.toFixed(0)}%
                            </span>
                        ` : ''}
                    </div>
                </div>
                
                <!-- Legend -->
                <div style="display: flex; gap: 15px; margin-top: 8px; font-size: 11px; flex-wrap: wrap;">
                    ${data.traced > 0 ? `
                        <span style="display: flex; align-items: center; gap: 5px;">
                            <span style="width: 12px; height: 12px; background: #27ae60; border-radius: 2px;"></span>
                            Traced: ${data.traced.toLocaleString()}
                        </span>
                    ` : ''}
                    ${data.vasp > 0 ? `
                        <span style="display: flex; align-items: center; gap: 5px;">
                            <span style="width: 12px; height: 12px; background: #9b59b6; border-radius: 2px;"></span>
                            Exchange/VASP: ${data.vasp.toLocaleString()}
                        </span>
                    ` : ''}
                    ${data.swapped > 0 ? `
                        <span style="display: flex; align-items: center; gap: 5px;">
                            <span style="width: 12px; height: 12px; background: #8B4513; border-radius: 2px;"></span>
                            Swapped: ${data.swapped.toLocaleString()}
                        </span>
                    ` : ''}
                    ${data.writeoff > 0 ? `
                        <span style="display: flex; align-items: center; gap: 5px;">
                            <span style="width: 12px; height: 12px; background: #95a5a6; border-radius: 2px;"></span>
                            Written off: ${data.writeoff.toLocaleString()}
                        </span>
                    ` : ''}
                    ${data.coldStorage > 0 ? `
                        <span style="display: flex; align-items: center; gap: 5px;">
                            <span style="width: 12px; height: 12px; background: #3498db; border-radius: 2px;"></span>
                            Cold Storage: ${data.coldStorage.toLocaleString()}
                        </span>
                    ` : ''}
                    ${data.remaining > 0 ? `
                        <span style="display: flex; align-items: center; gap: 5px;">
                            <span style="width: 12px; height: 12px; background: #e74c3c; border-radius: 2px;"></span>
                            Remaining: ${data.remaining.toLocaleString()}
                        </span>
                    ` : ''}
                </div>
            </div>
        `;
    });
    
    return html || '<div style="text-align: center; color: #999;">No ART data to display</div>';
}

// Show modal for ART completion options
function showARTCompletionModal(hop, validation) {
    const modalHTML = `
        <div id="artCompletionModal" class="modal" style="display: block;">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>⚠️ Complete ART Balance for Hop ${hop.hopNumber}</h2>
                    <p>All ART must be accounted for before starting the next hop</p>
                </div>
                
                <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 20px; margin: 20px 0;">
                    <h4 style="color: #856404; margin-bottom: 15px;">Unaccounted Amounts:</h4>
                    ${Object.entries(validation.remainingByCurrency).map(([currency, amount]) => 
                        amount > 0 ? `
                            <div style="margin-bottom: 15px; padding: 15px; background: white; border-radius: 6px; border-left: 4px solid #ffc107;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                    <strong>${currency}: ${amount.toLocaleString()} remaining</strong>
                                </div>
                                <div style="display: flex; gap: 10px;">
                                    <button class="btn btn-danger" onclick="createMaxWriteoff(${hop.hopNumber}, '${currency}', ${amount})">
                                        📝 Write Off All ${amount.toLocaleString()} ${currency}
                                    </button>
                                    <button class="btn" style="background: #3498db;" onclick="createColdStorage(${hop.hopNumber}, '${currency}', ${amount})">
                                        Mark as Cold Storage
                                    </button>
                                </div>
                                <div style="margin-top: 10px; font-size: 12px; color: #666;">
                                    Or manually add trace/write-off entries to account for this amount
                                </div>
                            </div>
                        ` : ''
                    ).join('')}
                </div>
                
                <div style="text-align: center; margin-top: 25px;">
                    <button class="btn btn-secondary" onclick="closeARTCompletionModal()">
                        Cancel - Return to Fix Hop ${hop.hopNumber}
                    </button>
                </div>
            </div>
        </div>
    `;
    
    // Create centered modal
    createCenteredModal('artCompletionModal', modalHTML);
}

// Create maximum write-off entry to balance ART
function createMaxWriteoff(hopNumber, currency, amount) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    if (!hop) return;
    
    const writeoffEntry = {
        id: hop.entries.length + 1,
        hopNumber: hopNumber,
        hopNumber: hop.hopNumber,
        entryType: 'writeoff',
        notation: '',
        amount: amount.toString(),
        currency: currency,
        customCurrency: currency === 'CUSTOM' ? currency : '',
        category: 'operational',
        justification: `ART balancing write-off: ${amount.toLocaleString()} ${currency} to complete hop accounting`,
        // Enhanced fields
        sourceChain: [],
        displayNotation: '',
        summaryNotation: '',
        victimNumbers: '',
        transactionNumbers: '',
        availableSourceAmount: 0,
        sourceThreadId: '',
        sourceThreadData: null,
        assignmentPercentage: 0,
        generatedNotation: '',
        isConvergence: false,
        convergenceData: null,
        fromWallet: '',
        fromWalletType: '',
        fromWalletId: '',
        toWallet: '',
        toWalletType: '',
        toWalletId: '',
        txHash: '',
        timestamp: '',
        timezone: 'UTC',
        notes: `Auto-generated to balance ART for hop completion`
    };
    
    hop.entries.push(writeoffEntry);
    
    // Sort entries chronologically
    sortHopEntriesChronologically(hop);
    
    closeARTCompletionModal();
    renderHops();
    saveToStorage();
    
    alert(` Write-off created for ${amount.toLocaleString()} ${currency}. Hop ${hop.hopNumber} is now balanced.`);
}

// Create cold storage entry to account for funds
function createColdStorage(hopNumber, currency, amount) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    if (!hop) return;
    
    // Find the most recent trace entry with the same currency to get wallet info
    let sourceWallet = '';
    let sourceWalletType = '';
    
    for (let i = hop.entries.length - 1; i >= 0; i--) {
        const entry = hop.entries[i];
        const entryCurrency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
        if (entry.entryType === 'trace' && entryCurrency === currency && entry.toWallet) {
            sourceWallet = entry.toWallet;
            sourceWalletType = entry.toWalletType || 'black';
            break;
        }
    }
    
    const coldStorageEntry = {
        id: hop.entries.length + 1,
        hopNumber: hopNumber,
        hopNumber: hop.hopNumber,
        entryType: 'cold_storage',
        notation: '',
        amount: amount.toString(),
        currency: currency,
        customCurrency: currency === 'CUSTOM' ? currency : '',
        category: '',
        justification: '',
        // Enhanced fields
        sourceChain: [],
        displayNotation: '',
        summaryNotation: '',
        victimNumbers: '',
        transactionNumbers: '',
        availableSourceAmount: 0,
        sourceThreadId: '',
        sourceThreadData: null,
        assignmentPercentage: 0,
        generatedNotation: '',
        isConvergence: false,
        convergenceData: null,
        fromWallet: sourceWallet,
        fromWalletType: sourceWalletType,
        fromWalletId: '',
        toWallet: sourceWallet, // Same wallet, marking as cold storage
        toWalletType: 'blue', // BLUE = Cold Storage
        toWalletId: '',
        txHash: '',
        timestamp: '',
        timezone: 'UTC',
        notes: `Auto-generated cold storage classification: ${amount.toLocaleString()} ${currency} remains in this wallet`
    };
    
    hop.entries.push(coldStorageEntry);
    
    // Sort entries chronologically
    sortHopEntriesChronologically(hop);
    
    closeARTCompletionModal();
    renderHops();
    saveToStorage();
    
    alert(`Cold storage entry created for ${amount.toLocaleString()} ${currency}. Funds marked as BLUE (cold storage) in current wallet.`);
}

// Close ART completion modal
function closeARTCompletionModal() {
    const modal = document.getElementById('artCompletionModal');
    if (modal) {
        modal.remove();
    }
}
// Main function to finalize a hop with all validation and options
// Analyze which wallets have untraced balances
function analyzeUntracedBalances(hop) {
    const walletBalances = {};
    
    // Calculate incoming amounts to each wallet in this hop
    hop.entries.forEach(entry => {
        if (entry.entryType === 'trace' && entry.toWallet && parseFloat(entry.amount) > 0) {
            const wallet = entry.toWallet;
            const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
            const key = `${wallet}|${currency}`;
            
            if (!walletBalances[key]) {
                walletBalances[key] = {
                    wallet: wallet,
                    walletType: entry.toWalletType,
                    currency: currency,
                    incoming: 0,
                    outgoing: 0,
                    balance: 0
                };
            }
            walletBalances[key].incoming += parseFloat(entry.amount);
        }
    });
    
    // Check if these wallets have outgoing transactions in the next hop
    const nextHopNumber = hop.hopNumber + 1;
    const nextHop = investigation.hops.find(h => h.hopNumber === nextHopNumber);
    
    if (nextHop) {
        nextHop.entries.forEach(entry => {
            if (entry.sourceThreadId) {
                // Parse the source thread to find the originating wallet
                const sourceMatch = entry.sourceThreadId.match(/H(\d+)$/);
                if (sourceMatch && parseInt(sourceMatch[1]) === hop.hopNumber) {
                    // This entry sources from the current hop
                    // Find which wallet it came from by checking the current hop's entries
                    hop.entries.forEach(hopEntry => {
                        if (hopEntry.notation === entry.sourceThreadId.replace(/-H\d+$/, '') && hopEntry.toWallet) {
                            const wallet = hopEntry.toWallet;
                            const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                            const key = `${wallet}|${currency}`;
                            
                            if (walletBalances[key]) {
                                walletBalances[key].outgoing += parseFloat(entry.amount);
                            }
                        }
                    });
                }
            }
        });
    }
    
    // Calculate final balances and identify wallets with remaining funds
    const walletsWithFunds = [];
    Object.values(walletBalances).forEach(wb => {
        wb.balance = wb.incoming - wb.outgoing;
        if (wb.balance > 0.01) {  // Only consider significant balances
            walletsWithFunds.push({
                wallet: wb.wallet,
                walletType: wb.walletType,
                currency: wb.currency,
                remainingBalance: wb.balance,
                suggestColdStorage: wb.walletType !== 'blue' && wb.walletType !== 'purple' && wb.walletType !== 'gray'
            });
        }
    });
    
    return walletsWithFunds;
}

// New function to show comprehensive hop finalization summary
function showHopFinalizationSummary(hop, remainingByCurrency, walletsWithRemainingFunds) {
    // Check for unallocated bridge/swap outputs FIRST
    const availableThreadsForNextHop = getAvailableSourcesForHop(hop.hopNumber + 1, null);
    const unallocatedBridgeOutputs = [];
    const unallocatedSwapOutputs = [];

    availableThreadsForNextHop.forEach(thread => {
        // Check if this is a same-hop conversion output that needs allocation
        if (thread.hopLevel === hop.hopNumber && thread.availableAmount > 0) {
            if (thread.sourceType === 'bridge_output') {
                unallocatedBridgeOutputs.push(thread);
            } else if (thread.sourceType === 'swap_output') {
                unallocatedSwapOutputs.push(thread);
            }
        }
    });

    // If there are unallocated bridge/swap outputs, show warning and prevent finalization
    if (unallocatedBridgeOutputs.length > 0 || unallocatedSwapOutputs.length > 0) {
        const modalHTML = `
            <div id="hopFinalizationModal" class="modal" style="display: block;">
                <div class="modal-content" style="max-width: 800px;">
                    <div class="modal-header" style="background: #f8d7da; border-bottom: 2px solid #f5c6cb;">
                        <h2>❌ Cannot Finalize Hop ${hop.hopNumber}</h2>
                        <p style="color: #721c24;">Unallocated bridge/swap outputs must be traced first</p>
                    </div>

                    <div style="padding: 20px;">
                        ${unallocatedBridgeOutputs.length > 0 ? `
                            <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                                <h3 style="margin-top: 0; color: #856404;">🌉 Unallocated Bridge Outputs (${unallocatedBridgeOutputs.length})</h3>
                                <p>These bridge outputs were created when you logged bridge destinations. They must be allocated before finalizing:</p>
                                <ul style="margin: 10px 0;">
                                    ${unallocatedBridgeOutputs.map(thread => `
                                        <li><strong>${thread.threadId}</strong>: ${thread.availableAmount.toLocaleString()} ${thread.currency}
                                            <small>(from ${thread.sourceWallet ? thread.sourceWallet.substring(0, 16) + '...' : 'bridge'})</small></li>
                                    `).join('')}
                                </ul>
                            </div>
                        ` : ''}

                        ${unallocatedSwapOutputs.length > 0 ? `
                            <div style="background: #e3f2fd; border: 2px solid #2196f3; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                                <h3 style="margin-top: 0; color: #0d47a1;">🔄 Unallocated Swap Outputs (${unallocatedSwapOutputs.length})</h3>
                                <p>These swap outputs need to be traced:</p>
                                <ul style="margin: 10px 0;">
                                    ${unallocatedSwapOutputs.map(thread => `
                                        <li><strong>${thread.threadId}</strong>: ${thread.availableAmount.toLocaleString()} ${thread.currency}</li>
                                    `).join('')}
                                </ul>
                            </div>
                        ` : ''}

                        <div style="background: #d4edda; border: 2px solid #c3e6cb; border-radius: 8px; padding: 15px;">
                            <h4 style="margin-top: 0; color: #155724;">What to do:</h4>
                            <ol style="margin: 10px 0; padding-left: 20px;">
                                <li>Click "Add Entry" to create trace entries for each unallocated output</li>
                                <li>Select the bridge/swap output threads as sources</li>
                                <li>Enter the transaction details for where these funds went</li>
                                <li>Once all outputs are allocated, you can finalize the hop</li>
                            </ol>
                        </div>

                        <div style="margin-top: 20px; text-align: center;">
                            <button class="btn btn-primary" onclick="closeFinalizationModal(); scrollToHop(${hop.hopNumber});">
                                Return to Hop ${hop.hopNumber}
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        `;

        document.body.insertAdjacentHTML('beforeend', modalHTML);
        return; // Don't show the normal finalization modal
    }

    // Calculate threads created in this hop
    const threadsCreated = [];
    let allThreadsTerminal = true;
    hop.entries.forEach(entry => {
        if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0 && entry.notation) {
            const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
            // Check if terminal - wallet type is stored as lowercase
            // Note: Bridge outputs are NOT terminal even though they were converted from purple wallets
            const isTerminal = (entry.toWalletType === 'purple' || entry.toWalletType === 'PURPLE' || entry.isTerminal === true) && !entry.isBridge;
            if (!isTerminal) {
                allThreadsTerminal = false;
            }
            threadsCreated.push({
                notation: entry.notation,
                amount: parseFloat(entry.amount),
                currency: currency,
                toWallet: entry.toWallet,
                toWalletType: entry.toWalletType,
                isTerminal: isTerminal,
                isBridge: entry.isBridge
            });
        }
    });
    
    // Calculate balance status
    const isBalanced = Object.keys(remainingByCurrency).length === 0;
    const balanceStatusHTML = isBalanced ? `
        <div style="background: #d4edda; border: 2px solid #27ae60; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
            <h3 style="color: #155724; margin-top: 0;">✅ Hop is Balanced!</h3>
            <p style="color: #155724; margin-bottom: 0;">All Adjusted Root Total (ART) has been accounted for. You can proceed to the next hop.</p>
        </div>
    ` : `
        <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
            <h3 style="color: #856404; margin-top: 0;">⚠️ Hop Has Unaccounted Amounts</h3>
            <p style="color: #856404;">The following amounts need to be accounted for before proceeding:</p>
            <ul style="margin-bottom: 0;">
                ${Object.entries(remainingByCurrency).map(([currency, amount]) => 
                    `<li><strong>${amount.toLocaleString()} ${currency}</strong> remaining</li>`
                ).join('')}
            </ul>
        </div>
    `;
    
    // Thread summary
    const threadSummaryHTML = threadsCreated.length > 0 ? `
        <div style="background: #e3f2fd; border: 2px solid #2196f3; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
            <h3 style="color: #0d47a1; margin-top: 0;">Threads Created in Hop ${hop.hopNumber}</h3>
            <p style="color: #0d47a1; margin-bottom: 15px;">${allThreadsTerminal ? 'All threads have reached terminal wallets:' : `These threads will be available for tracing in Hop ${hop.hopNumber + 1}:`}</p>
            <div style="max-height: 200px; overflow-y: auto;">
                ${threadsCreated.map(thread => `
                    <div style="background: white; padding: 10px; margin-bottom: 10px; border-radius: 4px; border-left: 4px solid #2196f3;">
                        <strong>${thread.notation}</strong> - ${thread.amount.toLocaleString()} ${thread.currency}
                        <br><span style="font-size: 12px; color: #666;">To: ${thread.toWallet.substring(0, 16)}... (${thread.isTerminal ? '🟪 TERMINAL - ' : ''}${walletTypes[thread.toWalletType] || thread.toWalletType})</span>
                    </div>
                `).join('')}
            </div>
        </div>
    ` : '';
    
    const modalHTML = `
        <div id="hopFinalizationModal" class="modal" style="display: block;">
            <div class="modal-content" style="max-width: 800px; max-height: 90vh; overflow-y: auto;">
                <div class="modal-header">
                    <h2>Finalize Hop ${hop.hopNumber}</h2>
                    <p>Review hop summary and balance any remaining amounts</p>
                </div>
                
                ${balanceStatusHTML}
                ${threadSummaryHTML}
                
                ${!isBalanced ? `
                    <div style="margin-bottom: 20px;">
                        <h3>Balance Remaining Amounts</h3>
                        <p style="color: #666; margin-bottom: 15px;">Choose how to account for the remaining amounts. These options close out funds without creating new threads:</p>
                        
                        ${Object.entries(remainingByCurrency).map(([currency, amount]) => `
                            <div style="background: white; border: 2px solid #ddd; border-radius: 8px; padding: 20px; margin-bottom: 15px;">
                                <h4 style="margin-top: 0;">${amount.toLocaleString()} ${currency} Remaining</h4>
                                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">
                                    <button class="btn btn-warning" onclick="writeOffAmount(${hop.hopNumber}, '${currency}', ${amount})">
                                        ❌ Write Off
                                    </button>
                                    <button class="btn btn-primary" onclick="markAsColdStorage(${hop.hopNumber}, '${currency}', ${amount})">
                                        ❄️ Cold Storage
                                    </button>
                                    <button class="btn btn-success" onclick="markAsVASPArrival(${hop.hopNumber}, '${currency}', ${amount})">
                                        VASP Arrival
                                    </button>
                                    <button class="btn btn-secondary" onclick="assignPartialAmount(${hop.hopNumber}, '${currency}', ${amount})">
                                        ✂️ Split Amount
                                    </button>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                ` : ''}
                
                <div style="margin-top: 30px; padding-top: 20px; border-top: 2px solid #e0e0e0; text-align: center;">
                    ${isBalanced ? `
                        <button class="btn btn-success btn-large" onclick="proceedWithHopFinalization(investigation.hops.find(h => h.hopNumber === ${hop.hopNumber}))">
                            ${allThreadsTerminal ? '🎯 Complete Trace' : `✅ Complete Hop ${hop.hopNumber}`}
                        </button>
                    ` : `
                        <p style="color: #666; margin-bottom: 10px;">Balance all remaining amounts to proceed</p>
                        <button class="btn btn-secondary" onclick="closeFinalizationModal()">
                            Cancel
                        </button>
                    `}
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHTML);
}

function closeFinalizationModal() {
    const modal = document.getElementById('hopFinalizationModal');
    if (modal) modal.remove();
}

function viewAvailableThreads(hopNumber) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    if (!hop) return;
    
    console.log('Viewing available threads for hop:', hop.hopNumber);
    console.log('Current hop entries:', hop.entries);
    
    const availableThreads = getAvailableSourcesForHop(hop.hopNumber, null);
    console.log('Available threads returned:', availableThreads);
    
    const modalHTML = `
        <div id="availableThreadsModal" class="modal" style="display: block; z-index: 9999;">
            <div class="modal-content" style="max-width: 800px; max-height: 90vh; overflow-y: auto;">
                <div class="modal-header">
                    <h2>📊 Available Threads for Hop ${hop.hopNumber}</h2>
                    <span class="close" onclick="document.getElementById('availableThreadsModal').remove()">&times;</span>
                </div>
                <div style="padding: 20px;">
                    ${availableThreads.length === 0 ? `
                        <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 20px; text-align: center;">
                            <p style="margin: 0; color: #856404;">No available threads for this hop.</p>
                            <small>Threads become available from previous hop entries that have been traced.</small>
                        </div>
                    ` : `
                        <div style="background: #e8f4f8; border: 1px solid #3498db; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                            <p style="margin: 0; color: #2c3e50;">
                                <strong>Available threads:</strong> These are the funds you can trace in this hop.
                                Each thread represents a transaction output from a previous hop that hasn't been fully assigned yet.
                            </p>
                        </div>
                        <table style="width: 100%; border-collapse: collapse;">
                            <thead>
                                <tr style="background: #f8f9fa; border-bottom: 2px solid #dee2e6;">
                                    <th style="padding: 12px; text-align: left;">Thread ID</th>
                                    <th style="padding: 12px; text-align: left;">Source</th>
                                    <th style="padding: 12px; text-align: left;">Date/Time</th>
                                    <th style="padding: 12px; text-align: right;">Available Amount</th>
                                    <th style="padding: 12px; text-align: left;">Currency</th>
                                    <th style="padding: 12px; text-align: left;">Status</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${availableThreads.map(thread => {
                                    const isFullyAssigned = thread.availableAmount === 0;
                                    return `
                                        <tr style="border-bottom: 1px solid #dee2e6;">
                                            <td style="padding: 10px; font-family: monospace;">${thread.threadId}</td>
                                            <td style="padding: 10px;">${thread.displayText}</td>
                                            <td style="padding: 10px; font-size: 13px;">
                                                ${thread.datetime ? 
                                                    formatDateTimeForReport(thread.datetime, thread.timezone) : 
                                                    '<span style="color: #999;">Not specified</span>'
                                                }
                                            </td>
                                            <td style="padding: 10px; text-align: right; font-weight: bold; color: ${isFullyAssigned ? '#dc3545' : '#28a745'};">
                                                ${thread.availableAmount.toLocaleString()}
                                            </td>
                                            <td style="padding: 10px;">${thread.currency}</td>
                                            <td style="padding: 10px;">
                                                ${isFullyAssigned ? 
                                                    '<span style="color: #dc3545;">✗ Fully Assigned</span>' : 
                                                    '<span style="color: #28a745;">✓ Available</span>'
                                                }
                                            </td>
                                        </tr>
                                    `;
                                }).join('')}
                            </tbody>
                        </table>
                        <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                            <h4 style="margin-bottom: 10px;">Summary by Currency:</h4>
                            ${Object.entries(availableThreads.reduce((acc, thread) => {
                                if (!acc[thread.currency]) acc[thread.currency] = 0;
                                acc[thread.currency] += thread.availableAmount;
                                return acc;
                            }, {})).map(([currency, total]) => `
                                <div style="margin: 5px 0;">
                                    <strong>${currency}:</strong> ${total.toLocaleString()} available
                                </div>
                            `).join('')}
                        </div>
                    `}
                    <div style="margin-top: 20px; text-align: center;">
                        <button class="btn btn-primary" onclick="document.getElementById('availableThreadsModal').remove()">Close</button>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHTML);
}

// Reopen a completed hop for editing
function reopenHopForEditing(hopNumber) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    if (!hop) {
        alert('Hop not found');
        return;
    }

    // Check if there are dependent hops
    const hasSubsequentHops = investigation.hops.some(h => h.hopNumber > hopNumber);

    if (hasSubsequentHops) {
        const confirmReopen = confirm(
            `⚠️ WARNING: Reopening Hop ${hopNumber} for Editing\n\n` +
            `This hop has subsequent hops that depend on it.\n\n` +
            `Reopening this hop may affect:\n` +
            `• Thread allocations in later hops\n` +
            `• Fund flow continuity\n` +
            `• Investigation integrity\n\n` +
            `Are you sure you want to reopen Hop ${hopNumber}?\n\n` +
            `Note: You may need to review and update subsequent hops after making changes.`
        );

        if (!confirmReopen) {
            return;
        }
    }

    // Save undo state
    saveUndoState(`Reopen Hop ${hopNumber} for editing`);

    // Mark hop as not completed
    hop.completed = false;
    hop.isCollapsed = false;
    window.hopCollapseState[hop.hopNumber] = false;

    // Log the action
    console.log(`Reopened Hop ${hopNumber} for editing`);

    // Re-render the hops
    renderHops();

    // Show success notification
    showNotification(`🔓 Hop ${hopNumber} has been reopened for editing`, 'info');

    // Scroll to the reopened hop
    setTimeout(() => {
        const hopElement = document.querySelector(`[data-hop="${hopNumber}"]`);
        if (hopElement) {
            hopElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
    }, 100);
}

function finalizeHop(hopNumber) {
    console.log(`🎯 Attempting to finalize Hop ${hopNumber}`);

    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    if (!hop) {
        console.error(`Hop ${hopNumber} not found in investigation`);
        alert('Hop not found');
        return;
    }

    console.log(`Found hop:`, hop);

    // Check if hop is already completed
    if (hop.completed) {
        console.log(`Hop ${hopNumber} is already completed`);
        alert(`Hop ${hopNumber} has already been completed`);
        return;
    }

    // CRITICAL: Check if hop has any entries at all
    if (!hop.entries || hop.entries.length === 0) {
        console.error(`Hop ${hopNumber} has no entries - cannot finalize empty hop`);
        alert(`Cannot finalize Hop ${hopNumber} - no entries added yet!\n\nPlease add at least one trace, swap, or write-off entry before finalizing.`);
        return;
    }

    // Check if hop has any meaningful entries (not just empty placeholders)
    const hasValidEntries = hop.entries.some(entry =>
        entry.amount && parseFloat(entry.amount) > 0 &&
        ['trace', 'swap', 'writeoff', 'cold_storage'].includes(entry.entryType)
    );

    if (!hasValidEntries) {
        console.error(`Hop ${hopNumber} has no valid entries with amounts`);
        alert(`Cannot finalize Hop ${hopNumber} - no valid entries!\n\nEntries must have amounts greater than 0.`);
        return;
    }

    // CRITICAL: Check if there are any entries going to conversion wallets (brown wallets)
    // These represent threads that are still active and awaiting conversion
    const conversionWalletEntries = hop.entries.filter(entry =>
        entry.toWalletType === 'brown' ||
        entry.isBridge ||
        entry.isConversionWallet ||
        (entry.swapDetails && !entry.swapDetails.outputCurrency) // Bridge without output logged yet
    );

    if (conversionWalletEntries.length > 0) {
        // Check if any conversion wallet outputs haven't been logged yet
        const unconvertedThreads = conversionWalletEntries.filter(entry => {
            // Check if bridge output has been logged
            if (entry.isBridge || entry.isConversionWallet) {
                return !entry.bridgeOutputLogged;
            }
            return false;
        });

        if (unconvertedThreads.length > 0) {
            const walletList = unconvertedThreads.map(entry => {
                const amount = parseFloat(entry.amount).toLocaleString();
                const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                return `  • ${amount} ${currency} to ${entry.toWallet || 'conversion wallet'}`;
            }).join('\n');

            alert(`❌ Cannot finalize Hop ${hopNumber}\n\nYou have threads at conversion wallets (bridges/DEXs) that haven't logged their output conversions yet:\n\n${walletList}\n\nThese threads are still active and need to be converted to their destination currency.\n\nPlease either:\n1. Log the bridge/swap outputs for these conversion wallets, OR\n2. Convert these wallets to terminal wallets if the funds actually stayed there`);
            return;
        }
    }

    // REMOVED AUTO-WRITE-OFF: Bridge and swap outputs are NOT fees - they're legitimate traced funds!
    // Bridge/swap outputs represent the converted currency that needs to be traced further.
    // Only actual fees (like gas fees paid in a different currency) should be written off.
    // The user must manually allocate bridge/swap outputs or explicitly write them off if needed.

    console.log('Checking available threads before validation...');
    buildAvailableThreadsIndex();

    // CRITICAL: Check for unallocated partial trace outputs before validation
    const availableThreads = investigation.availableThreads || {};
    const partialTraceOutputs = [];
    for (const currency in availableThreads) {
        for (const threadId in availableThreads[currency]) {
            const thread = availableThreads[currency][threadId];

            // Check for partial trace bridge/swap outputs that haven't been allocated
            if ((thread.sourceType === 'bridge_output' || thread.sourceType === 'swap_output') &&
                thread.wasPartialTrace &&
                thread.availableAmount > 0.01 &&
                thread.hopLevel === hopNumber) {

                partialTraceOutputs.push({
                    notation: thread.notation,
                    amount: thread.availableAmount,
                    currency: currency,
                    ownership: (thread.proportionalMultiplier * 100).toFixed(2)
                });
            }
        }
    }

    // Block finalization if there are unallocated partial trace outputs
    if (partialTraceOutputs.length > 0) {
        const outputList = partialTraceOutputs.map(output =>
            `  • ${output.notation}: ${output.amount.toLocaleString()} ${output.currency} (${output.ownership}% ownership)`
        ).join('\n');

        alert(`❌ Cannot finalize Hop ${hopNumber}\n\nYou have partial trace outputs that must be allocated:\n\n${outputList}\n\nThese represent your proportional share of bridge/swap outputs.\nYou must allocate these threads to continue the trace.\n\nNote: These are NOT fees - they are your actual traced funds!`);
        return;
    }

    // Also check for any unallocated bridge/swap outputs (not just partial traces)
    const unallocatedConversionOutputs = [];
    for (const currency in availableThreads) {
        for (const threadId in availableThreads[currency]) {
            const thread = availableThreads[currency][threadId];

            // Check for ANY bridge/swap outputs that haven't been allocated
            if ((thread.sourceType === 'bridge_output' || thread.sourceType === 'swap_output') &&
                thread.availableAmount > 0.01 &&
                thread.hopLevel === hopNumber &&
                !thread.wasPartialTrace) { // Already handled partial traces above

                unallocatedConversionOutputs.push({
                    notation: thread.notation,
                    amount: thread.availableAmount,
                    currency: currency
                });
            }
        }
    }

    // Block finalization if there are unallocated conversion outputs
    if (unallocatedConversionOutputs.length > 0) {
        const outputList = unallocatedConversionOutputs.map(output =>
            `  • ${output.notation}: ${output.amount.toLocaleString()} ${output.currency}`
        ).join('\n');

        alert(`❌ Cannot finalize Hop ${hopNumber}\n\nYou have bridge/swap outputs that must be allocated:\n\n${outputList}\n\nThese are converted funds that need to be traced further.\nPlease allocate these threads or explicitly write them off if they represent fees.`);
        return;
    }

    // USE the validateHopCompletion function which properly handles swaps!
    const validation = validateHopCompletion(hopNumber);
    console.log(`Hop ${hopNumber} validation result:`, validation);

    // Check for validation errors
    if (validation.errors && validation.errors.length > 0) {
        console.error(`Hop ${hopNumber} has validation errors:`, validation.errors);
        alert(`Cannot finalize hop - validation errors:\n${validation.errors.join('\n')}`);
        return;
    }

    // Use the remaining amounts from validation (which already accounts for swaps)
    const remainingByCurrency = validation.remainingByCurrency || {};

    // Check if hop is truly balanced (no remaining unallocated threads)
    const totalRemaining = Object.values(remainingByCurrency).reduce((sum, amt) => sum + Math.abs(amt), 0);
    const isBalanced = totalRemaining < 0.01;

    console.log(`Finalizing Hop ${hopNumber}: Total remaining = ${totalRemaining}, Is balanced = ${isBalanced}`);
    console.log(`Remaining by currency:`, remainingByCurrency);

    if (isBalanced) {
        // Skip finalization modal if already balanced - go straight to completion
        console.log(`✅ Hop ${hopNumber} is balanced - proceeding to completion`);
        completeHopAndProceed(hop);
    } else {
        // CONDITIONAL: Different behavior based on tracing method
        if (investigation.tracingMethod === 'PIFO') {
            // PIFO: Must be balanced before finalization
            console.log(`⚠️ PIFO method: Hop ${hopNumber} has unbalanced amounts - showing finalization options`);
            const walletsWithRemainingFunds = analyzeUntracedBalances(hop);
            showHopFinalizationSummary(hop, remainingByCurrency, walletsWithRemainingFunds);
        } else if (investigation.tracingMethod === 'LIBR') {
            // LIBR: Allow finalization with remaining funds (they stay in wallet per LIBR methodology)
            console.log(`ℹ️ LIBR method: Hop ${hopNumber} has remaining funds - this is expected per LIBR methodology`);

            const remainingList = Object.entries(remainingByCurrency)
                .map(([curr, amt]) => `  • ${amt.toLocaleString()} ${curr}`)
                .join('\n');

            const confirmLIBR = confirm(
                `⚠️ LIBR Method: Remaining Funds in Hop ${hopNumber}\n\n` +
                `The following funds remain untraced:\n\n${remainingList}\n\n` +
                `Per LIBR methodology, these funds remain in their current wallets ` +
                `until the wallet balance drops below the deposited criminal proceeds.\n\n` +
                `Document in notes: "LIBR applied - balance analysis shows funds remain above traced amount"\n\n` +
                `Proceed with finalization?`
            );

            if (confirmLIBR) {
                // Add LIBR documentation to hop
                if (!hop.librNotes) hop.librNotes = [];
                hop.librNotes.push({
                    timestamp: new Date().toISOString(),
                    hopNumber: hopNumber,
                    remainingByCurrency: remainingByCurrency,
                    note: `LIBR applied: ${Object.entries(remainingByCurrency)
                        .map(([c, a]) => `${a.toLocaleString()} ${c}`).join(', ')} ` +
                        `remains in wallet(s) - balance analysis indicates criminal proceeds not yet depleted per Lowest Intermediate Balance Rule.`
                });

                console.log(`📝 LIBR documentation added to Hop ${hopNumber}:`, hop.librNotes[hop.librNotes.length - 1]);

                completeHopAndProceed(hop);
            } else {
                // User cancelled - show finalization summary
                const walletsWithRemainingFunds = analyzeUntracedBalances(hop);
                showHopFinalizationSummary(hop, remainingByCurrency, walletsWithRemainingFunds);
            }
        }
    }
}

// Proceed with hop finalization after all amounts are accounted for
function proceedWithHopFinalization(hop) {
    // Close the finalization modal first
    closeFinalizationModal();

    // Streamlined: Skip intermediate modals and go straight to completion
    completeHopAndProceed(hop);
}

// Streamlined hop completion - single action instead of multiple modals
function completeHopAndProceed(hop) {
    // Mark hop as completed
    hop.completed = true;
    hop.isCollapsed = true;
    window.hopCollapseState[hop.hopNumber] = true;

    // Calculate threads and ART for next hop
    const threadsCreated = [];
    let allThreadsTerminal = true;
    hop.entries.forEach(entry => {
        if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0 && entry.notation) {
            const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;

            // CRITICAL: Skip bridges that have logged outputs - they consumed the original currency
            // The bridge output creates a NEW thread in the converted currency, not the original
            if (entry.isBridge && entry.bridgeOutputLogged) {
                console.log(`Skipping bridge entry ${entry.notation} from next hop ART - already converted to ${entry.bridgeDetails?.destinationAsset}`);
                return; // Skip this entry - it doesn't create a thread in the original currency
            }

            // Check if this is a terminal wallet - note that wallet type is stored as lowercase
            const isTerminal = entry.toWalletType === 'purple' || entry.toWalletType === 'PURPLE' || entry.isTerminal === true;

            threadsCreated.push({
                notation: entry.notation,
                amount: parseFloat(entry.amount),
                currency: currency,
                toWallet: entry.toWallet,
                toWalletType: entry.toWalletType,
                isTerminal: isTerminal,
                isBridge: entry.isBridge
            });

            // Track if any non-terminal threads exist
            if (!isTerminal) {
                allThreadsTerminal = false;
            }
        }
    });

    // Calculate ART for next hop (accounting for write-offs and terminal wallets)
    // Only count non-terminal threads for next hop ART
    const nextHopART = {};

    // Build ART from non-terminal threads only
    threadsCreated.forEach(thread => {
        if (!thread.isTerminal) {
            if (!nextHopART[thread.currency]) {
                nextHopART[thread.currency] = 0;
            }
            nextHopART[thread.currency] += thread.amount;
        }
    });

    const hasActiveThreads = Object.values(nextHopART).some(amount => amount > 0);

    // Don't create next hop if all threads reached terminal wallets
    const shouldCreateNextHop = hasActiveThreads && !allThreadsTerminal;

    // Create next hop only if there are non-terminal active threads
    if (shouldCreateNextHop) {
        const nextHopNumber = hop.hopNumber + 1;
        const existingNextHop = investigation.hops.find(h => h.hopNumber === nextHopNumber);

        if (!existingNextHop) {
            const nextHop = {
                hopNumber: nextHopNumber,
                entries: [],
                artAtStartByCurrency: nextHopART,
                artAtStart: Object.values(nextHopART).reduce((sum, amount) => sum + amount, 0),
                completed: false
            };
            investigation.hops.push(nextHop);
        }
    }

    // Save and update UI
    saveToStorage();
    renderHops();
    updateWorkflowSteps();
    updateValidationStatus();

    // Auto-save the investigation after hop completion
    autoSaveAfterHopCompletion(hop.hopNumber);

    // Check if investigation is complete
    updateInvestigationCompletionStatus();

    // Determine what to show based on state
    if (allThreadsTerminal && threadsCreated.length > 0) {
        // Trace is complete - show proper completion ceremony
        showTraceCompletionCeremony(hop, threadsCreated);
    } else if (shouldCreateNextHop) {
        // Show streamlined next hop notification
        const nextHopSummary = Object.entries(nextHopART)
            .map(([currency, amount]) => `${amount.toLocaleString()} ${currency}`)
            .join(', ');

        showNotification(
            `<strong>✅ Hop ${hop.hopNumber} Complete</strong><br>
            <small>Hop ${hop.hopNumber + 1} ready with: ${nextHopSummary}</small>`,
            'success',
            4000
        );

        // Auto-scroll to next hop
        setTimeout(() => {
            const nextHopElement = document.getElementById(`hop_${hop.hopNumber + 1}`);
            if (nextHopElement) {
                nextHopElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }, 100);
    } else {
        // All funds accounted but not terminal - show completion
        showNotification(
            `<strong>✅ Hop ${hop.hopNumber} Complete</strong><br>
            <small>All funds accounted for</small>`,
            'success',
            4000
        );

        // Check if this was the last hop with no remaining threads
        const nextHopThreads = getAvailableSourcesForHop(hop.hopNumber + 1, null);
        if (nextHopThreads.length === 0 && allThreadsTerminal) {
            // Investigation is complete - show completion options
            console.log('Investigation complete - no threads remain for next hop');
            showEnhancedCompletionModal();
        }
    }
}

// Auto-save investigation after hop completion
async function autoSaveAfterHopCompletion(hopNumber) {
    try {
        // Add hop completion metadata
        if (!investigation.hopCompletions) {
            investigation.hopCompletions = {};
        }
        investigation.hopCompletions[`hop${hopNumber}`] = new Date().toISOString();
        investigation.lastModified = new Date().toISOString();
        investigation.lastCompletedHop = hopNumber;

        // Build thread index before saving
        buildAvailableThreadsIndex();

        // Prepare the data
        const dataStr = JSON.stringify(investigation, null, 2);

        // Try to save to existing file handle if available
        if (fileHandle && isFileSystemAvailable) {
            try {
                const writable = await fileHandle.createWritable();
                await writable.write(dataStr);
                await writable.close();

                // Show subtle notification
                showNotification(`✅ Auto-saved after Hop ${hopNumber} completion`, 'success', 3000);
                console.log(`Auto-save successful after Hop ${hopNumber} completion`);
                return;
            } catch (error) {
                console.error('Auto-save to file handle failed:', error);
                // Fall through to download method
            }
        }

        // If no file handle or not saved yet, use standard save
        if (!investigation.hasBeenSaved && investigation.caseId) {
            // For first save after hop completion, trigger download
            const filename = `${investigation.caseId}_hop${hopNumber}_${new Date().toISOString().slice(0,10)}.bats`;
            downloadFile(dataStr, filename, 'application/json');

            investigation.hasBeenSaved = true;
            showNotification(`📥 Investigation saved as ${filename}`, 'info', 5000);
        } else if (investigation.caseId) {
            // For subsequent saves, just notify that auto-save would occur
            console.log(`Auto-save ready for Hop ${hopNumber} - use Ctrl+S or Save button to persist`);
            showNotification(`💾 Hop ${hopNumber} complete - Remember to save your progress`, 'info', 3000);
        }
    } catch (error) {
        console.error('Auto-save error:', error);
        showNotification('⚠️ Auto-save failed - Please save manually', 'error', 5000);
    }
}

// Show comprehensive trace completion ceremony
function showTraceCompletionCeremony(hop, threadsCreated) {
    // Mark hop as completed first
    hop.completed = true;
    hop.isCollapsed = true;
    window.hopCollapseState[hop.hopNumber] = true;

    // Mark investigation as complete
    investigation.traceCompletedAt = new Date().toISOString();
    investigation.traceComplete = true;

    // Save and update status
    saveInvestigation();
    updateInvestigationCompletionStatus(); // This will trigger the unified completion flow

    // The unified completion handler will show the proper modal
    console.log('✅ Trace completion detected - triggering unified completion flow');

    return; // Exit early - let unified flow handle everything

    // OLD CODE BELOW - NO LONGER EXECUTED
    // Calculate trace statistics
    const totalVictims = investigation.victims.length;
    const totalHops = investigation.hops.length;
    const totalTransactions = investigation.victims.reduce((sum, v) => sum + v.transactions.length, 0);

    // Calculate terminal arrivals
    const terminalsByExchange = {};
    let totalAmountsByExchange = {};

    threadsCreated.forEach(thread => {
        if (thread.isTerminal) {
            // Get exchange name from wallet attribution or use generic
            const exchangeName = thread.exchangeName || 'Exchange';
            if (!terminalsByExchange[exchangeName]) {
                terminalsByExchange[exchangeName] = [];
                totalAmountsByExchange[exchangeName] = {};
            }
            terminalsByExchange[exchangeName].push(thread);

            if (!totalAmountsByExchange[exchangeName][thread.currency]) {
                totalAmountsByExchange[exchangeName][thread.currency] = 0;
            }
            totalAmountsByExchange[exchangeName][thread.currency] += thread.amount;
        }
    });

    // Create completion modal
    const modal = document.createElement('div');
    modal.id = 'traceCompletionModal';
    modal.className = 'modal';
    modal.style.cssText = `
        display: flex;
        align-items: center;
        justify-content: center;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.8);
        z-index: 10001;
    `;

    const content = document.createElement('div');
    content.style.cssText = `
        background: white;
        border-radius: 16px;
        padding: 40px;
        max-width: 700px;
        width: 90%;
        max-height: 85vh;
        overflow-y: auto;
        box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    `;

    // Generate trace timestamp
    const completionTime = new Date().toLocaleString();
    const traceDuration = investigation.created ?
        Math.round((Date.now() - new Date(investigation.created).getTime()) / 60000) : 0;

    content.innerHTML = `
        <div style="text-align: center; margin-bottom: 30px;">
            <div style="font-size: 72px; margin-bottom: 20px;">🎯</div>
            <h1 style="color: #27ae60; margin: 0 0 10px 0; font-size: 2.5rem;">Trace Complete!</h1>
            <p style="color: #666; font-size: 18px;">All source threads have been traced to terminal wallets</p>
        </div>

        <div style="background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
                    border-radius: 12px; padding: 25px; margin-bottom: 25px;">
            <h3 style="color: #2e7d32; margin: 0 0 15px 0;">📊 Trace Summary</h3>
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;">
                <div>
                    <strong>Case ID:</strong> ${investigation.caseId || 'Untitled'}
                </div>
                <div>
                    <strong>Completion Time:</strong> ${completionTime}
                </div>
                <div>
                    <strong>Total Victims:</strong> ${totalVictims}
                </div>
                <div>
                    <strong>Total Hops:</strong> ${totalHops}
                </div>
                <div>
                    <strong>Transactions Traced:</strong> ${totalTransactions}
                </div>
                <div>
                    <strong>Duration:</strong> ${traceDuration} minutes
                </div>
            </div>
        </div>

        <div style="background: #f3e5ff; border-radius: 12px; padding: 25px; margin-bottom: 25px;">
            <h3 style="color: #6a1b9a; margin: 0 0 15px 0;">🏦 Terminal Wallet Arrivals</h3>
            ${Object.entries(terminalsByExchange).map(([exchange, threads]) => `
                <div style="background: white; border-radius: 8px; padding: 15px; margin-bottom: 10px;">
                    <h4 style="color: #333; margin: 0 0 10px 0;">${exchange}</h4>
                    ${Object.entries(totalAmountsByExchange[exchange]).map(([currency, amount]) =>
                        `<div style="font-size: 18px; color: #666;">
                            ${amount.toLocaleString()} ${currency}
                        </div>`
                    ).join('')}
                    <div style="font-size: 14px; color: #999; margin-top: 5px;">
                        ${threads.length} arrival${threads.length > 1 ? 's' : ''}
                    </div>
                </div>
            `).join('')}
        </div>

        <div style="background: #fff3cd; border-radius: 12px; padding: 25px; margin-bottom: 25px;">
            <h3 style="color: #856404; margin: 0 0 15px 0;">🎯 Next Steps in Your Investigation</h3>
            <p style="color: #856404; margin: 0 0 15px 0; line-height: 1.6;">
                <strong>Excellent work!</strong> Your trace is complete. Now proceed with:
            </p>
            <div style="display: flex; gap: 20px; margin-top: 20px;">
                <div style="flex: 1; background: white; padding: 15px; border-radius: 8px; border-left: 4px solid #9b59b6;">
                    <h4 style="color: #9b59b6; margin: 0 0 10px 0;">1️⃣ Visualize</h4>
                    <p style="color: #495057; font-size: 14px; margin: 0;">
                        Review the flow diagram to understand fund movement patterns
                    </p>
                </div>
                <div style="flex: 1; background: white; padding: 15px; border-radius: 8px; border-left: 4px solid #3498db;">
                    <h4 style="color: #3498db; margin: 0 0 10px 0;">2️⃣ Document</h4>
                    <p style="color: #495057; font-size: 14px; margin: 0;">
                        Generate professional reports for legal proceedings
                    </p>
                </div>
                <div style="flex: 1; background: white; padding: 15px; border-radius: 8px; border-left: 4px solid #27ae60;">
                    <h4 style="color: #27ae60; margin: 0 0 10px 0;">3️⃣ Export</h4>
                    <p style="color: #495057; font-size: 14px; margin: 0;">
                        Save all data and create exchange coordination reports
                    </p>
                </div>
            </div>
        </div>

        <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
            <button class="btn btn-success btn-large" onclick="saveAndProceedToVisualization()"
                    style="padding: 15px 40px; font-size: 18px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: none; color: white; box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);">
                🌐 Visualize → Reports
            </button>
            <button class="btn btn-primary btn-large" onclick="saveAndProceedToReports()"
                    style="padding: 15px 40px; font-size: 18px; background: #3498db; border: none; color: white; box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);">
                📄 Skip to Reports
            </button>
            <button class="btn btn-warning" onclick="saveInvestigationAfterCompletion()"
                    style="padding: 15px 30px; background: #27ae60; color: white; border: none;">
                💾 Save Only
            </button>
            <button class="btn btn-secondary" onclick="closeTraceCompletionModal()" style="padding: 15px 30px;">
                Continue Reviewing
            </button>
        </div>
    `;

    modal.appendChild(content);
    document.body.appendChild(modal);

    // Update investigation status
    saveToStorage();
    renderHops();
    updateWorkflowSteps();
    updateValidationStatus();
    updateInvestigationCompletionStatus();

    // Add to terminal wallet index
    threadsCreated.forEach(thread => {
        if (thread.isTerminal) {
            const terminalEntry = {
                timestamp: new Date().toISOString(),
                hopNumber: hop.hopNumber,
                notation: thread.notation,
                amount: thread.amount,
                currency: thread.currency,
                toWallet: thread.toWallet,
                exchangeName: thread.exchangeName || 'Unknown Exchange',
                detectionSource: 'trace_completion'
            };

            if (!investigation.terminalWalletIndex) {
                investigation.terminalWalletIndex = [];
            }
            investigation.terminalWalletIndex.push(terminalEntry);
        }
    });
}

// Helper functions for trace completion
function saveInvestigationAfterCompletion() {
    closeTraceCompletionModal();
    // Trigger save with a note about completion
    investigation.traceCompletedAt = new Date().toISOString();
    investigation.traceComplete = true;
    saveInvestigation();

    // Show confirmation
    showNotification('Investigation saved with trace completion status', 'success', 5000);
}

// New streamlined navigation functions
function saveAndProceedToVisualization() {
    // Save the investigation first
    saveInvestigationAfterCompletion();
    closeTraceCompletionModal();

    // Navigate to flow diagram
    switchTab('flowdiagram');

    // Initialize visualization
    setTimeout(() => {
        initializeGraphVisualization();

        // Show guidance for next steps
        showVisualizationGuidance();
    }, 100);
}

function saveAndProceedToReports() {
    // Save the investigation first
    saveInvestigationAfterCompletion();
    closeTraceCompletionModal();

    // Navigate directly to reports
    switchTab('reports');

    // Show guidance for report generation
    setTimeout(() => {
        showReportGuidance();
    }, 100);
}

function showVisualizationGuidance() {
    // Add a banner at the top of visualization with next steps
    const container = document.getElementById('visualizationContainer');
    if (!container) return;

    const existingBanner = document.getElementById('vizGuidanceBanner');
    if (existingBanner) existingBanner.remove();

    const banner = document.createElement('div');
    banner.id = 'vizGuidanceBanner';
    banner.style.cssText = `
        background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
        border: 2px solid #27ae60;
        border-radius: 8px;
        padding: 15px 20px;
        margin-bottom: 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
    `;

    banner.innerHTML = `
        <div>
            <strong style="color: #27ae60;">✅ Trace Complete - Reviewing Visualization</strong>
            <p style="margin: 5px 0 0 0; color: #2c3e50; font-size: 14px;">
                Review the fund flow, then proceed to generate your reports.
            </p>
        </div>
        <button class="btn btn-success" onclick="proceedToReportsFromViz()"
                style="padding: 10px 20px; background: #3498db; color: white; border: none; border-radius: 4px;">
            Continue to Reports →
        </button>
    `;

    container.insertBefore(banner, container.firstChild);
}

function showReportGuidance() {
    // Highlight the Reports tab and show initial guidance
    const reportContent = document.getElementById('reportContent');
    if (!reportContent) return;

    const existingBanner = document.getElementById('reportGuidanceBanner');
    if (existingBanner) existingBanner.remove();

    const banner = document.createElement('div');
    banner.id = 'reportGuidanceBanner';
    banner.style.cssText = `
        background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%);
        border: 2px solid #3498db;
        border-radius: 8px;
        padding: 20px;
        margin-bottom: 20px;
    `;

    banner.innerHTML = `
        <h4 style="color: #3498db; margin: 0 0 10px 0;">📄 Report Generation Guide</h4>
        <ol style="margin: 10px 0; color: #2c3e50;">
            <li>Review the <strong>Cover Page</strong> information</li>
            <li>Check <strong>Victim</strong> and <strong>Red Wallet</strong> indexes</li>
            <li>Verify <strong>Terminal Wallet</strong> arrivals</li>
            <li>Write your <strong>Narrative Report</strong> (not auto-generated)</li>
            <li>Review the <strong>Technical Audit Trail</strong></li>
            <li>Export individual tabs or the complete report</li>
        </ol>
        <button class="btn btn-sm" onclick="this.parentElement.remove()"
                style="float: right; padding: 5px 10px; background: #ecf0f1; border: none; border-radius: 4px;">
            Dismiss ✕
        </button>
    `;

    reportContent.parentElement.insertBefore(banner, reportContent);
}

function proceedToReportsFromViz() {
    // Remove visualization banner
    const banner = document.getElementById('vizGuidanceBanner');
    if (banner) banner.remove();

    // Show the reports tab
    document.querySelectorAll('.tab-content').forEach(tab => {
        tab.style.display = 'none';
        tab.classList.remove('active');
    });

    const reportsTab = document.getElementById('reports-tab');
    if (reportsTab) {
        reportsTab.style.display = 'block';
        reportsTab.classList.add('active');
    }

    // Activate the reports nav tab
    document.querySelectorAll('.nav-tab').forEach(tab => {
        tab.classList.remove('active');
    });
    const reportsNavTab = document.querySelector('[onclick="switchTab(\'reports\')"]');
    if (reportsNavTab) {
        reportsNavTab.classList.add('active');
    }

    // Show navigation tabs
    const navTabs = document.getElementById('mainNavTabs');
    if (navTabs) {
        navTabs.style.display = 'flex';
    }

    // Generate the reports
    generateReports();

    // Show report guidance
    setTimeout(() => {
        showReportGuidance();
    }, 100);
}

function closeTraceCompletionAndGoToAnalysis() {
    // Keep for backward compatibility, redirect to new function
    saveAndProceedToVisualization();
}

function closeTraceCompletionModal() {
    const modal = document.getElementById('traceCompletionModal');
    if (modal) {
        modal.remove();
    }
}

// Show thread review for the next hop
function showThreadReviewForNextHop(completedHop) {
    // Calculate threads created in this hop
    const threadsCreated = [];
    completedHop.entries.forEach(entry => {
        if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0 && entry.notation) {
            const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
            threadsCreated.push({
                notation: entry.notation,
                amount: parseFloat(entry.amount),
                currency: currency,
                toWallet: entry.toWallet,
                toWalletType: entry.toWalletType,
                fromWallet: entry.fromWallet
            });
        }
    });
    
    // Calculate starting ART for next hop
    const nextHopART = {};
    threadsCreated.forEach(thread => {
        if (thread.toWalletType !== 'purple') { // Exclude VASP arrivals
            if (!nextHopART[thread.currency]) {
                nextHopART[thread.currency] = 0;
            }
            nextHopART[thread.currency] += thread.amount;
        }
    });
    
    const totalActiveAmount = Object.values(nextHopART).reduce((sum, amount) => sum + amount, 0);
    
    const modalHTML = `
        <div id="threadReviewModal" class="modal" style="display: block;">
            <div class="modal-content" style="max-width: 900px; max-height: 90vh; overflow-y: auto;">
                <div class="modal-header">
                    <h2>🧵 Review Source Threads for Hop ${completedHop.hopNumber + 1}</h2>
                    <p>These are the threads created from Hop ${completedHop.hopNumber} that will be available for tracing</p>
                </div>
                
                <div style="padding: 20px;">
                    ${threadsCreated.length === 0 ? `
                        <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 20px; text-align: center;">
                            <h3 style="color: #856404; margin: 0;">No threads created in this hop</h3>
                            <p style="margin: 10px 0 0 0;">All funds were written off or sent to exchanges (PURPLE wallets)</p>
                        </div>
                    ` : `
                        <div style="background: #e3f2fd; border: 1px solid #2196f3; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                            <h3 style="margin-top: 0; color: #0d47a1;">📊 Thread Summary</h3>
                            <div style="display: grid; gap: 15px;">
                                ${threadsCreated.map((thread, index) => `
                                    <div style="background: white; padding: 15px; border-radius: 8px; border-left: 4px solid ${thread.toWalletType === 'purple' ? '#8e24aa' : '#2196f3'};">
                                        <div style="display: flex; justify-content: space-between; align-items: start;">
                                            <div>
                                                <h4 style="margin: 0 0 5px 0; color: #2c3e50;">${thread.notation}</h4>
                                                <div style="color: #666; font-size: 14px;">
                                                    <div>Amount: <strong>${thread.amount.toLocaleString()} ${thread.currency}</strong></div>
                                                    <div>From: ${thread.fromWallet.substring(0, 16)}...</div>
                                                    <div>To: ${thread.toWallet.substring(0, 16)}... <span>(${walletTypes[thread.toWalletType] || thread.toWalletType})</span></div>
                                                </div>
                                            </div>
                                            <div style="text-align: right;">
                                                ${thread.toWalletType === 'purple' ? 
                                                    '<span style="color: #8e24aa; font-weight: bold;">VASP ARRIVAL</span>' : 
                                                    '<span style="color: #28a745;">✓ Active Thread</span>'
                                                }
                                            </div>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        
                        ${totalActiveAmount > 0 ? `
                            <div style="background: #d4edda; border: 2px solid #27ae60; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
                                <h3 style="color: #155724; margin-top: 0;">Adjusted Root Total (ART) for Hop ${completedHop.hopNumber + 1}</h3>
                                <div style="display: grid; gap: 10px;">
                                    ${Object.entries(nextHopART).map(([currency, amount]) => `
                                        <div style="font-size: 18px;">
                                            <strong>${currency}:</strong> ${amount.toLocaleString()}
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        ` : ''}
                    `}
                    
                    <div style="margin-top: 30px; text-align: center; padding-top: 20px; border-top: 2px solid #e0e0e0;">
                        ${totalActiveAmount > 0 ? `
                            <button class="btn btn-success btn-large" onclick="proceedToNextHop(${completedHop.id})">
                                Continue to Hop ${completedHop.hopNumber + 1} →
                            </button>
                            <button class="btn btn-primary" onclick="saveInvestigationFile()" style="margin-left: 10px;">
                                💾 Save Progress
                            </button>
                        ` : `
                            <button class="btn btn-primary btn-large" onclick="completeInvestigation(${completedHop.id})">
                                Complete Investigation
                            </button>
                            <button class="btn btn-primary" onclick="saveInvestigationFile()" style="margin-left: 10px;">
                                💾 Save Progress
                            </button>
                        `}
                        <button class="btn btn-secondary" onclick="document.getElementById('threadReviewModal').remove()" style="margin-left: 10px;">
                            Review Later
                        </button>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHTML);
}

// Update the progress indicator bar
function updateProgressIndicator() {
    const status = analyzeCaseStatus();
    const indicator = document.getElementById('progressIndicator');
    const bar = document.getElementById('progressBar');
    const percentage = document.getElementById('progressPercentage');
    const statusText = document.getElementById('progressStatus');
    
    if (!indicator) return;
    
    // Show the indicator
    indicator.style.display = 'block';
    
    // Calculate progress percentage
    let progress = 0;
    let progressSteps = 0;
    const totalSteps = 5; // Setup, Victims, Root Total, Hops, Analysis
    
    if (investigation.caseId || investigation.investigatorName) progressSteps += 0.5;
    if (status.victimsComplete) progressSteps += 1;
    if (status.rootTotalConfirmed) progressSteps += 0.5;
    
    // Calculate hop progress
    if (status.hops.length > 0) {
        const completeHops = status.hops.filter(h => h.status === 'complete').length;
        const inProgressHops = status.hops.filter(h => h.status === 'in-progress' || h.status === 'current').length;
        progressSteps += completeHops + (inProgressHops * 0.5);
    }
    
    if (status.analysisReady) progressSteps += 1;
    
    // Cap at 100%
    progress = Math.min(100, Math.round((progressSteps / totalSteps) * 100));
    
    // Update UI
    bar.style.width = progress + '%';
    percentage.textContent = progress + '%';
    
    // Update status text
    if (status.currentPhase === 'complete') {
        statusText.textContent = '✅ Investigation complete - Ready for analysis';
        bar.style.background = '#27ae60';
    } else if (status.currentHopId) {
        const currentHop = status.hops.find(h => h.hopNumber === status.currentHopId);
        if (currentHop) {
            statusText.innerHTML = `🔄 Currently on <strong>Hop ${currentHop.number}</strong> - ${currentHop.entryCount} entries${currentHop.remainingART ? ` • Remaining: ${currentHop.remainingART}` : ''}`;
        }
        bar.style.background = '#3498db';
    } else if (!status.victimsComplete) {
        statusText.textContent = '📝 Add victim transactions to begin';
        bar.style.background = '#f39c12';
    } else if (!status.rootTotalConfirmed) {
        statusText.textContent = '⏳ Confirm root total to proceed';
        bar.style.background = '#f39c12';
    } else {
        statusText.textContent = status.summary;
        bar.style.background = '#3498db';
    }
}

// Show case status dashboard after loading investigation
function showCaseStatusDashboard() {
    // Analyze the investigation status
    const status = analyzeCaseStatus();

    // Update the progress indicator
    updateProgressIndicator();

    // Create dashboard modal
    const dashboard = document.createElement('div');
    dashboard.id = 'caseStatusDashboard';
    dashboard.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.7);
        z-index: 10000;
        display: flex;
        align-items: center;
        justify-content: center;
        animation: fadeIn 0.3s ease;
    `;

    const content = document.createElement('div');
    content.style.cssText = `
        background: white;
        border-radius: 12px;
        padding: 30px;
        max-width: 800px;
        width: 90%;
        max-height: 85vh;
        overflow-y: auto;
        box-shadow: 0 10px 40px rgba(0,0,0,0.3);
    `;

    // Get detailed status info
    const availableThreads = getAvailableSourcesForHop(
        status.currentHopId || (investigation.hops.length + 1),
        null
    );
    const hasAvailableThreads = availableThreads && availableThreads.length > 0;

    // Calculate terminal wallet summary
    let terminalSummary = '';
    if (investigation.terminalWalletIndex && investigation.terminalWalletIndex.length > 0) {
        const terminalsByExchange = {};
        investigation.terminalWalletIndex.forEach(terminal => {
            const exchange = terminal.exchangeName || 'Unknown Exchange';
            if (!terminalsByExchange[exchange]) {
                terminalsByExchange[exchange] = [];
            }
            terminalsByExchange[exchange].push(terminal);
        });

        terminalSummary = `
            <div style="margin-top: 15px; padding: 10px; background: #f3e5ff; border-radius: 6px;">
                <strong>🏦 Terminal Wallets Reached:</strong>
                ${Object.entries(terminalsByExchange).map(([exchange, terminals]) =>
                    `<div style="margin-top: 5px;">• ${exchange}: ${terminals.length} arrival(s)</div>`
                ).join('')}
            </div>
        `;
    }

    // Build status HTML
    let statusHTML = `
        <h2 style="margin: 0 0 20px 0; color: #2c3e50; border-bottom: 2px solid #e8f0fe; padding-bottom: 15px;">
            📊 Investigation Loaded: ${investigation.caseId || 'Untitled'}
        </h2>

        <div style="background: ${status.currentPhase === 'complete' ?
                'linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%)' :
                'linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%)'};
                    border-radius: 8px; padding: 20px; margin-bottom: 20px;">
            <h3 style="margin: 0 0 10px 0; color: ${status.currentPhase === 'complete' ? '#155724' : '#0d47a1'};">
                ${status.currentPhase === 'complete' ?
                    '✅ Investigation Complete - All Funds Traced to Terminal Wallets' :
                    `📍 Current Position: ${status.whereYouAre}`}
            </h3>
            <div style="color: #2c3e50; line-height: 1.6;">
                ${status.summary}
                ${terminalSummary}
            </div>
            ${hasAvailableThreads && !status.currentPhase === 'complete' ? `
                <div style="margin-top: 15px; padding: 10px; background: #fff3cd; border-radius: 6px;">
                    <strong>💰 Available to Trace:</strong>
                    ${availableThreads.map(thread =>
                        `<div style="margin-top: 5px;">• ${thread.displayText}: ${thread.availableAmount.toLocaleString()} ${thread.currency}</div>`
                    ).slice(0, 3).join('')}
                    ${availableThreads.length > 3 ? `<div style="margin-top: 5px;">... and ${availableThreads.length - 3} more threads</div>` : ''}
                </div>
            ` : ''}
        </div>
    `;
    
    // Progress sections
    statusHTML += '<div style="margin: 20px 0;">';
    
    // Setup & Victims
    statusHTML += `
        <div style="margin-bottom: 15px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid ${status.victimsComplete ? '#27ae60' : '#ffc107'};">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <strong>${status.victimsComplete ? '✅' : '⏳'} Victims & Root Total</strong>
                    <div style="color: #666; font-size: 14px; margin-top: 5px;">
                        ${status.victimCount} victim${status.victimCount !== 1 ? 's' : ''} • 
                        ${status.transactionCount} transaction${status.transactionCount !== 1 ? 's' : ''} • 
                        Root Total: ${status.rootTotal}
                    </div>
                </div>
                ${!status.victimsComplete ? 
                    '<button class="btn btn-primary btn-small" onclick="closeCaseStatusDashboard(); focusOnVictims()">Add Victims</button>' : 
                    '<span style="color: #27ae60; font-weight: bold;">Complete</span>'
                }
            </div>
        </div>
    `;
    
    // Hops
    status.hops.forEach(hop => {
        const hopStatus = hop.status;
        const statusColor = hopStatus === 'complete' ? '#27ae60' : hopStatus === 'in-progress' ? '#3498db' : '#999';
        const statusIcon = hopStatus === 'complete' ? '✅' : hopStatus === 'in-progress' ? '🔄' : '⏳';
        
        statusHTML += `
            <div style="margin-bottom: 15px; padding: 15px; background: ${hopStatus === 'current' ? '#fff3cd' : '#f8f9fa'}; 
                        border-radius: 8px; border-left: 4px solid ${statusColor};
                        ${hopStatus === 'current' ? 'border: 2px solid #ffc107;' : ''}">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <strong>${statusIcon} Hop ${hop.number}</strong>
                        ${hopStatus === 'current' ? '<span style="color: #856404; margin-left: 10px;">← You were here</span>' : ''}
                        <div style="color: #666; font-size: 14px; margin-top: 5px;">
                            ${hop.entryCount} entr${hop.entryCount !== 1 ? 'ies' : 'y'} • 
                            ${hop.amountTraced} traced
                            ${hop.remainingART ? ` • Remaining: ${hop.remainingART}` : ''}
                        </div>
                    </div>
                    ${hopStatus === 'current' || hopStatus === 'in-progress' ? 
                        `<button class="btn btn-primary btn-small" onclick="closeCaseStatusDashboard(); focusOnHop(${hop.hopNumber})">
                            ${hopStatus === 'current' ? 'Continue Here' : 'Go to Hop'}
                        </button>` : 
                        hopStatus === 'complete' ? 
                            '<span style="color: #27ae60; font-weight: bold;">Complete</span>' :
                            '<span style="color: #999;">Not Started</span>'
                    }
                </div>
            </div>
        `;
    });
    
    // Analysis
    if (status.showAnalysis) {
        statusHTML += `
            <div style="margin-bottom: 15px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid ${status.analysisReady ? '#27ae60' : '#999'};">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <strong>${status.analysisReady ? '✅' : '⏳'} Analysis & Reports</strong>
                        <div style="color: #666; font-size: 14px; margin-top: 5px;">
                            ${status.analysisReady ? 'Ready to generate reports' : 'Complete hops first'}
                        </div>
                    </div>
                    ${status.analysisReady ?
                        '<button class="btn btn-success btn-small" onclick="closeCaseStatusDashboard(); showEnhancedCompletionModal()">View Results</button>' :
                        '<span style="color: #999;">Not Ready</span>'
                    }
                </div>
            </div>
        `;
    }
    
    statusHTML += '</div>';
    
    // Action buttons
    statusHTML += `
        <div style="margin-top: 30px; padding-top: 20px; border-top: 2px solid #e8f0fe;">
            <div style="background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
                        border-radius: 8px; padding: 20px; margin-bottom: 20px;">
                <h4 style="margin: 0 0 10px 0; color: #856404;">
                    📝 What to do next:
                </h4>
                <p style="margin: 0 0 15px 0; color: #856404; font-size: 16px; line-height: 1.5;">
                    ${status.whatToDoNext}
                </p>
                <div style="text-align: center;">
                    ${status.currentHopId ?
                        `<button class="btn btn-success btn-large" onclick="closeCaseStatusDashboard(); focusOnHop(${status.currentHopId})"
                                 style="padding: 12px 30px; font-size: 18px;">
                            🎯 Continue Working on Hop ${status.currentHopId}
                        </button>` :
                        status.nextAction ?
                            `<button class="btn btn-success btn-large" onclick="closeCaseStatusDashboard(); ${status.nextAction}"
                                     style="padding: 12px 30px; font-size: 18px;">
                                🚀 ${status.whatToDoNext}
                            </button>` :
                            ''
                    }
                </div>
            </div>
            <div style="text-align: center;">
                <button class="btn btn-secondary" onclick="closeCaseStatusDashboard()" style="padding: 10px 20px;">
                    👁️ View Full Investigation
                </button>
                ${status.currentPhase === 'complete' ? `
                    <button class="btn btn-primary" onclick="closeCaseStatusDashboard(); showEnhancedCompletionModal()"
                            style="margin-left: 10px; padding: 10px 20px;">
                        📊 View Investigation Results
                    </button>
                ` : ''}
            </div>
        </div>
    `;
    
    content.innerHTML = statusHTML;
    dashboard.appendChild(content);
    document.body.appendChild(dashboard);
    
    // Add click-outside to close
    dashboard.addEventListener('click', (e) => {
        if (e.target === dashboard) {
            closeCaseStatusDashboard();
        }
    });
}

// Analyze case status to determine current state
function analyzeCaseStatus() {
    const status = {
        currentPhase: 'setup',
        whereYouAre: '',
        victimsComplete: false,
        rootTotalConfirmed: false,
        victimCount: 0,
        transactionCount: 0,
        rootTotal: '$0',
        hops: [],
        currentHopId: null,
        showAnalysis: false,
        analysisReady: false,
        nextAction: null,
        summary: '',
        whatToDoNext: ''
    };
    
    // Check victims
    if (investigation.victims && investigation.victims.length > 0) {
        status.victimCount = investigation.victims.length;
        status.transactionCount = investigation.victims.reduce((sum, v) => sum + (v.transactions?.length || 0), 0);
        
        // Calculate root total
        let rootTotal = 0;
        const currencies = {};
        investigation.victims.forEach(victim => {
            victim.transactions?.forEach(tx => {
                if (tx.amount) {
                    const currency = tx.currency === 'CUSTOM' ? tx.customCurrency : tx.currency;
                    if (!currencies[currency]) currencies[currency] = 0;
                    currencies[currency] += parseFloat(tx.amount);
                    rootTotal += parseFloat(tx.amount);
                }
            });
        });
        
        // Format root total
        if (Object.keys(currencies).length === 1) {
            const curr = Object.keys(currencies)[0];
            status.rootTotal = `${currencies[curr].toLocaleString()} ${curr}`;
        } else {
            status.rootTotal = Object.entries(currencies)
                .map(([curr, amt]) => `${amt.toLocaleString()} ${curr}`)
                .join(' + ');
        }
        
        status.victimsComplete = status.transactionCount > 0;
        status.rootTotalConfirmed = investigation.rootTotalConfirmed || false;
    }
    
    // Check hops
    let lastCompleteHop = null;
    let firstIncompleteHop = null;
    
    if (investigation.hops && investigation.hops.length > 0) {
        investigation.hops.forEach(hop => {
            const hopInfo = {
                id: hop.hopNumber,
                number: hop.hopNumber,
                entryCount: hop.entries?.length || 0,
                status: 'not-started',
                amountTraced: '0',
                remainingART: null
            };
            
            // Calculate hop amounts
            const hopCurrencies = {};
            hop.entries?.forEach(entry => {
                if (entry.amount) {
                    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                    if (!hopCurrencies[currency]) hopCurrencies[currency] = 0;
                    hopCurrencies[currency] += parseFloat(entry.amount);
                }
            });
            
            if (Object.keys(hopCurrencies).length > 0) {
                hopInfo.amountTraced = Object.entries(hopCurrencies)
                    .map(([curr, amt]) => `${amt.toLocaleString()} ${curr}`)
                    .join(' + ');
            }
            
            // Determine hop status
            if (hop.completed) {
                hopInfo.status = 'complete';
                lastCompleteHop = hop;
            } else if (hopInfo.entryCount > 0) {
                hopInfo.status = 'in-progress';
                if (!firstIncompleteHop) {
                    firstIncompleteHop = hop;
                    hopInfo.status = 'current';
                    status.currentHopId = hop.hopNumber;
                    
                    // Calculate remaining ART
                    const validation = validateHopCompletion(hop.hopNumber);
                    if (validation.remainingByCurrency) {
                        const remaining = Object.entries(validation.remainingByCurrency)
                            .filter(([_, amt]) => amt > 0)
                            .map(([curr, amt]) => `${amt.toLocaleString()} ${curr}`)
                            .join(' + ');
                        if (remaining) {
                            hopInfo.remainingART = remaining;
                        }
                    }
                }
            }
            
            status.hops.push(hopInfo);
        });
    }
    
    // Determine current phase and next action with detailed summary
    if (!status.victimsComplete) {
        status.currentPhase = 'victims';
        status.whereYouAre = 'Setup Phase - No Victims Added';
        status.nextAction = 'focusOnVictims()';
        status.summary = 'Your investigation needs victim transactions to begin. Add victims and their blockchain transactions to start tracing.';
        status.whatToDoNext = 'Add victim wallet addresses and transaction hashes';
    } else if (!status.rootTotalConfirmed) {
        status.currentPhase = 'root-total';
        status.whereYouAre = `Victims Added (${status.victimCount} victims, ${status.transactionCount} transactions)`;
        status.nextAction = 'confirmRootTotal()';
        status.summary = `You have entered ${status.transactionCount} transaction(s) totaling ${status.rootTotal}. Confirm the root total to begin tracing these funds.`;
        status.whatToDoNext = 'Confirm root total and generate initial threads';
    } else if (firstIncompleteHop) {
        status.currentPhase = 'hops';
        status.whereYouAre = `Working on Hop ${firstIncompleteHop.hopNumber}`;
        const validation = validateHopCompletion(firstIncompleteHop.hopNumber);
        if (validation.remainingByCurrency && Object.keys(validation.remainingByCurrency).length > 0) {
            const remainingAmounts = Object.entries(validation.remainingByCurrency)
                .filter(([_, amt]) => amt > 0)
                .map(([curr, amt]) => `${amt.toLocaleString()} ${curr}`)
                .join(', ');
            status.summary = `Hop ${firstIncompleteHop.hopNumber} is in progress with ${firstIncompleteHop.entryCount} entries recorded. You have ${remainingAmounts} remaining to trace.`;
            status.whatToDoNext = `Continue adding transactions to Hop ${firstIncompleteHop.hopNumber}`;
        } else {
            status.summary = `Hop ${firstIncompleteHop.hopNumber} has ${firstIncompleteHop.entryCount} entries. Complete this hop to proceed.`;
            status.whatToDoNext = `Complete Hop ${firstIncompleteHop.hopNumber}`;
        }
    } else if (lastCompleteHop) {
        // Check if there are any active threads
        const nextHopNumber = lastCompleteHop.hopNumber + 1;
        const availableThreads = getAvailableSourcesForHop(nextHopNumber, null);
        const hasActiveThreads = availableThreads && availableThreads.length > 0;

        if (hasActiveThreads) {
            status.currentPhase = 'hops';
            status.whereYouAre = `Completed Hop ${lastCompleteHop.hopNumber}`;
            status.nextAction = `addNewHop()`;
            const threadSummary = availableThreads.slice(0, 3)
                .map(t => `${t.availableAmount.toLocaleString()} ${t.currency}`)
                .join(', ');
            status.summary = `You've completed ${investigation.hops.length} hop(s). There are ${availableThreads.length} active thread(s) with ${threadSummary}${availableThreads.length > 3 ? '...' : ''} ready to trace in Hop ${nextHopNumber}.`;
            status.whatToDoNext = `Start Hop ${nextHopNumber} to continue tracing`;
        } else {
            status.currentPhase = 'complete';
            status.whereYouAre = 'Investigation Complete';
            status.showAnalysis = true;
            status.analysisReady = true;
            const terminalCount = investigation.terminalWalletIndex ? investigation.terminalWalletIndex.length : 0;
            status.summary = `All funds have been successfully traced through ${investigation.hops.length} hops. ${terminalCount} terminal wallet arrival(s) documented. Your investigation is complete and ready for reporting.`;
            status.whatToDoNext = 'Generate reports and visualizations';
        }
    } else {
        status.currentPhase = 'hops';
        status.whereYouAre = 'Ready to Start Tracing';
        status.nextAction = 'startHop1()';
        status.summary = `Root total confirmed: ${status.rootTotal}. Begin tracing these funds from the ${status.victimCount} victim wallet(s).`;
        status.whatToDoNext = 'Start Hop 1 to begin tracing victim funds';
    }
    
    return status;
}

// Check if there are active threads from a hop
function checkForActiveThreads(hop) {
    if (!hop || !hop.entries) return false;
    
    let hasActive = false;
    hop.entries.forEach(entry => {
        if (entry.entryType === 'trace' && 
            entry.toWalletType !== 'purple' && 
            entry.toWalletType !== 'blue' &&
            parseFloat(entry.amount) > 0) {
            hasActive = true;
        }
    });
    
    return hasActive;
}

// Close the case status dashboard
function closeCaseStatusDashboard() {
    const dashboard = document.getElementById('caseStatusDashboard');
    if (dashboard) {
        dashboard.remove();
    }
}

// Focus functions for different sections
function focusOnVictims() {
    switchTab('victims');
    setTimeout(() => {
        const firstInput = document.querySelector('#victimsContent input');
        if (firstInput) firstInput.focus();
    }, 100);
}

function focusOnHop(hopNumber) {
    switchTab('hops');
    setTimeout(() => {
        const hopElement = document.querySelector(`#hop_${hopNumber}`);
        if (hopElement) {
            hopElement.scrollIntoView({ behavior: 'smooth', block: 'center' });

            // Expand the hop if collapsed
            window.hopCollapseState = window.hopCollapseState || {};
            window.hopCollapseState[hopNumber] = false;
            const hopContent = document.getElementById(`hopContent_${hopNumber}`);
            if (hopContent) {
                hopContent.style.display = 'block';
            }

            // Highlight the hop
            hopElement.style.border = '3px solid #ffc107';
            hopElement.style.boxShadow = '0 0 20px rgba(255, 193, 7, 0.3)';
            setTimeout(() => {
                hopElement.style.border = '';
                hopElement.style.boxShadow = '';
            }, 3000);
        }
    }, 100);
}

// Alias for focusOnHop for consistency
function scrollToHop(hopNumber) {
    focusOnHop(hopNumber);
}

function focusOnAnalysis() {
    // Show the completion modal instead of going to a non-existent analysis tab
    showEnhancedCompletionModal();
}

function startHop1() {
    if (!investigation.hops || investigation.hops.length === 0) {
        investigation.hops = [{
            hopNumber: 1,
            entries: [],
            completed: false
        }];
        saveToStorage();
        renderHops();
    }
    document.getElementById('hopsTab').click();
}

function createNextHop(previousHopId) {
    const prevHop = investigation.hops.find(h => h.hopNumber === previousHopId);
    if (prevHop) {
        proceedToNextHop(previousHopId);
    }
}

// Check if a hop is fully accounted for and notify user
function showRemainingThreadsSummary(hop) {
    // Get available threads for the NEXT hop (what's available after this hop's entries)
    const nextHopNumber = hop.hopNumber + 1;
    const availableThreads = getAvailableSourcesForHop(nextHopNumber, null);

    // Filter for threads with remaining amounts
    const remainingThreads = availableThreads.filter(t => t.availableAmount > 0);

    if (remainingThreads.length > 0) {
        // Build summary of what's left to trace
        const totalsByCurrency = {};
        remainingThreads.forEach(thread => {
            if (!totalsByCurrency[thread.currency]) {
                totalsByCurrency[thread.currency] = 0;
            }
            totalsByCurrency[thread.currency] += thread.availableAmount;
        });

        // Show concise notification in corner instead of modal
        let summaryHTML = `<strong>✅ Entry created</strong><br>`;
        summaryHTML += `<small>${remainingThreads.length} thread${remainingThreads.length > 1 ? 's' : ''} remaining to trace</small>`;

        showNotification(summaryHTML, 'success', 4000);

        // Quick feedback without extra delays
        const addButton = document.querySelector(`button[onclick*="addHopEntry(${hop.hopNumber}"]`);
        if (addButton) {
            addButton.style.animation = 'pulse 2s ease-in-out 3';
        }
    } else {
        // All threads consumed - hop is complete
        // The completion modal will handle this notification
        hop.lastEntryCompleted = true;
    }

    // Update investigation completion status to check if we're done
    updateInvestigationCompletionStatus();
}

function checkHopCompletionStatus(hop) {
    if (!hop || hop.completed) return;

    const validation = validateHopCompletion(hop.hopNumber);

    // NEW APPROACH: Check if there are any available threads remaining
    // This properly handles swaps where the currency changes
    // IMPORTANT: We need to check threads for NEXT hop (hop + 1)
    // BUT also check same-hop conversion outputs (bridges/swaps) that haven't been allocated yet
    const nextHopThreads = getAvailableSourcesForHop(hop.hopNumber + 1, null);

    // Also check for unallocated same-hop conversion outputs
    // These are bridge/swap outputs created in the current hop that need to be traced
    const allAvailableThreads = [];

    // Add all threads that would be available for the next hop
    nextHopThreads.forEach(thread => {
        // Check if this is a same-hop conversion output from the CURRENT hop
        // These need to be allocated before the hop can be finalized
        if ((thread.sourceType === 'bridge_output' || thread.sourceType === 'swap_output') &&
            thread.hopLevel === hop.hopNumber) {
            console.log(`Found unallocated ${thread.sourceType} in current hop: ${thread.threadId} - ${thread.availableAmount} ${thread.currency}`);
        }
        allAvailableThreads.push(thread);
    });

    // Calculate total available across all currencies
    let totalAvailable = 0;
    const availableByCurrency = {};
    allAvailableThreads.forEach(thread => {
        if (thread.availableAmount > 0) {
            totalAvailable += thread.availableAmount;
            if (!availableByCurrency[thread.currency]) {
                availableByCurrency[thread.currency] = 0;
            }
            availableByCurrency[thread.currency] += thread.availableAmount;
        }
    });

    // Hop is fully accounted if no threads remain available
    const fullyAccounted = totalAvailable < 0.01; // Allow small rounding differences

    console.log(`Hop ${hop.hopNumber} completion check: ${totalAvailable} remaining across all currencies`, availableByCurrency);
    
    // Show notification if fully accounted
    if (fullyAccounted && hop.entries.length > 0) {
        // Check if we've already notified (to avoid spam)
        if (!hop.completionNotified) {
            hop.completionNotified = true;
            
            // Show notification immediately for better UX
            {
                // Show success notification with action prompt
                const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: #d4edda;
                border: 2px solid #27ae60;
                border-radius: 12px;
                padding: 30px;
                z-index: 10000;
                box-shadow: 0 10px 40px rgba(0,0,0,0.2);
                max-width: 500px;
                text-align: center;
            `;
            
            // Check if all threads reached terminal wallets
            let allThreadsTerminal = true;
            let hasAnyTraceEntries = false;
            hop.entries.forEach(entry => {
                if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0) {
                    hasAnyTraceEntries = true;
                    // Check if terminal - wallet type is stored as lowercase
                    const isTerminal = entry.toWalletType === 'purple' || entry.toWalletType === 'PURPLE' || entry.isTerminal === true;
                    if (!isTerminal) {
                        allThreadsTerminal = false;
                    }
                }
            });

            // Only consider all terminal if we actually have trace entries
            const traceComplete = hasAnyTraceEntries && allThreadsTerminal;

            const buttonText = traceComplete ?
                '🎯 Complete Trace' :
                `Close Hop ${hop.hopNumber} & Continue`;

            const subText = traceComplete ?
                'All funds have reached terminal wallets. Your trace is complete!' :
                'All source threads have been accounted for in this hop.';

            notification.innerHTML = `
                <h2 style="color: #155724; margin: 0 0 15px 0;">✅ Ready to ${traceComplete ? 'Complete Trace' : 'Continue'}</h2>
                <p style="color: #155724; margin: 0 0 20px 0;">
                    ${subText}
                </p>
                ${traceComplete ? `
                    <div style="background: #fff3cd; border: 1px solid #ffc107; border-radius: 4px; padding: 10px; margin: 15px 0; text-align: left;">
                        <small style="color: #856404;">
                            <strong>💡 Tip:</strong> If you need to investigate further (e.g., a wallet marked as terminal might actually be a bridge/DEX),
                            you can go back and edit your entries.
                        </small>
                    </div>
                ` : ''}
                <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                    <button class="btn btn-success" onclick="closeHopAndProceed(${hop.hopNumber}, this.parentElement.parentElement)" style="padding: 12px 24px; font-size: 16px;">
                        ${buttonText}
                    </button>
                    ${traceComplete ? `
                        <button class="btn btn-warning" onclick="saveInvestigation(); this.parentElement.parentElement.remove()" style="padding: 12px 24px; background: #ff9800; color: white;">
                            💾 Save Investigation
                        </button>
                        <button class="btn btn-primary" onclick="this.parentElement.parentElement.remove(); scrollToHop(${hop.hopNumber})" style="padding: 12px 24px; background: #3498db;">
                            ✏️ Edit Entries
                        </button>
                    ` : `
                        <button class="btn btn-secondary" onclick="this.parentElement.parentElement.remove()" style="padding: 12px 24px;">
                            <small>Continue Adding Entries</small>
                        </button>
                    `}
                    <button class="btn btn-light" onclick="finalizeHop(${hop.hopNumber}); this.parentElement.parentElement.remove()" style="padding: 12px 24px;">
                        <small>📊 Review Details</small>
                    </button>
                </div>
            `;
            
            document.body.appendChild(notification);
            
                // Don't auto-remove - let user decide when to proceed
            } // No delay - show immediately
        }
    } else {
        // Reset notification flag if no longer fully accounted
        hop.completionNotified = false;
    }
}

// Close hop and proceed to next
function closeHopAndProceed(hopNumber, notificationElement) {
    if (notificationElement) {
        notificationElement.remove();
    }

    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    if (!hop) return;

    // Streamlined: Use the consolidated completion function
    completeHopAndProceed(hop);
}

// Update hop progress indicator
function updateHopProgressIndicator(hop) {
    // Get available threads for this hop
    const availableThreads = getAvailableSourcesForHop(hop.hopNumber + 1, null);
    const totalRemaining = availableThreads.reduce((sum, t) => sum + (t.availableAmount || 0), 0);

    // Calculate progress percentage
    const startingART = hop.artAtStartByCurrency || {};
    const totalStarting = Object.values(startingART).reduce((sum, amt) => sum + amt, 0);
    const progress = totalStarting > 0 ? ((totalStarting - totalRemaining) / totalStarting) * 100 : 0;

    // Update hop header with progress
    const hopHeader = document.querySelector(`#hop_${hop.hopNumber} .hop-header`);
    if (hopHeader) {
        let progressBar = hopHeader.querySelector('.hop-progress-bar');
        if (!progressBar) {
            // Create progress bar if it doesn't exist
            progressBar = document.createElement('div');
            progressBar.className = 'hop-progress-bar';
            progressBar.style.cssText = `
                position: absolute;
                bottom: 0;
                left: 0;
                height: 3px;
                background: linear-gradient(90deg, #4CAF50 0%, #45a049 100%);
                transition: width 0.5s ease;
                border-radius: 0 0 0 8px;
            `;
            hopHeader.style.position = 'relative';
            hopHeader.appendChild(progressBar);
        }
        progressBar.style.width = `${progress}%`;

        // Add completion checkmark if fully accounted
        if (progress >= 99.99) {
            let checkmark = hopHeader.querySelector('.hop-complete-check');
            if (!checkmark) {
                checkmark = document.createElement('span');
                checkmark.className = 'hop-complete-check';
                checkmark.innerHTML = ' ✓';
                checkmark.style.cssText = 'color: #4CAF50; font-weight: bold;';
                const hopTitle = hopHeader.querySelector('h3');
                if (hopTitle && !hopTitle.innerHTML.includes('✓')) {
                    hopTitle.appendChild(checkmark);
                }
            }
        }
    }
}

// Check if hop has unaccounted threads
function checkForUnaccountedThreads(hop) {
    // Check if there are threads that haven't been fully allocated
    const threads = getAvailableSourcesForHop(hop.hopNumber, null);
    for (const thread of threads) {
        if (thread.availableAmount > 0.01) { // Small threshold to avoid rounding issues
            return true;
        }
    }
    return false;
}

// Proceed to next hop without modal
function proceedToNextHopFromObject(hop) {
    // Mark hop as completed
    hop.isCollapsed = true;

    // Create next hop if it doesn't exist
    const nextHopNumber = hop.hopNumber + 1;
    const existingNextHop = investigation.hops.find(h => h.hopNumber === nextHopNumber);

    if (!existingNextHop) {
        createNewHop();
    }

    // Save and update UI
    saveToStorage();
    renderHops();

    // Scroll to next hop
    setTimeout(() => {
        const nextHopElement = document.getElementById(`hop_${nextHopNumber}`);
        if (nextHopElement) {
            nextHopElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
    }, 100);
}

// Show thread review modal before proceeding to next hop
function showThreadReviewModal(hop) {
    // Calculate the ART for the next hop (accounting for write-offs)
    const nextHopART = getCurrentART();
    const hasWriteoffs = hop.entries.some(e => e.entryType === 'writeoff' && parseFloat(e.amount) > 0);

    // Get all untraced threads from this hop
    const untracedThreads = [];
    hop.entries.forEach(entry => {
        if (entry.type === 'trace' && !entry.writeOff) {
            const threadId = `V${entry.sourceThreads[0].victimId}-T${entry.sourceThreads[0].transactionId}-H${hop.hopNumber}`;
            untracedThreads.push({
                id: threadId,
                amount: entry.outputAmount,
                currency: entry.outputCurrency || entry.sourceThreads[0].currency,
                wallet: entry.toWallet
            });
        }
    });

    if (untracedThreads.length === 0) {
        // No threads to trace, proceed directly
        proceedToNextHop(hop.hopNumber);
        return;
    }

    const modalHTML = `
        <div id="threadReviewModal" class="modal" style="display: block; z-index: 10000;">
            <div class="modal-content" style="max-width: 700px;">
                <div class="modal-header" style="background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);">
                    <h2 style="color: white;">📊 Thread Review - Hop ${hop.hopNumber}</h2>
                </div>
                <div style="padding: 20px;">
                    <div class="alert alert-info">
                        <strong>✅ Hop ${hop.hopNumber} Complete!</strong><br>
                        The following threads are ready to be traced in Hop ${hop.hopNumber + 1}:
                    </div>

                    ${hasWriteoffs ? `
                        <div class="alert alert-warning" style="background: #fff3cd; border: 1px solid #ffc107; padding: 12px; border-radius: 8px; margin-bottom: 15px;">
                            <strong>⚠️ Write-offs Applied</strong><br>
                            The Adjusted Root Total (ART) has been reduced by write-offs in this hop.
                        </div>
                    ` : ''}

                    <div style="background: #f5f5f5; border-radius: 8px; padding: 15px; margin: 20px 0;">
                        <h4>Threads to Trace:</h4>
                        ${untracedThreads.map(thread => `
                            <div style="background: white; padding: 10px; margin: 10px 0; border-radius: 4px; border-left: 4px solid #4CAF50;">
                                <strong>${thread.id}</strong><br>
                                Amount: ${formatAmount(thread.amount, thread.currency)}<br>
                                Wallet: ${thread.wallet}
                            </div>
                        `).join('')}
                    </div>

                    <div style="background: #d4edda; border: 2px solid #27ae60; border-radius: 8px; padding: 15px; margin: 20px 0;">
                        <h4>Adjusted Root Total for Hop ${hop.hopNumber + 1}:</h4>
                        ${Object.entries(nextHopART).filter(([currency, amount]) => amount > 0).map(([currency, amount]) =>
                            `<div style="font-size: 16px; margin: 5px 0;">${currency}: ${amount.toLocaleString()}</div>`
                        ).join('')}
                        ${hasWriteoffs ? '<small style="color: #856404;">*ART reduced due to write-offs</small>' : ''}
                    </div>

                    <div style="text-align: center; margin-top: 20px;">
                        <button onclick="proceedToNextHop('${hop.hopNumber}')" class="btn btn-primary" style="padding: 10px 30px;">
                            Continue to Hop ${hop.hopNumber + 1} →
                        </button>
                    </div>
                </div>
            </div>
        </div>
    `;

    createCenteredModal('threadReviewModal', modalHTML);
}

// Proceed to next hop after thread review
function proceedToNextHop(hopNumber) {
    const modal = document.getElementById('threadReviewModal');
    if (modal) modal.remove();

    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    if (!hop) return;

    // Mark current hop as completed
    hop.completed = true;

    // Auto-collapse the completed hop
    window.hopCollapseState[hop.hopNumber] = true;

    // Calculate the ART for the next hop (after write-offs in current hop)
    const nextHopART = getCurrentART();

    // Create the next hop with proper ART tracking
    const nextHopNumber = hop.hopNumber + 1;
    const nextHop = {
        hopNumber: nextHopNumber,
        entries: [],
        artAtStartByCurrency: nextHopART,
        artAtStart: Object.values(nextHopART).reduce((sum, amount) => sum + amount, 0), // Legacy support
        completed: false
    };

    investigation.hops.push(nextHop);
    
    // Save and render
    saveToStorage();
    renderHops();
    
    // Scroll to the new hop
    setTimeout(() => {
        const newHopElement = document.querySelector(`#hop_${nextHop.hopNumber}`);
        if (newHopElement) {
            newHopElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
    }, 100);
    
    // Show success notification
    showNotification(`✅ Hop ${hop.hopNumber} completed! Starting Hop ${nextHopNumber}`, 'success');
}

// Keep the old function for backward compatibility but redirect to simpler flow
function proceedToWalletClassification(hopNumber) {
    proceedToNextHop(hopNumber);
}

// Complete the hop and create the next one
function completeHopAndCreateNext(hop) {
    hop.completed = true;

    // Auto-collapse the completed hop
    window.hopCollapseState[hop.hopNumber] = true;

    // Calculate ART for next hop (after accounting for write-offs in the current hop)
    const nextHopART = getCurrentART();
    const hasWriteoffs = hop.entries.some(e => e.entryType === 'writeoff' && parseFloat(e.amount) > 0);

    // Create the next hop with proper ART accounting
    const nextHopNumber = hop.hopNumber + 1;
    const nextHop = {
        hopNumber: nextHopNumber,
        entries: [],
        artAtStartByCurrency: nextHopART,
        artAtStart: Object.values(nextHopART).reduce((sum, amount) => sum + amount, 0), // Legacy support
        completed: false
    };

    investigation.hops.push(nextHop);

    // If there were write-offs, notify the user
    if (hasWriteoffs) {
        const writeoffTotal = {};
        hop.entries.forEach(entry => {
            if (entry.entryType === 'writeoff' && parseFloat(entry.amount) > 0) {
                const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                writeoffTotal[currency] = (writeoffTotal[currency] || 0) + parseFloat(entry.amount);
            }
        });

        let writeoffMessage = 'Write-offs applied:\n';
        Object.entries(writeoffTotal).forEach(([currency, amount]) => {
            writeoffMessage += `- ${amount.toLocaleString()} ${currency}\n`;
        });
        writeoffMessage += '\nThe ART has been reduced for Hop ' + nextHopNumber;

        console.log(writeoffMessage); // Log for debugging
    }

    saveToStorage();
    renderHops();
    updateInvestigationCompletionStatus();

    // Trigger autosave after hop completion
    if (isFileSystemAvailable) {
        autosaveInvestigation();
    }

    // Ensure we stay on the traces tab to see the new hop
    if (typeof switchTab === 'function') {
        switchTab('traces');
    }
}

// Complete investigation when no threads remain
function completeInvestigation(hopNumber) {
    const modal = document.getElementById('threadReviewModal');
    if (modal) modal.remove();

    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    if (!hop) return;

    hop.completed = true;
    window.hopCollapseState[hop.hopNumber] = true;

    saveToStorage();
    renderHops();
    updateInvestigationCompletionStatus();

    if (isFileSystemAvailable) {
        autosaveInvestigation();
    }

    // Show enhanced completion modal with workflow options
    showEnhancedCompletionModal();
}

// Enhanced completion modal with clear next steps
function showEnhancedCompletionModal() {
    // Remove any existing modal
    const existingModal = document.getElementById('completionWorkflowModal');
    if (existingModal) existingModal.remove();

    const modal = document.createElement('div');
    modal.id = 'completionWorkflowModal';
    modal.className = 'modal';
    modal.style.cssText = 'display: flex; z-index: 10000;';

    const terminalSummary = generateTerminalSummary();
    const threadSummary = generateThreadSummary();

    modal.innerHTML = `
        <div class="modal-content" style="max-width: 800px; width: 90%; max-height: 90vh; overflow-y: auto;">
            <div class="modal-header" style="background: linear-gradient(135deg, #27ae60, #2ecc71);">
                <h2 style="color: white; margin: 0;">🎉 Investigation Complete!</h2>
                <button onclick="closeCompletionModal()" class="modal-close" style="color: white;">&times;</button>
            </div>

            <div style="padding: 25px;">
                <!-- Success Message -->
                <div style="background: #d4edda; border: 2px solid #27ae60; border-radius: 8px; padding: 20px; margin-bottom: 25px; text-align: center;">
                    <h3 style="color: #27ae60; margin-bottom: 10px;">✅ All Funds Successfully Traced</h3>
                    <p style="color: #2c3e50; margin: 10px 0; font-size: 16px;">
                        Your investigation has been completed through <strong>${investigation.hops.length} hops</strong>.
                    </p>
                    ${terminalSummary}
                </div>

                <!-- Thread Summary -->
                <div style="background: #f8f9fa; border-radius: 8px; padding: 15px; margin-bottom: 25px;">
                    ${threadSummary}
                </div>

                <!-- Next Steps -->
                <h4 style="color: #2c3e50; margin: 20px 0 15px 0; text-align: center;">Choose Your Next Step:</h4>

                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 25px;">
                    <!-- Visualize Card -->
                    <div style="background: white; border: 2px solid #3498db; border-radius: 8px; padding: 20px; text-align: center; cursor: pointer; transition: transform 0.2s;"
                         onmouseover="this.style.transform='translateY(-2px)'"
                         onmouseout="this.style.transform='translateY(0)'"
                         onclick="proceedToVisualization()">
                        <div style="font-size: 48px; margin-bottom: 10px;">🌐</div>
                        <h5 style="color: #3498db; margin: 10px 0;">Visualize Flow</h5>
                        <p style="color: #666; font-size: 14px;">See an interactive graph of fund movements</p>
                    </div>

                    <!-- Document Card -->
                    <div style="background: white; border: 2px solid #9b59b6; border-radius: 8px; padding: 20px; text-align: center; cursor: pointer; transition: transform 0.2s;"
                         onmouseover="this.style.transform='translateY(-2px)'"
                         onmouseout="this.style.transform='translateY(0)'"
                         onclick="proceedToReports()">
                        <div style="font-size: 48px; margin-bottom: 10px;">📄</div>
                        <h5 style="color: #9b59b6; margin: 10px 0;">Generate Reports</h5>
                        <p style="color: #666; font-size: 14px;">Create professional documentation</p>
                    </div>

                    <!-- Export Card -->
                    <div style="background: white; border: 2px solid #e67e22; border-radius: 8px; padding: 20px; text-align: center; cursor: pointer; transition: transform 0.2s;"
                         onmouseover="this.style.transform='translateY(-2px)'"
                         onmouseout="this.style.transform='translateY(0)'"
                         onclick="showExportOptions()">
                        <div style="font-size: 48px; margin-bottom: 10px;">💾</div>
                        <h5 style="color: #e67e22; margin: 10px 0;">Export Data</h5>
                        <p style="color: #666; font-size: 14px;">Save in various formats</p>
                    </div>
                </div>

                <!-- Primary Actions -->
                <div style="display: flex; gap: 15px; justify-content: center; margin-top: 30px;">
                    <button class="btn btn-primary btn-large" style="background: linear-gradient(135deg, #3498db, #2980b9); padding: 12px 30px; font-size: 16px;"
                            onclick="proceedWithVisualizationFirst()">
                        🌐 Visualize → Reports
                    </button>
                    <button class="btn btn-secondary btn-large" style="background: linear-gradient(135deg, #9b59b6, #8e44ad); padding: 12px 30px; font-size: 16px;"
                            onclick="proceedDirectlyToReports()">
                        📄 Skip to Reports
                    </button>
                </div>

                <!-- Save Reminder -->
                <div style="margin-top: 25px; padding: 15px; background: #fff3cd; border: 1px solid #ffc107; border-radius: 8px; text-align: center;">
                    <strong>💡 Don't forget to save your work!</strong>
                    <div style="margin-top: 10px;">
                        <button class="btn" onclick="saveInvestigationFile()">💾 Save Investigation File</button>
                    </div>
                </div>
            </div>
        </div>
    `;

    document.body.appendChild(modal);
}
window.showEnhancedCompletionModal = showEnhancedCompletionModal;

// Generate terminal wallet summary for completion modal
function generateTerminalSummary() {
    // First check terminal wallet index
    const terminals = investigation.terminalWalletIndex || [];

    // Also check entries for terminal wallets (as backup)
    const terminalEntries = [];
    investigation.hops?.forEach(hop => {
        hop.entries?.forEach(entry => {
            if (entry.isTerminalWallet || entry.toWalletType === 'purple' || entry.toWalletType === 'blue') {
                terminalEntries.push({
                    walletAddress: entry.toWallet,
                    walletLabel: entry.exchangeName || entry.exchangeAttribution?.name ||
                                 (entry.notes && entry.notes.match(/Terminal wallet: ([^\n]+)/)?.[1]) ||
                                 'Unknown Exchange',
                    currency: entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency,
                    amount: parseFloat(entry.amount) || 0,
                    walletType: entry.toWalletType
                });
            }
        });
    });

    // Combine both sources but deduplicate by wallet address + amount to avoid double counting
    const uniqueTerminals = new Map();

    // Add terminals from index first
    terminals.forEach(terminal => {
        const key = `${terminal.walletAddress}_${terminal.amount}_${terminal.currency}`;
        uniqueTerminals.set(key, terminal);
    });

    // Add entries only if they don't already exist
    terminalEntries.forEach(terminal => {
        const key = `${terminal.walletAddress}_${terminal.amount}_${terminal.currency}`;
        if (!uniqueTerminals.has(key)) {
            uniqueTerminals.set(key, terminal);
        }
    });

    const allTerminals = Array.from(uniqueTerminals.values());
    if (allTerminals.length === 0) return '';

    // Group by exchange and currency
    const summary = allTerminals.reduce((acc, terminal) => {
        const label = terminal.walletLabel || 'Unknown Exchange';
        const key = `${label}_${terminal.currency}`;

        if (!acc[key]) {
            acc[key] = {
                label: label,
                currency: terminal.currency,
                totalAmount: 0,
                count: 0,
                walletType: terminal.walletType || 'purple'
            };
        }
        acc[key].totalAmount += parseFloat(terminal.amount) || 0;
        acc[key].count++;
        return acc;
    }, {});

    // Sort by amount descending
    const sortedSummary = Object.values(summary).sort((a, b) => b.totalAmount - a.totalAmount);

    return `
        <div style="margin-top: 15px;">
            <strong>${sortedSummary.length} Terminal Wallet(s) Identified:</strong>
            ${sortedSummary.map(s => {
                const icon = s.walletType === 'blue' ? '🔵' : '🟣';
                const typeLabel = s.walletType === 'blue' ? ' (Cold Storage)' : '';
                return `
                    <div style="margin-top: 8px; padding: 8px; background: white; border-radius: 4px; font-size: 14px;">
                        ${icon} ${s.label}${typeLabel}: ${s.totalAmount.toLocaleString()} ${s.currency}
                    </div>
                `;
            }).join('')}
        </div>
    `;
}

// Generate thread summary for completion modal
function generateThreadSummary() {
    const victims = investigation.victims || [];
    const totalsByVictim = {};

    victims.forEach(victim => {
        const victimId = `V${victim.id}`;
        totalsByVictim[victimId] = {
            name: victim.name,
            totals: {}
        };

        victim.transactions.forEach(tx => {
            if (!totalsByVictim[victimId].totals[tx.currency]) {
                totalsByVictim[victimId].totals[tx.currency] = 0;
            }
            totalsByVictim[victimId].totals[tx.currency] += parseFloat(tx.amount) || 0;
        });
    });

    return `
        <h4 style="margin-bottom: 15px;">📊 Investigation Summary:</h4>
        ${Object.entries(totalsByVictim).map(([vid, data]) => `
            <div style="margin-bottom: 10px;">
                <strong>${vid} - ${data.name}:</strong>
                ${Object.entries(data.totals).map(([curr, amt]) =>
                    `<span style="margin-left: 10px;">${amt.toLocaleString()} ${curr}</span>`
                ).join(', ')}
            </div>
        `).join('')}
    `;
}

// Close completion modal
function closeCompletionModal() {
    const modal = document.getElementById('completionWorkflowModal');
    if (modal) modal.remove();
}

// Generate complete HTML page for visualization in new window
function generateVisualizationPage() {
    // Serialize investigation data
    const investigationData = JSON.stringify(investigation);

    return `
<!DOCTYPE html>
<html>
<head>
    <title>B.A.T.S. Investigation Visualization - ${investigation.caseId || 'Untitled'}</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body { font-family: Arial, sans-serif; background: #f5f5f5; }
        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 30px;
            box-shadow: 0 4px 15px rgba(44, 62, 80, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 30px;
        }
        .header-logo {
            width: 140px;
            height: auto;
            flex-shrink: 0;
        }
        .header-content {
            flex: 1;
            text-align: center;
        }
        .header h1 {
            font-size: 2.2rem;
            margin-bottom: 10px;
            color: #FFBF00;
            font-weight: 700;
            letter-spacing: 1px;
        }
        .header p {
            opacity: 0.9;
            font-size: 1.1rem;
            color: #ffffff;
        }
        .controls {
            background: white;
            padding: 15px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
            align-items: center;
        }
        .controls button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            transition: transform 0.2s;
        }
        .controls button:hover { transform: translateY(-2px); }
        .btn-primary { background: #f39c12; color: white; font-weight: 500; }
        .btn-primary:hover { background: #e67e22; }
        .btn-secondary { background: #34495e; color: white; }
        .btn-secondary:hover { background: #2c3e50; }
        .btn-success { background: #27ae60; color: white; }
        .btn-success:hover { background: #229954; }
        #canvas-container {
            position: relative;
            width: 100%;
            height: calc(100vh - 180px);
            background: white;
        }
        #visualization-canvas {
            width: 100%;
            height: 100%;
        }
        .tab-nav {
            background: white;
            border-bottom: 2px solid #e0e0e0;
            display: flex;
            gap: 0;
        }
        .tab-nav button {
            padding: 12px 24px;
            border: none;
            background: none;
            cursor: pointer;
            position: relative;
            transition: all 0.3s;
        }
        .tab-nav button.active {
            color: #f39c12;
            background: #f8f9fa;
            font-weight: 600;
        }
        .tab-nav button.active::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            right: 0;
            height: 3px;
            background: #f39c12;
        }
        .tab-content {
            display: none;
            padding: 20px;
            background: white;
            min-height: calc(100vh - 200px);
        }
        .tab-content.active { display: block; }
    </style>
</head>
<body>
    <div class="header">
        <svg class="header-logo" viewBox="0 0 240 60" xmlns="http://www.w3.org/2000/svg">
            <defs>
                <linearGradient id="goldGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                    <stop offset="0%" style="stop-color:#f39c12;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#e67e22;stop-opacity:1" />
                </linearGradient>
                <linearGradient id="blockGradient" x1="0%" y1="0%" x2="100%" y2="0%">
                    <stop offset="0%" style="stop-color:#3498db;stop-opacity:1" />
                    <stop offset="100%" style="stop-color:#2980b9;stop-opacity:1" />
                </linearGradient>
            </defs>

            <!-- Block icon -->
            <g transform="translate(10, 15)">
                <rect x="0" y="0" width="30" height="30" fill="url(#blockGradient)" rx="3"/>
                <rect x="5" y="5" width="8" height="8" fill="#ffffff" opacity="0.9"/>
                <rect x="17" y="5" width="8" height="8" fill="#ffffff" opacity="0.7"/>
                <rect x="5" y="17" width="8" height="8" fill="#ffffff" opacity="0.7"/>
                <rect x="17" y="17" width="8" height="8" fill="#ffffff" opacity="0.5"/>
            </g>

            <!-- Text: BLOCK AUDIT -->
            <text x="50" y="36" font-family="Arial, sans-serif" font-size="24" font-weight="bold" fill="url(#goldGradient)">
                BLOCK AUDIT
            </text>
        </svg>
        <div class="header-content">
            <h1>B.A.T.S. Investigation Visualization</h1>
            <p>Case: ${investigation.caseId} | Total Traced: ${getTotalTracedSummary()}</p>
        </div>
    </div>

    <div class="tab-nav">
        <button class="active" onclick="switchVisualizationTab('graph')">📊 Graph View</button>
        <button onclick="switchVisualizationTab('reports')">📄 Reports</button>
        <button onclick="switchVisualizationTab('export')">💾 Export</button>
    </div>

    <!-- Graph View Tab -->
    <div id="graph-tab" class="tab-content active">
        <div class="controls">
            <button class="btn-primary" onclick="changeLayout('hierarchical')">📊 Hierarchical</button>
            <button class="btn-primary" onclick="changeLayout('force')">🔀 Force Layout</button>
            <button class="btn-primary" onclick="changeLayout('tree')">🌳 Tree Layout</button>
            <span style="flex: 1;"></span>
            <button class="btn-secondary" onclick="navigateToReports()">📄 Go to Reports</button>
            <button class="btn-secondary" onclick="resetView()">🔄 Reset View</button>
            <button class="btn-secondary" onclick="fitToScreen()">📐 Fit to Screen</button>
            <button class="btn-success" onclick="exportVisualization('png')">📸 Export PNG</button>
            <button class="btn-success" onclick="exportVisualization('svg')">📄 Export SVG</button>
        </div>

        <!-- Display Filter Button and Badge -->
        <div id="viz-controls" style="position: absolute; top: 80px; right: 20px; z-index: 1000;">
            <button onclick="openFilterModal()" class="btn btn-primary"
                    style="padding: 12px 24px; font-size: 16px; box-shadow: 0 2px 8px rgba(0,0,0,0.2);">
                🔍 Display Filter
            </button>

            <!-- Active Filter Badge -->
            <div id="active-filter-badge" style="display: none; margin-top: 10px;
                                                 background: #e3f2fd; padding: 10px;
                                                 border-radius: 5px; border-left: 4px solid #2563eb;
                                                 box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                <strong>Active View:</strong> <span id="filter-badge-text"></span>
                <button onclick="clearActiveFilter()" style="margin-left: 10px;
                                                             padding: 2px 8px; font-size: 11px;">
                    Clear
                </button>
            </div>

            <!-- Saved Views Quick Access -->
            <div id="saved-views-quick" style="margin-top: 10px; display: none;">
                <strong style="font-size: 12px;">Saved Views:</strong>
                <select id="quick-load-view" onchange="loadSavedViewQuick(this.value)"
                        class="form-control" style="font-size: 12px; margin-top: 5px;">
                    <option value="">-- Load Saved View --</option>
                </select>
            </div>
        </div>

        <div id="canvas-container">
            <canvas id="visualization-canvas"></canvas>
        </div>
    </div>

    <!-- Filter Modal -->
    <div id="filter-modal" class="modal-overlay" style="display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: rgba(0,0,0,0.5); z-index: 10001; align-items: center; justify-content: center;">
        <div class="modal-content" style="background: white; border-radius: 8px; padding: 30px; max-width: 600px; max-height: 80vh; overflow-y: auto;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2 style="margin: 0;">🔍 Display Filter</h2>
                <button onclick="closeFilterModal()" class="btn btn-secondary"
                        style="padding: 5px 15px;">✕ Close</button>
            </div>

            <!-- Step 1: Select Filter Mode -->
            <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 5px;">
                <label style="display: block; font-weight: bold; margin-bottom: 10px;">
                    Select Filter Mode:
                </label>
                <select id="filter-mode-select" onchange="updateFilterOptions()"
                        class="form-control" style="font-size: 16px;">
                    <option value="">-- Choose How to Filter --</option>
                    <option value="victim">📍 By Victim (Forward Trace)</option>
                    <option value="rootThread">🔗 By Root Thread (Forward Trace)</option>
                    <option value="terminal">🎯 By Terminal Wallet (Backward Trace)</option>
                </select>
            </div>

            <!-- Step 2: Multi-Select Checkboxes -->
            <div id="filter-options-container" style="display: none; margin-bottom: 20px;
                                                       padding: 15px; background: #fff;
                                                       border: 2px solid #dee2e6; border-radius: 5px;
                                                       max-height: 400px; overflow-y: auto;">
                <div style="display: flex; justify-content: space-between; margin-bottom: 10px;">
                    <strong>Select items to display:</strong>
                    <div>
                        <button onclick="selectAllFilterOptions()" class="btn btn-sm btn-secondary"
                                style="padding: 3px 10px; font-size: 12px; margin-right: 5px;">
                            Select All
                        </button>
                        <button onclick="deselectAllFilterOptions()" class="btn btn-sm btn-secondary"
                                style="padding: 3px 10px; font-size: 12px;">
                            Deselect All
                        </button>
                    </div>
                </div>

                <div id="filter-options-list"></div>
            </div>

            <!-- Step 3: Action Buttons -->
            <div style="margin-bottom: 20px;">
                <button onclick="applySelectedFilter()" class="btn btn-primary"
                        style="width: 100%; padding: 12px; font-size: 16px; margin-bottom: 10px;">
                    ✓ Apply Filter
                </button>

                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                    <button onclick="saveCurrentView()" class="btn btn-secondary"
                            style="padding: 10px;">
                        💾 Save View
                    </button>
                    <button onclick="exportCurrentView()" class="btn btn-secondary"
                            style="padding: 10px;">
                        📥 Export View
                    </button>
                </div>
            </div>

            <!-- Step 4: Manage Saved Views -->
            <div style="border-top: 2px solid #dee2e6; padding-top: 20px;">
                <h3 style="margin-bottom: 15px;">📚 Saved Views</h3>
                <div id="saved-views-list" style="max-height: 200px; overflow-y: auto;"></div>
            </div>
        </div>
    </div>

    <style>
    /* Filter option checkbox styling */
    .filter-option-item {
        padding: 10px;
        margin-bottom: 8px;
        border: 1px solid #dee2e6;
        border-radius: 4px;
        cursor: pointer;
        transition: background 0.2s;
        display: flex;
        align-items: flex-start;
    }

    .filter-option-item:hover {
        background: #f8f9fa;
    }

    .filter-option-item input[type="checkbox"] {
        margin-right: 10px;
        width: 18px;
        height: 18px;
        cursor: pointer;
        flex-shrink: 0;
    }

    .filter-option-item label {
        cursor: pointer;
        margin: 0;
        flex: 1;
    }

    .saved-view-item {
        padding: 10px;
        margin-bottom: 8px;
        border: 1px solid #dee2e6;
        border-radius: 4px;
        display: flex;
        justify-content: space-between;
        align-items: center;
    }

    .saved-view-item:hover {
        background: #f8f9fa;
    }
    </style>

    <!-- Reports Tab -->
    <div id="reports-tab" class="tab-content">
        <div class="controls">
            <button class="btn-secondary" onclick="switchTab('visualization')">📊 Go to Graph</button>
            <span style="flex: 1;"></span>
            <button class="btn-success" onclick="exportCompleteReport()">📄 Export Complete Report</button>
        </div>

        <!-- Read-Only Notice -->
        <div style="background: linear-gradient(135deg, #f39c12, #e67e22); color: white; padding: 15px 20px; margin: 20px auto; max-width: 1200px; border-radius: 8px; box-shadow: 0 2px 8px rgba(230, 126, 34, 0.3);">
            <div style="display: flex; align-items: center; gap: 10px;">
                <span style="font-size: 24px;">🔒</span>
                <div>
                    <strong style="font-size: 16px;">Read-Only View</strong>
                    <p style="margin: 5px 0 0 0; opacity: 0.95; font-size: 14px;">This is a snapshot of the investigation. To make changes, return to the main app window.</p>
                </div>
            </div>
        </div>

        <div id="reports-container" style="padding: 20px; max-width: 1200px; margin: 0 auto;">
            <!-- Report Sections -->
            <div style="margin-bottom: 40px;">
                <h1 style="color: #2c3e50; border-bottom: 3px solid #3498db; padding-bottom: 15px;">Investigation Report</h1>
                <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 20px 0;">
                    <strong>Case ID:</strong> <span id="report-case-id"></span><br>
                    <strong>Investigator:</strong> <span id="report-investigator"></span><br>
                    <strong>Date:</strong> <span id="report-date"></span>
                </div>
            </div>

            <!-- Wallet Indexes Section -->
            <div style="margin-bottom: 40px;">
                <h2 style="color: #2c3e50; border-bottom: 2px solid #e74c3c; padding-bottom: 10px;">📋 Wallet Indexes</h2>

                <!-- Universal Wallet Index -->
                <div style="margin: 20px 0;">
                    <h3 style="color: #34495e;">Universal Wallet Index</h3>
                    <div id="report-universal-index" style="overflow-x: auto;"></div>
                </div>

                <!-- Red Wallet Index -->
                <div style="margin: 20px 0;">
                    <h3 style="color: #e74c3c;">Red Wallet Index (Bad Actor Wallets)</h3>
                    <div id="report-red-index" style="overflow-x: auto;"></div>
                </div>

                <!-- Purple Wallet Index -->
                <div style="margin: 20px 0;">
                    <h3 style="color: #9b59b6;">Purple Wallet Index (Terminal/Exchange Wallets)</h3>
                    <div id="report-purple-index" style="overflow-x: auto;"></div>
                </div>
            </div>

            <!-- Technical Audit Trail -->
            <div style="margin-bottom: 40px;">
                <h2 style="color: #2c3e50; border-bottom: 2px solid #3498db; padding-bottom: 10px;">🔍 Technical Audit Trail</h2>
                <div id="report-technical-content" style="margin-top: 20px;"></div>
            </div>

            <!-- Narrative Section -->
            <div style="margin-bottom: 40px;">
                <h2 style="color: #2c3e50; border-bottom: 2px solid #27ae60; padding-bottom: 10px;">📝 Investigation Narrative</h2>
                <div id="report-narrative-content" style="margin-top: 20px; padding: 20px; background: #f8f9fa; border-radius: 8px; min-height: 200px;">
                    <p style="color: #7f8c8d; font-style: italic;">Write your investigation narrative here. This section is for summarizing findings, methodologies, and conclusions.</p>
                </div>
            </div>
        </div>
    </div>

    <!-- Export Tab -->
    <div id="export-tab" class="tab-content">
        <div style="max-width: 800px; margin: 0 auto; padding: 20px;">
            <h2>Export Investigation Data</h2>
            <div style="display: grid; grid-template-columns: repeat(auto-fill, minmax(200px, 1fr)); gap: 20px; margin-top: 20px;">
                <button class="export-card" onclick="exportFormat('json')" style="padding: 20px; border: 2px solid #3498db; background: white; border-radius: 8px; cursor: pointer;">
                    <div style="font-size: 36px;">📋</div>
                    <h3>JSON</h3>
                    <p style="color: #666; font-size: 12px;">Complete investigation data</p>
                </button>
                <button class="export-card" onclick="exportFormat('csv')" style="padding: 20px; border: 2px solid #27ae60; background: white; border-radius: 8px; cursor: pointer;">
                    <div style="font-size: 36px;">📊</div>
                    <h3>CSV</h3>
                    <p style="color: #666; font-size: 12px;">Spreadsheet format</p>
                </button>
                <button class="export-card" onclick="exportFormat('pdf')" style="padding: 20px; border: 2px solid #e74c3c; background: white; border-radius: 8px; cursor: pointer;">
                    <div style="font-size: 36px;">📄</div>
                    <h3>PDF Report</h3>
                    <p style="color: #666; font-size: 12px;">Professional documentation</p>
                </button>
                <button class="export-card" onclick="exportFormat('html')" style="padding: 20px; border: 2px solid #9b59b6; background: white; border-radius: 8px; cursor: pointer;">
                    <div style="font-size: 36px;">🌐</div>
                    <h3>HTML</h3>
                    <p style="color: #666; font-size: 12px;">Web-ready report</p>
                </button>
            </div>
        </div>
    </div>

    <!-- Include visualization engine -->
    <script src="bats-visualization-engine.js"><\/script>
    <script>
        // Store investigation data
        const investigation = ${investigationData};
        let visualizationEngine;

        // Initialize visualization
        window.initializeVisualization = function(data) {
            if (data) investigation = data;

            // Initialize the canvas-based visualization engine
            visualizationEngine = new BATSVisualizationEngine('visualization-canvas');
            visualizationEngine.loadInvestigation(investigation);

            // Initialize filter UI
            initializeFilterUI();
        };

        // Layout functions
        function changeLayout(type) {
            if (visualizationEngine) {
                visualizationEngine.applyLayout(type);
            }
        }

        function resetView() {
            if (visualizationEngine && visualizationEngine.interaction) {
                visualizationEngine.interaction.resetView();
            }
        }

        function fitToScreen() {
            if (visualizationEngine && visualizationEngine.interaction) {
                visualizationEngine.interaction.fitToScreen();
            }
        }

        function exportVisualization(format) {
            if (visualizationEngine && visualizationEngine.exporter) {
                if (format === 'png') {
                    visualizationEngine.exporter.exportPNG();
                } else if (format === 'svg') {
                    visualizationEngine.exporter.exportSVG();
                }
            }
        }

        // ============================================
        // Visualization Filter Functions
        // ============================================

        // Global state for filter UI
        const filterUI = {
            currentMode: null,
            selectedItems: new Set(),
            savedViews: [],
            currentViewName: null
        };

        // Helper to get localStorage key safely
        function getSavedViewsStorageKey() {
            const caseId = investigation.caseNumber || 'default';
            return 'bats_saved_views_' + caseId;
        }

        // Initialize filter UI
        function initializeFilterUI() {
            if (!visualizationEngine || !visualizationEngine.provenanceIndex) return;

            // Load saved views from localStorage
            const savedViewsJson = localStorage.getItem(getSavedViewsStorageKey());
            if (savedViewsJson) {
                try {
                    filterUI.savedViews = JSON.parse(savedViewsJson);
                } catch (e) {
                    console.error('Failed to load saved views:', e);
                    filterUI.savedViews = [];
                }
            }

            refreshSavedViewsList();
            updateQuickLoadDropdown();
        }

        // Open filter modal
        function openFilterModal() {
            document.getElementById('filter-modal').style.display = 'flex';

            if (filterUI.currentMode) {
                document.getElementById('filter-mode-select').value = filterUI.currentMode;
                updateFilterOptions();
            }
        }

        // Close filter modal
        function closeFilterModal() {
            document.getElementById('filter-modal').style.display = 'none';
        }

        // Update filter options based on selected mode
        function updateFilterOptions() {
            const mode = document.getElementById('filter-mode-select').value;
            const container = document.getElementById('filter-options-container');
            const optionsList = document.getElementById('filter-options-list');

            if (!mode) {
                container.style.display = 'none';
                return;
            }

            filterUI.currentMode = mode;
            container.style.display = 'block';
            optionsList.innerHTML = '';

            const idx = visualizationEngine.provenanceIndex;
            let options = [];

            if (mode === 'victim') {
                idx.victimRootThreads.forEach((threads, victimId) => {
                    const victimNum = parseInt(victimId.substring(1));
                    const victim = investigation.victims[victimNum - 1];

                    let totalAmount = 0;
                    let currency = 'Mixed';
                    const currencies = new Set();

                    threads.forEach(internalId => {
                        const thread = idx.threads.get(internalId);
                        if (thread) {
                            totalAmount += thread.totalAmount || 0;
                            currencies.add(thread.currency);
                        }
                    });

                    if (currencies.size === 1) {
                        currency = Array.from(currencies)[0];
                    }

                    options.push({
                        id: victimId,
                        label: victimId + ' - ' + (victim?.name || 'Unknown'),
                        details: threads.size + ' transaction' + (threads.size > 1 ? 's' : '') + ', ' + totalAmount.toFixed(4) + ' ' + currency,
                        type: 'victim'
                    });
                });
            } else if (mode === 'rootThread') {
                const rootNotations = new Map();

                idx.victimRootThreads.forEach((threads, victimId) => {
                    threads.forEach(internalId => {
                        const thread = idx.threads.get(internalId);
                        if (thread && thread.notation) {
                            if (!rootNotations.has(thread.notation)) {
                                rootNotations.set(thread.notation, {
                                    amount: 0,
                                    currency: thread.currency,
                                    count: 0
                                });
                            }
                            const data = rootNotations.get(thread.notation);
                            data.amount += thread.totalAmount || 0;
                            data.count++;
                        }
                    });
                });

                rootNotations.forEach((data, notation) => {
                    options.push({
                        id: notation,
                        label: notation,
                        details: data.amount.toFixed(4) + ' ' + data.currency + (data.count > 1 ? ' (' + data.count + ' threads)' : ''),
                        type: 'rootThread'
                    });
                });

                options.sort((a, b) => a.label.localeCompare(b.label));
            } else if (mode === 'terminal') {
                idx.terminalAncestors.forEach((ancestors, terminalNodeId) => {
                    const node = visualizationEngine.graph.getNode(terminalNodeId);
                    if (node) {
                        const victimSources = new Set();
                        ancestors.forEach(ancestorId => {
                            const thread = idx.threads.get(ancestorId);
                            if (thread && thread.victimId) {
                                victimSources.add('V' + thread.victimId);
                            }
                        });

                        options.push({
                            id: terminalNodeId,
                            label: node.label || 'Unknown Terminal',
                            details: ancestors.size + ' source thread' + (ancestors.size > 1 ? 's' : '') + ' from ' + Array.from(victimSources).join(', '),
                            type: 'terminal',
                            fullAddress: node.data?.toWallet || ''
                        });
                    }
                });
            }

            // Render options as checkboxes
            options.forEach(option => {
                const isChecked = filterUI.selectedItems.has(option.id);

                const optionDiv = document.createElement('div');
                optionDiv.className = 'filter-option-item';
                optionDiv.innerHTML = '<input type="checkbox" id="filter-opt-' + CSS.escape(option.id) + '" value="' + option.id + '" ' +
                    (isChecked ? 'checked' : '') + ' onchange="toggleFilterOption(\'' + option.id.replace(/'/g, "\\'") + '\')"> ' +
                    '<label for="filter-opt-' + CSS.escape(option.id) + '" style="display: flex; flex-direction: column;"> ' +
                    '<strong>' + option.label + '</strong> ' +
                    '<span style="font-size: 12px; color: #666;">' + option.details + '</span> ' +
                    (option.fullAddress ? '<span style="font-size: 11px; color: #999; font-family: monospace;">' + option.fullAddress + '</span>' : '') +
                    '</label>';

                optionsList.appendChild(optionDiv);
            });

            console.log('Loaded ' + options.length + ' ' + mode + ' options');
        }

        // Toggle individual filter option
        function toggleFilterOption(id) {
            if (filterUI.selectedItems.has(id)) {
                filterUI.selectedItems.delete(id);
            } else {
                filterUI.selectedItems.add(id);
            }
        }

        // Select all options
        function selectAllFilterOptions() {
            const checkboxes = document.querySelectorAll('#filter-options-list input[type="checkbox"]');
            checkboxes.forEach(cb => {
                cb.checked = true;
                filterUI.selectedItems.add(cb.value);
            });
        }

        // Deselect all options
        function deselectAllFilterOptions() {
            const checkboxes = document.querySelectorAll('#filter-options-list input[type="checkbox"]');
            checkboxes.forEach(cb => {
                cb.checked = false;
                filterUI.selectedItems.delete(cb.value);
            });
        }

        // Apply selected filter
        function applySelectedFilter() {
            if (filterUI.selectedItems.size === 0) {
                alert('Please select at least one item to display');
                return;
            }

            const mode = filterUI.currentMode;
            console.log('Applying ' + mode + ' filter with ' + filterUI.selectedItems.size + ' selected items:',
                        Array.from(filterUI.selectedItems));

            const combinedNodes = new Set();
            const combinedEdges = new Set();

            filterUI.selectedItems.forEach(itemId => {
                let result;

                if (mode === 'victim') {
                    result = visualizationEngine.filterManager.filterByVictim(itemId);
                } else if (mode === 'rootThread') {
                    result = visualizationEngine.filterManager.filterByRootThread(itemId);
                } else if (mode === 'terminal') {
                    result = visualizationEngine.filterManager.filterByTerminal(itemId);
                }

                if (result) {
                    result.nodes.forEach(nodeId => combinedNodes.add(nodeId));
                    result.edges.forEach(edgeId => combinedEdges.add(edgeId));
                }
            });

            visualizationEngine.currentFilterResult = {
                nodes: combinedNodes,
                edges: combinedEdges,
                filter: {
                    type: mode,
                    selectedItems: Array.from(filterUI.selectedItems),
                    description: filterUI.selectedItems.size + ' ' + mode + (filterUI.selectedItems.size > 1 ? 's' : '') + ' selected'
                }
            };

            visualizationEngine.render();
            visualizationEngine.interaction.fitToScreen();

            showActiveFilterBadge(filterUI.selectedItems.size + ' ' + mode + (filterUI.selectedItems.size > 1 ? 's' : ''));
            closeFilterModal();

            console.log('Filter applied: ' + combinedNodes.size + ' nodes, ' + combinedEdges.size + ' edges visible');
        }

        // Save current view
        function saveCurrentView() {
            if (filterUI.selectedItems.size === 0) {
                alert('Please apply a filter before saving');
                return;
            }

            const viewName = prompt('Enter a name for this view:');
            if (!viewName || viewName.trim() === '') {
                return;
            }

            const savedView = {
                id: Date.now().toString(),
                name: viewName.trim(),
                mode: filterUI.currentMode,
                selectedItems: Array.from(filterUI.selectedItems),
                createdAt: new Date().toISOString(),
                description: filterUI.selectedItems.size + ' ' + filterUI.currentMode + (filterUI.selectedItems.size > 1 ? 's' : '')
            };

            filterUI.savedViews.push(savedView);
            saveSavedViewsToStorage();
            refreshSavedViewsList();
            updateQuickLoadDropdown();

            alert('View "' + viewName + '" saved successfully!');
        }

        // Load saved view
        function loadSavedView(viewId) {
            const view = filterUI.savedViews.find(v => v.id === viewId);
            if (!view) {
                console.error('Saved view not found:', viewId);
                return;
            }

            filterUI.currentMode = view.mode;
            filterUI.selectedItems = new Set(view.selectedItems);
            filterUI.currentViewName = view.name;

            document.getElementById('filter-mode-select').value = view.mode;
            updateFilterOptions();

            applySelectedFilter();

            console.log('Loaded saved view: ' + view.name);
        }

        // Quick load from dropdown
        function loadSavedViewQuick(viewId) {
            if (!viewId) return;

            loadSavedView(viewId);
            document.getElementById('quick-load-view').value = '';
        }

        // Delete saved view
        function deleteSavedView(viewId) {
            const view = filterUI.savedViews.find(v => v.id === viewId);
            if (!view) return;

            if (!confirm('Delete saved view "' + view.name + '"?')) {
                return;
            }

            filterUI.savedViews = filterUI.savedViews.filter(v => v.id !== viewId);
            saveSavedViewsToStorage();
            refreshSavedViewsList();
            updateQuickLoadDropdown();
        }

        // Export current view as PNG
        async function exportCurrentView() {
            if (!visualizationEngine.currentFilterResult ||
                visualizationEngine.currentFilterResult.nodes.size === 0) {
                alert('Please apply a filter before exporting');
                return;
            }

            try {
                const blob = await visualizationEngine.exportAs('png');
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;

                const viewName = filterUI.currentViewName || 'filtered-view';
                const timestamp = new Date().toISOString().slice(0, 10);
                a.download = investigation.caseNumber + '_' + viewName + '_' + timestamp + '.png';

                a.click();
                URL.revokeObjectURL(url);

                console.log('View exported as PNG');
            } catch (error) {
                console.error('Export failed:', error);
                alert('Failed to export view: ' + error.message);
            }
        }

        // Clear active filter
        function clearActiveFilter() {
            filterUI.selectedItems.clear();
            filterUI.currentViewName = null;

            visualizationEngine.clearFilter();

            hideActiveFilterBadge();
        }

        // Show active filter badge
        function showActiveFilterBadge(text) {
            const badge = document.getElementById('active-filter-badge');
            const badgeText = document.getElementById('filter-badge-text');

            badgeText.textContent = text;
            badge.style.display = 'block';

            document.getElementById('saved-views-quick').style.display = 'block';
        }

        // Hide active filter badge
        function hideActiveFilterBadge() {
            document.getElementById('active-filter-badge').style.display = 'none';
            document.getElementById('saved-views-quick').style.display = 'none';
        }

        // Refresh saved views list in modal
        function refreshSavedViewsList() {
            const listDiv = document.getElementById('saved-views-list');

            if (filterUI.savedViews.length === 0) {
                listDiv.innerHTML = '<p style="color: #999; text-align: center; padding: 20px;">No saved views yet</p>';
                return;
            }

            listDiv.innerHTML = '';

            filterUI.savedViews.forEach(view => {
                const viewDiv = document.createElement('div');
                viewDiv.className = 'saved-view-item';

                const createdDate = new Date(view.createdAt).toLocaleDateString();

                viewDiv.innerHTML = '<div style="flex: 1;">' +
                    '<strong>' + view.name + '</strong><br>' +
                    '<span style="font-size: 12px; color: #666;">' +
                    view.description + ' • Created ' + createdDate +
                    '</span>' +
                    '</div>' +
                    '<div style="display: flex; gap: 5px;">' +
                    '<button onclick="loadSavedView(\'' + view.id + '\')" class="btn btn-sm btn-primary" style="padding: 5px 10px; font-size: 12px;">Load</button>' +
                    '<button onclick="exportSavedView(\'' + view.id + '\')" class="btn btn-sm btn-secondary" style="padding: 5px 10px; font-size: 12px;">Export</button>' +
                    '<button onclick="deleteSavedView(\'' + view.id + '\')" class="btn btn-sm btn-danger" style="padding: 5px 10px; font-size: 12px;">Delete</button>' +
                    '</div>';

                listDiv.appendChild(viewDiv);
            });
        }

        // Update quick load dropdown
        function updateQuickLoadDropdown() {
            const select = document.getElementById('quick-load-view');

            select.innerHTML = '<option value="">-- Load Saved View --</option>';

            filterUI.savedViews.forEach(view => {
                const option = document.createElement('option');
                option.value = view.id;
                option.textContent = view.name;
                select.appendChild(option);
            });
        }

        // Export saved view configuration
        function exportSavedView(viewId) {
            const view = filterUI.savedViews.find(v => v.id === viewId);
            if (!view) return;

            loadSavedView(viewId);

            setTimeout(async () => {
                await exportCurrentView();
            }, 500);
        }

        // Save to localStorage
        function saveSavedViewsToStorage() {
            localStorage.setItem(
                getSavedViewsStorageKey(),
                JSON.stringify(filterUI.savedViews)
            );
        }

        // Tab switching
        function switchVisualizationTab(tabName) {
            document.querySelectorAll('.tab-nav button').forEach(btn => btn.classList.remove('active'));
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));

            event.target.classList.add('active');
            document.getElementById(tabName + '-tab').classList.add('active');

            if (tabName === 'reports') {
                generateReports();
            }
        }

        // Navigation functions
        function navigateToReports() {
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
            document.getElementById('reports-tab').classList.add('active');
            generateReports();
        }

        function navigateToGraph() {
            document.querySelectorAll('.tab-content').forEach(tab => tab.classList.remove('active'));
            document.getElementById('graph-tab').classList.add('active');
        }

        // Generate reports
        function generateReports() {
            const container = document.getElementById('reports-container');
            container.innerHTML = '<h2>Investigation Reports</h2><p>Generating reports...</p>';
            // Add report generation logic here
        }

        // Export functions
        function exportFormat(format) {
            console.log('Exporting as:', format);
            // Add export logic here
        }

        // Helper function
        function getTotalTracedSummary() {
            // Calculate total from investigation data
            return 'Calculating...';
        }

        // Initialize on load
        window.addEventListener('load', () => {
            initializeVisualization();
        });
    <\/script>
</body>
</html>
    `;
}

// Helper function for total traced summary
function getTotalTracedSummary() {
    if (!investigation.rootTotals) return 'No data';
    const totals = Object.entries(investigation.rootTotals)
        .map(([curr, amt]) => `${amt.toLocaleString()} ${curr}`)
        .join(' + ');
    return totals || 'No data';
}

// Proceed with visualization first - opens in new window
function proceedWithVisualizationFirst() {
    closeCompletionModal();

    // Open visualization.html in new window
    const newWindow = window.open('visualization.html', '_blank', 'width=1400,height=900');

    if (newWindow) {
        // Pass investigation data to the popup after it loads
        newWindow.addEventListener('load', function() {
            if (newWindow.initializeVisualization) {
                newWindow.initializeVisualization(investigation);
            }
        });
    } else {
        alert('Popup blocked! Please allow popups for this site to view visualization.');
    }
}

// Add guidance banner to visualization tab
function addVisualizationGuidanceBanner() {
    const container = document.getElementById('visualization-tab');
    if (!container) return;

    // Remove existing banner if present
    const existingBanner = container.querySelector('.workflow-guidance-banner');
    if (existingBanner) existingBanner.remove();

    const banner = document.createElement('div');
    banner.className = 'workflow-guidance-banner';
    banner.style.cssText = 'background: linear-gradient(135deg, #3498db, #2980b9); color: white; padding: 15px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 10px rgba(52, 152, 219, 0.3);';
    banner.innerHTML = `
        <div style="display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px;">
            <div>
                <h4 style="margin: 0 0 5px 0; color: white;">🌐 Fund Flow Visualization</h4>
                <p style="margin: 0; opacity: 0.95;">Review the visual representation of fund movements. Click on nodes for details.</p>
            </div>
            <button class="btn" style="background: white; color: #3498db; border: none; padding: 10px 20px; font-weight: bold;"
                    onclick="switchTab('reports'); addReportGuidanceBanner();">
                Continue to Reports →
            </button>
        </div>
    `;

    container.insertBefore(banner, container.firstChild);
}

// Add guidance banner to reports tab
function addReportGuidanceBanner() {
    const container = document.getElementById('reports-tab');
    if (!container) return;

    // Remove existing banner if present
    const existingBanner = container.querySelector('.workflow-guidance-banner');
    if (existingBanner) existingBanner.remove();

    const banner = document.createElement('div');
    banner.className = 'workflow-guidance-banner';
    banner.style.cssText = 'background: linear-gradient(135deg, #9b59b6, #8e44ad); color: white; padding: 15px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 10px rgba(155, 89, 182, 0.3);';
    banner.innerHTML = `
        <div>
            <h4 style="margin: 0 0 10px 0; color: white;">📄 Professional Report Generation</h4>
            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px; margin-top: 15px;">
                <div style="background: rgba(255, 255, 255, 0.1); padding: 10px; border-radius: 4px;">
                    <strong>Step 1:</strong> Review the Cover Page tab
                </div>
                <div style="background: rgba(255, 255, 255, 0.1); padding: 10px; border-radius: 4px;">
                    <strong>Step 2:</strong> Check Victim Index for completeness
                </div>
                <div style="background: rgba(255, 255, 255, 0.1); padding: 10px; border-radius: 4px;">
                    <strong>Step 3:</strong> Write your narrative report
                </div>
                <div style="background: rgba(255, 255, 255, 0.1); padding: 10px; border-radius: 4px;">
                    <strong>Step 4:</strong> Export final documentation
                </div>
            </div>
            <div style="margin-top: 15px; text-align: center;">
                <button class="btn" style="background: white; color: #9b59b6; border: none; padding: 10px 20px; font-weight: bold; margin-right: 10px;"
                        onclick="exportReport();">
                    💾 Export Full Report
                </button>
                <button class="btn" style="background: rgba(255, 255, 255, 0.2); color: white; border: 1px solid white; padding: 10px 20px;"
                        onclick="switchTab('visualization');">
                    ← Back to Visualization
                </button>
            </div>
        </div>
    `;

    container.insertBefore(banner, container.firstChild);
}

// Show quick export menu
function showQuickExportMenu() {
    closeCompletionModal();

    const menu = document.createElement('div');
    menu.id = 'quickExportMenu';
    menu.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 30px; border: 2px solid #e67e22; border-radius: 12px; z-index: 10001; box-shadow: 0 4px 20px rgba(0,0,0,0.15);';
    menu.innerHTML = `
        <h3 style="color: #e67e22; margin-bottom: 20px;">💾 Export Options</h3>
        <div style="display: flex; flex-direction: column; gap: 12px;">
            <button class="btn btn-primary" style="background: #e67e22; padding: 12px;"
                    onclick="exportReport(); document.getElementById('quickExportMenu').remove();">
                📋 Export B.A.T.S. Report (PDF/HTML)
            </button>
            <button class="btn" style="padding: 12px;"
                    onclick="exportJSON(); document.getElementById('quickExportMenu').remove();">
                📄 Export JSON Data
            </button>
            <button class="btn" style="padding: 12px;"
                    onclick="exportCSV(); document.getElementById('quickExportMenu').remove();">
                📊 Export CSV Spreadsheet
            </button>
            <button class="btn" style="padding: 12px;"
                    onclick="saveInvestigationFile(); document.getElementById('quickExportMenu').remove();">
                💾 Save Investigation File
            </button>
            <button class="btn btn-secondary" style="padding: 12px;"
                    onclick="document.getElementById('quickExportMenu').remove();">
                Cancel
            </button>
        </div>
    `;
    document.body.appendChild(menu);
}

// Skip directly to reports
function proceedDirectlyToReports() {
    console.log('proceedDirectlyToReports called');
    closeCompletionModal();

    // Show the reports tab
    document.querySelectorAll('.tab-content').forEach(tab => {
        tab.style.display = 'none';
        tab.classList.remove('active');
    });

    const reportsTab = document.getElementById('reports-tab');
    console.log('Reports tab element:', reportsTab);
    if (reportsTab) {
        reportsTab.style.display = 'block';
        reportsTab.classList.add('active');
        console.log('Reports tab shown');
    } else {
        console.error('Reports tab not found in DOM!');
    }

    // Activate the reports nav tab
    document.querySelectorAll('.nav-tab').forEach(tab => {
        tab.classList.remove('active');
    });
    const reportsNavTab = document.querySelector('[onclick="switchTab(\'reports\')"]');
    if (reportsNavTab) {
        reportsNavTab.classList.add('active');
    }

    // Show navigation tabs
    const navTabs = document.getElementById('mainNavTabs');
    if (navTabs) {
        navTabs.style.display = 'flex';
    }

    // Generate report content
    console.log('Generating report content...');
    generateReportContent();
    console.log('Report content generation complete');

    // Show audit trail by default
    switchReportTab('audit-trail');
}

// Switch between report sub-tabs
function switchReportTab(tabName) {
    // Hide all report sections
    document.querySelectorAll('.report-section').forEach(section => {
        section.style.display = 'none';
    });

    // Reset all tab button styles
    document.getElementById('report-tab-audit').style.background = '#95a5a6';
    document.getElementById('report-tab-indexes').style.background = '#95a5a6';
    document.getElementById('report-tab-narrative').style.background = '#95a5a6';

    // Show selected section and highlight button
    if (tabName === 'audit-trail') {
        document.getElementById('report-audit-trail-section').style.display = 'block';
        document.getElementById('report-tab-audit').style.background = '#3498db';
    } else if (tabName === 'indexes') {
        document.getElementById('report-indexes-section').style.display = 'block';
        document.getElementById('report-tab-indexes').style.background = '#e74c3c';
    } else if (tabName === 'narrative') {
        document.getElementById('report-narrative-section').style.display = 'block';
        document.getElementById('report-tab-narrative').style.background = '#27ae60';
        // Load saved narrative if exists
        loadNarrative();
    }
}

// Switch between wallet index views
function showWalletIndex(indexType) {
    // Hide all index views
    document.querySelectorAll('.wallet-index-view').forEach(view => {
        view.style.display = 'none';
    });

    // Reset all index button styles
    document.getElementById('index-btn-universal').style.background = '#95a5a6';
    document.getElementById('index-btn-red').style.background = '#95a5a6';
    document.getElementById('index-btn-purple').style.background = '#95a5a6';

    // Show selected index and highlight button
    if (indexType === 'universal') {
        document.getElementById('wallet-index-universal').style.display = 'block';
        document.getElementById('index-btn-universal').style.background = '#34495e';
    } else if (indexType === 'red') {
        document.getElementById('wallet-index-red').style.display = 'block';
        document.getElementById('index-btn-red').style.background = '#e74c3c';
    } else if (indexType === 'purple') {
        document.getElementById('wallet-index-purple').style.display = 'block';
        document.getElementById('index-btn-purple').style.background = '#9b59b6';
    }
}

// Save investigation narrative
function saveNarrative() {
    const textarea = document.getElementById('report-narrative-textarea');
    const narrative = textarea.value;

    // Save to investigation object
    if (!investigation.metadata) {
        investigation.metadata = {};
    }
    investigation.metadata.narrative = narrative;
    investigation.metadata.narrativeLastUpdated = new Date().toISOString();

    // Show save confirmation
    const status = document.getElementById('narrative-save-status');
    status.textContent = '✓ Saved';
    setTimeout(() => {
        status.textContent = '';
    }, 2000);

    // Auto-save to file if filepath exists
    if (investigation.filePath) {
        saveInvestigationSilent();
    }
}

// Load saved narrative
function loadNarrative() {
    const textarea = document.getElementById('report-narrative-textarea');
    if (investigation.metadata && investigation.metadata.narrative) {
        textarea.value = investigation.metadata.narrative;
    }
}

// Export complete investigation report in printable format
function exportCompleteReport() {
    // Generate complete HTML report
    const reportHTML = generatePrintableReport();

    // Create blob and download
    const blob = new Blob([reportHTML], { type: 'text/html' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `BATS_Report_${investigation.caseId || 'Investigation'}_${new Date().toISOString().split('T')[0]}.html`;
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);

    // Show success message
    alert('Report exported successfully! Open the HTML file in your browser and use Print to PDF.');
}

function generatePrintableReport() {
    const caseId = investigation.caseId || 'N/A';
    const investigator = investigation.investigator || 'N/A';
    const agency = investigation.agency || 'N/A';
    const caseType = investigation.caseType || 'N/A';
    const dateOpened = investigation.dateOpened || new Date().toISOString().split('T')[0];
    const summary = investigation.summary || 'No summary provided';
    const narrative = (investigation.metadata && investigation.metadata.narrative) || 'No narrative provided';

    // Get wallet indexes HTML
    const universalIndexHTML = document.getElementById('report-universal-index').innerHTML || '<p>No wallets</p>';
    const redIndexHTML = document.getElementById('report-red-index').innerHTML || '<p>No victim wallets</p>';
    const purpleIndexHTML = document.getElementById('report-purple-index').innerHTML || '<p>No terminal wallets</p>';

    // Get technical audit trail HTML
    const auditTrailHTML = document.getElementById('report-technical-content').innerHTML || '<p>No audit trail</p>';

    // Calculate totals
    const rootTotals = investigation.confirmedRootTotalsByCurrency || {};
    const rootTotalsDisplay = Object.entries(rootTotals)
        .map(([curr, amt]) => `${amt.toLocaleString()} ${curr}`)
        .join(' + ') || 'N/A';

    const hopCount = investigation.hops ? investigation.hops.length : 0;
    const victimCount = investigation.victims ? investigation.victims.length : 0;

    return `<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>B.A.T.S. Investigation Report - ${caseId}</title>
    <style>
        @media print {
            .page-break { page-break-before: always; }
            body { margin: 0; }
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            line-height: 1.6;
            color: #2c3e50;
            max-width: 8.5in;
            margin: 0 auto;
            padding: 0.5in;
            background: white;
        }

        .cover-page {
            text-align: center;
            padding: 2in 0;
            min-height: 9in;
        }

        .cover-title {
            font-size: 36px;
            font-weight: bold;
            color: #2c3e50;
            margin-bottom: 20px;
            border-bottom: 4px solid #3498db;
            padding-bottom: 20px;
        }

        .cover-subtitle {
            font-size: 24px;
            color: #7f8c8d;
            margin-bottom: 40px;
        }

        .cover-case-id {
            font-size: 32px;
            font-weight: bold;
            color: #e74c3c;
            margin: 40px 0;
            padding: 20px;
            border: 3px solid #e74c3c;
            display: inline-block;
        }

        .cover-info {
            text-align: left;
            max-width: 500px;
            margin: 40px auto;
            font-size: 16px;
        }

        .cover-info table {
            width: 100%;
            border-collapse: collapse;
        }

        .cover-info td {
            padding: 10px;
            border-bottom: 1px solid #ecf0f1;
        }

        .cover-info td:first-child {
            font-weight: bold;
            width: 40%;
        }

        .cover-footer {
            position: absolute;
            bottom: 1in;
            left: 0;
            right: 0;
            text-align: center;
            font-size: 12px;
            color: #95a5a6;
        }

        .section-title {
            font-size: 28px;
            font-weight: bold;
            color: #2c3e50;
            margin-top: 40px;
            margin-bottom: 20px;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }

        .subsection-title {
            font-size: 20px;
            font-weight: bold;
            color: #34495e;
            margin-top: 30px;
            margin-bottom: 15px;
        }

        table {
            width: 100%;
            border-collapse: collapse;
            margin-bottom: 30px;
            font-size: 13px;
        }

        table th {
            background: #34495e;
            color: white;
            padding: 12px;
            text-align: left;
            font-weight: bold;
        }

        table td {
            padding: 10px;
            border-bottom: 1px solid #ecf0f1;
        }

        table tr:nth-child(even) {
            background: #f8f9fa;
        }

        .narrative-text {
            white-space: pre-wrap;
            background: #f8f9fa;
            padding: 20px;
            border-radius: 8px;
            border-left: 4px solid #27ae60;
            font-size: 14px;
            line-height: 1.8;
        }

        .toc {
            margin: 40px 0;
        }

        .toc-item {
            padding: 10px 0;
            border-bottom: 1px dotted #bdc3c7;
            font-size: 16px;
        }

        .toc-item strong {
            color: #2c3e50;
        }

        .index-description {
            font-size: 14px;
            color: #7f8c8d;
            font-style: italic;
            margin-bottom: 15px;
        }

        code {
            background: #f4f4f4;
            padding: 2px 6px;
            border-radius: 3px;
            font-family: 'Courier New', monospace;
            font-size: 11px;
            word-break: break-all;
        }

        .header {
            text-align: center;
            padding: 20px 0;
            border-bottom: 2px solid #3498db;
            margin-bottom: 30px;
        }

        .header h1 {
            margin: 0;
            color: #2c3e50;
            font-size: 24px;
        }

        .header .case-info {
            font-size: 14px;
            color: #7f8c8d;
            margin-top: 10px;
        }
    </style>
</head>
<body>

<!-- COVER PAGE -->
<div class="cover-page">
    <div class="cover-title">B.A.T.S. Investigation Report</div>
    <div class="cover-subtitle">Blockchain Asset Tracing Standard</div>

    <div class="cover-case-id">Case #${caseId}</div>

    <div class="cover-info">
        <table>
            <tr>
                <td>Investigation Agency:</td>
                <td>${agency}</td>
            </tr>
            <tr>
                <td>Lead Investigator:</td>
                <td>${investigator}</td>
            </tr>
            <tr>
                <td>Case Type:</td>
                <td>${caseType}</td>
            </tr>
            <tr>
                <td>Date Opened:</td>
                <td>${dateOpened}</td>
            </tr>
            <tr>
                <td>Report Generated:</td>
                <td>${new Date().toLocaleString()}</td>
            </tr>
            <tr>
                <td>Total Traced:</td>
                <td>${rootTotalsDisplay}</td>
            </tr>
            <tr>
                <td>Victims:</td>
                <td>${victimCount}</td>
            </tr>
            <tr>
                <td>Hops Traced:</td>
                <td>${hopCount}</td>
            </tr>
        </table>
    </div>

    <div style="margin-top: 60px; padding: 20px; background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; text-align: left;">
        <strong style="color: #856404;">Case Summary:</strong>
        <p style="margin-top: 10px; color: #333;">${summary}</p>
    </div>

    <div class="cover-footer">
        <strong>CONFIDENTIAL INVESTIGATION REPORT</strong><br>
        For Law Enforcement Use Only
    </div>
</div>

<!-- TABLE OF CONTENTS -->
<div class="page-break"></div>
<div class="header">
    <h1>Table of Contents</h1>
    <div class="case-info">Case #${caseId} | ${investigator}</div>
</div>

<div class="toc">
    <div class="toc-item"><strong>1.</strong> Universal Wallet Index</div>
    <div class="toc-item"><strong>2.</strong> Red Wallet Index (Bad Actor Wallets)</div>
    <div class="toc-item"><strong>3.</strong> Purple Wallet Index (Terminal Wallets)</div>
    <div class="toc-item"><strong>4.</strong> Investigation Narrative</div>
    <div class="toc-item"><strong>5.</strong> Technical Audit Trail</div>
</div>

<!-- UNIVERSAL WALLET INDEX -->
<div class="page-break"></div>
<div class="header">
    <h1>Section 1: Universal Wallet Index</h1>
    <div class="case-info">Case #${caseId} | ${investigator}</div>
</div>

<p class="index-description">
    Complete chronological record of all blockchain addresses encountered during this investigation,
    listed in order of first appearance during the trace.
</p>

${universalIndexHTML}

<!-- RED WALLET INDEX -->
<div class="page-break"></div>
<div class="header">
    <h1>Section 2: Red Wallet Index</h1>
    <div class="case-info">Case #${caseId} | ${investigator}</div>
</div>

<p class="index-description">
    Blockchain addresses belonging to identified victims that received stolen or illicit funds.
    These represent the initial entry points of traced assets.
</p>

${redIndexHTML}

<!-- PURPLE WALLET INDEX -->
<div class="page-break"></div>
<div class="header">
    <h1>Section 3: Purple Wallet Index</h1>
    <div class="case-info">Case #${caseId} | ${investigator}</div>
</div>

<p class="index-description">
    Terminal destinations including cryptocurrency exchange deposit addresses and other endpoints
    where traced funds cannot be followed further without additional investigative tools.
</p>

${purpleIndexHTML}

<!-- NARRATIVE -->
<div class="page-break"></div>
<div class="header">
    <h1>Section 4: Investigation Narrative</h1>
    <div class="case-info">Case #${caseId} | ${investigator}</div>
</div>

<div class="narrative-text">${narrative}</div>

<!-- TECHNICAL AUDIT TRAIL -->
<div class="page-break"></div>
<div class="header">
    <h1>Section 5: Technical Audit Trail</h1>
    <div class="case-info">Case #${caseId} | ${investigator}</div>
</div>

<p class="index-description">
    Detailed transaction-by-transaction flow analysis documenting the movement of traced assets
    through the blockchain, including all transaction hashes, timestamps, and allocations.
</p>

${auditTrailHTML}

<!-- FOOTER -->
<div style="margin-top: 60px; padding: 20px; background: #f8f9fa; border-top: 2px solid #bdc3c7; text-align: center; font-size: 12px; color: #7f8c8d;">
    <p><strong>Report Generated:</strong> ${new Date().toLocaleString()}</p>
    <p><strong>Generated with:</strong> B.A.T.S. (Blockchain Asset Tracing Standard) Tool</p>
    <p style="margin-top: 15px; font-size: 10px;">
        This report contains confidential law enforcement information. Unauthorized disclosure is prohibited.
    </p>
</div>

</body>
</html>`;
}

function generateReportContent() {
    // Update case info with safety checks
    const caseIdEl = document.getElementById('report-case-id');
    const investigatorEl = document.getElementById('report-investigator');
    const dateEl = document.getElementById('report-date');

    if (caseIdEl) caseIdEl.textContent = investigation.caseId || 'N/A';
    if (investigatorEl) investigatorEl.textContent = investigation.investigator || 'N/A';
    if (dateEl) dateEl.textContent = investigation.dateOpened || new Date().toISOString().split('T')[0];

    // Generate wallet indexes
    generateReportUniversalIndex();
    generateReportRedIndex();
    generateReportPurpleIndex();

    // Generate technical audit trail
    generateTechnicalAuditTrail();
}

function generateReportUniversalIndex() {
    const container = document.getElementById('report-universal-index');
    if (!container) return;

    console.log('Universal Wallet Index:', investigation.universalWalletIndex);
    const wallets = investigation.universalWalletIndex || [];
    console.log('Wallets array length:', wallets.length);
    if (wallets.length === 0) {
        container.innerHTML = '<p style="color: #7f8c8d; font-style: italic;">No wallets in index</p>';
        return;
    }

    let html = '<table style="width: 100%; border-collapse: collapse; font-size: 13px;">';
    html += '<thead><tr style="background: #34495e; color: white;">';
    html += '<th style="padding: 10px; text-align: left;">Wallet ID</th>';
    html += '<th style="padding: 10px; text-align: left;">Type</th>';
    html += '<th style="padding: 10px; text-align: left;">Address</th>';
    html += '<th style="padding: 10px; text-align: left;">First Seen</th>';
    html += '</tr></thead><tbody>';

    wallets.forEach((wallet, index) => {
        const bgColor = index % 2 === 0 ? '#f8f9fa' : '#ffffff';
        html += `<tr style="background: ${bgColor};">`;
        html += `<td style="padding: 8px;"><strong>${wallet.permanentId}</strong></td>`;
        html += `<td style="padding: 8px;">${wallet.permanentType}</td>`;
        html += `<td style="padding: 8px; font-family: monospace; font-size: 11px;">${wallet.address}</td>`;
        html += `<td style="padding: 8px;">${wallet.firstSeen || 'N/A'}</td>`;
        html += '</tr>';
    });

    html += '</tbody></table>';
    container.innerHTML = html;
}

function generateReportRedIndex() {
    const container = document.getElementById('report-red-index');
    if (!container) return;

    const redWallets = investigation.redWalletIndex || [];
    if (redWallets.length === 0) {
        container.innerHTML = '<p style="color: #7f8c8d; font-style: italic;">No bad actor wallets</p>';
        return;
    }

    let html = '<table style="width: 100%; border-collapse: collapse; font-size: 13px;">';
    html += '<thead><tr style="background: #e74c3c; color: white;">';
    html += '<th style="padding: 10px; text-align: left;">Wallet ID</th>';
    html += '<th style="padding: 10px; text-align: left;">V-T Notation</th>';
    html += '<th style="padding: 10px; text-align: left;">Address</th>';
    html += '<th style="padding: 10px; text-align: left;">Amount Received</th>';
    html += '</tr></thead><tbody>';

    redWallets.forEach((wallet, index) => {
        const bgColor = index % 2 === 0 ? '#ffebee' : '#ffffff';
        html += `<tr style="background: ${bgColor};">`;
        html += `<td style="padding: 8px;"><strong>${wallet.walletId || 'N/A'}</strong></td>`;
        html += `<td style="padding: 8px;">${wallet.vtNotation || 'N/A'}</td>`;
        html += `<td style="padding: 8px; font-family: monospace; font-size: 11px;">${wallet.walletAddress || 'N/A'}</td>`;
        html += `<td style="padding: 8px;">${(wallet.amount || 0).toLocaleString()} ${wallet.currency || ''}</td>`;
        html += '</tr>';
    });

    html += '</tbody></table>';
    container.innerHTML = html;
}

function generateReportPurpleIndex() {
    const container = document.getElementById('report-purple-index');
    if (!container) return;

    const purpleWallets = investigation.terminalWalletIndex || [];
    if (purpleWallets.length === 0) {
        container.innerHTML = '<p style="color: #7f8c8d; font-style: italic;">No terminal/exchange wallets</p>';
        return;
    }

    let html = '<table style="width: 100%; border-collapse: collapse; font-size: 13px;">';
    html += '<thead><tr style="background: #9b59b6; color: white;">';
    html += '<th style="padding: 10px; text-align: left;">Exchange</th>';
    html += '<th style="padding: 10px; text-align: left;">Address</th>';
    html += '<th style="padding: 10px; text-align: left;">Amount</th>';
    html += '<th style="padding: 10px; text-align: left;">Notation</th>';
    html += '<th style="padding: 10px; text-align: left;">Hop</th>';
    html += '</tr></thead><tbody>';

    purpleWallets.forEach((wallet, index) => {
        const bgColor = index % 2 === 0 ? '#f3e5ff' : '#ffffff';
        html += `<tr style="background: ${bgColor};">`;
        html += `<td style="padding: 8px;"><strong>${wallet.exchangeName || wallet.walletLabel || 'Unknown'}</strong></td>`;
        html += `<td style="padding: 8px; font-family: monospace; font-size: 11px;">${wallet.walletAddress || wallet.toWallet || 'N/A'}</td>`;
        html += `<td style="padding: 8px;">${(wallet.amount || 0).toLocaleString()} ${wallet.currency || ''}</td>`;
        html += `<td style="padding: 8px;">${wallet.notation || 'N/A'}</td>`;
        html += `<td style="padding: 8px;">H${wallet.hopNumber || 'N/A'}</td>`;
        html += '</tr>';
    });

    html += '</tbody></table>';
    container.innerHTML = html;
}

// Generate flow visualization if not already defined
function generateFlowVisualization() {
    if (typeof initializeGraphVisualization === 'function') {
        initializeGraphVisualization();
    } else {
        console.log('Visualization function will initialize when tab is opened');
    }
}

// Simple proceed functions for cards
function proceedToVisualization() {
    // Close the modal first
    const modal = document.getElementById('completionWorkflowModal');
    if (modal) modal.remove();

    // Then proceed to visualization
    proceedWithVisualizationFirst();
}

function proceedToReports() {
    proceedDirectlyToReports();
}

function showExportOptions() {
    closeCompletionModal();
    // Show export menu
    const menu = document.createElement('div');
    menu.style.cssText = 'position: fixed; top: 50%; left: 50%; transform: translate(-50%, -50%); background: white; padding: 20px; border: 2px solid #3498db; border-radius: 8px; z-index: 10001;';
    menu.innerHTML = `
        <h3>Export Options:</h3>
        <div style="display: flex; flex-direction: column; gap: 10px; margin-top: 15px;">
            <button class="btn btn-primary" onclick="exportReport(); this.parentElement.parentElement.remove();">📋 B.A.T.S. Report</button>
            <button class="btn" onclick="exportJSON(); this.parentElement.parentElement.remove();">📄 JSON Data</button>
            <button class="btn" onclick="exportCSV(); this.parentElement.parentElement.remove();">📊 CSV Format</button>
            <button class="btn btn-secondary" onclick="this.parentElement.parentElement.remove();">Cancel</button>
        </div>
    `;
    document.body.appendChild(menu);
}

// Analyze wallet behaviors for classification suggestions
function analyzeWalletBehaviors(hop) {
    const suggestions = [];
    const walletAnalysis = {};
    
    // Analyze each wallet in the hop
    hop.entries.forEach(entry => {
        if (entry.entryType === 'trace' && entry.toWallet) {
            const wallet = entry.toWallet;
            if (!walletAnalysis[wallet]) {
                walletAnalysis[wallet] = {
                    incomingCount: 0,
                    outgoingCount: 0,
                    currencies: new Set(),
                    totalAmount: 0,
                    currentType: entry.toWalletType || 'black'
                };
            }
            walletAnalysis[wallet].incomingCount++;
            walletAnalysis[wallet].currencies.add(entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency);
            walletAnalysis[wallet].totalAmount += parseFloat(entry.amount);
        }
    });
    
    // Check previous hops for outgoing transactions
    investigation.hops.forEach(h => {
        if (h.id !== hop.hopNumber) {
            h.entries.forEach(entry => {
                if (entry.entryType === 'trace' && entry.fromWallet && walletAnalysis[entry.fromWallet]) {
                    walletAnalysis[entry.fromWallet].outgoingCount++;
                }
            });
        }
    });
    
    // Generate suggestions based on behavior
    Object.entries(walletAnalysis).forEach(([wallet, analysis]) => {
        // Yellow wallet: Multiple incoming transactions (convergence)
        if (analysis.incomingCount >= 2 && analysis.currentType !== 'yellow') {
            suggestions.push({
                wallet: wallet,
                suggestedType: 'yellow',
                reason: `Convergence detected: ${analysis.incomingCount} incoming transactions`,
                currentType: analysis.currentType
            });
        }
        
        // Brown wallet: Multiple currencies (conversion)
        if (analysis.currencies.size > 1 && analysis.currentType !== 'brown') {
            suggestions.push({
                wallet: wallet,
                suggestedType: 'brown',
                reason: `Conversion detected: handles ${analysis.currencies.size} different currencies`,
                currentType: analysis.currentType
            });
        }
        
        // Blue wallet logic removed - will be handled at hop finalization
        // when we can properly identify wallets with untraced remaining balances
    });
    
    return suggestions;
}

// Show wallet classification suggestions
function showWalletClassificationSuggestions(hop, suggestions) {
    const modalHTML = `
        <div id="walletSuggestionsModal" class="modal" style="display: block;">
            <div class="modal-content" style="max-width: 800px;">
                <div class="modal-header">
                    <h2>🔍 Wallet Classification Suggestions</h2>
                    <p>Based on transaction patterns, we suggest updating these wallet classifications:</p>
                </div>
                
                <div style="margin: 20px 0;">
                    ${suggestions.map((suggestion, index) => `
                        <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid ${getWalletColor(suggestion.suggestedType)};">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <strong style="font-family: monospace;">${suggestion.wallet.substring(0, 20)}...</strong><br>
                                    <span style="color: #666;">Current: ${walletTypes[suggestion.currentType] || suggestion.currentType}</span><br>
                                    <span style="color: ${getWalletColor(suggestion.suggestedType)};">Suggested: ${walletTypes[suggestion.suggestedType]}</span><br>
                                    <small style="color: #666;">${suggestion.reason}</small>
                                </div>
                                <div>
                                    <button class="btn btn-confirm" onclick="acceptWalletSuggestion('${suggestion.wallet}', '${suggestion.suggestedType}', ${index})">
                                        ✅ Accept
                                    </button>
                                    <button class="btn btn-secondary" onclick="declineWalletSuggestion(${index})">
                                        ❌ Decline
                                    </button>
                                </div>
                            </div>
                        </div>
                    `).join('')}
                </div>
                
                <div style="text-align: center;">
                    <button class="btn btn-confirm" onclick="completeWalletSuggestions(${hop.hopNumber})">
                        Continue to Complete Hop ${hop.hopNumber}
                    </button>
                </div>
            </div>
        </div>
    `;
    
    createCenteredModal('walletSuggestionsModal', modalHTML);
}

// Accept wallet classification suggestion
function acceptWalletSuggestion(walletAddress, newType, suggestionIndex) {
    // Use the new authorization system
    const success = updateWalletClassificationWithAuth(walletAddress, newType, false);
    
    if (success) {
        // Hide this suggestion
        const suggestionDiv = document.querySelectorAll('#walletSuggestionsModal .modal-content > div')[1].children[suggestionIndex];
        suggestionDiv.style.display = 'none';
    }
    
    saveToStorage();
}

// Decline wallet classification suggestion
function declineWalletSuggestion(suggestionIndex) {
    const suggestionDiv = document.querySelectorAll('#walletSuggestionsModal .modal-content > div')[1].children[suggestionIndex];
    suggestionDiv.style.display = 'none';
}

// Complete wallet suggestions and finalize hop
function completeWalletSuggestions(hopNumber) {
    const modal = document.getElementById('walletSuggestionsModal');
    if (modal) modal.remove();
    
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    if (hop) {
        completeHopAndCreateNext(hop);
    }
}

// Open Smart Allocation Modal
function openSmartAllocationModal(hopNumber, entryId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    
    if (!hop || !entry) {
        alert('Error: Could not find hop or entry');
        return;
    }
    
    // Store current context
    window.smartAllocationContext = {
        hopNumber: hopNumber,
        entryId: entryId,
        hop: hop,
        entry: entry
    };
    
    // Get available currencies from sources
    const availableSourcesAll = getAvailableSourcesForHop(hop.hopNumber, null);
    const availableCurrencies = [...new Set(availableSourcesAll.map(s => s.currency))];
    
    // Populate currency dropdown
    const currencySelect = document.getElementById('smartAllocationTargetCurrency');
    currencySelect.innerHTML = '<option value="">Select currency...</option>' + 
        availableCurrencies.map(curr => {
            const currencyName = currencies[curr]?.name || curr;
            return `<option value="${curr}">${currencyName}</option>`;
        }).join('');
    
    // Clear previous state
    document.getElementById('smartAllocationTargetAmount').value = '';
    document.getElementById('smartAllocationAvailableSources').style.display = 'none';
    document.getElementById('smartAllocationPreview').style.display = 'none';
    document.getElementById('smartAllocationError').style.display = 'none';
    document.getElementById('confirmSmartAllocation').style.display = 'none';
    
    // Show modal
    showModal('smartAllocationModal');
    
    // Add event listeners
    document.getElementById('smartAllocationTargetAmount').addEventListener('input', updateSmartAllocationPreview);
    document.getElementById('smartAllocationTargetCurrency').addEventListener('change', function() {
        // Update step value when currency changes
        const currency = this.value;
        const amountInput = document.getElementById('smartAllocationTargetAmount');
        if (currency && amountInput) {
            amountInput.step = getCurrencyStep(currency);
        }
        updateSmartAllocationPreview();
    });
}

// Close Smart Allocation Modal
function closeSmartAllocationModal() {
    hideModal('smartAllocationModal');
    window.smartAllocationContext = null;
}

// Update Smart Allocation Preview
function updateSmartAllocationPreview() {
    const targetAmount = parseFloat(document.getElementById('smartAllocationTargetAmount').value);
    const targetCurrency = document.getElementById('smartAllocationTargetCurrency').value;
    
    if (!targetAmount || !targetCurrency || targetAmount <= 0) {
        document.getElementById('smartAllocationAvailableSources').style.display = 'none';
        document.getElementById('smartAllocationPreview').style.display = 'none';
        document.getElementById('smartAllocationError').style.display = 'none';
        document.getElementById('confirmSmartAllocation').style.display = 'none';
        return;
    }
    
    const context = window.smartAllocationContext;
    if (!context) return;
    
    // Get available sources for this currency
    const availableSources = getAvailableSourcesForHop(context.hop.hopNumber, targetCurrency);
    
    // Show available sources
    const sourcesListDiv = document.getElementById('availableSourcesList');
    sourcesListDiv.innerHTML = availableSources.map(source => `
        <div style="padding: 10px; margin-bottom: 5px; background: #f8f9fa; border-radius: 6px; border-left: 4px solid #3498db;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <strong>${source.threadId}</strong>
                <span style="color: #27ae60; font-weight: bold;">${source.availableAmount.toLocaleString()} ${source.currency}</span>
            </div>
            <div style="font-size: 11px; color: #666; margin-top: 3px;">
                ${source.sourceType === 'victim_transaction' ? 'Victim Transaction (RED Wallet)' : 'Previous Hop Output'}
            </div>
        </div>
    `).join('');
    document.getElementById('smartAllocationAvailableSources').style.display = 'block';
    
    // Calculate allocation
    const allocation = calculateSmartAllocation(availableSources, targetAmount);
    
    if (allocation.error) {
        document.getElementById('smartAllocationError').innerHTML = `⚠️ ${allocation.error}`;
        document.getElementById('smartAllocationError').style.display = 'block';
        document.getElementById('smartAllocationPreview').style.display = 'none';
        document.getElementById('confirmSmartAllocation').style.display = 'none';
    } else {
        document.getElementById('smartAllocationError').style.display = 'none';
        
        // Show allocation preview
        const previewContent = document.getElementById('allocationPreviewContent');
        previewContent.innerHTML = `
            <div style="background: #f8f9fa; border: 1px solid #ddd; border-radius: 6px; padding: 15px;">
                ${allocation.allocations.map(alloc => `
                    <div style="margin-bottom: 10px; padding: 10px; background: white; border-radius: 4px; border-left: 4px solid ${alloc.fullyUsed ? '#e74c3c' : '#27ae60'};">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <strong>${alloc.threadId}</strong>
                            <span style="color: ${alloc.fullyUsed ? '#e74c3c' : '#27ae60'};">
                                Use ${alloc.amountToUse.toLocaleString()} of ${alloc.availableAmount.toLocaleString()} ${targetCurrency}
                            </span>
                        </div>
                        ${alloc.fullyUsed ? 
                            '<div style="font-size: 11px; color: #e74c3c; margin-top: 3px;">✓ Fully depleted</div>' : 
                            `<div style="font-size: 11px; color: #666; margin-top: 3px;">${alloc.remaining.toLocaleString()} ${targetCurrency} will remain</div>`
                        }
                    </div>
                `).join('')}
                
                <div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid #ddd;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <strong>Total Allocated:</strong>
                        <span style="color: #27ae60; font-size: 18px; font-weight: bold;">
                            ${allocation.totalAllocated.toLocaleString()} ${targetCurrency}
                        </span>
                    </div>
                    ${allocation.totalAllocated < targetAmount ? 
                        `<div style="color: #e74c3c; font-size: 12px; margin-top: 5px;">
                            ⚠️ Only ${allocation.totalAllocated.toLocaleString()} of ${targetAmount.toLocaleString()} ${targetCurrency} available
                        </div>` : ''
                    }
                </div>
            </div>
        `;
        
        document.getElementById('smartAllocationPreview').style.display = 'block';
        document.getElementById('confirmSmartAllocation').style.display = 'inline-block';
        
        // Store allocation for confirmation
        window.smartAllocationContext.allocation = allocation;
        window.smartAllocationContext.targetCurrency = targetCurrency;
    }
}

// Calculate Smart Allocation
function calculateSmartAllocation(sources, targetAmount) {
    let remainingAmount = targetAmount;
    const allocations = [];
    let totalAllocated = 0;
    
    for (const source of sources) {
        if (remainingAmount <= 0) break;
        
        const amountToUse = Math.min(source.availableAmount, remainingAmount);
        allocations.push({
            threadId: source.threadId,
            availableAmount: source.availableAmount,
            amountToUse: amountToUse,
            remaining: source.availableAmount - amountToUse,
            fullyUsed: amountToUse === source.availableAmount
        });
        
        totalAllocated += amountToUse;
        remainingAmount -= amountToUse;
    }
    
    if (totalAllocated < targetAmount) {
        const totalAvailable = sources.reduce((sum, s) => sum + s.availableAmount, 0);
        if (totalAvailable < targetAmount) {
            return {
                error: `Insufficient funds. Only ${totalAvailable.toLocaleString()} available, but ${targetAmount.toLocaleString()} requested.`,
                totalAvailable: totalAvailable
            };
        }
    }
    
    return {
        allocations: allocations,
        totalAllocated: totalAllocated,
        success: true
    };
}

// Confirm and Apply Smart Allocation
function confirmSmartAllocation() {
    const context = window.smartAllocationContext;
    if (!context || !context.allocation) return;
    
    const entry = context.entry;
    const allocation = context.allocation;
    const targetCurrency = context.targetCurrency;
    
    // Set up multiple source threads
    entry.multipleSourceThreads = allocation.allocations.map(a => a.threadId);
    entry.individualSourceAssignments = {};
    allocation.allocations.forEach(alloc => {
        entry.individualSourceAssignments[alloc.threadId] = alloc.amountToUse;
    });
    
    // Set total amount and currency, preserving full precision
    entry.amount = formatCurrencyAmount(allocation.totalAllocated, targetCurrency, true);
    entry.currency = targetCurrency;
    
    // Mark as convergence if multiple sources and apply Sequential Hop Rule
    if (allocation.allocations.length > 1) {
        entry.isConvergence = true;
        
        // Apply Sequential Hop Rule: find the highest hop number among converging paths
        let maxSourceHopNumber = 0;
        let allSourcesAreBridgeOutputs = true;
        let bridgeOutputHopNumber = null;

        allocation.allocations.forEach(alloc => {
            // Check if this is a bridge output thread (starts with "bridge_")
            const isBridgeOutput = alloc.threadId.startsWith('bridge_');

            if (!isBridgeOutput) {
                allSourcesAreBridgeOutputs = false;
            }

            // Extract hop number from notation or bridge ID
            let sourceHopNumber = 0;
            if (isBridgeOutput) {
                // Bridge outputs don't have -H notation, they're created in the current hop
                // Extract from the entry ID part: bridge_{entryId}_{currency}_{timestamp}_{random}
                // The entry belongs to the current hop being edited
                sourceHopNumber = entry.hopNumber || 1;
                bridgeOutputHopNumber = sourceHopNumber;
            } else {
                const threadMatch = alloc.threadId.match(/-H(\d+)$/);
                if (threadMatch) {
                    sourceHopNumber = parseInt(threadMatch[1]);
                }
            }
            maxSourceHopNumber = Math.max(maxSourceHopNumber, sourceHopNumber);
        });

        // The convergence output should be at maxHop + 1 ONLY if sources are from different hops
        // If all sources are bridge outputs from the SAME hop, stay in that hop (no hop increment for swaps/conversions)
        if (investigation.tracingMethod === 'PIFO') {
            if (allSourcesAreBridgeOutputs && bridgeOutputHopNumber !== null) {
                // Bridge outputs consumed in same hop = no hop increment
                entry.hopNumber = bridgeOutputHopNumber;
                console.log(`ℹ️ Bridge outputs consumed in same hop ${entry.hopNumber} - no hop increment`);
            } else {
                // Normal convergence from different threads/hops = apply Sequential Hop Rule
                entry.hopNumber = maxSourceHopNumber + 1;

                // Show notification about Sequential Hop Rule application
                showNotification(
                    `Sequential Hop Rule applied: Convergence of ${allocation.allocations.length} sources at hop ${entry.hopNumber}`,
                    'info'
                );
            }
        }
        
        entry.convergenceData = {
            sourceCount: allocation.allocations.length,
            sources: allocation.allocations,
            maxSourceHop: maxSourceHopNumber,
            sequentialHopRuleApplied: true
        };
    }
    
    // Close modal
    closeSmartAllocationModal();
    
    // Re-render the hop entries
    renderHops();
    saveToStorage();
    
    alert(` Smart allocation applied: ${allocation.totalAllocated.toLocaleString()} ${targetCurrency} allocated across ${allocation.allocations.length} source(s)`);
}

// Original smart allocation function (keep for compatibility)
function smartAllocateAmount(hopNumber, entryId) {
    // Redirect to the new modal-based approach
    openSmartAllocationModal(hopNumber, entryId);
}

// Clear all allocations
function clearAllAllocations(hopNumber, entryId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    
    entry.multipleSourceThreads = [];
    entry.individualSourceAssignments = {};
    entry.sourceThreadId = '';
    entry.amount = '';
    
    const previewDiv = document.getElementById(`smartAllocationPreview_${hopNumber}_${entryId}`);
    if (previewDiv) {
        previewDiv.innerHTML = '';
    }
    
    const targetAmountInput = document.getElementById(`targetAmount_${hopNumber}_${entryId}`);
    if (targetAmountInput) {
        targetAmountInput.value = '';
    }
    
    renderHops();
    saveToStorage();
}

// Get wallet color based on type
function getWalletColor(walletType) {
    const colorMap = {
        'red': '#e74c3c',
        'pink': '#e91e63',
        'yellow': '#f1c40f',
        'orange': '#ff9800',
        'brown': '#795548',
        'black': '#2c3e50',
        'blue': '#3498db',
        'purple': '#9b59b6',
        'gray': '#95a5a6',
        'green': '#27ae60'
    };
    return colorMap[walletType] || '#95a5a6';
}

// Define criminal hierarchy for wallet classifications
const walletHierarchy = {
    'green': 1,   // Victim-owned (legitimate)
    'gray': 2,    // Obfuscated (write-off)
    'black': 3,   // Default intermediary
    'orange': 4,  // Bitcoin change (technical)
    'brown': 4,   // Asset conversion (technical)
    'blue': 5,    // Cold storage
    'yellow': 6,  // Hub (convergence)
    'pink': 7,    // Deception/Dividend
    'purple': 8,  // Exchange (terminal)
    'red': 9      // Victim-facing (highest exposure)
};

// Check if wallet classification change is allowed (only up the hierarchy)
function canChangeWalletClassification(currentType, newType) {
    const currentLevel = walletHierarchy[currentType] || 0;
    const newLevel = walletHierarchy[newType] || 0;
    return newLevel > currentLevel;
}

// Update wallet classification with authorization
function updateWalletClassificationWithAuth(walletAddress, newType, skipAuth = false) {
    const wallet = investigation.universalWalletIndex.find(w => w.address === walletAddress);
    if (!wallet) {
        alert('Wallet not found in index');
        return false;
    }
    
    const oldType = wallet.permanentType;
    
    // Check if change is allowed
    if (!canChangeWalletClassification(oldType, newType)) {
        alert(`Cannot change wallet classification from ${oldType.toUpperCase()} to ${newType.toUpperCase()}. Wallets can only progress UP the criminal hierarchy.`);
        return false;
    }
    
    // Get authorization unless skipped (for automatic updates)
    let justification = '';
    if (!skipAuth) {
        justification = prompt(
            `Changing wallet classification from ${walletTypes[oldType]} to ${walletTypes[newType]}.\n\n` +
            `This is a significant change that will affect all entries using this wallet.\n\n` +
            `Please provide justification for this classification change:`
        );
        
        if (!justification || justification.trim() === '') {
            alert('Classification change cancelled - justification required.');
            return false;
        }
    } else {
        justification = 'Automatic classification based on observed behavior';
    }
    
    // Record the change
    if (!wallet.classificationHistory) {
        wallet.classificationHistory = [];
    }
    
    wallet.classificationHistory.push({
        timestamp: new Date().toISOString(),
        fromType: oldType,
        toType: newType,
        justification: justification,
        investigator: investigation.investigator || 'Unknown'
    });
    
    // Update the wallet
    wallet.permanentType = newType;
    wallet.currentStatus = newType;
    
    // Update wallet ID if needed
    const colorCounters = {};
    investigation.universalWalletIndex.forEach(w => {
        const type = w.permanentType;
        if (!colorCounters[type]) colorCounters[type] = 0;
        const match = w.permanentId.match(/\d+$/);
        if (match) {
            colorCounters[type] = Math.max(colorCounters[type], parseInt(match[0]));
        }
    });
    
    if (!colorCounters[newType]) colorCounters[newType] = 0;
    wallet.permanentId = `${newType.toUpperCase()} ${colorCounters[newType] + 1}`;
    
    // Add to status history
    if (!wallet.statusHistory) wallet.statusHistory = [];
    wallet.statusHistory.push(`Reclassified from ${oldType} to ${newType}: ${justification}`);
    
    // Update all entries retroactively
    updateWalletClassificationRetroactively(walletAddress, newType);
    
    // Save and refresh
    saveToStorage();
    buildUniversalWalletIndex();
    renderHops();
    
    showNotification(
        `Wallet reclassified from ${oldType.toUpperCase()} to ${newType.toUpperCase()}.\n` +
        `Justification: ${justification}`,
        'success'
    );
    
    return true;
}

// Update wallet classification retroactively across all entries
function updateWalletClassificationRetroactively(walletAddress, newType) {
    // Update all hop entries with this wallet
    investigation.hops.forEach(hop => {
        hop.entries.forEach(entry => {
            if (entry.toWallet === walletAddress) {
                entry.toWalletType = newType;
                if (entry.toWalletId) {
                    // Update wallet ID if it exists
                    const wallet = investigation.universalWalletIndex.find(w => w.address === walletAddress);
                    if (wallet) {
                        entry.toWalletId = wallet.permanentId;
                    }
                }
            }
            if (entry.fromWallet === walletAddress) {
                entry.fromWalletType = newType;
                if (entry.fromWalletId) {
                    const wallet = investigation.universalWalletIndex.find(w => w.address === walletAddress);
                    if (wallet) {
                        entry.fromWalletId = wallet.permanentId;
                    }
                }
            }
        });
    });
    
    // Rebuild UWI to ensure consistency
    buildUniversalWalletIndex();
}

// Complete current hop and start the next one
function completeCurrentHopAndStartNext() {
    const lastHop = investigation.hops[investigation.hops.length - 1];
    if (!lastHop) {
        alert('No hop found to complete');
        return;
    }
    
    // Mark the hop as completed
    lastHop.completed = true;
    
    // Save the state
    saveToStorage();
    
    // Add a new hop
    addNewHop();
    
    // Update the display
    renderHops();
    updateInvestigationCompletionStatus();
    
    console.log(` Completed Hop ${lastHop.hopNumber} and started Hop ${lastHop.hopNumber + 1}`);
}

// Show modal for hop finalization options
function showHopFinalizationModal(hop, remainingByCurrency, walletsWithRemainingFunds = []) {
    // Generate wallet suggestions HTML
    let walletSuggestionsHTML = '';
    if (walletsWithRemainingFunds.length > 0) {
        const walletsByCurrency = {};
        walletsWithRemainingFunds.forEach(w => {
            if (!walletsByCurrency[w.currency]) {
                walletsByCurrency[w.currency] = [];
            }
            walletsByCurrency[w.currency].push(w);
        });
        
        walletSuggestionsHTML = `
            <div style="background: #e8f4f8; border: 2px solid #3498db; border-radius: 8px; padding: 20px; margin: 20px 0;">
                <h4 style="color: #2c3e50; margin-bottom: 15px;">💡 Wallets with Remaining Balances:</h4>
                <p style="margin-bottom: 15px; color: #34495e;">These wallets have funds that are not being traced forward. Consider marking them as cold storage:</p>
                ${Object.entries(walletsByCurrency).map(([currency, wallets]) => `
                    <div style="margin-bottom: 15px;">
                        <strong>${currency}:</strong>
                        ${wallets.map(w => `
                            <div style="margin: 10px 0; padding: 10px; background: white; border-radius: 4px; border-left: 3px solid ${w.suggestColdStorage ? '#3498db' : '#95a5a6'};">
                                <div style="font-family: monospace; font-size: 12px; color: #7f8c8d;">
                                    ${w.wallet.substring(0, 20)}...
                                </div>
                                <div style="margin-top: 5px;">
                                    <strong>${w.remainingBalance.toLocaleString()} ${w.currency}</strong> remaining
                                    ${w.suggestColdStorage ? 
                                        `<span style="color: #3498db; margin-left: 10px;">Suggest: Mark as Cold Storage</span>` : 
                                        `<span style="color: #95a5a6; margin-left: 10px;">Already classified as ${w.walletType.toUpperCase()}</span>`
                                    }
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `).join('')}
            </div>
        `;
    }
    
    const modalHTML = `
        <div id="hopFinalizationModal" class="modal" style="display: block;">
            <div class="modal-content" style="max-width: 700px;">
                <div class="modal-header">
                    <h2>Finalize Hop ${hop.hopNumber}</h2>
                    <p>Choose how to account for remaining amounts before proceeding to the next hop</p>
                </div>
                
                ${walletSuggestionsHTML}
                
                <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 20px; margin: 20px 0;">
                    <h4 style="color: #856404; margin-bottom: 15px;">Unaccounted Amounts:</h4>
                    ${Object.entries(remainingByCurrency).map(([currency, amount]) => `
                        <div style="margin-bottom: 20px; padding: 15px; background: white; border-radius: 6px; border-left: 4px solid #ffc107;">
                            <div style="font-size: 18px; font-weight: bold; margin-bottom: 15px;">
                                ${currency}: ${amount.toLocaleString()} remaining
                            </div>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                                <button class="btn btn-danger" onclick="createAutoWriteoff(${hop.hopNumber}, '${currency}', ${amount})" style="padding: 15px;">
                                    📝 Automatic Write-off
                                    <div style="font-size: 12px; margin-top: 5px; font-weight: normal;">Mark as unrecoverable</div>
                                </button>
                                <button class="btn" style="background: #3498db; padding: 15px;" onclick="markAsColdStorage(${hop.hopNumber}, '${currency}', ${amount})">
                                    Cold Storage
                                    <div style="font-size: 12px; margin-top: 5px; font-weight: normal;">Funds remain in current wallet</div>
                                </button>
                                <button class="btn" style="background: #9b59b6; padding: 15px;" onclick="markAsVASPArrival(${hop.hopNumber}, '${currency}', ${amount})">
                                    VASP Arrival
                                    <div style="font-size: 12px; margin-top: 5px; font-weight: normal;">Funds arrived at exchange/service</div>
                                </button>
                                <button class="btn btn-secondary" style="padding: 15px;" onclick="assignPartialAmount(${hop.hopNumber}, '${currency}', ${amount})">
                                    ✂️ Partial Assignment
                                    <div style="font-size: 12px; margin-top: 5px; font-weight: normal;">Split amount across options</div>
                                </button>
                            </div>
                        </div>
                    `).join('')}
                </div>
                
                <div style="text-align: center; margin-top: 25px;">
                    <button class="btn btn-secondary" onclick="closeHopFinalizationModal()">
                        Cancel - Continue Editing Hop ${hop.hopNumber}
                    </button>
                </div>
            </div>
        </div>
    `;
    
    // Remove existing modal if present
    const existingModal = document.getElementById('hopFinalizationModal');
    if (existingModal) {
        existingModal.remove();
    }
    
    // Create centered modal
    createCenteredModal('hopFinalizationModal', modalHTML);
}

// Close hop finalization modal
function closeHopFinalizationModal() {
    const modal = document.getElementById('hopFinalizationModal');
    if (modal) {
        modal.remove();
    }
}

// Create automatic writeoff for remaining amount
function createAutoWriteoff(hopNumber, currency, amount) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    if (!hop) return;
    
    const writeoffEntry = {
        id: hop.entries.length + 1,
        hopNumber: hopNumber,
        hopNumber: hop.hopNumber,
        entryType: 'writeoff',
        notation: `H${hop.hopNumber}-WO`,
        amount: amount.toString(),
        currency: currency,
        customCurrency: currency === 'CUSTOM' ? currency : '',
        category: 'operational',
        justification: `Automatic write-off during hop finalization: ${amount.toLocaleString()} ${currency} unaccounted for`,
        // Default fields
        sourceChain: [],
        displayNotation: '',
        summaryNotation: '',
        victimNumbers: '',
        transactionNumbers: '',
        availableSourceAmount: 0,
        sourceThreadId: '',
        sourceThreadData: null,
        assignmentPercentage: 0,
        generatedNotation: '',
        isConvergence: false,
        convergenceData: null,
        fromWallet: '',
        fromWalletType: '',
        fromWalletId: '',
        toWallet: '',
        toWalletType: '',
        toWalletId: '',
        txHash: '',
        timestamp: new Date().toISOString(),
        timezone: 'UTC',
        notes: `Auto-generated during hop ${hop.hopNumber} finalization`
    };
    
    hop.entries.push(writeoffEntry);
    
    // Sort entries chronologically
    sortHopEntriesChronologically(hop);
    
    closeHopFinalizationModal();
    renderHops();
    saveToStorage();
    
    // Close the modal and re-run finalization to refresh the view
    closeFinalizationModal();
    
    // Re-run finalization to show updated state
    setTimeout(() => {
        finalizeHop(hopNumber);
    }, 100);
}

// Mark funds as cold storage
function markAsColdStorage(hopNumber, currency, amount) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    if (!hop) return;
    
    // Find the most recent wallet that handled this currency
    let lastWallet = '';
    let lastWalletType = 'black';
    
    for (let i = hop.entries.length - 1; i >= 0; i--) {
        const entry = hop.entries[i];
        const entryCurrency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
        if (entry.entryType === 'trace' && entryCurrency === currency && entry.toWallet) {
            lastWallet = entry.toWallet;
            lastWalletType = entry.toWalletType || 'black';
            break;
        }
    }
    
    const coldStorageEntry = {
        id: hop.entries.length + 1,
        hopNumber: hopNumber,
        hopNumber: hop.hopNumber,
        entryType: 'trace',
        notation: `H${hop.hopNumber}-CS`,
        amount: amount.toString(),
        currency: currency,
        customCurrency: currency === 'CUSTOM' ? currency : '',
        category: '',
        justification: '',
        // Enhanced fields
        sourceChain: [],
        displayNotation: '',
        summaryNotation: '',
        victimNumbers: '',
        transactionNumbers: '',
        availableSourceAmount: 0,
        sourceThreadId: '',
        sourceThreadData: null,
        assignmentPercentage: 0,
        generatedNotation: '',
        isConvergence: false,
        convergenceData: null,
        fromWallet: lastWallet,
        fromWalletType: lastWalletType,
        fromWalletId: '',
        toWallet: lastWallet,
        toWalletType: 'blue', // BLUE = Cold Storage
        toWalletId: '',
        txHash: '',
        timestamp: new Date().toISOString(),
        timezone: 'UTC',
        notes: `Cold storage: ${amount.toLocaleString()} ${currency} remains in wallet for future movement`
    };
    
    hop.entries.push(coldStorageEntry);
    
    // Sort entries chronologically
    sortHopEntriesChronologically(hop);
    
    // Update wallet classification in UWI
    let walletReclassified = false;
    if (investigation.universalWalletIndex && lastWallet) {
        const walletEntry = investigation.universalWalletIndex.find(w => w.address === lastWallet);
        if (walletEntry && walletEntry.currentStatus !== 'blue') {
            const previousType = walletEntry.currentStatus || 'unknown';
            walletEntry.currentStatus = 'blue';
            walletEntry.statusHistory = walletEntry.statusHistory || [];
            walletEntry.statusHistory.push(`Cold Storage (Hop ${hop.hopNumber})`);
            walletReclassified = true;
            
            // Show notification about wallet reclassification
            setTimeout(() => {
                alert(`Wallet Classification Updated\n\nWallet ${lastWallet.substring(0, 20)}... has been reclassified from ${previousType.toUpperCase()} to BLUE (Cold Storage) based on the remaining balance of ${amount.toLocaleString()} ${currency}.`);
            }, 100);
        }
    }
    
    closeHopFinalizationModal();
    renderHops();
    saveToStorage();
    
    // Close the modal and re-run finalization to refresh the view
    closeFinalizationModal();
    
    // Re-run finalization to show updated state
    setTimeout(() => {
        finalizeHop(hopNumber);
    }, 100);
}


// Mark funds as arriving at VASP
function markAsVASPArrival(hopNumber, currency, amount) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    if (!hop) return;
    
    // Prompt for VASP details
    const vaspName = prompt('Enter VASP/Exchange name:', 'Exchange');
    if (!vaspName) return;
    
    const vaspEntry = {
        id: hop.entries.length + 1,
        hopNumber: hopNumber,
        hopNumber: hop.hopNumber,
        entryType: 'trace',
        notation: `H${hop.hopNumber}-VASP`,
        amount: amount.toString(),
        currency: currency,
        customCurrency: currency === 'CUSTOM' ? currency : '',
        category: '',
        justification: '',
        // Enhanced fields
        sourceChain: [],
        displayNotation: '',
        summaryNotation: '',
        victimNumbers: '',
        transactionNumbers: '',
        availableSourceAmount: 0,
        sourceThreadId: '',
        sourceThreadData: null,
        assignmentPercentage: 0,
        generatedNotation: '',
        isConvergence: false,
        convergenceData: null,
        fromWallet: '',
        fromWalletType: 'black',
        fromWalletId: '',
        toWallet: vaspName,
        toWalletType: 'purple', // PURPLE = VASP
        toWalletId: '',
        txHash: '',
        timestamp: new Date().toISOString(),
        timezone: 'UTC',
        notes: `Funds arrived at VASP: ${vaspName} - ${amount.toLocaleString()} ${currency} (Fully traced)`
    };
    
    hop.entries.push(vaspEntry);
    
    // Sort entries chronologically
    sortHopEntriesChronologically(hop);
    
    // Create a new hop entry for the purple wallet to terminal exchange
    // This ensures the funds continue to be traced to their final destination
    const nextHopNumber = hop.hopNumber + 1;
    let nextHop = investigation.hops.find(h => h.hopNumber === nextHopNumber);
    
    if (!nextHop) {
        // Create the next hop if it doesn't exist
        nextHop = {
            id: investigation.hops.length + 1,
            hopNumber: nextHopNumber,
            entries: [],
            isCollapsed: false
        };
        investigation.hops.push(nextHop);
    }
    
    // Create the terminal exchange entry in the next hop
    const terminalEntry = {
        id: nextHop.entries.length + 1,
        hopNumber: nextHop.hopNumber,
        hopNumber: nextHop.hopNumber,
        entryType: 'trace',
        notation: `H${nextHop.hopNumber}-TERMINAL`,
        amount: amount.toString(),
        currency: currency,
        customCurrency: currency === 'CUSTOM' ? currency : '',
        category: '',
        justification: `Funds from ${vaspName} to terminal exchange wallet`,
        // Source from the VASP entry
        sourceChain: [{
            sourceNotation: vaspEntry.notation,
            amount: amount,
            currency: currency
        }],
        sourceThreadId: vaspEntry.notation,
        fromWallet: vaspName,
        fromWalletType: 'purple',
        toWallet: 'Terminal Exchange Wallet',
        toWalletType: 'purple',
        notes: `Terminal destination for ${amount.toLocaleString()} ${currency} from ${vaspName}`,
        timestamp: new Date().toISOString(),
        timezone: 'UTC'
    };
    
    nextHop.entries.push(terminalEntry);
    
    closeHopFinalizationModal();
    renderHops();
    saveToStorage();
    
    // Close the modal and re-run finalization to refresh the view
    closeFinalizationModal();
    
    // Re-run finalization to show updated state
    setTimeout(() => {
        finalizeHop(hopNumber);
    }, 100);
}

// Handle partial amount assignment
function assignPartialAmount(hopNumber, currency, totalAmount) {
    const modalHTML = `
        <div id="partialAssignmentModal" class="modal" style="display: block;">
            <div class="modal-content" style="max-width: 600px;">
                <div class="modal-header">
                    <h2>✂️ Partial Amount Assignment</h2>
                    <p>Split ${totalAmount.toLocaleString()} ${currency} across different options</p>
                </div>
                
                <div style="margin: 20px 0;">
                    <div style="margin-bottom: 20px;">
                        <label>Write-off Amount:</label>
                        <input type="number" id="partialWriteoff" step="0.01" min="0" max="${totalAmount}" 
                               value="0" onchange="updatePartialTotal(${totalAmount})">
                    </div>
                    <div style="margin-bottom: 20px;">
                        <label>Cold Storage Amount:</label>
                        <input type="number" id="partialColdStorage" step="0.01" min="0" max="${totalAmount}" 
                               value="0" onchange="updatePartialTotal(${totalAmount})">
                    </div>
                    <div style="margin-bottom: 20px;">
                        <label>VASP Arrival Amount:</label>
                        <input type="number" id="partialVASP" step="0.01" min="0" max="${totalAmount}" 
                               value="0" onchange="updatePartialTotal(${totalAmount})">
                    </div>
                    <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 6px;">
                        <strong>Total Assigned:</strong> <span id="partialTotal">0</span> / ${totalAmount.toLocaleString()} ${currency}
                        <div id="partialValidation" style="margin-top: 10px; color: #e74c3c;"></div>
                    </div>
                </div>
                
                <div style="text-align: center;">
                    <button class="btn btn-confirm" onclick="applyPartialAssignments(${hopNumber}, '${currency}', ${totalAmount})">
                        Apply Assignments
                    </button>
                    <button class="btn btn-secondary" onclick="closePartialAssignmentModal()">
                        Cancel
                    </button>
                </div>
            </div>
        </div>
    `;
    
    createCenteredModal('partialAssignmentModal', modalHTML);
}

// Update partial assignment total
function updatePartialTotal(totalAmount) {
    const writeoff = parseFloat(document.getElementById('partialWriteoff').value) || 0;
    const coldStorage = parseFloat(document.getElementById('partialColdStorage').value) || 0;
    const vasp = parseFloat(document.getElementById('partialVASP').value) || 0;
    
    const total = writeoff + coldStorage + vasp;
    document.getElementById('partialTotal').textContent = total.toLocaleString();
    
    const validation = document.getElementById('partialValidation');
    if (Math.abs(total - totalAmount) < 0.01) {
        validation.textContent = '✅ Amounts balance correctly';
        validation.style.color = '#27ae60';
    } else if (total > totalAmount) {
        validation.textContent = '❌ Total exceeds available amount';
        validation.style.color = '#e74c3c';
    } else {
        validation.textContent = `⚠️ ${(totalAmount - total).toLocaleString()} still unassigned`;
        validation.style.color = '#f39c12';
    }
}

// Apply partial assignments
function applyPartialAssignments(hopNumber, currency, totalAmount) {
    const writeoff = parseFloat(document.getElementById('partialWriteoff').value) || 0;
    const coldStorage = parseFloat(document.getElementById('partialColdStorage').value) || 0;
    const vasp = parseFloat(document.getElementById('partialVASP').value) || 0;
    
    const total = writeoff + coldStorage + vasp;
    if (Math.abs(total - totalAmount) >= 0.01) {
        alert('Assigned amounts must equal the total remaining amount');
        return;
    }
    
    closePartialAssignmentModal();
    closeHopFinalizationModal();
    
    // Apply each assignment
    if (writeoff > 0) {
        createAutoWriteoff(hopNumber, currency, writeoff);
    }
    if (coldStorage > 0) {
        markAsColdStorage(hopNumber, currency, coldStorage);
    }
    if (vasp > 0) {
        markAsVASPArrival(hopNumber, currency, vasp);
    }
}

// Close partial assignment modal
function closePartialAssignmentModal() {
    const modal = document.getElementById('partialAssignmentModal');
    if (modal) {
        modal.remove();
    }
}

// Confirm hop completion and start next (duplicate removed - using new flow above)
function confirmHopAndProceed(completedHop) {
    // Show confirmation modal
    const nextHopART = {};
    
    // Calculate starting ART for next hop from trace outputs
    completedHop.entries.forEach(entry => {
        if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0 && entry.toWalletType !== 'purple') {
            const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
            if (!nextHopART[currency]) {
                nextHopART[currency] = 0;
            }
            nextHopART[currency] += parseFloat(entry.amount);
        }
    });
    
    const totalActiveAmount = Object.values(nextHopART).reduce((sum, amount) => sum + amount, 0);
    
    const confirmHTML = `
        <div id="hopConfirmModal" class="modal" style="display: block;">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>✅ Confirm Hop ${completedHop.hopNumber} Completion</h2>
                </div>
                
                <div style="margin: 20px 0;">
                    <p><strong>Hop ${completedHop.hopNumber} Summary:</strong></p>
                    <ul>
                        <li>Total Entries: ${completedHop.entries.length}</li>
                        <li>Traces: ${completedHop.entries.filter(e => e.entryType === 'trace').length}</li>
                        <li>Write-offs: ${completedHop.entries.filter(e => e.entryType === 'writeoff').length}</li>
                    </ul>
                    
                    ${totalActiveAmount > 0 ? `
                        <div style="margin-top: 20px; padding: 15px; background: #d4edda; border: 2px solid #27ae60; border-radius: 8px;">
                            <p><strong>Starting ART for Hop ${completedHop.hopNumber + 1}:</strong></p>
                            ${Object.entries(nextHopART).map(([currency, amount]) => 
                                `<div>${currency}: ${amount.toLocaleString()}</div>`
                            ).join('')}
                        </div>
                    ` : `
                        <div style="margin-top: 20px; padding: 15px; background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px;">
                            <p><strong>No active threads remaining - Investigation complete!</strong></p>
                        </div>
                    `}
                </div>
                
                <div style="text-align: center;">
                    <button class="btn btn-confirm" onclick="confirmHopCompletion(${completedHop.id})">
                        ${totalActiveAmount > 0 ? `Confirm & Start Hop ${completedHop.hopNumber + 1}` : 'Complete Investigation'}
                    </button>
                    <button class="btn btn-secondary" onclick="closeHopConfirmModal()">
                        Cancel
                    </button>
                </div>
            </div>
        </div>
    `;
    
    createCenteredModal('hopConfirmModal', confirmHTML);
}

// Confirm hop completion
function confirmHopCompletion(hopNumber) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    if (!hop) return;
    
    closeHopConfirmModal();
    
    // Create next hop if there are active threads
    createNextHopFromCurrent(hop);
}

// Close hop confirmation modal
function closeHopConfirmModal() {
    const modal = document.getElementById('hopConfirmModal');
    if (modal) {
        modal.remove();
    }
}

function validateHopCompletion(hopNumber) {
            const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
            if (!hop) return { valid: false, errors: ['Hop not found'] };

            const errors = [];
            const warnings = [];

            // Get starting ART by currency for this hop
            const startingART = hop.artAtStartByCurrency || {};

            // Track which currencies have been swapped out
            const swappedOutCurrencies = new Set();
            const swappedInAmounts = {};

            // First pass: identify swaps
            hop.entries.forEach(entry => {
                if (entry.entryType === 'swap' && entry.swapDetails) {
                    // Mark the source currency as swapped out
                    swappedOutCurrencies.add(entry.currency);

                    // Track the swapped-in amount
                    const toCurrency = entry.swapDetails.toCurrency;
                    if (!swappedInAmounts[toCurrency]) {
                        swappedInAmounts[toCurrency] = 0;
                    }
                    swappedInAmounts[toCurrency] += parseFloat(entry.swapDetails.toAmount || 0);
                }
            });

            // Calculate totals by currency from all entries in this hop
            const entryTotalsByCurrency = {};
            hop.entries.forEach(entry => {
                if (parseFloat(entry.amount) > 0) {
                    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                    if (!entryTotalsByCurrency[currency]) {
                        entryTotalsByCurrency[currency] = 0;
                    }
                    // Include all entry types that account for funds
                    if (['trace', 'writeoff', 'cold_storage', 'vasp_arrival'].includes(entry.entryType)) {
                        entryTotalsByCurrency[currency] += parseFloat(entry.amount);
                    }
                    // Swap entries account for the SOURCE currency only
                    // The OUTPUT must still be traced!
                    if (entry.entryType === 'swap') {
                        entryTotalsByCurrency[currency] += parseFloat(entry.amount);
                        // Note: The output currency will be available as a thread for the next hop
                    }
                }
            });
            
            // Validate each currency balances
            Object.entries(startingART).forEach(([currency, startAmount]) => {
                const tracedAmount = entryTotalsByCurrency[currency] || 0;
                const difference = Math.abs(startAmount - tracedAmount);

                // Skip validation for currencies that were fully swapped
                if (swappedOutCurrencies.has(currency)) {
                    // For swapped currencies, the entire amount should be accounted for
                    if (difference >= 0.01 && tracedAmount < startAmount) {
                        warnings.push(`${currency}: ${(startAmount - tracedAmount).toLocaleString()} was not swapped (only ${tracedAmount.toLocaleString()} of ${startAmount.toLocaleString()} converted)`);
                    }
                } else if (difference >= 0.01) {
                    if (tracedAmount > startAmount) {
                        errors.push(`${currency}: Traced ${tracedAmount.toLocaleString()} exceeds ART ${startAmount.toLocaleString()}`);
                    } else {
                        warnings.push(`${currency}: Missing ${(startAmount - tracedAmount).toLocaleString()} (${tracedAmount.toLocaleString()} of ${startAmount.toLocaleString()} traced)`);
                    }
                }
            });
            
            // Check for source thread over-assignment
            const sourceThreadUsage = {};
            hop.entries.forEach(entry => {
                if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0) {
                    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                    
                    if (entry.sourceThreadId) {
                        if (!sourceThreadUsage[currency]) sourceThreadUsage[currency] = {};
                        if (!sourceThreadUsage[currency][entry.sourceThreadId]) {
                            sourceThreadUsage[currency][entry.sourceThreadId] = 0;
                        }
                        sourceThreadUsage[currency][entry.sourceThreadId] += parseFloat(entry.amount);
                    }
                    
                    if (entry.individualSourceAssignments) {
                        Object.entries(entry.individualSourceAssignments).forEach(([sourceId, amount]) => {
                            if (!sourceThreadUsage[currency]) sourceThreadUsage[currency] = {};
                            if (!sourceThreadUsage[currency][sourceId]) {
                                sourceThreadUsage[currency][sourceId] = 0;
                            }
                            sourceThreadUsage[currency][sourceId] += parseFloat(amount);
                        });
                    }
                }
            });
            
            // Validate source thread assignments don't exceed availability
            Object.entries(sourceThreadUsage).forEach(([currency, threads]) => {
                Object.entries(threads).forEach(([threadId, usedAmount]) => {
                    if (investigation.availableThreads[currency] && investigation.availableThreads[currency][threadId]) {
                        const totalAvailable = investigation.availableThreads[currency][threadId].totalAmount;
                        if (usedAmount > totalAvailable + 0.01) {
                            errors.push(`${threadId}: Assigned ${usedAmount.toLocaleString()} exceeds available ${totalAvailable.toLocaleString()} ${currency}`);
                        }
                    }
                });
            });
            
            // CRITICAL FIX: Distinguish between untraced funds and funds traced to next hop
            // Funds traced to non-terminal wallets create threads for the next hop - that's EXPECTED
            // Only funds that haven't been traced AT ALL in this hop are "remaining/unaccounted"
            const remainingByCurrency = {};

            // Compare what was available at START of this hop vs what was actually used
            Object.entries(startingART).forEach(([currency, startAmount]) => {
                const tracedAmount = entryTotalsByCurrency[currency] || 0;
                const unaccounted = startAmount - tracedAmount;

                // Only consider it "remaining" if we haven't traced it at all
                if (unaccounted > 0.01) {
                    // Check if this currency was swapped
                    if (swappedOutCurrencies.has(currency)) {
                        // For swapped currencies, we expect the full amount to be in the swap entry
                        if (tracedAmount < startAmount - 0.01) {
                            remainingByCurrency[currency] = unaccounted;
                        }
                    } else {
                        // For non-swapped currencies, any untraced amount is truly remaining
                        remainingByCurrency[currency] = unaccounted;
                    }
                }
            });

            // Special case: Check for swap outputs created IN THIS HOP that haven't been traced
            hop.entries.forEach(entry => {
                if (entry.entryType === 'swap' && entry.swapDetails) {
                    const outputCurrency = entry.swapDetails.toCurrency;
                    const outputAmount = parseFloat(entry.swapDetails.toAmount || 0);

                    // Check if this swap output has been traced in this same hop
                    const tracedSwapOutput = hop.entries.filter(e =>
                        e.entryType === 'trace' &&
                        e.currency === outputCurrency &&
                        parseFloat(e.amount) > 0 &&
                        e.id !== entry.id  // Don't count the swap itself
                    ).reduce((sum, e) => sum + parseFloat(e.amount), 0);

                    if (tracedSwapOutput < outputAmount - 0.01) {
                        // Swap output exists but hasn't been traced yet in this hop
                        // This IS remaining because swaps in the same hop should be traced
                        if (!remainingByCurrency[outputCurrency]) {
                            remainingByCurrency[outputCurrency] = 0;
                        }
                        remainingByCurrency[outputCurrency] += (outputAmount - tracedSwapOutput);
                        console.log(`⚠️ Swap output not traced: ${outputAmount - tracedSwapOutput} ${outputCurrency} from swap`);
                    }
                }
            });

            console.log(`Hop ${hopNumber} validation - truly unaccounted amounts:`, remainingByCurrency);
            console.log(`Hop ${hopNumber} is balanced: ${Object.keys(remainingByCurrency).length === 0}`);

            // Add swapped-in currencies to the available threads for next hop
            Object.entries(swappedInAmounts).forEach(([currency, amount]) => {
                // The swapped-in currency becomes available for the next hop
                // This is handled by buildAvailableThreadsIndex after the swap
            });
            
            return {
                valid: errors.length === 0,
                errors: errors,
                warnings: warnings,
                balanceStatus: entryTotalsByCurrency,
                remainingByCurrency: remainingByCurrency
            };
        }

function updateInvestigationCompletionStatus() {
    const addHopBtn = document.getElementById('addHopBtn');
    const completeSection = document.getElementById('completeInvestigationSection');
    const visualizationSection = document.getElementById('visualizationPromptSection');

    // Early exit if these elements don't exist (were part of removed tabs)
    if (!addHopBtn && !completeSection) return;

    // Hide both sections by default (with null checks)
    if (visualizationSection) {
        visualizationSection.style.display = 'none';
    }
    if (completeSection) completeSection.style.display = 'none';

    // Check if we have victims entered
    if (!investigation.victims || investigation.victims.length === 0) {
        // No victims yet - hide everything
        if (addHopBtn) addHopBtn.style.display = 'none';
        return;
    }

    // Check if all victims have root totals (are completed)
    const allVictimsComplete = investigation.victims.every(victim =>
        victim.rootTotals && Object.keys(victim.rootTotals).length > 0
    );

    if (!allVictimsComplete) {
        // Victims not complete - hide everything
        addHopBtn.style.display = 'none';
        return;
    }

    if (investigation.hops.length === 0) {
        // Victims complete, no hops yet - show add hop button
        addHopBtn.style.display = 'inline-block';
        return;
    }

    let allHopsComplete = true;
    let lastHopComplete = false;
    let totalValidationErrors = 0;

    // Check all hops for completion and validation
    investigation.hops.forEach((hop, index) => {
        const isLastHop = index === investigation.hops.length - 1;
        const validation = validateHopCompletion(hop.hopNumber);

        if (validation.errors && validation.errors.length > 0) {
            totalValidationErrors += validation.errors.length;
        }

        if (!hop.completed) {
            allHopsComplete = false;
        } else if (isLastHop) {
            lastHopComplete = true;
        }
    });

    // Check if all threads have reached terminal wallets
    const threadStatus = checkAllThreadsTerminated();

    // Calculate next hop ART from available threads
    const lastHop = investigation.hops[investigation.hops.length - 1];
    let nextHopART = {};
    let hasActiveThreads = false;

    // Get available threads for the next hop
    if (lastHop) {
        const nextHopNumber = lastHop.hopNumber + 1;
        const availableThreads = getAvailableSourcesForHop(nextHopNumber, null);

        // Check if any threads are available for tracing
        availableThreads.forEach(thread => {
            if (thread.availableAmount > 0) {
                const currency = thread.currency;
                if (!nextHopART[currency]) {
                    nextHopART[currency] = 0;
                }
                nextHopART[currency] += thread.availableAmount;
                hasActiveThreads = true;
            }
        });
    }

    // Show different buttons based on state
    // Only show complete if we have traced funds AND all threads are terminated
    const hasTracedFunds = investigation.hops.some(hop =>
        hop.entries && hop.entries.some(e => e.entryType === 'trace' && e.amount > 0)
    );

    // UNIFIED COMPLETION CHECK - All paths lead to same completion flow
    const investigationComplete = hasTracedFunds && (
        // All threads terminated (purple exchanges, blue cold storage, gray obfuscated)
        threadStatus.allTerminated ||
        // All write-offs completed
        (allHopsComplete && !hasActiveThreads && checkAllWrittenOff()) ||
        // Manual close triggered
        investigation.manuallyCompleted ||
        // No remaining threads to trace and hops completed
        (!hasActiveThreads && investigation.hops.length > 0 && allHopsComplete)
    );

    if (investigationComplete) {
        // UNIFIED COMPLETION PATH - Always show the same modal and options
        console.log('✅ Investigation complete via unified flow - showing completion modal');

        // Hide the add hop button and manual completion option
        addHopBtn.style.display = 'none';
        const manualOption = document.getElementById('manualCompletionOption');
        if (manualOption) {
            manualOption.style.display = 'none';
        }

        // Show completion section with graph and report options
        completeSection.style.display = 'block';
        if (visualizationSection) {
            visualizationSection.style.display = 'block';
        }

        // Update final thread summary
        updateFinalThreadSummary();

        // ALWAYS show the completion modal with graph/report options
        // This ensures consistent flow regardless of how investigation ended
        if (!document.getElementById('completionWorkflowModal')) {
            setTimeout(() => {
                showEnhancedCompletionModal();
            }, 500); // Small delay to ensure DOM is ready
        }
    } else if (lastHopComplete && hasActiveThreads) {
        // Last hop complete with active threads - show what will be traced
        const artSummary = Object.entries(nextHopART)
            .map(([currency, amount]) => `${amount.toLocaleString()} ${currency}`)
            .join(' + ');

        addHopBtn.innerHTML = `📝 Start Hop ${lastHop.hopNumber + 1} (${artSummary} available)`;
        addHopBtn.style.display = 'inline-block';
        addHopBtn.onclick = function() {
            addNewHop();
        };
        completeSection.style.display = 'none';

        // Also show manual completion option since there are active threads
        const manualOption = document.getElementById('manualCompletionOption');
        if (manualOption) {
            manualOption.style.display = 'block';
        }
    } else if (lastHopComplete && !hasActiveThreads && hasTracedFunds && threadStatus.allTerminated) {
        // No active threads AND all threads terminated - investigation is complete
        addHopBtn.style.display = 'none';

        // Show completion section
        completeSection.style.display = 'block';
        if (visualizationSection) {
            visualizationSection.style.display = 'block';
        }
        updateFinalThreadSummary();
    } else if (!lastHopComplete && investigation.hops.length > 0) {
        // Current hop not complete
        const currentHop = investigation.hops[investigation.hops.length - 1];
        addHopBtn.innerHTML = `⏸️ Complete Hop ${currentHop.hopNumber} First`;
        addHopBtn.style.display = 'inline-block';
        addHopBtn.disabled = true;
        addHopBtn.style.opacity = '0.6';
        addHopBtn.onclick = null;
        completeSection.style.display = 'none';

        // Hide manual option when hop is incomplete
        const manualOption = document.getElementById('manualCompletionOption');
        if (manualOption) {
            manualOption.style.display = 'none';
        }
    } else {
        // Initial state or validation errors
        addHopBtn.innerHTML = `📝 Start First Hop`;
        addHopBtn.style.display = totalValidationErrors === 0 ? 'inline-block' : 'none';
        addHopBtn.disabled = false;
        addHopBtn.style.opacity = '1';
        addHopBtn.onclick = function() { addNewHop(); };
        completeSection.style.display = 'none';

        // Hide manual option in initial state
        const manualOption = document.getElementById('manualCompletionOption');
        if (manualOption) {
            manualOption.style.display = 'none';
        }
        
        // Show validation status in console for debugging
        if (totalValidationErrors > 0) {
            console.log(`⚠️ Investigation has ${totalValidationErrors} validation errors across hops`);
        }
    }
}

        function showWalletClassificationModal(suggestions, hopNumber, onComplete) {
            const modalHTML = `
                <div id="walletClassificationModal" class="modal" style="display: block;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h2>Wallet Classification Review - Hop ${hopNumber}</h2>
                            <p>Based on observed behaviors, these wallets may need reclassification:</p>
                        </div>
                        
                        <div style="max-height: 400px; overflow-y: auto;">
                            ${suggestions.map((suggestion, index) => `
                                <div style="background: #f8f9fa; border: 2px solid #3498db; border-radius: 8px; padding: 20px; margin: 15px 0;">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                                        <div>
                                            <strong>Wallet:</strong> <span style="font-family: monospace; font-size: 12px;">${suggestion.walletAddress.substring(0, 20)}...</span>
                                        </div>
                                        <div>
                                            <strong>Amount:</strong> ${suggestion.totalAmount.toLocaleString()} ${suggestion.currencies.join('/')}
                                        </div>
                                    </div>
                                    
                                    <div style="margin-bottom: 15px;">
                                        <strong>Behavior Analysis:</strong> ${suggestion.reason}
                                    </div>
                                    
                                    <div style="margin-bottom: 15px;">
                                        <strong>Source Threads:</strong> ${suggestion.sourceThreads.join(', ')}
                                    </div>
                                    
                                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; align-items: center;">
                                        <div>
                                            <strong>Current:</strong><br>
                                            <span class="wallet-display ${suggestion.currentType}" style="margin: 0; display: inline-block;">
                                                ${walletTypes[suggestion.currentType] || suggestion.currentType.toUpperCase()}
                                            </span>
                                        </div>
                                        <div style="text-align: center;">
                                            <strong>→ Suggested:</strong><br>
                                            <span class="wallet-display ${suggestion.suggestedType}" style="margin: 0; display: inline-block;">
                                                ${walletTypes[suggestion.suggestedType] || suggestion.suggestedType.toUpperCase()}
                                            </span>
                                        </div>
                                        <div style="text-align: center;">
                                            <label style="cursor: pointer;">
                                                <input type="checkbox" id="approve_${index}" checked style="margin-right: 8px;">
                                                <strong>Apply Change</strong>
                                            </label>
                                        </div>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                        
                        <div style="text-align: center; margin-top: 25px;">
                            <button class="btn btn-confirm" onclick="applyWalletClassificationChanges(${JSON.stringify(suggestions).replace(/"/g, '&quot;')}, ${hopNumber}, arguments.callee.onComplete)">
                                ✅ Apply Selected Changes & Continue
                            </button>
                            <button class="btn btn-secondary" onclick="closeWalletClassificationModal(); arguments.callee.onComplete();">
                                Skip Classification Review
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            // Store callback for later use
            modalHTML.onComplete = onComplete;
            
            // Remove existing modal if present
            const existingModal = document.getElementById('walletClassificationModal');
            if (existingModal) {
                existingModal.remove();
            }
            
            // Create centered modal
            createCenteredModal('walletClassificationModal', modalHTML);
            
            // Store the callback on the window for access
            window.walletClassificationCallback = onComplete;
        }

        function applyWalletClassificationChanges(suggestions, hopNumber, onComplete) {
            console.log('Applying wallet classification changes...');
            
            let changesApplied = 0;
            let walletUpdates = [];
            
            suggestions.forEach((suggestion, index) => {
                const checkbox = document.getElementById(`approve_${index}`);
                if (checkbox && checkbox.checked) {
                    walletUpdates.push({
                        address: suggestion.walletAddress,
                        newType: suggestion.suggestedType,
                        oldType: suggestion.currentType,
                        reason: suggestion.reason
                    });
                    
                    // Update all entries for this wallet address retroactively
                    investigation.hops.forEach(hop => {
                        hop.entries.forEach(entry => {
                            // Update toWallet references
                            if (entry.toWallet && entry.toWallet.trim() === suggestion.walletAddress) {
                                entry.toWalletType = suggestion.suggestedType;
                                changesApplied++;
                            }
                            // Also update fromWallet references
                            if (entry.fromWallet && entry.fromWallet.trim() === suggestion.walletAddress) {
                                entry.fromWalletType = suggestion.suggestedType;
                                changesApplied++;
                            }
                        });
                    });
                    
                    // Update Red Wallet Index if needed
                    if (investigation.redWalletIndex) {
                        investigation.redWalletIndex.forEach(redEntry => {
                            if (redEntry.walletAddress === suggestion.walletAddress) {
                                // Update the wallet ID to reflect new classification
                                const walletIndex = investigation.universalWalletIndex.find(w => w.address === suggestion.walletAddress);
                                if (walletIndex) {
                                    redEntry.walletId = walletIndex.permanentId;
                                }
                            }
                        });
                    }
                }
            });
            
            if (changesApplied > 0) {
                // Rebuild Universal Wallet Index with updated classifications
                buildUniversalWalletIndex();
                buildRedWalletIndex();
                
                // Apply permanent UWI updates
                applyPermanentUWIUpdates(walletUpdates);
                
                alert(` Applied ${changesApplied} wallet classification changes retroactively!\n\nUpdated wallets:\n${walletUpdates.map(u => `• ${u.address.substring(0, 20)}... ${u.newType.toUpperCase()}`).join('\n')}`);
                saveToStorage();
                
                // Re-render all affected components
                renderHops();
                renderRedWalletIndex();
                renderUniversalWalletIndex();
            }
            
            closeWalletClassificationModal();
            
            // Call the completion callback
            if (window.walletClassificationCallback) {
                window.walletClassificationCallback();
                window.walletClassificationCallback = null;
            }
        }
        
        // Apply permanent updates to UWI
        function applyPermanentUWIUpdates(walletUpdates) {
            walletUpdates.forEach(update => {
                const walletEntry = investigation.universalWalletIndex.find(w => w.address === update.address);
                if (walletEntry) {
                    // Add audit trail entry
                    if (!walletEntry.auditTrail) {
                        walletEntry.auditTrail = [];
                    }
                    walletEntry.auditTrail.push({
                        timestamp: new Date().toISOString(),
                        action: 'Classification Update',
                        from: update.oldType,
                        to: update.newType,
                        reason: update.reason,
                        investigator: investigation.investigator || 'Unknown'
                    });
                    
                    // Update notes with classification reason
                    if (walletEntry.notes) {
                        walletEntry.notes += `\n[${new Date().toLocaleDateString()}] ${update.reason}`;
                    } else {
                        walletEntry.notes = `[${new Date().toLocaleDateString()}] ${update.reason}`;
                    }
                }
            });
        }

        function closeWalletClassificationModal() {
            const modal = document.getElementById('walletClassificationModal');
            if (modal) {
                modal.remove();
            }
        }
        
        // Show wallet selector modal
        function showWalletSelector(hopNumber, entryId) {
            const sortedWallets = [...(investigation.universalWalletIndex || [])].sort((a, b) => {
                if (a.permanentType !== b.permanentType) {
                    const typeOrder = ['red', 'pink', 'yellow', 'orange', 'brown', 'black', 'blue', 'purple', 'gray', 'green'];
                    return typeOrder.indexOf(a.permanentType) - typeOrder.indexOf(b.permanentType);
                }
                return a.permanentId.localeCompare(b.permanentId);
            });
            
            const modalHTML = `
                <div id="walletSelectorModal" class="modal" style="display: block;">
                    <div class="modal-content" style="max-width: 800px;">
                        <div class="modal-header">
                            <h2>📋 Select Wallet</h2>
                            <p>Choose an existing wallet from the Universal Wallet Index</p>
                        </div>
                        
                        <div style="margin-bottom: 20px;">
                            <input type="text" 
                                   id="walletSearchInput" 
                                   placeholder="Search by wallet address or ID..."
                                   onkeyup="filterWalletList()"
                                   style="width: 100%; padding: 10px; border: 2px solid #e8f0fe; border-radius: 6px;">
                        </div>
                        
                        <div style="max-height: 400px; overflow-y: auto;">
                            <table style="width: 100%; border-collapse: collapse;">
                                <thead>
                                    <tr style="background: #f8f9fa; position: sticky; top: 0;">
                                        <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Wallet ID</th>
                                        <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Type</th>
                                        <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Address</th>
                                        <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Action</th>
                                    </tr>
                                </thead>
                                <tbody id="walletListBody">
                                    ${sortedWallets.map(wallet => `
                                        <tr class="wallet-row" data-address="${wallet.address.toLowerCase()}" data-id="${wallet.permanentId.toLowerCase()}">
                                            <td style="border: 1px solid #ddd; padding: 12px;">
                                                <div class="wallet-display ${wallet.permanentType}" style="margin: 0;">
                                                    ${wallet.permanentId}
                                                </div>
                                            </td>
                                            <td style="border: 1px solid #ddd; padding: 12px;">
                                                ${walletTypes[wallet.permanentType] || wallet.permanentType}
                                            </td>
                                            <td style="border: 1px solid #ddd; padding: 12px; font-family: monospace; font-size: 11px;">
                                                ${wallet.address}
                                            </td>
                                            <td style="border: 1px solid #ddd; padding: 12px; text-align: center;">
                                                <button class="btn btn-confirm" style="padding: 6px 12px;"
                                                        onclick="selectWallet(${hopNumber}, ${entryId}, '${wallet.address}', '${wallet.permanentType}')">
                                                    Select
                                                </button>
                                            </td>
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                        </div>
                        
                        <div style="text-align: center; margin-top: 25px;">
                            <button class="btn btn-secondary" onclick="closeWalletSelectorModal()">
                                Cancel
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            // Remove existing modal if present
            const existingModal = document.getElementById('walletSelectorModal');
            if (existingModal) {
                existingModal.remove();
            }
            
            // Create centered modal
            createCenteredModal('walletSelectorModal', modalHTML);
        }
        
        // Filter wallet list in modal
        function filterWalletList() {
            const searchInput = document.getElementById('walletSearchInput');
            const filter = searchInput.value.toLowerCase();
            const rows = document.querySelectorAll('#walletListBody .wallet-row');
            
            rows.forEach(row => {
                const address = row.getAttribute('data-address');
                const id = row.getAttribute('data-id');
                
                if (address.includes(filter) || id.includes(filter)) {
                    row.style.display = '';
                } else {
                    row.style.display = 'none';
                }
            });
        }
        
        // Select wallet from modal
        function selectWallet(hopNumber, entryId, address, walletType) {
            // Update the entry
            const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
            const entry = hop.entries.find(e => e.id === entryId);
            
            if (entry) {
                entry.toWallet = address;
                entry.toWalletType = walletType;
            }
            
            // Update the input field
            const input = document.getElementById(`toWallet_${hopNumber}_${entryId}`);
            if (input) {
                input.value = address;
            }
            
            // Update the wallet type dropdown
            const typeSelect = document.querySelector(`select[onchange="updateHopEntryWalletType(${hopNumber}, ${entryId}, this.value)"]`);
            if (typeSelect) {
                typeSelect.value = walletType;
            }
            
            // Close modal and save
            closeWalletSelectorModal();
            saveToStorage();
            
            // Re-render to update UI
            renderHops();
        }
        
        // Close wallet selector modal
        function closeWalletSelectorModal() {
            const modal = document.getElementById('walletSelectorModal');
            if (modal) {
                modal.remove();
            }
        }

        function analyzeWalletBehaviors(hop) {
            console.log(` Analyzing wallet behaviors for hop ${hop.hopNumber}...`);
            
            const suggestions = [];
            const walletBehaviors = {};
            
            // Analyze each entry to track wallet behaviors
            hop.entries.forEach(entry => {
                if (entry.entryType === 'trace' && entry.toWallet && parseFloat(entry.amount) > 0) {
                    const walletAddress = entry.toWallet.trim();
                    
                    if (!walletBehaviors[walletAddress]) {
                        walletBehaviors[walletAddress] = {
                            address: walletAddress,
                            currentClassification: entry.toWalletType,
                            sourceThreads: [],
                            totalAmount: 0,
                            currencies: new Set()
                        };
                    }
                    
                    const behavior = walletBehaviors[walletAddress];
                    const sourceThread = entry.sourceThreadId || 'Multiple Sources';
                    
                    if (!behavior.sourceThreads.includes(sourceThread)) {
                        behavior.sourceThreads.push(sourceThread);
                    }
                    
                    behavior.totalAmount += parseFloat(entry.amount);
                    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                    behavior.currencies.add(currency);
                }
            });
            
            // Analyze behaviors and suggest reclassifications
            Object.values(walletBehaviors).forEach(behavior => {
                const sourceCount = behavior.sourceThreads.length;
                const currencyCount = behavior.currencies.size;
                let suggestedType = behavior.currentClassification;
                let reason = '';
                
                // Multiple source threads = convergence behavior
                if (sourceCount > 1) {
                    if (behavior.currentClassification !== 'yellow') {
                        suggestedType = 'yellow';
                        reason = `Received funds from ${sourceCount} different source threads, indicating convergence/hub behavior`;
                    }
                }
                
                // Multiple currencies = conversion behavior
                if (currencyCount > 1) {
                    if (behavior.currentClassification !== 'brown') {
                        suggestedType = 'brown';
                        reason = `Handled ${currencyCount} different currencies, indicating asset conversion behavior`;
                    }
                }
                
                // Cold storage detection moved to hop finalization
                // BLUE wallet classification is now only suggested when:
                // 1. User is finalizing a hop with remaining balances
                // 2. User explicitly creates cold storage entries
                // This prevents false positives during active tracing
                
                // Add suggestion if classification should change
                if (suggestedType !== behavior.currentClassification) {
                    suggestions.push({
                        walletAddress: behavior.address,
                        currentType: behavior.currentClassification,
                        suggestedType: suggestedType,
                        reason: reason,
                        sourceThreads: behavior.sourceThreads,
                        totalAmount: behavior.totalAmount,
                        currencies: Array.from(behavior.currencies)
                    });
                }
            });
            
            console.log(` Found ${suggestions.length} wallet classification suggestions:`, suggestions);
            return suggestions;
        }

        function completeCurrentHopAndStartNext() {
            console.log(' Completing current hop and starting next...');
            
            const currentHop = investigation.hops[investigation.hops.length - 1];
            const validation = validateHopCompletion(currentHop.id);
            
            if (!validation.valid) {
                alert(`Cannot complete hop ${currentHop.hopNumber}. Please fix validation errors first:\n${validation.errors.join('\n')}`);
                return;
            }
            
            // Mark current hop as completed
            currentHop.completed = true;
            
            // Analyze wallet behaviors for classification suggestions
            const classificationSuggestions = analyzeWalletBehaviors(currentHop);
            
            if (classificationSuggestions.length > 0) {
                showWalletClassificationModal(classificationSuggestions, currentHop.hopNumber, () => {
                    // After classification review, create next hop
                    createNextHopFromCurrent(currentHop);
                });
            } else {
                // No classification changes needed, proceed directly
                createNextHopFromCurrent(currentHop);
            }
        }

        function createNextHopFromCurrent(completedHop) {
            console.log(`Creating hop ${completedHop.hopNumber + 1} from completed hop ${completedHop.hopNumber}`);
            
            // Calculate starting ART for next hop based on trace outputs from current hop
            const nextHopART = {};
            
            completedHop.entries.forEach(entry => {
                if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0) {
                    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                    if (!nextHopART[currency]) {
                        nextHopART[currency] = 0;
                    }
                    nextHopART[currency] += parseFloat(entry.amount);
                }
            });
            
            // Only create next hop if there are active threads to trace
            const totalActiveAmount = Object.values(nextHopART).reduce((sum, amount) => sum + amount, 0);
            
            if (totalActiveAmount > 0) {
                const nextHop = {
                    hopNumber: completedHop.hopNumber + 1,
                    entries: [],
                    artAtStartByCurrency: nextHopART,
                    artAtStart: totalActiveAmount, // Legacy support
                    completed: false
                };
                
                investigation.hops.push(nextHop);
                
                // Rebuild thread index
                if (typeof buildAvailableThreadsIndex === 'function') {
                    buildAvailableThreadsIndex();
                }
                
                // Update Universal Wallet Index with any new wallets
                buildUniversalWalletIndex();
                
                renderHops();
                saveToStorage();
                updateWorkflowSteps();
                
                alert(` Hop ${completedHop.hopNumber} completed! \n🎯 Hop ${nextHop.hopNumber} ready with starting ART: ${Object.entries(nextHopART).map(([currency, amount]) => `${amount.toLocaleString()} ${currency}`).join(', ')}`);
                
                console.log(` Hop ${nextHop.hopNumber} created successfully with ART:`, nextHopART);
            } else {
                // No trace outputs from this hop - check if investigation is complete
                saveToStorage();
                renderHops();
                updateInvestigationCompletionStatus();
                
                // The completion status function will handle showing the appropriate message
                console.log(`Hop ${completedHop.hopNumber} completed with no trace outputs.`);
            }
        }
        
// Check if a wallet type is a terminal wallet (where traces should end)
function isTerminalWalletType(walletType) {
    // Terminal wallets: GRAY (obfuscated), PURPLE (exchange deposit), BLUE (cold storage - temporary terminal)
    return ['gray', 'purple', 'blue'].includes(walletType);
}

// Check if all remaining threads have been written off
function checkAllWrittenOff() {
    // Check if all available threads have been written off
    let hasNonWrittenOffThreads = false;

    Object.entries(investigation.availableThreads || {}).forEach(([currency, threads]) => {
        Object.entries(threads).forEach(([threadId, thread]) => {
            const availableAmount = getMaxAssignableAmount(thread.internalId || threadId, currency);
            // If thread has available amount and isn't written off, investigation not complete
            if (availableAmount > 0.01 && !thread.writtenOff) {
                hasNonWrittenOffThreads = true;
            }
        });
    });

    return !hasNonWrittenOffThreads;
}

// Manual completion trigger - can be called when user wants to end investigation
function manuallyCompleteInvestigation() {
    // Confirm with user
    const confirm = window.confirm(
        'Are you sure you want to manually complete this investigation?\n\n' +
        'This will mark the investigation as complete even if there are remaining untraced funds.\n\n' +
        'You can still generate reports and visualizations after completion.'
    );

    if (!confirm) return;

    // Mark as manually completed
    investigation.manuallyCompleted = true;
    investigation.manualCompletionTime = new Date().toISOString();

    // Save the state
    saveInvestigation();

    // Trigger the unified completion flow
    updateInvestigationCompletionStatus();

    console.log('✅ Investigation manually completed - triggering unified completion flow');
}

// Check if all active threads have reached terminal wallets
function checkAllThreadsTerminated() {
    const activeThreads = [];
    const nonTerminalThreads = [];
    const unallocatedThreads = [];

    // CRITICAL FIX: First check for any unallocated threads in availableThreads
    // This includes swap outputs that haven't been traced yet
    buildAvailableThreadsIndex(); // Ensure index is up to date

    // Check all available threads for any unallocated amounts
    Object.entries(investigation.availableThreads || {}).forEach(([currency, threads]) => {
        Object.entries(threads).forEach(([threadId, thread]) => {
            const availableAmount = getMaxAssignableAmount(thread.internalId || threadId, currency);

            if (availableAmount > 0.01) {
                // This thread has unallocated funds!
                unallocatedThreads.push({
                    threadId: thread.notation || threadId,
                    internalId: thread.internalId || threadId,
                    amount: availableAmount,
                    currency: currency,
                    sourceType: thread.sourceType,
                    isSwapOutput: thread.sourceType === 'swap_output'
                });

                // These are NOT terminated - they need to be traced
                nonTerminalThreads.push({
                    path: thread.notation || threadId,
                    amount: availableAmount,
                    currency: currency,
                    toWalletType: 'unallocated',
                    toWallet: 'NOT_TRACED_YET',
                    walletTypeDisplay: 'Unallocated Funds'
                });
            }
        });
    });

    // Now check traced threads for their terminal status
    const threadPaths = {};

    investigation.hops.forEach(hop => {
        hop.entries.forEach(entry => {
            if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0) {
                let threadPath = null;

                // Try to extract thread path from notation
                if (entry.notation) {
                    const pathMatch = entry.notation.match(/^(V\d+-T\d+)/);
                    if (pathMatch) {
                        threadPath = pathMatch[1];
                    }
                }

                // If no valid notation, create a unique identifier based on source
                if (!threadPath) {
                    // Use sourceThreadId or create a generic identifier
                    if (entry.sourceThreadId) {
                        threadPath = entry.sourceThreadId;
                    } else if (entry.victimNumbers && entry.transactionNumbers) {
                        threadPath = `V${entry.victimNumbers}-T${entry.transactionNumbers}`;
                    } else {
                        // Create a unique identifier for this entry
                        threadPath = `H${hop.hopNumber}-E${entry.id}`;
                    }
                }

                // Store the most recent (highest hop number) entry for each thread
                if (!threadPaths[threadPath] || hop.hopNumber > threadPaths[threadPath].hopNumber) {
                    threadPaths[threadPath] = {
                        hopNumber: hop.hopNumber,
                        entry: entry,
                        amount: parseFloat(entry.amount),
                        currency: entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency,
                        toWalletType: entry.toWalletType || 'black',
                        toWallet: entry.toWallet,
                        path: threadPath
                    };
                }
            }
        });
    });

    // Check each traced thread's terminal status
    Object.entries(threadPaths).forEach(([threadPath, threadData]) => {
        activeThreads.push({
            path: threadPath,
            ...threadData
        });

        if (!isTerminalWalletType(threadData.toWalletType)) {
            // Only add to nonTerminalThreads if not already there as unallocated
            const isAlreadyUnallocated = nonTerminalThreads.some(t => t.path === threadPath);
            if (!isAlreadyUnallocated) {
                nonTerminalThreads.push({
                    path: threadPath,
                    ...threadData,
                    walletTypeDisplay: walletTypes[threadData.toWalletType] || threadData.toWalletType
                });
            }
        }
    });

    console.log('Thread termination check:', {
        unallocatedThreads: unallocatedThreads,
        activeThreads: activeThreads,
        nonTerminalThreads: nonTerminalThreads
    });

    // Investigation is only complete if:
    // 1. No unallocated threads (including swap outputs)
    // 2. All traced threads reached terminal wallets
    const allTerminated = unallocatedThreads.length === 0 && nonTerminalThreads.length === 0;

    return {
        allTerminated: allTerminated,
        activeThreads: activeThreads,
        nonTerminalThreads: nonTerminalThreads,
        unallocatedThreads: unallocatedThreads,
        totalActiveAmount: activeThreads.reduce((sum, thread) => sum + thread.amount, 0),
        hasUnallocatedFunds: unallocatedThreads.length > 0
    };
}
        function updateFinalThreadSummary() {
            const summaryContainer = document.getElementById('finalThreadSummary');
            const threadStatus = checkAllThreadsTerminated();
            
            let summaryHTML = '<h4 style="margin-bottom: 15px; color: #2c3e50;">🎯 Investigation Complete - All Threads at Terminal Wallets</h4>';
            
            if (threadStatus.activeThreads.length > 0) {
                // Group threads by currency and terminal status
                const threadsByCurrency = {};
                
                threadStatus.activeThreads.forEach(thread => {
                    if (!threadsByCurrency[thread.currency]) {
                        threadsByCurrency[thread.currency] = {
                            total: 0,
                            threads: []
                        };
                    }
                    threadsByCurrency[thread.currency].total += thread.amount;
                    threadsByCurrency[thread.currency].threads.push(thread);
                });
                
                Object.entries(threadsByCurrency).forEach(([currency, data]) => {
                    summaryHTML += `
                        <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                            <div style="font-weight: bold; margin-bottom: 10px;">
                                ${currency}: ${data.total.toLocaleString()} Total
                            </div>
                            <div style="font-size: 14px;">
                    `;
                    
                    data.threads.forEach(thread => {
                        const walletTypeColor = getWalletColor(thread.toWalletType);
                        const isTerminal = isTerminalWalletType(thread.toWalletType);
                        const icon = isTerminal ? '✅' : '⚠️';
                        
                        summaryHTML += `
                            <div style="margin: 5px 0; padding: 8px; background: white; border-radius: 4px; border-left: 4px solid ${walletTypeColor};">
                                ${icon} <strong>${thread.path}</strong>: ${thread.amount.toLocaleString()} ${currency} 
                                <span style="color: ${walletTypeColor}; font-weight: bold;">
                                    ${walletTypes[thread.toWalletType] || thread.toWalletType}
                                </span>
                                ${thread.toWalletType === 'blue' ? '<small style="color: #666;"> (Cold Storage - Temporary Terminal)</small>' : ''}
                            </div>
                        `;
                    });
                    
                    summaryHTML += `
                            </div>
                        </div>
                    `;
                });
                
                // Add terminal wallet legend
                summaryHTML += `
                    <div style="margin-top: 20px; padding: 15px; background: #e8f5e8; border: 2px solid #27ae60; border-radius: 8px;">
                        <h5 style="color: #27ae60; margin-bottom: 10px;">Terminal Wallet Types:</h5>
                        <div style="font-size: 13px; color: #2c3e50;">
                            <div style="margin: 5px 0;">
                                <span style="background: ${getWalletColor('purple')}; color: white; padding: 2px 8px; border-radius: 4px;">PURPLE</span>
                                - Exchange/VASP Deposit (Final Destination)
                            </div>
                            <div style="margin: 5px 0;">
                                <span style="background: ${getWalletColor('gray')}; color: white; padding: 2px 8px; border-radius: 4px;">GRAY</span>
                                - Obfuscated/Mixed (Cannot trace further)
                            </div>
                            <div style="margin: 5px 0;">
                                <span style="background: ${getWalletColor('blue')}; color: white; padding: 2px 8px; border-radius: 4px;">BLUE</span>
                                - Cold Storage (Temporary - May move later)
                            </div>
                        </div>
                    </div>
                `;
            } else {
                summaryHTML += '<p style="color: #666; text-align: center;">No active threads found.</p>';
            }
            
            summaryContainer.innerHTML = summaryHTML;
        }

        function getCurrentThreadValues() {
            const threadsByCurrency = {};
            
            // Group entries by currency and V-T path
            const tracePathsByCurrency = {};
            
            investigation.hops.forEach(hop => {
                hop.entries.forEach(entry => {
                    if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0 && entry.notation) {
                        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                        
                        const pathMatch = entry.notation.match(/^(V\d+-T\d+)/);
                        if (pathMatch) {
                            const vtPath = pathMatch[1];
                            
                            if (!tracePathsByCurrency[currency]) {
                                tracePathsByCurrency[currency] = {};
                            }
                            if (!tracePathsByCurrency[currency][vtPath]) {
                                tracePathsByCurrency[currency][vtPath] = [];
                            }
                            
                            tracePathsByCurrency[currency][vtPath].push({
                                hopNumber: entry.hopNumber,
                                amount: parseFloat(entry.amount),
                                notation: entry.notation,
                                toWalletType: entry.toWalletType
                            });
                        }
                    }
                });
            });
            
            // For each currency, get current thread values and terminal types
            Object.entries(tracePathsByCurrency).forEach(([currency, paths]) => {
                threadsByCurrency[currency] = {
                    totalAmount: 0,
                    paths: [],
                    terminalTypes: new Set()
                };
                
                Object.entries(paths).forEach(([vtPath, entries]) => {
                    entries.sort((a, b) => b.hopNumber - a.hopNumber);
                    const currentEntry = entries[0];
                    
                    threadsByCurrency[currency].totalAmount += currentEntry.amount;
                    threadsByCurrency[currency].paths.push({
                        path: vtPath,
                        amount: currentEntry.amount,
                        notation: currentEntry.notation
                    });
                    
                    if (currentEntry.toWalletType) {
                        threadsByCurrency[currency].terminalTypes.add(walletTypes[currentEntry.toWalletType] || currentEntry.toWalletType);
                    }
                });
                
                threadsByCurrency[currency].terminalTypes = Array.from(threadsByCurrency[currency].terminalTypes);
            });
            
            return threadsByCurrency;
        }
        
        // =================================
        // PART 4: CORE THREAD TRACKING FUNCTIONS
        // Add these functions to your existing JavaScript
        // =================================

// DUPLICATE FUNCTION - Using the one at line 1572 instead
/*function buildAvailableThreadsIndex() {
    console.log('Building available threads index...');
    console.log('Victims:', investigation.victims);
    
    investigation.availableThreads = {};
    
    // Start with ALL victim transactions
    investigation.victims.forEach(victim => {
        console.log(`Processing victim ${victim.id} with ${victim.transactions.length} transactions`);
        
        victim.transactions.forEach(transaction => {
            console.log(`Transaction ${transaction.id}:`, transaction);
            console.log(`Amount: "${transaction.amount}" (parsed: ${parseFloat(transaction.amount)})`);
            console.log(`Receiving Wallet: "${transaction.receivingWallet}" (length: ${transaction.receivingWallet ? transaction.receivingWallet.length : 'undefined'})`);
            
            const amountCheck = parseFloat(transaction.amount) > 0;
            const walletCheck = transaction.receivingWallet && transaction.receivingWallet.trim() !== '';
            
            console.log(`Amount check: ${amountCheck}, Wallet check: ${walletCheck}`);
            
            if (amountCheck && walletCheck) {
                const currency = transaction.currency === 'CUSTOM' ? 
                    transaction.customCurrency : transaction.currency;
                const threadId = `V${victim.id}-T${transaction.id}`;
                
                if (!investigation.availableThreads[currency]) {
                    investigation.availableThreads[currency] = {};
                }
                
                investigation.availableThreads[currency][threadId] = {
                    totalAmount: roundAmount(parseFloat(transaction.amount)),
                    availableAmount: roundAmount(parseFloat(transaction.amount)),
                    currency: currency
                };
                
                console.log(` Added thread ${threadId} with ${transaction.amount} ${currency}`);
            } else {
                console.log(` Skipped transaction ${transaction.id}: Amount check: ${amountCheck}, Wallet check: ${walletCheck}`);
            }
        });
    });
    
    // Add threads from hop outputs
    investigation.hops.forEach(hop => {
        hop.entries.forEach(entry => {
            if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0 && entry.notation) {
                const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                // Thread ID is the notation itself (already contains hop number)
                const threadId = entry.notation;
                
                if (!investigation.availableThreads[currency]) {
                    investigation.availableThreads[currency] = {};
                }
                
                // Only add if it doesn't already exist (to preserve any existing data)
                if (!investigation.availableThreads[currency][threadId]) {
                    investigation.availableThreads[currency][threadId] = {
                        totalAmount: roundAmount(parseFloat(entry.amount)),
                        availableAmount: roundAmount(parseFloat(entry.amount)),
                        currency: currency,
                        sourceType: 'hop_output',
                        hopLevel: entry.hopNumber,
                        fromWallet: entry.toWallet
                    };
                    
                    console.log(` Added hop output thread ${threadId} with ${entry.amount} ${currency} from hop ${entry.hopNumber}`);
                }
            }
        });
    });
    
    console.log(' Final available threads:', investigation.availableThreads);
}*/

// DUPLICATE FUNCTION - Using the one at line 1619 instead
/*function updateThreadAvailabilityFromHop(entry) {
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    const amount = parseFloat(entry.amount);
    
    if (!investigation.availableThreads[currency]) {
        investigation.availableThreads[currency] = {};
    }
    
    // Create new thread entry for this hop output
    const newThreadId = entry.notation;
    investigation.availableThreads[currency][newThreadId] = {
        totalAmount: amount,
        availableAmount: amount,
        assignments: [],
        sourceWallet: entry.toWallet,
        sourceType: 'hop_output',
        hopLevel: entry.hopNumber,
        createdAt: entry.timestamp || new Date().toISOString(),
        isActive: true,
        parentThreads: entry.sourceThreadId ? [entry.sourceThreadId] : [],
        childThreads: [],
        currency: currency
    };
    
    // Reduce availability from source thread if specified
    if (entry.sourceThreadId && investigation.availableThreads[currency][entry.sourceThreadId]) {
        const sourceThread = investigation.availableThreads[currency][entry.sourceThreadId];
        sourceThread.availableAmount -= amount;
        sourceThread.assignments.push({
            assignedTo: newThreadId,
            amount: amount,
            timestamp: new Date().toISOString(),
            isActive: true
        });
        
        // Add child reference
        if (!sourceThread.childThreads.includes(newThreadId)) {
            sourceThread.childThreads.push(newThreadId);
        }
    }
}*/

// DUPLICATE FUNCTION - Using the one at line 1663 instead
/*function getAvailableSourcesForHop(hopNumber, targetCurrency) {
    console.log(` Getting available sources for Hop ${hopNumber}, Currency filter: ${targetCurrency || 'ALL'}`);
    
    buildAvailableThreadsIndex(); // Refresh the index
    
    console.log('Available threads after build:', investigation.availableThreads);
    
    const availableSources = [];
    
    if (hopNumber === 1) {
        // First hop: ALL victim transactions (RED wallets) from ALL victims, ALL currencies
        console.log(`📋 Checking ${investigation.victims.length} victims for available transactions`);
        
        investigation.victims.forEach(victim => {
            victim.transactions.forEach(transaction => {
                console.log(`Checking V${victim.id}-T${transaction.id}: Amount=${transaction.amount}, Wallet=${transaction.receivingWallet}, Currency=${transaction.currency}`);
                
                if (parseFloat(transaction.amount) > 0 && transaction.receivingWallet && transaction.receivingWallet.trim() !== '') {
                    const currency = transaction.currency === 'CUSTOM' ? transaction.customCurrency : transaction.currency;
                    
                    console.log(`Transaction currency: ${currency}, Target filter: ${targetCurrency || 'NONE'}`);
                    
                    // Only filter by currency if targetCurrency is specified
                    if (!targetCurrency || currency === targetCurrency) {
                        const threadId = `V${victim.id}-T${transaction.id}`;
                        
                        // Use the REAL-TIME availability calculation
                        const currentAvailable = getMaxAssignableAmount(threadId, currency);
                        
                        console.log(`Thread ${threadId}: Available ${currentAvailable} ${currency} from real-time calculation`);
                        
                        if (currentAvailable > 0) {
                            const source = {
                                threadId: threadId,
                                displayText: `${threadId} (RED Wallet)`,
                                availableAmount: currentAvailable,
                                currency: currency,
                                sourceWallet: transaction.receivingWallet,
                                sourceType: 'victim_transaction',
                                hopLevel: 0
                            };
                            
                            console.log(` Adding source:`, source);
                            availableSources.push(source);
                        } else {
                            console.log(` Skipping ${threadId}: No availability remaining`);
                        }
                    }
                }
            });
        });
    } else {
        // Subsequent hops: ALL outputs from previous hop level across ALL victim paths
        const previousHopNumber = hopNumber - 1;
        console.log(`📋 Checking previous hop ${previousHopNumber} for available sources`);
        
        investigation.hops.forEach(hop => {
            if (hop.hopNumber === previousHopNumber) {
                hop.entries.forEach(entry => {
                    if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0 && entry.notation) {
                        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                        
                        if (!targetCurrency || currency === targetCurrency) {
                            // Thread ID is the notation itself (already contains hop number)
                            const threadId = entry.notation;
                            const currentAvailable = getMaxAssignableAmount(threadId, currency);
                            
                            if (currentAvailable > 0) {
                                availableSources.push({
                                    threadId: threadId,
                                    displayText: `${threadId}`,
                                    availableAmount: currentAvailable,
                                    currency: currency,
                                    sourceWallet: entry.toWallet,
                                    sourceType: 'hop_output',
                                    hopLevel: previousHopNumber
                                });
                            }
                        }
                    }
                });
            }
        });
    }
    
    console.log(` Final available sources (${availableSources.length}):`, availableSources);
    
    return availableSources.sort((a, b) => a.threadId.localeCompare(b.threadId));
}*/

function getMaxAssignableAmount(sourceThreadIdentifier, currency, excludeEntryId = null, excludeHopId = null) {
    // Support both internal IDs and legacy notation-based IDs
    let threadCurrency = null;
    let threadData = null;
    let internalId = null;

    // Search through all currencies to find this thread
    Object.entries(investigation.availableThreads || {}).forEach(([curr, threads]) => {
        // First try direct lookup (for internal IDs)
        if (threads[sourceThreadIdentifier]) {
            threadCurrency = curr;
            threadData = threads[sourceThreadIdentifier];
            internalId = sourceThreadIdentifier;
        } else {
            // If not found, search by notation (for backward compatibility)
            Object.entries(threads).forEach(([id, thread]) => {
                if (thread.notation === sourceThreadIdentifier) {
                    threadCurrency = curr;
                    threadData = thread;
                    internalId = id;
                }
            });
        }
    });

    if (!threadData) {
        return 0;
    }

    // If a specific currency was requested and it doesn't match the thread's currency, return 0
    if (currency && currency !== threadCurrency) {
        console.warn(`Currency mismatch: Thread ${threadData.notation || sourceThreadIdentifier} has ${threadCurrency} but ${currency} was requested`);
        return 0;
    }

    // Use the thread data we found
    const thread = threadData;
    const actualCurrency = threadCurrency;
    let totalAssignedInCurrentSession = 0;

    // Calculate what's already been assigned across ALL hop entries in the current session
    investigation.hops.forEach(hop => {
        hop.entries.forEach(entry => {
            // Skip the entry being edited to avoid double-counting
            if (excludeEntryId && excludeHopId && entry.id === excludeEntryId && hop.hopNumber === excludeHopId) {
                return; // Skip this entry
            }

            // Check trace, swap, and writeoff entries - all consume source threads
            if ((entry.entryType === 'trace' || entry.entryType === 'swap' || entry.entryType === 'writeoff') && parseFloat(entry.amount) > 0) {
                const entryCurrency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;

                if (entryCurrency === actualCurrency) {
                    // Check both internal ID fields and legacy fields
                    const usesThisThread =
                        // New internal ID system
                        entry.sourceThreadInternalId === internalId ||
                        // Legacy notation system
                        entry.sourceThreadId === sourceThreadIdentifier ||
                        entry.sourceThreadId === thread.notation;

                    if (usesThisThread) {
                        // Single source entry
                        totalAssignedInCurrentSession += parseFloat(entry.amount);
                    } else {
                        // Check multiple source assignments
                        const multipleIds = entry.multipleSourceInternalIds || entry.multipleSourceThreads || [];
                        const assignments = entry.individualSourceAssignments || {};

                        // Check if this thread is in multiple sources
                        if (multipleIds.includes(internalId) || multipleIds.includes(sourceThreadIdentifier) || multipleIds.includes(thread.notation)) {
                            // Look for assignment by internal ID, notation, or identifier
                            const assignedAmount = assignments[internalId] ||
                                                 assignments[sourceThreadIdentifier] ||
                                                 assignments[thread.notation] || 0;
                            totalAssignedInCurrentSession += parseFloat(assignedAmount);
                        }
                    }
                }
            }
        });
    });

    // Calculate available as total minus what's been assigned
    const availableAmount = roundAmount(thread.totalAmount - totalAssignedInCurrentSession);
    const displayName = thread.notation || sourceThreadIdentifier;
    console.log(`Thread ${displayName}: Total ${thread.totalAmount}, Assigned ${totalAssignedInCurrentSession}, Available ${availableAmount}`);

    // Ensure no negative values and apply rounding
    return Math.max(0, availableAmount);
}

function validateThreadAssignment(sourceThreadId, requestedAmount, currency, excludeEntryId = null, excludeHopId = null) {
    const maxAmount = getMaxAssignableAmount(sourceThreadId, currency, excludeEntryId, excludeHopId);
    const amount = parseFloat(requestedAmount);
    
    if (isNaN(amount) || amount <= 0) {
        return { valid: false, error: 'Amount must be a positive number' };
    }
    
    if (amount > maxAmount) {
        // Get the actual currency from the source thread
        let actualCurrency = currency;
        if (!currency) {
            Object.entries(investigation.availableThreads || {}).forEach(([curr, threads]) => {
                if (threads[sourceThreadId]) {
                    actualCurrency = curr;
                }
            });
        }
        
        return { 
            valid: false, 
            error: `Amount ${amount.toLocaleString()} exceeds available ${maxAmount.toLocaleString()} ${actualCurrency}` 
        };
    }
    
    return { valid: true };
}

// DUPLICATE FUNCTION - Using the one at line 1760 instead which has Log Entry button and styling
/*function renderHopEntry(entry) {
    const isWriteoff = entry.entryType === 'writeoff';
    const isColdStorage = entry.entryType === 'cold_storage';
    const isTrace = entry.entryType === 'trace';
    
    // Get available source threads for ALL entry types (not just traces)
    const availableSourceThreads = getAvailableSourcesForHop(entry.hopNumber, null);    
    console.log(`Available sources for Hop ${entry.hopNumber}:`, availableSourceThreads);
    
    // Build source options properly with real-time amounts
    const sourceOptions = availableSourceThreads.map(source => {
        const dateStr = source.datetime ? 
            ` (${formatDateTimeForReport(source.datetime, source.timezone)})` : '';
        return `<option value="${source.threadId}" 
                ${entry.sourceThreadId === source.threadId ? 'selected' : ''}
                title="${source.displayText}${dateStr}">
            ${source.displayText} - ${source.availableAmount.toLocaleString()} ${source.currency} available${dateStr}
        </option>`;
    }).join('');
    
    // Determine if we should show single or multiple source selection
    const showMultipleSelection = availableSourceThreads.length > 1;
    
    // Calculate max amount for input field using real-time calculations
    let maxAmount = 0;
    if (entry.multipleSourceThreads && entry.multipleSourceThreads.length > 0) {
        // Multiple sources selected - sum them up without specifying currency
        entry.multipleSourceThreads.forEach(sourceId => {
            maxAmount += getMaxAssignableAmount(sourceId, null, entry.id, entry.hopNumber);
        });
    } else if (entry.sourceThreadId) {
        // Single source selected - don't pass currency, let the function find it
        maxAmount = getMaxAssignableAmount(entry.sourceThreadId, null, entry.id, hop.hopNumber);
    }
    
    // SOURCE SELECTION HTML - NOW AVAILABLE FOR ALL ENTRY TYPES
    let sourceSelectionHTML = '';
    if (showMultipleSelection) {
        // Multiple sources available - show checkboxes for commingling
        sourceSelectionHTML = `
            <div class="form-group">
                <label>Source Thread Selection ${isWriteoff ? '(Required for balanced accounting)' : '(Select multiple for commingling)'}</label>
                <div style="background: #f8f9fa; border: 1px solid #ddd; border-radius: 4px; padding: 10px;">
                    ${availableSourceThreads.map(source => {
                        const isSelected = entry.multipleSourceThreads && entry.multipleSourceThreads.includes(source.threadId);
                        const proposedAmount = entry.individualSourceAssignments && entry.individualSourceAssignments[source.threadId] || 0;
            
                        return `
                            <div style="margin-bottom: 8px;">
                                <!-- Source Selection Row -->
                                <div style="padding: 8px; background: white; border-radius: 3px; border: 1px solid ${isSelected ? '#3498db' : '#ddd'};">
                                    <input type="checkbox" 
                                        value="${source.threadId}" 
                                        ${isSelected ? 'checked' : ''}
                                        onchange="toggleSourceSelection(${hop.hopNumber}, ${entry.id}, '${source.threadId}')"
                                        style="margin-right: 10px; vertical-align: middle;"> 
                                    <span style="font-weight: bold; color: #2c3e50;">${source.displayText} - ${source.availableAmount.toLocaleString()} ${source.currency} available</span>
                                </div>
                    
                                <!-- Amount Input Row (only show if selected) -->
                                ${isSelected ? `
                                    <div style="margin-top: 6px; margin-left: 30px; display: flex; align-items: center; gap: 8px;">
                                        <span style="font-size: 12px; color: #666; min-width: 80px;">${isWriteoff ? 'Write off:' : 'Propose to use:'}</span>
                                        <input type="number" 
                                            step="0.01" 
                                            min="0" 
                                            max="${source.availableAmount}"
                                            value="${proposedAmount}"
                                            style="width: 120px; padding: 4px 6px; border: 1px solid #ddd; border-radius: 3px;"
                                            onchange="updateProposedAmount(${hop.hopNumber}, ${entry.id}, '${source.threadId}', this.value)"
                                            placeholder="0.00">
                                    <button type="button" 
                                            onclick="proposeMaxAmount(${hop.hopNumber}, ${entry.id}, '${source.threadId}')"
                                            style="padding: 4px 8px; font-size: 11px; background: #3498db; color: white; border: none; border-radius: 3px; cursor: pointer;">
                                        All
                                </button>
                                <span style="font-size: 11px; color: #666;">
                                    (${(source.availableAmount - proposedAmount).toLocaleString()} would remain)
                             </span>
                        </div>
                    ` : ''}
                </div>
            `;
                    }).join('')}
            
                    <!-- Assignment Summary and Action Button -->
                    ${entry.multipleSourceThreads && entry.multipleSourceThreads.length > 0 ? `
                        <div style="margin-top: 15px; padding: 15px; background: ${isWriteoff ? '#fff3cd' : '#e8f4f8'}; border: 1px solid ${isWriteoff ? '#ffc107' : '#3498db'}; border-radius: 6px;">
                            <div style="font-weight: bold; color: #2c3e50; margin-bottom: 10px;">${isWriteoff ? 'Proposed Write-off Summary:' : 'Proposed Assignment Summary:'}</div>
                            <div id="proposedSummary_${hop.hopNumber}_${entry.id}" style="margin-bottom: 15px;"></div>
                            <div style="text-align: center;">
                                <button type="button" 
                                        onclick="commitAssignmentToEntry(${hop.hopNumber}, ${entry.id})"
                                        style="padding: 10px 20px; font-size: 14px; background: ${isWriteoff ? '#e67e22' : '#27ae60'}; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold;">
                                    ${isWriteoff ? '📝 Confirm Write-off' : '🎯 Assign to Hop Entry'} ${entry.id}
                                </button>
                            </div>
                        </div>
                    ` : ''}
                </div>
            </div>
        `;
    } else {
        // Single source or no sources - use dropdown
        sourceSelectionHTML = `
            <div class="form-group">
                <label>Source Thread Selection ${isWriteoff ? '(Required for balanced accounting)' : ''}</label>
                <select id="sourceSelect_${hop.hopNumber}_${entry.id}" 
                        onchange="handleSourceSelection(${hop.hopNumber}, ${entry.id}, this.value)">
                    <option value="">Select source thread...</option>
                    ${sourceOptions}
                </select>
                ${entry.sourceThreadId ? `
                    <div style="margin-top: 8px; font-size: 11px; color: #666;">
                        <strong>Source:</strong> ${entry.sourceThreadId} (${getMaxAssignableAmount(entry.sourceThreadId, entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency).toLocaleString()} available)
                    </div>
                ` : ''}
            </div>
        `;
    }

    return `
        <div style="background: white; border: 2px solid #e8f0fe; border-radius: 8px; padding: 20px; margin-bottom: 15px;">
            <div class="trace-header">
                <div>
                    <span class="trace-notation">Entry ${entry.id} - ${entryTypes[entry.entryType]}</span>
                    ${entry.notation ? `<br><small style="color: #666;">${entry.notation}</small>` : ''}
                </div>
                <button class="btn btn-danger" onclick="removeHopEntry(${hop.hopNumber}, ${entry.id})">Remove</button>
            </div>
            
            <div class="form-group">
                <label>Entry Type</label>
                <select onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'entryType', this.value)">
                    ${Object.entries(entryTypes).map(([key, value]) => 
                        `<option value="${key}" ${entry.entryType === key ? 'selected' : ''}>${value}</option>`
                    ).join('')}
                </select>
            </div>
            
            ${sourceSelectionHTML}
            
            ${isTrace && availableSourceThreads.length > 0 ? `
            <!-- Smart Allocation Button -->
            <div class="form-group" style="text-align: center; margin: 20px 0;">
                <button type="button" 
                        class="btn btn-confirm"
                        onclick="openSmartAllocationModal(${hop.hopNumber}, ${entry.id})"
                        style="background: linear-gradient(135deg, #27ae60 0%, #219a52 100%); padding: 12px 30px;">
                    🎯 Smart Amount Allocation - Auto-Calculate Source Usage
                </button>
                <div style="font-size: 11px; color: #666; margin-top: 8px;">
                    ${availableSourceThreads.length > 1 
                        ? `You have ${availableSourceThreads.length} fund sources. This tool helps split the transaction amount across them.`
                        : `Calculate how much of the available ${availableSourceThreads[0]?.availableAmount.toLocaleString()} ${availableSourceThreads[0]?.currency} to use`
                    }
                </div>
                <div style="background: #e8f5e8; border: 1px solid #27ae60; border-radius: 4px; padding: 8px; margin-top: 8px; font-size: 11px;">
                    <strong>💡 When to use:</strong> You know the transaction amount from the blockchain, but need help determining 
                    which victim funds were used. The tool follows FIFO (First In, First Out) to match real blockchain behavior.
                </div>
            </div>
            ` : ''}
            
            <div class="form-group">
                <label>${isWriteoff ? 'Write-off Amount' : isColdStorage ? 'Cold Storage Amount' : 'New Thread Total'}</label>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="number" step="0.01" 
                           id="assignAmount_${hop.hopNumber}_${entry.id}"
                           value="${entry.amount || ''}"
                           max="${maxAmount}"
                           onchange="updateAssignmentAmount(${hop.hopNumber}, ${entry.id}, this.value)">
                    <button type="button" class="btn btn-secondary" 
                onclick="${isWriteoff ? 'assignMaxWriteoffAmount' : 'assignMaxAmount'}(${hop.hopNumber}, ${entry.id})"
                ${!isWriteoff && (!entry.sourceThreadId && (!entry.multipleSourceThreads || entry.multipleSourceThreads.length === 0)) ? 'disabled' : ''}>
                ${isWriteoff ? 'Balance ART' : 'Max'}
        </button>
                </div>
                <div style="font-size: 11px; color: #666; margin-top: 5px;">
                    Max assignable: ${maxAmount.toLocaleString()} ${entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency}
                </div>
                <div id="assignmentPreview_${hop.hopNumber}_${entry.id}" 
                     style="font-size: 12px; margin-top: 5px;"></div>
            </div>

            <div class="form-group">
                <label>Notation Builder</label>
                <div style="display: flex; align-items: center; gap: 5px; font-family: monospace; font-weight: bold;">
                    <span>V</span>
                    <input type="text" style="width: 60px; text-align: center;" 
                           placeholder="1" 
                           value="${entry.victimNumbers || ''}"
                           onchange="updateNotationField(${hop.hopNumber}, ${entry.id}, 'victims', this.value)">
                    <span>-T</span>
                    <input type="text" style="width: 80px; text-align: center;" 
                           placeholder="1,2,3" 
                           value="${entry.transactionNumbers || ''}"
                           onchange="updateNotationField(${hop.hopNumber}, ${entry.id}, 'transactions', this.value)">
                    <span>-H${entry.hopNumber}${isWriteoff ? '-WO' : isColdStorage ? '-CS' : ''}</span>
                </div>
                <div style="font-size: 12px; color: #666; margin-top: 5px;">
                    Preview: <span id="notation_preview_${hop.hopNumber}_${entry.id}" style="font-family: monospace; font-weight: bold;">${entry.notation || 'Enter V and T numbers'}</span>
                </div>
            </div>
            
            ${!isWriteoff ? `
                <div class="form-group">
                    <label>Full Notation Display</label>
                    <div id="notationPreview_${hop.hopNumber}_${entry.id}" 
                         style="font-family: monospace; padding: 10px; background: #f8f9fa; border-radius: 4px; min-height: 60px;">
                        ${entry.displayNotation || 'Complete source selection and notation to generate full display'}
                    </div>
                </div>
            ` : `
                <div class="form-group">
                    <label>Write-off Justification Display</label>
                    <div id="writeoffPreview_${hop.hopNumber}_${entry.id}" 
                         style="font-family: monospace; padding: 10px; background: #fff3cd; border-radius: 4px; min-height: 60px;">
                        ${entry.sourceThreadId ? `Writing off from: ${entry.sourceThreadId}` : 'Select source thread to track write-off'}
                    </div>
                </div>
            `}

            <div class="form-group">
                <label>Currency</label>
                <select onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'currency', this.value)">
                    <option value="USD" ${entry.currency === 'USD' ? 'selected' : ''}>US Dollar</option>
                    <option value="BTC" ${entry.currency === 'BTC' ? 'selected' : ''}>Bitcoin</option>
                    <option value="ETH" ${entry.currency === 'ETH' ? 'selected' : ''}>Ethereum</option>
                    <option value="USDT" ${entry.currency === 'USDT' ? 'selected' : ''}>Tether</option>
                    <option value="USDC" ${entry.currency === 'USDC' ? 'selected' : ''}>USD Coin</option>
                    <option value="TRX" ${entry.currency === 'TRX' ? 'selected' : ''}>TRON</option>
                    <option value="SOL" ${entry.currency === 'SOL' ? 'selected' : ''}>Solana</option>
                    <option value="ADA" ${entry.currency === 'ADA' ? 'selected' : ''}>Cardano</option>
                    <option value="DAI" ${entry.currency === 'DAI' ? 'selected' : ''}>DAI</option>
                    <option value="BNB" ${entry.currency === 'BNB' ? 'selected' : ''}>BNB</option>
                    <option value="MATIC" ${entry.currency === 'MATIC' ? 'selected' : ''}>MATIC</option>
                    <option value="AVAX" ${entry.currency === 'AVAX' ? 'selected' : ''}>AVAX</option>
                    <option value="HYPE" ${entry.currency === 'HYPE' ? 'selected' : ''}>HYPE</option>
                    <option value="MNT" ${entry.currency === 'MNT' ? 'selected' : ''}>MNT</option>
                    <option value="CUSTOM" ${entry.currency === 'CUSTOM' ? 'selected' : ''}>Custom Currency</option>
                </select>
            </div>
            
            <div class="form-group ${entry.currency === 'CUSTOM' ? '' : 'custom-currency-input'}" 
                 id="customEntryCurrency_${hop.hopNumber}_${entry.id}">
                <label>Custom Currency Symbol</label>
                <input type="text" value="${entry.customCurrency || ''}" 
                       placeholder="e.g., DOGE, SHIB"
                       onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'customCurrency', this.value)">
            </div>
            
            ${!isWriteoff && !isColdStorage ? `
                <div class="form-group">
                    <label>To Wallet Address</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <div class="wallet-autocomplete-container" style="flex: 1;">
                            <input type="text" 
                                   id="toWallet_${hop.hopNumber}_${entry.id}"
                                   value="${entry.toWallet || ''}" 
                                   placeholder="Select existing or enter new wallet address"
                                   onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'toWallet', this.value)"
                                   oninput="handleWalletAutocomplete(this, ${entry.hopNumber}, ${entry.id})"
                                   autocomplete="off"
                                   list="walletList_${hop.hopNumber}_${entry.id}"
                                   style="width: 100%;">
                            <div id="autocomplete_${hop.hopNumber}_${entry.id}" class="wallet-autocomplete-dropdown"></div>
                        </div>
                        <datalist id="walletList_${hop.hopNumber}_${entry.id}">
                            ${(investigation.universalWalletIndex || []).map(wallet => `
                                <option value="${wallet.address}">
                                    ${wallet.permanentId} - ${wallet.address.substring(0, 20)}...
                                </option>
                            `).join('')}
                        </datalist>
                        <button type="button" class="btn btn-secondary" style="padding: 6px 12px; font-size: 12px;"
                                onclick="showWalletSelector(${hop.hopNumber}, ${entry.id})">
                            📋 Browse
                        </button>
                    </div>
                    <div style="font-size: 11px; color: #666; margin-top: 5px;">
                        Type to search existing wallets or enter a new address
                    </div>
                </div>
                <div class="form-group">
                    <label>To Wallet Classification</label>
                    <select onchange="updateHopEntryWalletType(${hop.hopNumber}, ${entry.id}, this.value)">
                        <option value="">Select classification...</option>
                        ${Object.entries(walletTypes).filter(([key]) => key !== 'red').map(([key, value]) => 
                            `<option value="${key}" ${entry.toWalletType === key ? 'selected' : ''}>${value}</option>`
                        ).join('')}
                    </select>
                </div>
                <div class="form-group">
                    <label>Transaction Hash</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <input type="text" 
                               id="txHash_${hop.hopNumber}_${entry.id}"
                               value="${entry.txHash || ''}" 
                               placeholder="Blockchain transaction hash"
                               onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'txHash', this.value)"
                               style="flex: 1;">
                        <button type="button" 
                                class="btn btn-secondary" 
                                onclick="openBlockchainLookup(${hop.hopNumber}, ${entry.id})"
                                style="background: #3498db; color: white; padding: 8px 15px; font-size: 14px;">
                            Lookup
                        </button>
                    </div>
                </div>
                <div class="form-group">
                    <label>Timestamp with Timezone</label>
                    <div class="datetime-timezone">
                        <input type="datetime-local" 
                               id="timestamp_${hop.hopNumber}_${entry.id}"
                               value="${entry.timestamp || ''}" 
                               onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'timestamp', this.value)">
                        <select onchange="onTimezoneChange('timestamp_${hop.hopNumber}_${entry.id}', 'hop', ${hop.hopNumber}, ${entry.id})">
                            ${Object.entries(timezones).map(([key, value]) => 
                                `<option value="${key}" ${entry.timezone === key ? 'selected' : ''}>${value}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
            ` : ''}
            
            ${isWriteoff ? `
                <div class="form-group">
                    <label>Write-off Category</label>
                    <select onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'category', this.value)">
                        <option value="">Select category...</option>
                        ${Object.entries(writeoffCategories).map(([key, value]) => 
                            `<option value="${key}" ${entry.category === key ? 'selected' : ''}>${value}</option>`
                        ).join('')}
                    </select>
                </div>
                <div class="form-group" style="grid-column: span 2;">
                    <label>Justification</label>
                    <textarea rows="2" placeholder="Detailed explanation for abandoning this trace path..." 
                              onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'justification', this.value)">${entry.justification || ''}</textarea>
                </div>
            ` : `
                <div class="form-group" style="grid-column: span 2;">
                    <label>Notes</label>
                    <textarea rows="2" placeholder="PIFO application, convergence notes, etc." 
                              onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'notes', this.value)">${entry.notes || ''}</textarea>
                </div>
            `}
        </div>
    `;
}*/

// Enhanced Amount Assignment for Multiple Sources
function updateAssignmentAmountMultiple(hopNumber, entryId, amount) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    
    entry.amount = amount;
    
    if (entry.multipleSourceThreads && entry.multipleSourceThreads.length > 0) {
        updateMultipleSourcePreview(hopNumber, entryId);
        updateFullNotationDisplayMultiple(hopNumber, entryId);
    } else {
        updateAssignmentPreview(hopNumber, entryId);
        updateFullNotationDisplay(hopNumber, entryId);
    }
    
    saveToStorage();
}

// Enhanced Max Amount Assignment for Multiple Sources
function assignMaxAmountMultiple(hopNumber, entryId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    
    let maxAmount = 0;
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    
    if (entry.multipleSourceThreads && entry.multipleSourceThreads.length > 0) {
        // First, validate that all sources have the same currency as the entry
        const availableSources = getAvailableSourcesForHop(hop.hopNumber, null);
        const invalidSources = [];
        
        entry.multipleSourceThreads.forEach(sourceId => {
            const source = availableSources.find(s => s.threadId === sourceId);
            if (source && source.currency !== currency) {
                invalidSources.push(`${sourceId} (${source.currency})`);
            }
        });
        
        if (invalidSources.length > 0) {
            alert(`ERROR:  Cannot mix different asset types!\n\nEntry currency: ${currency}\nMismatched sources: ${invalidSources.join(', ')}\n\nPlease select only ${currency} threads or change the entry currency.`);
            return;
        }
        
        // Calculate total from multiple sources
        entry.multipleSourceThreads.forEach(sourceId => {
            maxAmount += getMaxAssignableAmount(sourceId, currency);
        });
    } else if (entry.sourceThreadId) {
        // Single source
        maxAmount = getMaxAssignableAmount(entry.sourceThreadId, currency);
    } else {
        alert('Please select source thread(s) first.');
        return;
    }
    
    entry.amount = maxAmount.toString();
    
    const amountInput = document.getElementById(`assignAmount_${hopNumber}_${entryId}`);
    if (amountInput) {
        amountInput.value = maxAmount;
    }
    
    updateAssignmentAmountMultiple(hopNumber, entryId, maxAmount);
}


function showAddEntryWizard(hopNumber) {
    console.log('showAddEntryWizard called for hopNumber:', hopNumber);

    // Prevent auto-reopening after write-off
    if (window.justCreatedWriteoff) {
        console.log('Preventing auto-reopen after write-off');
        return;
    }

    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    if (!hop) {
        console.error('Hop not found:', hopNumber);
        return;
    }
    
    const entryTypeDescriptions = {
        'trace': {
            icon: '🔍',
            description: 'Outgoing Transaction - Track where funds moved to another wallet',
            color: '#3498db'
        },
        'cold_storage': {
            icon: '🧊',
            description: 'Mark as Cold Storage - Funds haven\'t moved yet (monitoring required)',
            color: '#00bcd4'
        }
    };
    
    const wizardHTML = `
        <div id="addEntryWizard" class="modal" style="display: block; z-index: 9998;">
            <div class="modal-content" style="max-width: 600px;">
                <div class="modal-header">
                    <h2>Add Entry - Hop ${hop.hopNumber}</h2>
                    <p>What type of entry do you want to document?</p>
                </div>
                
                <div style="padding: 20px;">
                    ${Object.entries(entryTypes).map(([key, value]) => {
                        const info = entryTypeDescriptions[key] || { icon: '📄', description: '', color: '#95a5a6' };
                        return `
                            <div onclick="selectEntryType('${hopNumber}', '${key}')"
                                 style="background: white; border: 2px solid #e8f0fe; border-radius: 8px; padding: 20px; margin-bottom: 15px; cursor: pointer; transition: all 0.2s;"
                                 onmouseover="this.style.borderColor='${info.color}'; this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.15)'"
                                 onmouseout="this.style.borderColor='#e8f0fe'; this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                                <div style="display: flex; align-items: center; gap: 15px;">
                                    <span style="font-size: 32px;">${info.icon}</span>
                                    <div style="flex: 1;">
                                        <h3 style="margin: 0; color: #2c3e50;">${value}</h3>
                                        <p style="margin: 5px 0 0 0; color: #7f8c8d; font-size: 14px;">${info.description}</p>
                                    </div>
                                    <span style="color: ${info.color}; font-size: 24px;">→</span>
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
                
                <div class="modal-footer">
                    <button class="btn btn-secondary" onclick="window.closeAddEntryWizard ? window.closeAddEntryWizard() : (function(){ const el = document.getElementById('addEntryWizard'); if(el) el.remove(); })()">Cancel</button>
                </div>
            </div>
        </div>
    `;
    
    createCenteredModal('addEntryWizard', wizardHTML);
}

function selectEntryType(hopNumber, entryType) {
    console.log('selectEntryType called with:', hopNumber, entryType);
    closeAddEntryWizard();

    // Check if we should use wizards
    const wizardDisabled = localStorage.getItem('bats_hop_wizard_disabled') === 'true';
    console.log('Wizard disabled:', wizardDisabled);

    // Add a small delay to prevent race condition with modal closing
    setTimeout(() => {
        console.log('Inside setTimeout - entryType:', entryType, 'wizardDisabled:', wizardDisabled);
        if (entryType === 'trace' && !wizardDisabled) {
            // Use the existing trace wizard
            console.log('About to call showHopEntryWizard for hopNumber:', hopNumber);
            try {
                showHopEntryWizard(hopNumber);
                console.log('showHopEntryWizard called successfully');
                // Check if wizard was created
                setTimeout(() => {
                    const wizard = document.getElementById('hopEntryWizard');
                    console.log('Wizard element found:', !!wizard);
                    if (!wizard) {
                        console.error('Wizard element not found after creation');
                    }
                }, 50);
            } catch (error) {
                console.error('Error showing hop entry wizard:', error);
                alert('Error opening wizard: ' + error.message);
            }
        } else if (entryType === 'swap' || entryType === 'dex') {
            // Swap entry type has been deprecated - swaps are now handled through trace entries
            alert('DEX/Swap entries are now handled through the regular transaction flow. Please select "Outgoing Transaction" instead.');
            return;
            console.log('Creating swap entry - showing swap wizard');
            showSwapWizard(hopNumber);
        } else {
            // For now, create other types directly
            // In the future, we could add specific wizards for each type
            console.log('Creating entry directly for type:', entryType);
            createHopEntryDirectly(hopNumber, entryType);
        }
    }, 250);
}
window.showAddEntryWizard = showAddEntryWizard;

function closeAddEntryWizard() {
    const wizard = document.getElementById('addEntryWizard');
    if (wizard) wizard.remove();
}
window.closeAddEntryWizard = closeAddEntryWizard;

function addHopEntry(hopNumber, entryType = 'trace') {
    // This function is now primarily used when wizards are disabled
    // or called from other parts of the code
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    if (!hop) return;

    // Check if hop is fully allocated (only for trace entries)
    if (entryType === 'trace') {
        const availableSources = getAvailableSourcesForHop(hopNumber, null);
        const hasAvailableFunds = availableSources.some(source => source.availableAmount > 0);

        if (!hasAvailableFunds) {
            showNotification('❌ This hop has been fully allocated. No funds remaining to trace. Please close this hop and proceed to the next hop.', 'error');
            return;
        }
    }

    // Check if wizard is disabled
    const wizardDisabled = localStorage.getItem('bats_hop_wizard_disabled') === 'true';
    
    if (entryType === 'trace' && !wizardDisabled) {
        // Show wizard for trace entries
        showHopEntryWizard(hopNumber);
    } else {
        // Direct creation for non-trace entries or when wizard is disabled
        createHopEntryDirectly(hopNumber, entryType);
    }
}

function createHopEntryDirectly(hopNumber, entryType = 'trace') {
    // Convert hopId to number to ensure type matching
    const numericHopNumber = typeof hopNumber === 'string' ? parseInt(hopNumber) : hopNumber;
    const hop = investigation.hops.find(h => h.hopNumber === numericHopNumber);
    if (!hop) {
        console.error('Hop not found in createHopEntryDirectly:', hopNumber, 'numericHopNumber:', numericHopNumber);
        return;
    }

    // Check if hop is fully allocated before creating entry (only for trace entries)
    if (entryType === 'trace') {
        const availableSources = getAvailableSourcesForHop(hopNumber, null);
        const hasAvailableFunds = availableSources.some(source => source.availableAmount > 0);

        if (!hasAvailableFunds) {
            showNotification('❌ This hop has been fully allocated. No funds remaining to trace. Please close this hop and proceed to the next hop.', 'error');
            return;
        }
    }

    // Apply Sequential Hop Rule for convergence scenarios
    let effectiveHopNumber = hop.hopNumber;
    if (entryType === 'trace' && hop.entries.length > 0) {
        // Check if this entry will have multiple source threads (convergence)
        const availableSources = getAvailableSourcesForHop(hop.hopNumber, null);
        if (availableSources.length > 1) {
            // This could be a convergence - prepare for Sequential Hop Rule
            effectiveHopNumber = hop.hopNumber; // Will be updated when sources are selected
        }
    }
    
    const entry = {
        id: hop.entries.length + 1,
        hopNumber: hopNumber,
        hopNumber: effectiveHopNumber,
        entryType: entryType,
        notation: '',
        fromWallet: '',
        fromWalletType: hop.hopNumber === 1 ? 'red' : 'black',
        fromWalletId: '',
        toWallet: '',
        toWalletType: entryType === 'cold_storage' ? 'blue' : '', // Auto-set BLUE for cold storage
        toWalletId: '',
        amount: '',
        currency: '', // No default currency - must be set from source thread
        customCurrency: '',
        txHash: '',
        timestamp: '',
        timezone: 'UTC',
        notes: '',
        category: '',
        justification: '',
        // Enhanced fields
        sourceChain: [],
        displayNotation: '',
        summaryNotation: '',
        victimNumbers: '',
        transactionNumbers: '',
        availableSourceAmount: 0,
        sourceThreadId: '',
        sourceThreadData: null,
        assignmentPercentage: 0,
        generatedNotation: '',
        isConvergence: false,
        convergenceData: null
    };
    
    // Save undo state
    saveUndoState(`Add ${entryType} entry to Hop ${hop.hopNumber}`);
    
    hop.entries.push(entry);
    
    // Store the original entry reference before sorting
    const newEntry = entry;
    
    // Sort entries by timestamp to maintain chronological order
    sortHopEntriesChronologically(hop);
    
    // Find the entry's new ID after sorting
    const sortedEntryIndex = hop.entries.indexOf(newEntry);
    const sortedEntryId = sortedEntryIndex >= 0 ? hop.entries[sortedEntryIndex].id : entry.id;
    
    // Rebuild thread index to ensure available amounts are updated
    buildAvailableThreadsIndex();
    
    renderHops();
    saveToStorage();
    
    // Check if hop is now fully accounted for
    checkHopCompletionStatus(hop);
    
    // Scroll to the newly created entry after a short delay to allow DOM update
    setTimeout(() => {
        const entryElement = document.getElementById(`entry_${hop.hopNumber}_${sortedEntryId}`);
        if (entryElement) {
            // Scroll the entry into view, centered on screen
            entryElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            
            // Add a temporary highlight effect
            entryElement.style.transition = 'background-color 0.5s ease';
            entryElement.style.backgroundColor = '#e3f2fd';
            setTimeout(() => {
                entryElement.style.backgroundColor = '';
            }, 2000);
        }
    }, 300);
}

function sortHopEntriesChronologically(hop) {
    // Sort entries by timestamp, with entries without timestamps at the end
    hop.entries.sort((a, b) => {
        // If both have timestamps, sort chronologically
        if (a.timestamp && b.timestamp) {
            return new Date(a.timestamp) - new Date(b.timestamp);
        }
        // If only one has timestamp, put the one with timestamp first
        if (a.timestamp && !b.timestamp) return -1;
        if (!a.timestamp && b.timestamp) return 1;
        // If neither has timestamp, maintain existing order
        return 0;
    });
    
    // Re-assign IDs to maintain sequential ordering
    hop.entries.forEach((entry, index) => {
        entry.id = index + 1;
    });
}

function showHopEntryWizard(hopNumber) {
    // Just redirect to openHopEntryWizard which has the correct implementation
    openHopEntryWizard(hopNumber);
}

function showHopWizardStep(step) {
    const content = document.getElementById('wizardContent');
    const wizardData = window.hopWizardData;

    // Safety check - if wizard data is lost, show error
    if (!wizardData) {
        console.error('Wizard data not available in showHopWizardStep');
        if (content) {
            content.innerHTML = `
                <div style="background: #f8d7da; border: 1px solid #f5c6cb; border-radius: 8px; padding: 20px; text-align: center;">
                    <strong>⚠️ Session Error</strong><br>
                    The wizard session was lost. Please close and restart.<br>
                    <button class="btn btn-secondary" onclick="window.closeHopWizard()" style="margin-top: 15px;">Close Wizard</button>
                </div>
            `;
        }
        return;
    }

    const progress = document.getElementById('wizardProgress');
    const header = document.querySelector('#hopEntryWizard .modal-header h2');
    const footerButtons = document.getElementById('wizardFooterButtons');

    // Check if footerButtons exists before manipulating it
    if (!footerButtons) {
        console.error('Footer buttons container not found');
        return;
    }

    // Restore standard buttons for steps 1 and 2
    if (step !== 3) {
        footerButtons.innerHTML = `
            <button class="btn btn-secondary" id="wizardBackBtn" onclick="window.hopWizardBack()" style="padding: 10px 20px;" ${step === 1 ? 'disabled' : ''}>← Back</button>
            <button class="btn btn-primary" id="wizardNextBtn" onclick="window.hopWizardNext()" style="padding: 10px 20px;">Next →</button>
        `;
    }

    // Get button references after recreating them
    const backBtn = document.getElementById('wizardBackBtn');
    const nextBtn = document.getElementById('wizardNextBtn');

    // Update progress
    progress.style.width = `${step * 33}%`;
    header.textContent = `🧙‍♂️ Hop Entry Wizard - Step ${step} of 3`;

    if (step === 1) {
        // Step 1: Select source threads
        const availableThreads = getAvailableSourcesForHop(wizardData.hopNumber, null);
        
        console.log('Step 1 - Available threads for hop', wizardData.hopNumber, ':', availableThreads);
        console.log('Available threads count:', availableThreads.length);
        
        const isHop1 = wizardData.hopNumber === 1;
        
        content.innerHTML = `
            <h3>Step 1: Select Source ${isHop1 ? 'RED Wallet(s)' : 'Threads'}</h3>
            ${isHop1 ? `
                <div style="background: #e3f2fd; border-left: 4px solid #2196f3; padding: 15px; margin-bottom: 20px;">
                    <strong>🎯 For Hop 1:</strong> Select the RED wallet(s) that sent funds in the first transaction after the theft.
                    <br><br>
                    These are the wallets where victim funds were initially received (your RED wallets from Step 2).
                </div>
            ` : ''}
            <p>Choose which ${isHop1 ? 'RED wallet' : 'thread'}(s) you want to trace from. You can select multiple if the transaction combines funds.</p>
            
            <div style="margin-top: 20px;">
                ${availableThreads.length > 0 ? `
                    ${availableThreads.map(thread => `
                        <div style="background: white; border: 2px solid #e8f0fe; border-radius: 8px; padding: 15px; margin-bottom: 10px;">
                            <label style="display: flex; align-items: center; cursor: pointer;">
                                <input type="checkbox"
                                       value="${thread.internalId || thread.threadId}"
                                       data-notation="${thread.threadId}"
                                       data-internal-id="${thread.internalId || thread.threadId}"
                                       onchange="updateWizardThreadSelection({notation: '${thread.threadId}', internalId: '${thread.internalId || thread.threadId}'})"
                                       ${(wizardData.selectedInternalIds || wizardData.selectedThreads || []).includes(thread.internalId || thread.threadId) ? 'checked' : ''}
                                       style="margin-right: 10px;">
                                <div>
                                    <strong>${thread.displayText}</strong><br>
                                    <span style="color: #666;">${thread.availableAmount.toLocaleString()} ${thread.currency} available</span>
                                </div>
                            </label>
                        </div>
                    `).join('')}
                ` : `
                    <div style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px; padding: 15px;">
                        <strong>⚠️ No source threads available</strong><br>
                        You need to complete previous hops or victim transactions first.
                    </div>
                `}
            </div>

            ${investigation.tracingMethod === 'LIBR' && availableThreads.length > 0 ? `
                <div style="background: #fff8e1; border: 2px solid #ffc107; padding: 15px; border-radius: 8px; margin-top: 20px;">
                    <h4 style="color: #f57c00; margin-top: 0;">⚖️ LIBR Method Active</h4>
                    <p style="margin-bottom: 15px;">
                        Use the Lowest Intermediate Balance Rule to analyze wallet balances
                        and determine which transactions to follow.
                    </p>

                    <button onclick="launchLIBRAnalyzerFromWizard()" class="btn btn-secondary" style="width: 100%;">
                        📊 Analyze Wallet Balance (LIBR)
                    </button>

                    <div style="background: white; padding: 10px; border-radius: 4px; margin-top: 10px; font-size: 13px;">
                        <strong>LIBR allows you to:</strong>
                        <ul style="margin: 5px 0; padding-left: 20px;">
                            <li>Skip earlier transactions if wallet balance never dropped</li>
                            <li>Select specific transaction where balance dropped below proceeds</li>
                            <li>Leave threads unallocated if funds remain above threshold</li>
                        </ul>
                    </div>
                </div>
            ` : ''}
        `;

        nextBtn.disabled = wizardData.selectedThreads.length === 0;
        nextBtn.textContent = 'Next';

    } else if (step === 2) {
        // Step 2: Allocate amounts

        // Apply allocation based on mode (default to PIFO if not set)
        if (wizardData.txData && Object.keys(wizardData.allocations).length === 0) {
            const txAmount = wizardData.txData.amount || 0;
            if (txAmount > 0 && wizardData.selectedThreads.length > 0) {
                // Default to PIFO mode if not specified
                if (!wizardData.allocationMode) {
                    wizardData.allocationMode = 'pifo';
                }

                // Apply allocation based on mode
                wizardData.allocations = applyPIFOAllocation(txAmount, wizardData.selectedThreads);

                // Create allocation notes
                const allocationNotes = [];
                const threads = getAvailableSourcesForHop(wizardData.hopNumber, null);
                for (const [threadId, amount] of Object.entries(wizardData.allocations)) {
                    if (amount > 0) {
                        const thread = threads.find(t => t.threadId === threadId);
                        if (thread) {
                            allocationNotes.push(`${threadId}: ${amount}/${thread.availableAmount} ${thread.currency}`);
                        }
                    }
                }

                const modeLabel = wizardData.allocationMode === 'matching' ? 'Transaction matching' : 'PIFO allocation';
                wizardData.pifoNote = `${modeLabel} applied: ${allocationNotes.join(', ')}`;
            }
        }

        content.innerHTML = `
            <h3>Step 2: Allocate Amounts</h3>
            <p>Specify how much from each selected thread will be traced in this transaction.</p>

            <div style="background: #f0f8ff; border: 1px solid #87ceeb; border-radius: 8px; padding: 15px; margin: 15px 0;">
                <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="radio"
                               name="allocationMode"
                               value="pifo"
                               ${wizardData.allocationMode !== 'matching' ? 'checked' : ''}
                               onchange="setAllocationMode('pifo')"
                               style="margin-right: 8px;">
                        <strong>PIFO Allocation</strong> <small style="margin-left: 5px;">(Proceeds In First Out)</small>
                    </label>
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="radio"
                               name="allocationMode"
                               value="matching"
                               ${wizardData.allocationMode === 'matching' ? 'checked' : ''}
                               onchange="setAllocationMode('matching')"
                               style="margin-right: 8px;">
                        <strong>Match Transaction</strong> <small style="margin-left: 5px;">(Exact amounts)</small>
                    </label>
                </div>
                ${wizardData.allocationMode === 'matching' && wizardData.txData && wizardData.txData.amount ? `
                    <div style="background: #fffbf0; border-left: 4px solid #ffa726; padding: 8px; margin-top: 10px;">
                        <small>Will attempt to match transaction amount: ${wizardData.txData.amount.toLocaleString()} ${wizardData.txData.currency || ''}</small>
                    </div>
                ` : ''}
            </div>

            ${wizardData.pifoNote ? `
                <div style="background: #e3f2fd; border-left: 4px solid #2196f3; padding: 10px; margin: 15px 0;">
                    <strong>📊 ${wizardData.allocationMode === 'matching' ? 'Matching Mode' : 'PIFO Applied'}:</strong> ${wizardData.pifoNote}
                    <br><small>You can adjust these amounts manually if needed.</small>
                </div>
            ` : ''}

            <div style="margin-top: 20px;">
                ${(wizardData.selectedInternalIds || wizardData.selectedThreads).map(id => {
                    const threads = getAvailableSourcesForHop(wizardData.hopNumber, null);
                    // Try to find by internal ID first, then by notation
                    const thread = threads.find(t => t.internalId === id) || threads.find(t => t.threadId === id);
                    const allocation = wizardData.allocations[id] || wizardData.allocations[thread?.threadId] || 0;

                    return `
                        <div style="background: white; border: 2px solid #e8f0fe; border-radius: 8px; padding: 15px; margin-bottom: 15px;">
                            <h4 style="margin-top: 0;">${thread.displayText}</h4>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <label style="min-width: 80px;">Amount:</label>
                                <input type="number"
                                       id="wizardAllocation_${id}"
                                       step="${getCurrencyStep(thread.currency)}"
                                       min="0"
                                       max="${thread.availableAmount}"
                                       value="${allocation}"
                                       onchange="updateWizardAllocation('${id}', this.value)"
                                       style="width: 150px; padding: 8px;">
                                <span>${thread.currency}</span>
                                <button class="btn btn-sm btn-primary"
                                        onclick="setWizardMaxAllocation('${id}', ${thread.availableAmount})">
                                    Max (${thread.availableAmount.toLocaleString()})
                                </button>
                            </div>
                            <div style="margin-top: 8px; font-size: 12px; color: #666;">
                                ${allocation > 0 ? `${(thread.availableAmount - allocation).toLocaleString()} ${thread.currency} will remain` : ''}
                            </div>
                        </div>
                    `;
                }).join('')}

                <div style="margin-top: 20px; padding: 15px; background: #e8f4f8; border-radius: 8px;">
                    <strong>Total to trace:</strong>
                    <span id="wizardTotalAmount">0</span>
                </div>

                <div style="margin-top: 15px;">
                    <button class="btn btn-secondary" onclick="applyPIFOToWizard()" style="padding: 8px 15px;">
                        🔄 Re-apply PIFO Allocation
                    </button>
                </div>
            </div>
        `;
        
        updateWizardTotal();
        const hasAllocations = Object.values(wizardData.allocations).some(v => v > 0);
        nextBtn.disabled = !hasAllocations;
        nextBtn.textContent = 'Next';
        
    } else if (step === 3) {
        // Step 3: Transaction details
        console.log('Showing hop wizard step 3 with write-off option');
        const isHop1 = wizardData.hopNumber === 1;

        content.innerHTML = `
            <h3>Step 3: Transaction Details</h3>
            ${window.expectingSwapEntry ? `
                <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                    <h4 style="margin-top: 0; color: #e65100;">🔄 DEX/Swap Entry Mode</h4>
                    <p style="margin: 5px 0;">Enter the transaction hash for the currency conversion (e.g., USDC → USDT at DEX).</p>
                    <ul style="margin: 10px 0; padding-left: 20px;">
                        <li>This documents the asset conversion without incrementing the hop number</li>
                        <li>The thread will continue with the new currency</li>
                        <li>DEX wallet will be marked as BROWN (asset conversion)</li>
                    </ul>
                </div>
            ` : isHop1 ? `
                <div style="background: #e8f5e9; border-left: 4px solid #4caf50; padding: 15px; margin-bottom: 20px;">
                    <strong>🎯 For Hop 1:</strong> Enter the transaction where funds LEFT the RED wallet(s).
                    <br><br>
                    This is the FIRST movement of stolen funds after the initial theft.
                </div>
            ` : ''}
            <p>Enter the transaction hash showing where the funds went:</p>
            
            <div style="margin: 20px 0;">
                <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                    <button class="btn ${wizardData.entryMode === 'lookup' ? 'btn-primary' : 'btn-secondary'}" 
                            onclick="setWizardEntryMode('lookup')" style="flex: 1;">
                        🔍 API Lookup
                    </button>
                    <button class="btn ${wizardData.entryMode === 'manual' ? 'btn-primary' : 'btn-secondary'}" 
                            onclick="setWizardEntryMode('manual')" style="flex: 1;">
                        ✏️ Manual Entry
                    </button>
                </div>
                
                ${wizardData.entryMode === 'lookup' ? `
                    <div style="background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%); padding: 20px; border-radius: 8px; border: 2px solid #2196f3;">
                        <label style="font-weight: bold; color: #0d47a1;">Transaction Hash:</label>
                        <div style="display: flex; gap: 10px; margin-top: 10px;">
                            <input type="text"
                                   id="wizardTxHash"
                                   placeholder="Paste transaction hash here"
                                   value="${wizardData.txHash || ''}"
                                   onchange="window.hopWizardData.txHash = this.value; updateStep3Buttons();"
                                   style="flex: 1; padding: 12px; font-size: 16px;">
                            <button class="btn btn-primary" onclick="lookupWizardTransaction()">
                                🔍 Lookup
                            </button>
                        </div>

                        <div class="form-group" style="margin-top: 15px;">
                            <label style="font-weight: bold; color: #0d47a1;">Notes (Optional):</label>
                            <textarea id="wizardNotesLookup"
                                      rows="3"
                                      placeholder="PIFO application, convergence notes, special circumstances, etc."
                                      onchange="updateWizardManualData('notes', this.value)"
                                      style="width: 100%; padding: 8px; margin-top: 5px;">${wizardData.manualData?.notes || ''}</textarea>
                            <small style="color: #555; display: block; margin-top: 5px;">
                                💡 Document any special handling, PIFO applications, or investigative notes here
                            </small>
                        </div>
                    </div>
                ` : `
                    <div style="background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%); padding: 20px; border-radius: 8px; border: 2px solid #ff9800;">
                        <h4 style="margin-top: 0; color: #e65100;">Manual Transaction Entry</h4>
                        
                        <div class="form-group">
                            <label>Transaction Hash:</label>
                            <input type="text" 
                                   id="wizardTxHashManual"
                                   placeholder="Enter transaction hash"
                                   value="${wizardData.txHash || ''}"
                                   onchange="window.hopWizardData.txHash = this.value; if(typeof checkWizardButtonState === 'function') checkWizardButtonState();"
                                   style="width: 100%;">
                        </div>
                        
                        <div class="form-group">
                            <label>From Wallet (Auto-filled from source):</label>
                            <div style="background: #f5f5f5; padding: 10px; border-radius: 4px; border: 1px solid #ddd;">
                                ${(() => {
                                    // Get the source wallet address from selected threads
                                    if (wizardData.selectedThreads.length > 0) {
                                        const threads = getAvailableSourcesForHop(wizardData.hopNumber, null);
                                        const sourceWallets = wizardData.selectedThreads.map(threadId => {
                                            const thread = threads.find(t => t.threadId === threadId);
                                            return thread ? `${thread.displayText}: ${thread.sourceWallet}` : 'Unknown';
                                        });
                                        return sourceWallets.join('<br>');
                                    }
                                    return 'No source thread selected';
                                })()}
                            </div>
                        </div>
                        
                        <div class="form-group">
                            <label>To Wallet:</label>
                            <input type="text" 
                                   id="wizardToWallet"
                                   placeholder="Enter receiving wallet address"
                                   value="${wizardData.manualData?.toWallet || ''}"
                                   onchange="updateWizardManualData('toWallet', this.value)"
                                   style="width: 100%;">
                        </div>
                        
                        <div class="form-group">
                            <label>Timestamp:</label>
                            <input type="datetime-local" 
                                   id="wizardTimestamp"
                                   value="${wizardData.manualData?.timestamp || ''}"
                                   onchange="updateWizardManualData('timestamp', this.value)"
                                   style="width: 100%;">
                        </div>
                        
                        <div class="form-group">
                            <label>Wallet Type (can be updated later):</label>
                            <select id="wizardWalletType"
                                    onchange="updateWizardManualData('walletType', this.value)"
                                    style="width: 100%;">
                                <option value="black" ${wizardData.manualData?.walletType === 'black' ? 'selected' : ''}>⚫ BLACK - Default Intermediary</option>
                                <option value="yellow" ${wizardData.manualData?.walletType === 'yellow' ? 'selected' : ''}>🟡 YELLOW - Hub (Convergence)</option>
                                <option value="pink" ${wizardData.manualData?.walletType === 'pink' ? 'selected' : ''}>🌸 PINK - Dividend/Deception</option>
                                <option value="orange" ${wizardData.manualData?.walletType === 'orange' ? 'selected' : ''}>🟠 ORANGE - Bitcoin Change</option>
                                <option value="brown" ${wizardData.manualData?.walletType === 'brown' ? 'selected' : ''}>🟤 BROWN - Asset Conversion</option>
                                <option value="blue" ${wizardData.manualData?.walletType === 'blue' ? 'selected' : ''}>🔵 BLUE - Cold Storage</option>
                                <option value="purple" ${wizardData.manualData?.walletType === 'purple' ? 'selected' : ''}>🟣 PURPLE - Exchange Deposit</option>
                                <option value="gray" ${wizardData.manualData?.walletType === 'gray' ? 'selected' : ''}>⚪ GRAY - Obfuscated/Diluted</option>
                                <option value="green" ${wizardData.manualData?.walletType === 'green' ? 'selected' : ''}>🟢 GREEN - Victim Owned</option>
                            </select>
                            <small style="color: #666; display: block; margin-top: 5px;">
                                💡 Tip: BLACK is the default for intermediary wallets. Update classification as patterns emerge (e.g., YELLOW for convergence hubs, PURPLE for exchanges).
                            </small>
                        </div>

                        <div class="form-group">
                            <label>Notes (Optional):</label>
                            <textarea id="wizardNotes"
                                      rows="3"
                                      placeholder="PIFO application, convergence notes, special circumstances, etc."
                                      onchange="updateWizardManualData('notes', this.value)"
                                      style="width: 100%; padding: 8px;">${wizardData.manualData?.notes || ''}</textarea>
                            <small style="color: #666; display: block; margin-top: 5px;">
                                💡 Document any special handling, PIFO applications, or investigative notes here
                            </small>
                        </div>
                    </div>
                `}
                
                <div id="wizardTxResult" style="margin-top: 20px;">
                    <!-- Transaction details will appear here -->
                </div>

                <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                    <h4 style="margin-top: 0;">Summary</h4>
                    <div style="font-size: 14px; line-height: 1.6;">
                        ${(wizardData.selectedInternalIds || wizardData.selectedThreads).map(id => {
                            const threads = getAvailableSourcesForHop(wizardData.hopNumber, null);
                            // Try to find by internal ID first, then by notation
                            const thread = threads.find(t => t.internalId === id) || threads.find(t => t.threadId === id);
                            const allocation = wizardData.allocations[id] || wizardData.allocations[thread?.threadId] || 0;
                            return thread ? `<div><strong>${thread.displayText}:</strong> ${allocation.toLocaleString()} ${thread.currency}</div>` : '';
                        }).join('')}
                    </div>
                </div>
            </div>
        `;
        
        // Replace the footer buttons for Step 3
        const footerButtons = document.getElementById('wizardFooterButtons');

        // Check if required data is available
        console.log('Checking required data - txHash:', wizardData.txHash, 'entryMode:', wizardData.entryMode);
        let hasRequiredData = false;
        if (wizardData.entryMode === 'manual') {
            hasRequiredData = wizardData.txHash && wizardData.manualData?.toWallet;
        } else {
            hasRequiredData = !!wizardData.txHash;
        }
        console.log('hasRequiredData:', hasRequiredData);

        // Clear and recreate buttons with proper event listeners
        footerButtons.innerHTML = '';

        // Back button
        const backBtn = document.createElement('button');
        backBtn.className = 'btn btn-secondary';
        backBtn.id = 'wizardBackBtn';
        backBtn.textContent = '← Back';
        backBtn.style.cssText = 'padding: 10px 20px;';
        backBtn.addEventListener('click', function() {
            console.log('Back button clicked via addEventListener');
            window.hopWizardBack();
        });
        footerButtons.appendChild(backBtn);
        console.log('Back button added to Step 3');

        // Log Entry button
        const logEntryBtn = document.createElement('button');
        logEntryBtn.className = 'btn btn-primary';
        logEntryBtn.textContent = '✅ Log Entry';
        logEntryBtn.style.cssText = 'padding: 10px 20px;';
        logEntryBtn.disabled = !hasRequiredData;
        logEntryBtn.addEventListener('click', function() {
            console.log('Log Entry button clicked via addEventListener');
            console.log('Current wizard step:', wizardData.step);
            console.log('Calling hopWizardNext...');
            // Call the global function directly
            window.hopWizardNext();
        });
        footerButtons.appendChild(logEntryBtn);
        console.log('Log Entry button added, disabled:', logEntryBtn.disabled);

        // Log Write-off button (gray with red border)
        const writeoffBtn = document.createElement('button');
        writeoffBtn.className = 'btn btn-secondary';
        writeoffBtn.textContent = '🚫 Log Write-off';
        writeoffBtn.style.cssText = 'padding: 10px 20px; background: #9e9e9e; color: white; border: 2px solid #dc3545;';
        writeoffBtn.disabled = !hasRequiredData;
        writeoffBtn.addEventListener('click', function() {
            console.log('Write-off button clicked via addEventListener');
            // Call the global function directly
            window.showWriteoffConfirmation();
        });
        footerButtons.appendChild(writeoffBtn);
        console.log('Write-off button added, disabled:', writeoffBtn.disabled);

        // Store button references globally for updating
        window.step3LogEntryBtn = logEntryBtn;
        window.step3WriteoffBtn = writeoffBtn;
    }

    wizardData.step = step;
    wizardData.currentStep = step; // Set both for compatibility
}

window.hopWizardNext = function() {
    console.log('hopWizardNext called');
    const wizardData = window.hopWizardData;

    if (!wizardData) {
        console.error('No wizard data found');
        return;
    }

    // Normal progression through steps
    if (wizardData.step === 3) {
        // From step 3, create the entry
        if (wizardData.txHash) {
            // If we have multipleTransfers but no selectedTransfers, select all by default
            if (wizardData.txData?.multipleTransfers && !wizardData.selectedTransfers) {
                console.log('Auto-selecting all transfers for multi-transfer transaction');
                wizardData.selectedTransfers = wizardData.txData.transfers.map((_, index) => index);
            }
            createHopEntryFromWizard();
            // Don't proceed to step 4 or create any additional entries
            return;
        } else {
            alert('Please enter a transaction hash before proceeding.');
        }
    } else {
        wizardData.step = wizardData.step + 1;
        showHopWizardStep(wizardData.step);
    }
}

window.hopWizardBack = function() {
    console.log('hopWizardBack called');
    const wizardData = window.hopWizardData;
    if (wizardData && wizardData.step > 1) {
        wizardData.step = wizardData.step - 1;
        showHopWizardStep(wizardData.step);
    }
}

// Update Step 3 buttons when txHash changes
window.updateStep3Buttons = function() {
    const wizardData = window.hopWizardData;
    if (!wizardData) return;

    console.log('Updating Step 3 buttons, txHash:', wizardData.txHash, 'step:', wizardData.step);

    // Use stored button references or find them
    const logEntryBtn = window.step3LogEntryBtn || document.querySelector('#wizardFooterButtons button:nth-child(2)');
    const writeoffBtn = window.step3WriteoffBtn || document.querySelector('#wizardFooterButtons button:nth-child(3)');

    // Check if we have required data - we need both txHash and txData
    let hasRequiredData = false;
    if (wizardData.entryMode === 'manual') {
        hasRequiredData = wizardData.txHash && wizardData.manualData?.toWallet;
    } else {
        // For lookup mode, we need both txHash and successful txData
        hasRequiredData = !!(wizardData.txHash && wizardData.txData);
    }

    console.log('Updating buttons - hasRequiredData:', hasRequiredData, 'txData exists:', !!wizardData.txData);

    // Enable/disable buttons
    if (logEntryBtn) {
        logEntryBtn.disabled = !hasRequiredData;
        console.log('Log Entry button disabled:', logEntryBtn.disabled);
    }
    if (writeoffBtn) {
        writeoffBtn.disabled = !hasRequiredData;
        console.log('Write-off button disabled:', writeoffBtn.disabled);
    }
}

window.showWriteoffConfirmation = function() {
    console.log('showWriteoffConfirmation called');
    const wizardData = window.hopWizardData;

    // Use the actual transaction amount, not allocations
    const actualTxAmount = wizardData.txData ? parseFloat(wizardData.txData.amount) : 0;
    const totalAmount = actualTxAmount > 0 ? actualTxAmount : Object.values(wizardData.allocations).reduce((sum, val) => sum + val, 0);

    // Get currency from first thread
    const threads = getAvailableSourcesForHop(wizardData.hopNumber, null);
    const firstThreadId = wizardData.selectedThreads[0];
    const thread = threads.find(t => t.threadId === firstThreadId);
    const currency = thread ? thread.currency : 'USD';

    // Create confirmation dialog
    const modal = document.createElement('div');
    modal.className = 'modal show';
    modal.id = 'writeoffConfirmationModal';
    modal.innerHTML = `
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header" style="background: #ff9800; color: white;">
                <h2>🚫 Confirm Write-off</h2>
            </div>

            <div class="modal-body" style="padding: 20px;">
                <div style="background: #fff3cd; border-left: 4px solid #ffc107; padding: 15px; margin-bottom: 20px;">
                    <strong>⚠️ Write-off Confirmation</strong><br>
                    You are about to write off <strong>${totalAmount.toLocaleString()} ${currency}</strong>
                </div>

                <p><strong>This action will:</strong></p>
                <ul style="margin: 10px 0; padding-left: 20px;">
                    <li>Record the transaction hash: <code>${wizardData.txHash || 'Not provided'}</code></li>
                    <li>Document ${totalAmount.toLocaleString()} ${currency} as unrecoverable</li>
                    <li>Reduce the source thread by this amount</li>
                    <li>NOT create a new thread for further tracking</li>
                    <li>Mark the entry with "-WO" suffix</li>
                </ul>

                <div style="margin-top: 20px;">
                    <label style="font-weight: bold;">Write-off Category:</label>
                    <select id="confirmWriteoffCategory"
                            style="width: 100%; padding: 8px; margin-top: 5px;">
                        <option value="minimal_amount">Minimal Amount - Not worth tracking</option>
                        <option value="operational">Operational - Network fees/costs</option>
                        <option value="untraceable">Untraceable - Lost trail</option>
                        <option value="mixer">Mixer/Obfuscation Service</option>
                        <option value="scam_fee">Scam Fee - Paid to accomplices</option>
                        <option value="other">Other - See notes</option>
                    </select>
                </div>

                <div style="margin-top: 15px;">
                    <label style="font-weight: bold;">Justification Notes (Optional):</label>
                    <textarea id="confirmWriteoffNotes"
                              rows="3"
                              placeholder="Additional justification or notes..."
                              style="width: 100%; padding: 8px; margin-top: 5px;"></textarea>
                </div>
            </div>

            <div class="modal-footer" style="display: flex; justify-content: space-between; padding: 15px;">
                <button class="btn btn-secondary"
                        onclick="document.getElementById('writeoffConfirmationModal').remove()">
                    Cancel
                </button>
                <button class="btn btn-warning"
                        style="background: #ff9800; color: white; border: none;"
                        onclick="confirmWriteoff()">
                    🚫 Confirm Write-off
                </button>
            </div>
        </div>
    `;

    document.body.appendChild(modal);
}

window.confirmWriteoff = function() {
    // Check if wizard data exists
    if (!window.hopWizardData) {
        console.error('Wizard data lost - cannot confirm write-off');
        // Remove all modals to clean up
        document.querySelectorAll('.modal').forEach(m => m.remove());
        return;
    }

    // Get the write-off details from the confirmation dialog
    const category = document.getElementById('confirmWriteoffCategory').value;
    const notes = document.getElementById('confirmWriteoffNotes').value;

    // Store in wizard data
    window.hopWizardData.isWriteoff = true;
    window.hopWizardData.writeoffCategory = category;
    window.hopWizardData.writeoffNotes = notes;

    // Remove ONLY the confirmation modal
    const confirmModal = document.getElementById('writeoffConfirmationModal');
    if (confirmModal) {
        confirmModal.remove();
    } else {
        console.error('Confirmation modal not found - trying to clean up');
        // Fallback: remove the last modal
        const modals = document.querySelectorAll('.modal');
        if (modals.length > 1) {
            modals[modals.length - 1].remove();
        }
    }

    // Create the write-off entry
    createWriteoffEntryFromWizard();
}

function closeHopWizard() {
    console.log('closeHopWizard called');

    // Try multiple methods to find and remove the wizard
    const wizardSelectors = [
        '#hopEntryWizard',
        '.modal#hopEntryWizard',
        '[id="hopEntryWizard"]',
        '.modal.show'  // Fallback to any visible modal
    ];

    let removed = false;
    for (const selector of wizardSelectors) {
        const wizards = document.querySelectorAll(selector);
        wizards.forEach(wizard => {
            // Check if it's the hop wizard (by ID or by checking content)
            if (wizard.id === 'hopEntryWizard' ||
                (wizard.querySelector && wizard.querySelector('h2') &&
                 wizard.querySelector('h2').textContent.includes('Add Trace Entry'))) {
                console.log(`Removing wizard found with selector: ${selector}`);
                wizard.remove();
                removed = true;
            }
        });
        if (removed) break;
    }

    if (!removed) {
        console.log('Wizard not found, forcing removal of all wizard modals');
        // Force remove any element with hopEntryWizard ID
        const allElements = document.getElementsByTagName('*');
        for (let elem of allElements) {
            if (elem.id === 'hopEntryWizard') {
                console.log('Force removing element with hopEntryWizard ID');
                elem.remove();
                removed = true;
                break;
            }
        }
    }

    // Clear all wizard data
    window.hopWizardData = null;
    window.expectingSwapEntry = false;
    window.currentWizardData = null;
    window.swapWizardData = null;

    console.log('closeHopWizard completed, removed:', removed);
}

// Ensure the function is globally accessible for inline onclick handlers
window.closeHopWizard = closeHopWizard;

// Dedicated swap wizard for more flexibility
function showSwapWizard(hopNumber) {
    console.log('showSwapWizard called with hopNumber:', hopNumber, 'type:', typeof hopNumber);

    // Convert to number if it's a string
    let numericHopNumber = hopNumber;
    if (typeof hopNumber === 'string') {
        numericHopNumber = parseInt(hopNumber);
        console.log('Converted to number:', numericHopNumber);
    }

    console.log('Available hops:', investigation.hops.map(h => ({ id: h.id, hopNumber: h.hopNumber, type: typeof h.id })));

    // Try to find the hop
    let hop = investigation.hops.find(h => h.hopNumber === numericHopNumber);

    // If not found by ID, try to find by hop number (fallback)
    if (!hop && typeof numericHopNumber === 'number' && numericHopNumber <= 10) {
        // If hop number looks like a small value, try to find by hopNumber
        hop = investigation.hops.find(h => h.hopNumber === numericHopNumber);
        if (hop) {
            console.log('Found hop by hopNumber instead of ID');
        }
    }

    if (!hop) {
        console.error('Hop not found for swap wizard:', numericHopNumber);
        console.error('Looking for hop with number:', numericHopNumber);
        console.error('Available hop IDs:', investigation.hops.map(h => h.id));
        alert('Error: Could not find the hop. Please close this wizard and try again.');
        return;
    }

    console.log('Initializing swap wizard for hop:', hop);

    // Initialize swap wizard data
    // Store the hop for reference, but swap wizard primarily works with source threads
    window.swapWizardData = {
        hop: hop,  // Store the whole hop object instead of just ID
        hopNumber: hop.hopNumber,
        selectedThreads: [],
        selectedInternalIds: [],  // Track internal IDs for dual-layer support
        threadAmounts: {}, // Track partial amounts for each thread
        inputAmount: 0,
        inputCurrency: '',
        outputAmount: 0,
        outputCurrency: '',
        swapService: '',
        providerName: '', // Optional provider name (Uniswap, Binance, etc.)
        swapType: 'dex', // 'dex' or 'cex' (centralized exchange)
        txHash: '',
        notes: '',
        step: 1
    };

    // Get available threads
    const availableThreads = getAvailableSourcesForHop(hop.hopNumber, null);

    const wizardHTML = `
        <div id="swapWizard" class="modal" style="display: block; z-index: 10000;">
            <div class="modal-content" style="max-width: 700px; max-height: 90vh; overflow-y: auto;">
                <div class="modal-header" style="background: linear-gradient(135deg, #ffc107 0%, #ff9800 100%);">
                    <h2 style="color: white;">🔄 Asset Swap/Conversion - Hop ${hop.hopNumber}</h2>
                    <button onclick="closeSwapWizard()" class="close-btn" style="color: white;">×</button>
                </div>

                <div id="swapWizardContent" style="padding: 20px;">
                    <!-- Content will be populated by showSwapWizardStep -->
                </div>

                <div style="padding: 20px; border-top: 1px solid #e0e0e0; display: flex; justify-content: space-between;">
                    <button class="btn btn-secondary" id="swapBackBtn" onclick="swapWizardBack()" style="display: none;">Back</button>
                    <button class="btn btn-primary" id="swapNextBtn" onclick="swapWizardNext()">Next</button>
                </div>
            </div>
        </div>
    `;

    console.log('Creating swap wizard modal');
    createCenteredModal('swapWizard', wizardHTML);

    // Ensure modal is visible
    const swapModal = document.getElementById('swapWizard');
    if (swapModal) {
        console.log('Swap wizard modal created successfully');
        swapModal.style.display = 'block';
        swapModal.classList.add('show');
    } else {
        console.error('Failed to create swap wizard modal');
    }

    showSwapWizardStep(1);
}

function showSwapWizardStep(step) {
    console.log('Showing swap wizard step:', step);
    const content = document.getElementById('swapWizardContent');
    const backBtn = document.getElementById('swapBackBtn');
    const nextBtn = document.getElementById('swapNextBtn');
    const wizardData = window.swapWizardData;

    if (!content || !wizardData) {
        console.error('Missing swap wizard elements or data');
        return;
    }

    backBtn.style.display = step > 1 ? 'inline-block' : 'none';

    if (step === 1) {
        // Step 1: Select source threads
        const allThreads = getAvailableSourcesForHop(wizardData.hopNumber, null);

        // CRITICAL: Filter to only show threads that actually have availability
        const availableThreads = allThreads.filter(thread => thread.availableAmount > 0);

        // Log for debugging
        console.log('Swap wizard - All threads:', allThreads);
        console.log('Swap wizard - Available threads (>0 amount):', availableThreads);

        content.innerHTML = `
            <h3>Step 1: Select Source Threads</h3>
            <p>Select the thread(s) and amounts to swap:</p>

            ${availableThreads.length === 0 ? `
                <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 20px; text-align: center; margin: 20px 0;">
                    <p style="margin: 0; color: #856404; font-weight: bold;">⚠️ No threads available for swapping</p>
                    <p style="margin: 10px 0 0 0; color: #856404;">All threads have been fully assigned. Please check your previous entries.</p>
                </div>
            ` : `
            <div style="max-height: 400px; overflow-y: auto; border: 1px solid #ddd; border-radius: 8px; padding: 10px; margin: 20px 0;">
                ${availableThreads.map(thread => {
                    const internalId = thread.internalId || thread.threadId;
                    const isSelected = (wizardData.selectedInternalIds || wizardData.selectedThreads || []).includes(internalId);
                    const threadAmount = wizardData.threadAmounts[internalId] || thread.availableAmount;
                    return `
                    <div style="padding: 12px; margin: 8px 0; background: white; border: 2px solid ${isSelected ? '#4caf50' : '#e0e0e0'}; border-radius: 8px; transition: all 0.3s;">
                        <div style="display: flex; align-items: center; gap: 15px;">
                            <input type="checkbox"
                                   id="swap_thread_${thread.internalId || thread.threadId}"
                                   data-internal-id="${thread.internalId || thread.threadId}"
                                   data-notation="${thread.threadId}"
                                   ${isSelected ? 'checked' : ''}
                                   onchange="toggleSwapThread({notation: '${thread.threadId}', internalId: '${thread.internalId || thread.threadId}'})"
                                   style="width: 20px; height: 20px; cursor: pointer;">

                            <div style="flex: 1;">
                                <label for="swap_thread_${thread.threadId}" style="cursor: pointer; display: block;">
                                    <strong>${thread.displayText}</strong>
                                    <div style="font-size: 12px; color: #666; margin-top: 4px;">
                                        From: ${thread.sourceWallet ? thread.sourceWallet.substring(0, 10) + '...' : 'Unknown'}
                                        ${thread.displayText.includes('% TRACE]') ? `<br><span style="color: #ff9800;">⚠️ Partial trace - your proportional share</span>` : ''}
                                    </div>
                                </label>
                            </div>

                            <div style="text-align: right; min-width: 200px;">
                                <div style="margin-bottom: 5px;">
                                    <strong>Available: ${thread.availableAmount.toLocaleString()} ${thread.currency}</strong>
                                </div>
                                ${isSelected ? `
                                    <div style="display: flex; align-items: center; gap: 5px;">
                                        <label style="font-size: 12px;">Amount:</label>
                                        <input type="number"
                                               id="swap_amount_${thread.threadId}"
                                               value="${threadAmount}"
                                               min="0"
                                               max="${thread.availableAmount}"
                                               step="0.000001"
                                               onchange="updateSwapThreadAmount('${thread.threadId}', this.value, ${thread.availableAmount})"
                                               style="width: 120px; padding: 4px; font-size: 12px;">
                                        <button onclick="setMaxSwapAmount('${thread.threadId}', ${thread.availableAmount})"
                                                class="btn btn-sm" style="padding: 2px 8px; font-size: 11px;">Max</button>
                                    </div>
                                ` : ''}
                            </div>
                        </div>
                    </div>
                `;}).join('')}
            </div>
            `}

            <div style="background: #f0f8ff; padding: 15px; border-radius: 8px; margin-top: 20px;">
                <strong>ℹ️ Partial Swaps:</strong> You can swap partial amounts from each thread.
                The remaining balance will stay in the original thread.
            </div>
        `;

        nextBtn.disabled = wizardData.selectedThreads.length === 0;
        nextBtn.textContent = 'Next';

    } else if (step === 2) {
        // Step 2: Define swap details
        const selectedThreads = wizardData.selectedThreads.map(id =>
            getAvailableSourcesForHop(wizardData.hopNumber, null).find(t => t.threadId === id)
        );

        // Auto-calculate input totals by currency using partial amounts
        const inputByCurrency = {};
        selectedThreads.forEach(thread => {
            const swapAmount = wizardData.threadAmounts[thread.threadId] || thread.availableAmount;
            if (!inputByCurrency[thread.currency]) {
                inputByCurrency[thread.currency] = 0;
            }
            inputByCurrency[thread.currency] += swapAmount;
        });

        content.innerHTML = `
            <h3>Step 2: Swap Details</h3>

            <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                <h4 style="margin-top: 0;">Input Assets (Being Swapped)</h4>
                ${Object.entries(inputByCurrency).map(([currency, amount]) => `
                    <div style="margin: 10px 0; padding: 10px; background: white; border-radius: 4px;">
                        <strong>${amount.toLocaleString()} ${currency}</strong>
                    </div>
                `).join('')}
            </div>

            <div style="margin: 20px 0;">
                <label style="display: block; margin-bottom: 10px;">Swap Service Type:</label>
                <div style="display: flex; gap: 10px;">
                    <button class="btn ${wizardData.swapType === 'dex' ? 'btn-primary' : 'btn-secondary'}"
                            onclick="setSwapType('dex')" style="flex: 1;">
                        🔄 DEX (On-chain)
                    </button>
                    <button class="btn ${wizardData.swapType === 'cex' ? 'btn-primary' : 'btn-secondary'}"
                            onclick="setSwapType('cex')" style="flex: 1;">
                        🏦 CEX (Off-chain)
                    </button>
                </div>
            </div>

            <div style="margin: 20px 0;">
                <label>Transaction Hash:</label>
                <div style="display: flex; gap: 10px; margin-top: 5px;">
                    <input type="text" id="swapTxHash"
                           placeholder="Transaction hash"
                           value="${wizardData.txHash}"
                           onchange="window.swapWizardData.txHash = this.value"
                           style="flex: 1; padding: 10px;">
                    <button class="btn btn-primary" onclick="lookupSwapTransaction()"
                            ${wizardData.swapType === 'cex' ? 'disabled title="Lookup not available for CEX swaps"' : ''}>
                        🔍 Lookup & Auto-fill
                    </button>
                </div>
                <div id="inputInfo" style="margin-top: 10px; color: #666;"></div>
                <small style="color: #666;">
                    ${wizardData.swapType === 'dex' ?
                        '💡 Paste transaction hash to automatically extract swap amounts' :
                        '💡 Manual entry required for centralized exchange swaps'}
                </small>
            </div>

            <div style="margin: 20px 0;">
                <label>Swap Service ${wizardData.swapType === 'dex' ? 'Address' : 'Name'}:</label>
                <input type="text" id="swapService"
                       placeholder="${wizardData.swapType === 'dex' ? 'DEX contract address (e.g., 0x...)' : 'Exchange name (e.g., Binance, Coinbase)'}"
                       value="${wizardData.swapService}"
                       onchange="window.swapWizardData.swapService = this.value"
                       style="width: 100%; padding: 10px; margin-top: 5px;">
            </div>

            <div style="margin: 20px 0;">
                <label>Service Provider Name (Optional):</label>
                <input type="text" id="swapProviderName"
                       placeholder="${wizardData.swapType === 'dex' ? 'Uniswap, SushiSwap, PancakeSwap, etc.' : 'Trading desk, OTC provider, etc.'}"
                       value="${wizardData.providerName || ''}"
                       onchange="window.swapWizardData.providerName = this.value"
                       style="width: 100%; padding: 10px; margin-top: 5px;">
                <small style="color: #666;">Optional: Name of the DEX protocol or exchange for documentation</small>
            </div>

            <div style="background: #e8f5e9; border: 2px solid #4caf50; border-radius: 8px; padding: 15px; margin-top: 20px;">
                <h4 style="margin-top: 0;">Output Asset (Received Back)</h4>

                <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                    <div style="flex: 1;">
                        <label>Amount Received:</label>
                        <input type="number" id="outputAmount"
                               step="0.000001"
                               placeholder="0.00"
                               value="${wizardData.outputAmount || ''}"
                               onchange="window.swapWizardData.outputAmount = Math.round((parseFloat(this.value) || 0) * 1000000) / 1000000"
                               style="width: 100%; padding: 10px; margin-top: 5px;">
                    </div>
                    <div style="flex: 1;">
                        <label>Currency Received:</label>
                        <input type="text" id="outputCurrency"
                               placeholder="USDT, ETH, etc."
                               value="${wizardData.outputCurrency}"
                               onchange="window.swapWizardData.outputCurrency = this.value.toUpperCase()"
                               style="width: 100%; padding: 10px; margin-top: 5px;">
                    </div>
                </div>

                <small style="color: #666;">
                    💡 Enter the exact amount and currency returned to the sender's control after the swap
                </small>
            </div>

            <div style="margin-top: 20px;">
                <label>Notes:</label>
                <textarea id="swapNotes"
                          rows="3"
                          placeholder="Exchange records, swap rates, additional details..."
                          onchange="window.swapWizardData.notes = this.value"
                          style="width: 100%; padding: 10px; margin-top: 5px;">${wizardData.notes}</textarea>
            </div>
        `;

        nextBtn.textContent = 'Create Swap Entry';
        // Enable button if we have output amount and currency (service is optional now with provider name)
        nextBtn.disabled = !wizardData.outputAmount || !wizardData.outputCurrency;

    } else if (step === 3) {
        // Step 3: Review and confirm
        createSwapEntry();
    }

    wizardData.step = step;
}

function toggleSwapThread(threadInfo) {
    const wizardData = window.swapWizardData;

    // Support both string (legacy) and object (dual-layer) inputs
    let notation, internalId;
    if (typeof threadInfo === 'string') {
        // Legacy - find the thread to get internal ID
        const threads = getAvailableSourcesForHop(wizardData.hopNumber, null);
        const thread = threads.find(t => t.threadId === threadInfo || t.internalId === threadInfo);
        if (thread) {
            notation = thread.threadId;
            internalId = thread.internalId || thread.threadId;
        } else {
            notation = threadInfo;
            internalId = threadInfo;
        }
    } else {
        notation = threadInfo.notation || threadInfo.threadId;
        internalId = threadInfo.internalId || notation;
    }

    // Initialize arrays if needed
    if (!wizardData.selectedInternalIds) wizardData.selectedInternalIds = [];
    if (!wizardData.selectedThreads) wizardData.selectedThreads = [];

    const index = wizardData.selectedInternalIds.indexOf(internalId);
    const threads = getAvailableSourcesForHop(wizardData.hopNumber, null);
    const thread = threads.find(t => t.internalId === internalId || t.threadId === internalId);

    if (!thread) {
        alert('Error: Thread not found');
        return;
    }

    // CRITICAL: Validate thread is actually available
    if (thread.availableAmount <= 0) {
        alert(`Thread ${threadId} has no available amount to swap. It may have been fully assigned already.`);
        // Uncheck the checkbox
        const checkbox = document.getElementById(`swap_thread_${threadId}`);
        if (checkbox) checkbox.checked = false;
        return;
    }

    if (index > -1) {
        // Remove thread and clear amount
        wizardData.selectedInternalIds.splice(index, 1);
        const notationIndex = wizardData.selectedThreads.indexOf(notation);
        if (notationIndex > -1) {
            wizardData.selectedThreads.splice(notationIndex, 1);
        }
        delete wizardData.threadAmounts[internalId];
    } else {
        // Add thread and set default amount to full amount
        wizardData.selectedInternalIds.push(internalId);
        if (!wizardData.selectedThreads.includes(notation)) {
            wizardData.selectedThreads.push(notation);
        }
        wizardData.threadAmounts[internalId] = thread.availableAmount;
    }

    showSwapWizardStep(wizardData.step); // Refresh display
}

// Update partial swap amount for a thread
function updateSwapThreadAmount(threadId, value, maxAmount) {
    const wizardData = window.swapWizardData;
    const amount = parseFloat(value) || 0;

    // Clamp to valid range
    wizardData.threadAmounts[threadId] = Math.min(Math.max(0, amount), maxAmount);

    // If amount is 0, remove the thread from selection
    if (wizardData.threadAmounts[threadId] === 0) {
        const index = wizardData.selectedThreads.indexOf(threadId);
        if (index !== -1) {
            wizardData.selectedThreads.splice(index, 1);
            delete wizardData.threadAmounts[threadId];
            showSwapWizardStep(wizardData.step);
        }
    }
}

// Set max amount for a swap thread
function setMaxSwapAmount(threadId, maxAmount) {
    const amountInput = document.getElementById(`swap_amount_${threadId}`);
    if (amountInput) {
        amountInput.value = maxAmount;
        updateSwapThreadAmount(threadId, maxAmount, maxAmount);
    }
}

function setSwapType(type) {
    window.swapWizardData.swapType = type;
    showSwapWizardStep(2); // Refresh to update placeholder text
}

function swapWizardNext() {
    const wizardData = window.swapWizardData;

    if (wizardData.step === 2) {
        // Create the swap entry
        createSwapEntry();
    } else {
        wizardData.step++;
        showSwapWizardStep(wizardData.step);
    }
}

function swapWizardBack() {
    const wizardData = window.swapWizardData;
    if (wizardData.step > 1) {
        wizardData.step--;
        showSwapWizardStep(wizardData.step);
    }
}

function closeSwapWizard() {
    console.log('closeSwapWizard called');
    const wizard = document.getElementById('swapWizard');
    if (wizard) {
        console.log('Removing swap wizard element');
        wizard.remove();
    } else {
        console.log('Swap wizard element not found');
        // Try alternative removal methods
        const wizardAlt = document.querySelector('#swapWizard');
        if (wizardAlt) {
            console.log('Found swap wizard via querySelector, removing');
            wizardAlt.remove();
        }
    }
    window.swapWizardData = null;
}

async function lookupSwapTransaction() {
    const wizardData = window.swapWizardData;
    const txHash = document.getElementById('swapTxHash').value.trim();

    if (!txHash) {
        alert('Please enter a transaction hash first');
        return;
    }

    const lookupBtn = event.target;
    const originalText = lookupBtn.textContent;
    lookupBtn.textContent = 'Looking up...';
    lookupBtn.disabled = true;

    try {
        // Try to detect blockchain from hash format
        const blockchain = detectBlockchainFromHash(txHash);
        if (!blockchain) {
            alert('Could not detect blockchain from hash format');
            lookupBtn.textContent = originalText;
            lookupBtn.disabled = false;
            return;
        }

        // Get transaction data using existing lookup functions
        let txData;
        switch(blockchain) {
            case 'ethereum':
                txData = await lookupEthereumTransaction(txHash);
                break;
            case 'bitcoin':
                txData = await lookupBitcoinTransaction(txHash);
                break;
            case 'tron':
                txData = await lookupTronTransaction(txHash);
                break;
            case 'solana':
                txData = await lookupSolanaTransaction(txHash);
                break;
            default:
                alert('Unsupported blockchain: ' + blockchain);
                lookupBtn.textContent = originalText;
                lookupBtn.disabled = false;
                return;
        }

        if (!txData) {
            alert('Failed to retrieve transaction data');
            lookupBtn.textContent = originalText;
            lookupBtn.disabled = false;
            return;
        }

        // For swap transactions, we need to find:
        // 1. What left the user's wallet (outgoing)
        // 2. What came back to the user's wallet (incoming)

        // Get the user's wallet address from the source thread
        let userWallet = null;

        // First try to get it from the selected thread's last receiving wallet
        if (wizardData.selectedThreads && wizardData.selectedThreads.length > 0) {
            const threads = getAvailableSourcesForHop(wizardData.hopNumber, null);
            const sourceThread = threads.find(t => t.threadId === wizardData.selectedThreads[0]);
            if (sourceThread && sourceThread.lastReceivingWallet) {
                userWallet = sourceThread.lastReceivingWallet;
                console.log('Using wallet from source thread:', userWallet);
            }
        }

        // Fallback to transaction sender
        if (!userWallet) {
            userWallet = txData.transaction?.from || txData.from;
            console.log('Using wallet from transaction sender:', userWallet);
        }

        if (!userWallet) {
            alert('Could not determine user wallet address. Please ensure you have selected a source thread.');
            lookupBtn.textContent = originalText;
            lookupBtn.disabled = false;
            return;
        }

        // CRITICAL VALIDATION: Verify the transaction involves the correct wallet(s)
        if (wizardData.selectedThreads && wizardData.selectedThreads.length > 0) {
            const threads = getAvailableSourcesForHop(wizardData.hopNumber, null);
            const selectedThreadData = wizardData.selectedThreads.map(id => threads.find(t => t.threadId === id));

            // Get all wallets associated with selected threads
            const threadWallets = selectedThreadData.map(t => t.sourceWallet).filter(w => w);

            // Check if the transaction involves any of the thread wallets
            const txSender = (txData.transaction?.from || txData.from || '').toLowerCase();
            const hasMatchingWallet = threadWallets.some(wallet =>
                wallet.toLowerCase() === txSender
            );

            if (!hasMatchingWallet && threadWallets.length > 0) {
                const walletList = threadWallets.join(', ');
                const proceed = confirm(`⚠️ WARNING: This transaction sender does not match your selected thread wallet(s).\n\nSelected thread wallet(s): ${walletList}\nTransaction sender: ${txSender}\n\nThis may indicate you selected the wrong thread or wrong transaction.\n\nContinue anyway?`);
                if (!proceed) {
                    lookupBtn.textContent = originalText;
                    lookupBtn.disabled = false;
                    return;
                }
            }
        }

        // Filter transfers to find what left and what came back to the user
        const outgoingTransfers = [];
        const incomingTransfers = [];

        if (txData.transfers && Array.isArray(txData.transfers)) {
            txData.transfers.forEach(transfer => {
                // Normalize the from/to addresses
                const from = (transfer.from || '').toLowerCase();
                const to = (transfer.to || '').toLowerCase();
                const userAddr = userWallet.toLowerCase();

                if (from === userAddr) {
                    // User sent this
                    outgoingTransfers.push(transfer);
                } else if (to === userAddr) {
                    // User received this
                    incomingTransfers.push(transfer);
                }
            });
        }

        console.log('Swap analysis:', {
            userWallet,
            outgoing: outgoingTransfers,
            incoming: incomingTransfers
        });

        // Auto-fill based on what we found
        if (outgoingTransfers.length > 0 && incomingTransfers.length > 0) {
            // We found both sides of the swap

            // Input (what was sent from user's wallet)
            const sentAmount = outgoingTransfers.reduce((sum, t) => sum + (parseFloat(t.amount) || 0), 0);
            const sentCurrency = outgoingTransfers[0].currency || outgoingTransfers[0].symbol || 'UNKNOWN';

            // Output (what was received back to user's wallet)
            const receivedAmount = incomingTransfers.reduce((sum, t) => sum + (parseFloat(t.amount) || 0), 0);
            const receivedCurrency = incomingTransfers[0].currency || incomingTransfers[0].symbol || 'UNKNOWN';

            // The input amount/currency should match what we're tracing from source threads
            // The output is what we received back
            document.getElementById('outputAmount').value = receivedAmount;
            document.getElementById('outputCurrency').value = receivedCurrency.toUpperCase();

            // Update wizard data with proper precision
            wizardData.outputAmount = Math.round(receivedAmount * 1000000) / 1000000;
            wizardData.outputCurrency = receivedCurrency.toUpperCase();

            // Display the detected input for reference
            const inputInfo = document.getElementById('inputInfo');
            if (inputInfo) {
                inputInfo.innerHTML = `<small>Detected swap: ${sentAmount} ${sentCurrency} → ${receivedAmount} ${receivedCurrency}</small>`;
            }

            // Get DEX contract address (usually the first contract interacted with)
            if (outgoingTransfers[0].to && outgoingTransfers[0].to !== userWallet) {
                document.getElementById('swapService').value = outgoingTransfers[0].to;
                wizardData.swapService = outgoingTransfers[0].to;
            }

            // Update notes with details
            const notes = `DEX Swap: ${sentAmount} ${sentCurrency} → ${receivedAmount} ${receivedCurrency}`;
            document.getElementById('swapNotes').value = notes;
            wizardData.notes = notes;

            // Refresh the UI
            showSwapWizardStep(2);

            alert(`✅ Swap detected!\n\nSent: ${sentAmount} ${sentCurrency}\nReceived: ${receivedAmount} ${receivedCurrency}\n\nPlease verify and adjust if needed.`);
        } else if (outgoingTransfers.length > 0) {
            alert('⚠️ Only found outgoing transfers. Please manually enter what was received.');
        } else if (incomingTransfers.length > 0) {
            alert('⚠️ Only found incoming transfers. Please verify this is the correct transaction.');
        } else {
            alert('⚠️ No transfers found for the user wallet. Please enter details manually.');
        }

    } catch (error) {
        console.error('Swap lookup error:', error);
        alert('Error analyzing swap transaction: ' + error.message);
    } finally {
        lookupBtn.textContent = originalText;
        lookupBtn.disabled = false;
    }
}

function createSwapEntry() {
    console.log('Creating swap entry...');
    const wizardData = window.swapWizardData;

    if (!wizardData) {
        console.error('No swap wizard data found');
        alert('Error: Swap wizard data not found. Please try again.');
        return;
    }

    // Get the hop from wizard data (we stored the whole hop object)
    const hop = wizardData.hop;
    if (!hop) {
        console.error('No hop stored in swap wizard data');
        alert('Error: Swap wizard data is incomplete. Please try again.');
        return;
    }

    // CRITICAL VALIDATION: Check for duplicate transaction hash in the same hop
    if (wizardData.txHash) {
        const duplicateEntry = hop.entries.find(entry =>
            entry.txHash &&
            entry.txHash.toLowerCase() === wizardData.txHash.toLowerCase() &&
            entry.entryType !== 'writeoff'
        );

        if (duplicateEntry) {
            alert(`❌ Transaction hash already used in this hop!\n\nTransaction ${wizardData.txHash} is already logged in entry ${duplicateEntry.id} (${duplicateEntry.notation || 'unnamed'}).\n\nSwap transactions must use unique transaction hashes.`);
            return;
        }
    }

    // Get selected thread details
    const threads = getAvailableSourcesForHop(hop.hopNumber, null);
    const selectedThreadData = wizardData.selectedThreads.map(id => threads.find(t => t.threadId === id));

    // Calculate total input amounts using partial amounts
    const inputByCurrency = {};
    const partialSwaps = [];  // Track which threads have partial amounts

    selectedThreadData.forEach(thread => {
        const swapAmount = wizardData.threadAmounts[thread.threadId] || thread.availableAmount;
        const isPartial = swapAmount < thread.availableAmount;

        if (isPartial) {
            partialSwaps.push({
                threadId: thread.threadId,
                swapAmount: swapAmount,
                remainingAmount: thread.availableAmount - swapAmount
            });
        }

        if (!inputByCurrency[thread.currency]) {
            inputByCurrency[thread.currency] = { amount: 0, threads: [] };
        }
        inputByCurrency[thread.currency].amount += swapAmount;
        inputByCurrency[thread.currency].threads.push(thread.threadId);
    });

    // Get the input currency (assuming single currency for now)
    const inputCurrency = Object.keys(inputByCurrency)[0];
    const inputData = inputByCurrency[inputCurrency];

    // Keep same notation - swaps replace threads in place
    const notation = wizardData.selectedThreads.length === 1 ?
        wizardData.selectedThreads[0] :
        wizardData.selectedThreads.map(t => t.split('-').slice(0, 2).join('-')).join('+') + `-H${hop.hopNumber}`;

    // Create the swap entry with dual-layer support
    const swapEntry = {
        id: Date.now(),
        hopNumber: hop.hopNumber,  // Use hop number as the identifier
        entryType: 'swap',

        // Dual-layer thread tracking for input threads
        sourceThreadInternalId: selectedThreadData.length === 1 && selectedThreadData[0] ?
            (selectedThreadData[0].internalId || selectedThreadData[0].threadId) : '',
        multipleSourceInternalIds: selectedThreadData.length > 1 ?
            selectedThreadData.map(t => t.internalId || t.threadId) : [],

        // Keep notation for backward compatibility
        sourceThreadId: wizardData.selectedThreads.length === 1 ? wizardData.selectedThreads[0] : '',
        multipleSourceThreads: wizardData.selectedThreads.length > 1 ? wizardData.selectedThreads : [],

        threadAmounts: wizardData.threadAmounts, // Store partial amounts for each thread
        fromWallet: selectedThreadData[0]?.sourceWallet || '',
        toWallet: wizardData.swapService,
        toWalletType: 'brown', // BROWN for asset conversion
        amount: inputData.amount.toString(),
        outputAmount: roundToCurrencyPrecision(wizardData.outputAmount, wizardData.outputCurrency).toString(),
        currency: inputCurrency,
        outputCurrency: wizardData.outputCurrency,
        txHash: wizardData.txHash,
        timestamp: new Date().toISOString().slice(0, 16),
        timezone: 'UTC',
        notes: wizardData.notes || `Asset conversion: ${inputData.amount} ${inputCurrency} swapped for ${wizardData.outputAmount} ${wizardData.outputCurrency} via ${wizardData.providerName || (wizardData.swapType === 'cex' ? 'CEX' : 'DEX')}`,
        notation: notation,
        isSwap: true,
        isBridge: true, // CRITICAL: All brown conversion wallets should have bridge flag
        partialSwaps: partialSwaps, // Track which threads had partial amounts
        swapDetails: {
            fromCurrency: inputCurrency,
            toCurrency: wizardData.outputCurrency,
            fromAmount: inputData.amount,
            toAmount: roundToCurrencyPrecision(wizardData.outputAmount, wizardData.outputCurrency),
            dexAddress: wizardData.swapService,
            providerName: wizardData.providerName,
            type: wizardData.swapType
        }
    };

    // Save undo state
    saveUndoState(`Add swap entry to Hop ${hop.hopNumber}`);

    // Add entry to hop
    hop.entries.push(swapEntry);

    // Update available threads - use the dual-layer version
    // updateThreadsAfterSwap(hop, swapEntry); // OLD function
    updateThreadAvailabilityFromSwap(swapEntry); // NEW dual-layer function

    // Close wizard and update UI
    closeSwapWizard();

    // Mark the swap entry as logged/collapsed immediately
    const entryKey = `${hop.hopNumber}_${swapEntry.id}`;
    window.entryCollapseState[entryKey] = true;

    buildAvailableThreadsIndex();
    renderHops();
    saveToStorage();

    // Show success message
    const providerInfo = wizardData.providerName ? ` via ${wizardData.providerName}` : '';
    showNotification(
        `✅ Swap entry created: ${inputData.amount} ${inputCurrency} → ${wizardData.outputAmount} ${wizardData.outputCurrency}${providerInfo}`,
        'success',
        4000
    );

    console.log('Swap entry created successfully:', swapEntry);

    // Check if all source threads are consumed - if not, show add entry dialog for remaining threads
    const remainingSources = getAvailableSourcesForHop(hop.hopNumber + 1, null);
    if (remainingSources && remainingSources.length > 0) {
        // Show the next entry wizard for continuing the trace with the new currency
        setTimeout(() => {
            showAddEntryWizard(hop.hopNumber + 1);
        }, 500);
    } else {
        // Show remaining threads summary
        showRemainingThreadsSummary(hop);
    }
}

function createAndFinalizeEntry() {
    // This function is deprecated but kept for backwards compatibility
    // The new workflow creates entries directly from step 2
    window.hopWizardData.shouldFinalize = true;
    createHopEntryFromWizard();
}

function reopenHopWizard(hopNumber, entryId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop?.entries.find(e => e.id === entryId);
    if (!hop || !entry) return;

    // Initialize wizard data with existing entry data
    window.hopWizardData = {
        entryId: entryId,  // Store the entry ID for updating
        hopNumber: hop.hopNumber,
        selectedThreads: entry.multipleSourceThreads || (entry.sourceThreadId ? [entry.sourceThreadId] : []),
        allocations: entry.individualSourceAssignments || {},
        step: 1,
        txHash: entry.txHash || '',
        entryMode: 'lookup',
        manualData: {
            fromWallet: entry.fromWallet || '',
            toWallet: entry.toWallet || '',
            timestamp: entry.timestamp || new Date().toISOString().slice(0, 16)
        },
        isEditMode: true  // Flag to indicate we're editing an existing entry
    };

    // If entry has a single source thread and amount, set the allocation
    if (entry.sourceThreadId && !entry.multipleSourceThreads) {
        window.hopWizardData.allocations[entry.sourceThreadId] = parseFloat(entry.amount) || 0;
    }

    // Detect chain from selected threads
    const selectedThreadIds = entry.multipleSourceThreads || (entry.sourceThreadId ? [entry.sourceThreadId] : []);
    if (selectedThreadIds.length > 0) {
        const availableThreads = getAvailableSourcesForHop(hopNumber, null);
        for (const threadId of selectedThreadIds) {
            const thread = availableThreads.find(t => t.threadId === threadId || t.internalId === threadId);
            if (thread && thread.chainId) {
                window.hopWizardData.detectedChain = thread.chainId;
                console.log(`Detected chain ${thread.chainId} from thread ${threadId} when reopening wizard`);
                break;
            }
        }
    }

    openHopEntryWizard(hopNumber);
}
window.reopenHopWizard = reopenHopWizard;

function openHopEntryWizard(hopNumber) {
    console.log('openHopEntryWizard called with hopNumber:', hopNumber, 'type:', typeof hopNumber);

    // Convert to number if it's a string
    const numericHopNumber = typeof hopNumber === 'string' ? parseInt(hopNumber) : hopNumber;

    // Get hop data
    const hop = investigation.hops.find(h => h.hopNumber === numericHopNumber);
    if (!hop) {
        console.error('Hop not found for hopNumber:', numericHopNumber);
        console.error('Available hops:', investigation.hops.map(h => h.hopNumber));
        return;
    }
    console.log('Hop found:', hop);

    // IMPORTANT: Rebuild threads database to ensure we have latest state after any swaps
    buildAvailableThreadsIndex();
    console.log('Rebuilt threads database before opening wizard');

    // Initialize wizard data if not already editing
    if (!window.hopWizardData || !window.hopWizardData.isEditMode) {
        window.hopWizardData = {
            hopNumber: numericHopNumber,
            selectedThreads: [],
            selectedInternalIds: [],  // Add for dual-layer support
            selectedNotations: [],    // Add for dual-layer support
            allocations: {},
            step: 1,
            txHash: '',
            entryMode: 'lookup'
        };
    }
    
    const wizardHTML = `
        <div id="hopEntryWizard" class="modal show">
            <div class="modal-content" style="max-width: 900px; width: 90%;">
                <div class="modal-header" style="position: relative;">
                    <h2>🔍 Add Trace Entry - Hop ${numericHopNumber}</h2>
                    <button class="close-btn" onclick="window.closeHopWizard(); return false;"
                            style="position: absolute; right: 15px; top: 15px; width: 30px; height: 30px;
                                   font-size: 24px; background: #e74c3c; color: white; border: none;
                                   border-radius: 50%; cursor: pointer; display: flex; align-items: center;
                                   justify-content: center; box-shadow: 0 2px 5px rgba(0,0,0,0.2);
                                   transition: all 0.3s ease; font-weight: bold; line-height: 1;
                                   z-index: 10000;"
                            onmouseover="this.style.background='#c0392b'; this.style.transform='scale(1.1)'"
                            onmouseout="this.style.background='#e74c3c'; this.style.transform='scale(1)'"
                            title="Close Wizard">&times;</button>
                </div>
                
                <div class="wizard-progress" id="wizardProgress">
                    <div class="wizard-step active" id="wizStep1">1. Select Source</div>
                    <div class="wizard-step" id="wizStep2">2. Lookup Transaction</div>
                    <div class="wizard-step" id="wizStep3">3. Review & Create</div>
                </div>
                
                <div id="wizardContent" style="min-height: 400px; padding: 20px;">
                    <!-- Content will be loaded here -->
                </div>
                
                <div class="wizard-footer" style="padding: 20px; border-top: 1px solid #ddd;">
                    <div id="wizardFooterButtons" style="display: flex; justify-content: space-around; align-items: center;">
                        <button class="btn btn-secondary" id="wizardBackBtn" onclick="window.hopWizardBack()" style="padding: 10px 20px;" disabled>← Back</button>
                        <button class="btn btn-primary" id="wizardNextBtn" onclick="window.hopWizardNext()" style="padding: 10px 20px;">Next →</button>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    // Remove any existing wizard
    const existingWizard = document.getElementById('hopEntryWizard');
    if (existingWizard) {
        console.log('Removing existing wizard');
        existingWizard.remove();
    }

    console.log('About to insert wizard HTML to DOM');
    console.log('HTML length:', wizardHTML.length);

    // Add wizard directly to DOM
    document.body.insertAdjacentHTML('beforeend', wizardHTML);

    console.log('Wizard HTML inserted, checking for element...');

    // Verify wizard was created
    const wizardElement = document.getElementById('hopEntryWizard');

    // Add event listener to the close button as a fallback
    if (wizardElement) {
        const closeBtn = wizardElement.querySelector('.close-btn');
        if (closeBtn) {
            // Add click event listener (keep onclick as primary)
            closeBtn.addEventListener('click', function(e) {
                console.log('Close button clicked via event listener');
                if (!this.onclick) {
                    // Only handle if onclick didn't fire
                    e.preventDefault();
                    e.stopPropagation();
                    if (window.closeHopWizard) {
                        window.closeHopWizard();
                    } else if (typeof closeHopWizard === 'function') {
                        closeHopWizard();
                    } else {
                        // Direct removal as last resort
                        wizardElement.remove();
                    }
                }
            });
            console.log('Close button event listener attached');
        }
    }
    console.log('Wizard element found:', !!wizardElement);

    if (!wizardElement) {
        console.error('Failed to create hop entry wizard');
        console.error('Body children count:', document.body.children.length);
        return;
    }

    console.log('Wizard created successfully, showing first step');

    // Show first step
    showHopWizardStep(1);
}
window.openHopEntryWizard = openHopEntryWizard;

function skipHopWizard() {
    closeHopWizard();
    createHopEntryDirectly(window.hopWizardData.hopNumber, 'trace');
}

// Skip wizard just for this entry without disabling it permanently
function skipWizardThisTime() {
    const hopNumber = window.hopWizardData.hopNumber;
    closeHopWizard();
    createHopEntryDirectly(hopNumber, 'trace');
}

// Cancel wizard and transfer data to manual entry form
function cancelWizardToManual() {
    const wizardData = window.hopWizardData;
    if (!wizardData) return;
    
    const hopNumber = wizardData.hopNumber;
    
    // Close wizard
    closeHopWizard();
    
    // Create manual entry with pre-filled data
    createHopEntryDirectly(hopNumber, 'trace');
    
    // Wait for DOM update then fill in the data
    setTimeout(() => {
        // Find the last added entry form
        const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
        if (!hop) return;
        
        const lastEntry = hop.entries[hop.entries.length - 1];
        if (!lastEntry) return;
        
        // Pre-fill amount if allocations exist
        const totalAmount = Object.values(wizardData.allocations).reduce((sum, val) => sum + val, 0);
        if (totalAmount > 0) {
            const amountInput = document.querySelector(`[onchange*="updateEntryAmount(${hopNumber}, ${lastEntry.id}"]`);
            if (amountInput) {
                amountInput.value = totalAmount;
                updateEntryAmount(hopNumber, lastEntry.id, totalAmount.toString());
            }
        }
        
        // Pre-fill transaction hash
        if (wizardData.txHash) {
            const txHashInput = document.querySelector(`[onchange*="updateEntryField(${hopNumber}, ${lastEntry.id}, 'txHash'"]`);
            if (txHashInput) {
                txHashInput.value = wizardData.txHash;
                updateEntryField(hopNumber, lastEntry.id, 'txHash', wizardData.txHash);
            }
        }
        
        // Pre-fill manual data if available
        if (wizardData.manualData) {
            if (wizardData.manualData.fromWallet) {
                const fromInput = document.querySelector(`[onchange*="updateEntryField(${hopNumber}, ${lastEntry.id}, 'fromWallet'"]`);
                if (fromInput) {
                    fromInput.value = wizardData.manualData.fromWallet;
                    updateEntryField(hopNumber, lastEntry.id, 'fromWallet', wizardData.manualData.fromWallet);
                }
            }
            
            if (wizardData.manualData.toWallet) {
                const toInput = document.querySelector(`[onchange*="updateEntryField(${hopNumber}, ${lastEntry.id}, 'toWallet'"]`);
                if (toInput) {
                    toInput.value = wizardData.manualData.toWallet;
                    updateEntryField(hopNumber, lastEntry.id, 'toWallet', wizardData.manualData.toWallet);
                }
            }
            
            if (wizardData.manualData.timestamp) {
                const timestampInput = document.querySelector(`[onchange*="updateEntryField(${hopNumber}, ${lastEntry.id}, 'timestamp'"]`);
                if (timestampInput) {
                    timestampInput.value = wizardData.manualData.timestamp;
                    updateEntryField(hopNumber, lastEntry.id, 'timestamp', wizardData.manualData.timestamp);
                }
            }
        }
        
        // Pre-fill source threads if single thread
        if (wizardData.selectedThreads.length === 1) {
            const threadId = wizardData.selectedThreads[0];
            const sourceSelect = document.querySelector(`[onchange*="updateSourceThread(${hopNumber}, ${lastEntry.id}"]`);
            if (sourceSelect) {
                sourceSelect.value = threadId;
                updateSourceThread(hopNumber, lastEntry.id, threadId);
            }
        }
        
        // Scroll to the new entry
        const entryElement = document.getElementById(`entry_${hopNumber}_${lastEntry.id}`);
        if (entryElement) {
            entryElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            // Highlight it briefly
            entryElement.style.border = '3px solid #3498db';
            setTimeout(() => {
                entryElement.style.border = '';
            }, 2000);
        }
    }, 100);
}

// Set wizard entry mode (lookup vs manual)
function setWizardEntryMode(mode) {
    window.hopWizardData.entryMode = mode;
    // When switching modes, preserve existing data
    if (mode === 'manual' && !window.hopWizardData.manualData) {
        window.hopWizardData.manualData = {};
    }
    showHopWizardStep(3); // Refresh step 3
}

// Update wizard manual data
function updateWizardManualData(field, value) {
    if (!window.hopWizardData.manualData) {
        window.hopWizardData.manualData = {};
    }
    window.hopWizardData.manualData[field] = value;
    // Check if we can enable the button now
    checkWizardButtonState();
}

function checkWizardButtonState() {
    if (!window.hopWizardData) return;

    const nextBtn = document.getElementById('wizardNextBtn');
    if (!nextBtn) return;

    const wizardData = window.hopWizardData;

    if (wizardData.step === 3) {
        // On step 3, check if we have minimum requirements
        if (wizardData.entryMode === 'manual') {
            nextBtn.disabled = !wizardData.txHash || !wizardData.manualData?.toWallet;
        } else {
            // In lookup mode, just need the hash
            nextBtn.disabled = !wizardData.txHash;
        }
    }
}

function toggleWizardPreference() {
    const checkbox = document.getElementById('disableWizardCheckbox');
    localStorage.setItem('bats_hop_wizard_disabled', checkbox.checked ? 'true' : 'false');
}

function updateWizardThreadSelection(threadInfo) {
    const wizardData = window.hopWizardData;

    // Support both string (legacy) and object (dual-layer) inputs
    let notation, internalId;
    if (typeof threadInfo === 'string') {
        // Legacy mode - just notation
        notation = threadInfo;
        internalId = threadInfo;  // Use notation as internal ID for backward compatibility
    } else {
        // Dual-layer mode - object with both notation and internalId
        notation = threadInfo.notation || threadInfo.threadId;
        internalId = threadInfo.internalId || threadInfo.notation || threadInfo.threadId;
    }

    // Store selections using internal IDs
    const index = wizardData.selectedInternalIds?.indexOf(internalId) ?? -1;

    if (!wizardData.selectedInternalIds) {
        wizardData.selectedInternalIds = [];
    }
    if (!wizardData.selectedNotations) {
        wizardData.selectedNotations = [];
    }

    if (index > -1) {
        wizardData.selectedInternalIds.splice(index, 1);
        const notationIndex = wizardData.selectedNotations.indexOf(notation);
        if (notationIndex > -1) {
            wizardData.selectedNotations.splice(notationIndex, 1);
        }
        delete wizardData.allocations[internalId];
    } else {
        wizardData.selectedInternalIds.push(internalId);
        wizardData.selectedNotations.push(notation);
    }

    // Keep backward compatibility
    wizardData.selectedThreads = wizardData.selectedNotations;

    // Detect chain from selected threads
    if (wizardData.selectedInternalIds.length > 0) {
        const availableThreads = getAvailableSourcesForHop(wizardData.hopNumber, null);
        let detectedChain = null;

        // Check all selected threads for chain information
        for (const selectedId of wizardData.selectedInternalIds) {
            const thread = availableThreads.find(t =>
                t.internalId === selectedId || t.threadId === selectedId
            );
            if (thread && thread.chainId) {
                detectedChain = thread.chainId;
                console.log(`Detected chain ${detectedChain} from thread ${selectedId}`);
                break;  // Use the first thread with chain info
            }
        }

        if (detectedChain) {
            wizardData.detectedChain = detectedChain;
            console.log(`Wizard chain detection: Set detectedChain to ${detectedChain}`);
        }
    } else {
        // Clear detected chain if no threads selected
        wizardData.detectedChain = null;
    }

    const nextBtn = document.getElementById('wizardNextBtn');
    nextBtn.disabled = wizardData.selectedInternalIds.length === 0;
}

function updateWizardAllocation(threadInfo, value) {
    // Support both string and object inputs
    const internalId = typeof threadInfo === 'string' ?
                      threadInfo :
                      (threadInfo.internalId || threadInfo.threadId);

    window.hopWizardData.allocations[internalId] = parseFloat(value) || 0;
    updateWizardTotal();
}

// Set allocation mode (PIFO or Matching)
function setAllocationMode(mode) {
    if (!window.hopWizardData) return;

    window.hopWizardData.allocationMode = mode;

    // Re-apply allocation based on the selected mode
    if (mode === 'pifo') {
        applyPIFOToWizard();
    } else if (mode === 'matching' && window.hopWizardData.txData) {
        // Apply matching allocation (use full transaction amount)
        applyMatchingAllocation();
    }

    // Re-render the step
    hopWizardNextStep();
    hopWizardPrevStep(); // Go back to step 2 to show updated allocations
    hopWizardNextStep();
}

// Apply matching allocation (use exact transaction amounts)
function applyMatchingAllocation() {
    if (!window.hopWizardData || !window.hopWizardData.txData) return;

    const wizardData = window.hopWizardData;
    const txAmount = wizardData.txData.amount || 0;

    if (txAmount > 0 && wizardData.selectedThreads.length > 0) {
        // For matching mode, try to match the exact transaction amount
        wizardData.allocations = applyPIFOAllocation(txAmount, wizardData.selectedThreads);

        // Add note indicating matching mode
        const matchNotes = [];
        const threads = getAvailableSourcesForHop(wizardData.hopNumber, null);
        for (const [threadId, amount] of Object.entries(wizardData.allocations)) {
            if (amount > 0) {
                const thread = threads.find(t => t.threadId === threadId);
                if (thread) {
                    matchNotes.push(`${threadId}: ${amount}/${thread.availableAmount} ${thread.currency}`);
                }
            }
        }
        wizardData.pifoNote = `Transaction matching (${txAmount.toLocaleString()}): ${matchNotes.join(', ')}`;
    }
}

// Apply PIFO (Proceeds In First Out) allocation across multiple source threads
function applyPIFOAllocation(totalAmount, selectedThreads) {
    const allocations = {};
    let remainingAmount = totalAmount;
    const threads = getAvailableSourcesForHop(window.hopWizardData.hopNumber, null);

    // Sort threads by victim ID and transaction ID for consistent PIFO order
    const sortedThreadIds = selectedThreads.sort((a, b) => {
        // Parse thread IDs (e.g., "V1-T1-H1" or "V1-T1")
        const parseThreadId = (id) => {
            const parts = id.match(/V(\d+)-T(\d+)/);
            if (parts) {
                return { victim: parseInt(parts[1]), transaction: parseInt(parts[2]) };
            }
            return { victim: 999, transaction: 999 };
        };

        const threadA = parseThreadId(a);
        const threadB = parseThreadId(b);

        // Sort by victim first, then by transaction
        if (threadA.victim !== threadB.victim) {
            return threadA.victim - threadB.victim;
        }
        return threadA.transaction - threadB.transaction;
    });

    // Calculate total available across all selected threads
    let totalAvailable = 0;
    for (const threadId of sortedThreadIds) {
        const thread = threads.find(t => t.threadId === threadId);
        if (thread) {
            totalAvailable += thread.availableAmount;
        }
    }

    // If transaction amount exceeds total available, this is partial tracing
    // Only allocate what we have available
    if (totalAmount > totalAvailable) {
        console.log(`Partial trace: Transaction amount ${totalAmount} exceeds available ${totalAvailable}`);
        remainingAmount = totalAvailable; // Cap at what's available
    }

    // Apply PIFO allocation
    for (const threadId of sortedThreadIds) {
        if (remainingAmount <= 0) break;

        const thread = threads.find(t => t.threadId === threadId);
        if (!thread) continue;

        const available = thread.availableAmount;
        const toAllocate = Math.min(available, remainingAmount);
        const currency = thread.currency || 'USD';

        allocations[threadId] = roundToCurrencyPrecision(toAllocate, currency);
        remainingAmount = roundToCurrencyPrecision(remainingAmount - toAllocate, currency);
    }

    return allocations;
}

// Re-apply PIFO to current wizard state
function applyPIFOToWizard() {
    if (!window.hopWizardData) return;

    const wizardData = window.hopWizardData;
    const txAmount = wizardData.txData ? wizardData.txData.amount : 0;

    if (txAmount > 0 && wizardData.selectedThreads.length > 0) {
        // Apply PIFO allocation
        wizardData.allocations = applyPIFOAllocation(txAmount, wizardData.selectedThreads);

        // Update the UI
        for (const [threadId, amount] of Object.entries(wizardData.allocations)) {
            const input = document.getElementById(`wizardAllocation_${threadId}`);
            if (input) {
                input.value = amount;
            }
        }

        // Update the total
        updateWizardTotal();
    }
}

function setWizardMaxAllocation(threadId, maxAmount) {
    document.getElementById(`wizardAllocation_${threadId}`).value = maxAmount;
    updateWizardAllocation(threadId, maxAmount);
}

function updateWizardTotal() {
    const wizardData = window.hopWizardData;
    if (!wizardData) {
        console.error('Wizard data not available in updateWizardTotal');
        return;
    }
    const threads = getAvailableSourcesForHop(wizardData.hopNumber, null);
    
    let totalText = [];
    const currencyTotals = {};
    
    Object.entries(wizardData.allocations).forEach(([threadId, amount]) => {
        if (amount > 0) {
            const thread = threads.find(t => t.threadId === threadId);
            if (thread) {
                if (!currencyTotals[thread.currency]) {
                    currencyTotals[thread.currency] = 0;
                }
                currencyTotals[thread.currency] += amount;
            }
        }
    });
    
    Object.entries(currencyTotals).forEach(([currency, total]) => {
        totalText.push(`${total.toLocaleString()} ${currency}`);
    });
    
    const totalElement = document.getElementById('wizardTotalAmount');
    if (totalElement) {
        totalElement.textContent = totalText.join(' + ') || '0';
    }
    
    const nextBtn = document.getElementById('wizardNextBtn');
    const hasAllocations = Object.values(wizardData.allocations).some(v => v > 0);
    nextBtn.disabled = !hasAllocations;
}

async function lookupWizardTransaction() {
    // Ensure wizard data is initialized
    if (!window.hopWizardData) {
        console.error('Wizard data not initialized when looking up transaction');
        alert('Error: Wizard not properly initialized. Please close and reopen the wizard.');
        return;
    }

    // Store the wizard session ID to detect if wizard was closed during lookup
    const sessionId = Date.now();
    window.hopWizardData.lookupSessionId = sessionId;

    const txHash = document.getElementById('wizardTxHash').value.trim();
    if (!txHash) return;

    const resultDiv = document.getElementById('wizardTxResult');
    resultDiv.innerHTML = '<div style="text-align: center;">Looking up transaction...</div>';

    try {
        // First check if chain was detected from source thread
        let detectedChain = window.hopWizardData?.detectedChain;

        // If no chain from source thread, check if chain selector exists (main lookup modal)
        if (!detectedChain) {
            detectedChain = document.getElementById('chainSelector')?.value;
        }

        // If still no chain, try to detect from hash
        if (!detectedChain) {
            detectedChain = detectBlockchainFromHash(txHash);
        }

        if (!detectedChain) {
            throw new Error('Unable to detect blockchain from hash');
        }

        // Detect the actual blockchain from the hash pattern
        const actualChain = detectBlockchainFromHash(txHash);

        // Check for chain mismatch
        if (actualChain && actualChain !== detectedChain) {
            // Special handling for EVM chains - they share the same hash format
            const evmChains = ['ethereum', 'base', 'arbitrum', 'optimism', 'polygon', 'bsc',
                              'avalanche', 'hyperevm', 'linea', 'scroll', 'mantle', 'blast',
                              'zksync', 'gnosis', 'celo', 'moonbeam', 'moonriver', 'fraxtal',
                              'taiko', 'arbitrumnova', 'bittorrent', 'opbnb'];

            const isSourceEVM = evmChains.includes(detectedChain);
            const isHashEVM = evmChains.includes(actualChain);

            // If not both EVM (which share format), show clear mismatch error
            if (!(isSourceEVM && isHashEVM)) {
                const sourceChainName = window.blockchainAPIs[detectedChain]?.name || detectedChain;
                const actualChainName = window.blockchainAPIs[actualChain]?.name || actualChain;

                throw new Error(`CHAIN MISMATCH: This transaction hash appears to be from ${actualChainName}, but the source thread is on ${sourceChainName}. Please check that you've copied the correct transaction hash for this hop.`);
            }
        }

        console.log(`Using chain: ${detectedChain} for transaction lookup`);

        // Call the appropriate lookup function based on chain type
        let txData;
        const evmChains = ['ethereum', 'base', 'arbitrum', 'optimism', 'polygon', 'bsc',
                          'avalanche', 'hyperevm', 'linea', 'scroll', 'mantle', 'blast',
                          'zksync', 'gnosis', 'celo', 'moonbeam', 'moonriver', 'fraxtal',
                          'taiko', 'arbitrumnova', 'bittorrent', 'opbnb'];

        if (evmChains.includes(detectedChain)) {
            // For EVM chains, temporarily set chain selector and use the ethereum lookup
            // which will actually use the detected chain from the selector
            const originalChain = document.getElementById('chainSelector')?.value;
            if (document.getElementById('chainSelector')) {
                document.getElementById('chainSelector').value = detectedChain;
            }

            // Call the existing lookup with the specific chain
            txData = await lookupEthereumTransaction(txHash, detectedChain);

            // Restore original chain selector
            if (document.getElementById('chainSelector') && originalChain !== undefined) {
                document.getElementById('chainSelector').value = originalChain;
            }
        } else {
            switch(detectedChain) {
                case 'bitcoin':
                    txData = await lookupBitcoinTransaction(txHash);
                    break;
                case 'tron':
                    txData = await lookupTronTransaction(txHash);
                    break;
                case 'solana':
                    txData = await lookupSolanaTransaction(txHash);
                    break;
                default:
                    throw new Error('Unsupported blockchain');
            }
        }

        // Check if wizard was closed or session changed during the async operation
        if (!window.hopWizardData || window.hopWizardData.lookupSessionId !== sessionId) {
            console.log('Wizard closed or session changed during transaction lookup');
            return; // Exit silently as wizard was closed
        }

        // Determine the currency we're tracking from source threads
        // IMPORTANT: For swap outputs, we need to track the OUTPUT currency, not the input
        let trackingCurrency = null;
        if (window.hopWizardData.selectedThreads && window.hopWizardData.selectedThreads.length > 0) {
            const threads = getAvailableSourcesForHop(window.hopWizardData.hopNumber, null);
            const sourceCurrencies = new Set();
            window.hopWizardData.selectedThreads.forEach(threadId => {
                const thread = threads.find(t => t.threadId === threadId);
                if (thread) {
                    // The thread object from getAvailableSourcesForHop already has the correct currency
                    // For swap outputs, it will be the output currency
                    sourceCurrencies.add(thread.currency);
                    console.log(`Thread ${threadId} has currency: ${thread.currency} (type: ${thread.sourceType})`);
                }
            });
            // If all source threads are the same currency, that's what we're tracking
            if (sourceCurrencies.size === 1) {
                trackingCurrency = Array.from(sourceCurrencies)[0];
                console.log(`Tracking currency determined: ${trackingCurrency}`);
            } else if (sourceCurrencies.size > 1) {
                console.log(`Multiple currencies in source threads: ${Array.from(sourceCurrencies).join(', ')}`);
            }
        }

        // Check if there are token transfers that need selection
        if (txData.transfers && txData.transfers.length > 0) {
            // Ensure wizard data still exists with proper session
            if (!window.hopWizardData || window.hopWizardData.lookupSessionId !== sessionId) {
                console.error('Wizard data lost or session changed during transaction processing');
                return;
            }

            // Filter transfers to only show those matching the tracking currency
            let relevantTransfers = txData.transfers;
            if (trackingCurrency) {
                // Filter to only transfers of the currency we're tracking
                relevantTransfers = txData.transfers.filter(t => t.currency === trackingCurrency);
                console.log(`Filtered ${txData.transfers.length} transfers to ${relevantTransfers.length} ${trackingCurrency} transfers`);

                // If no transfers match our currency, this might be an issue
                if (relevantTransfers.length === 0) {
                    throw new Error(`No ${trackingCurrency} transfers found in this transaction. Found: ${txData.transfers.map(t => t.currency).join(', ')}`);
                }
            }

            // If after filtering we only have one transfer, treat it as a single transfer
            if (relevantTransfers.length === 1) {
                // Single transfer - no need for selection
                window.hopWizardData.txData = {
                    ...txData,
                    ...relevantTransfers[0], // Use the single relevant transfer's data
                    transfers: relevantTransfers
                };
                // Update txData to use the filtered single transfer
                txData = window.hopWizardData.txData;
                // Important: Don't process this transfer twice - skip the multi-transfer handling
            } else if (relevantTransfers.length > 1) {
                // Multiple transfers of the same currency - need selection
                window.hopWizardData.pendingTransfers = relevantTransfers;
                window.hopWizardData.txData = txData;

                // Initialize selection tracking
                window.hopWizardData.selectedOutputs = window.hopWizardData.selectedOutputs || [];
                window.hopWizardData.outputClassifications = window.hopWizardData.outputClassifications || {};

                // Auto-detect potential change outputs
                const sourceWallet = window.hopWizardData.selectedThreads && window.hopWizardData.selectedThreads.length > 0 ?
                    getAvailableSourcesForHop(window.hopWizardData.hopNumber, null).find(t => t.threadId === window.hopWizardData.selectedThreads[0])?.sourceWallet : null;

                // Pre-classify outputs based on advanced change detection heuristics
                relevantTransfers.forEach((transfer, index) => {
                    const isBackToSender = sourceWallet && transfer.to.toLowerCase() === sourceWallet.toLowerCase();

                    // Advanced change detection heuristics
                    let changeScore = 0;
                    let changeReasons = [];

                    // 1. Same address (100% change)
                    if (isBackToSender) {
                        changeScore = 100;
                        changeReasons.push('Same address as sender');
                    } else {
                        // 2. Round amount heuristic (payments are often round)
                        const isRoundAmount = transfer.amount % 1 === 0 || transfer.amount % 0.1 === 0 || transfer.amount % 0.01 === 0;
                        const hasManySigFigs = transfer.amount.toString().split('.')[1]?.length > 4;

                        if (hasManySigFigs) {
                            changeScore += 30;
                            changeReasons.push('Many decimal places');
                        } else if (!isRoundAmount) {
                            changeScore += 20;
                            changeReasons.push('Non-round amount');
                        }

                        // 3. Output order heuristic (change often comes last in Bitcoin)
                        if (relevantTransfers.length === 2 && index === 1) {
                            changeScore += 15;
                            changeReasons.push('Second of two outputs');
                        }

                        // 4. Address type matching (change often uses same script type)
                        if (transfer.scriptType && sourceWallet) {
                            // Check if address types match (P2PKH, P2SH, P2WPKH, etc.)
                            const sourcePrefix = sourceWallet.substring(0, 1);
                            const destPrefix = transfer.to.substring(0, 1);

                            // Bitcoin address prefixes
                            const p2pkhPrefixes = ['1']; // Legacy
                            const p2shPrefixes = ['3'];  // SegWit nested
                            const bech32Prefixes = ['bc1']; // Native SegWit

                            const sourceType = transfer.to.startsWith('bc1') ? 'bech32' :
                                              p2shPrefixes.includes(sourcePrefix) ? 'p2sh' :
                                              p2pkhPrefixes.includes(sourcePrefix) ? 'p2pkh' : 'unknown';

                            const destType = transfer.to.startsWith('bc1') ? 'bech32' :
                                            p2shPrefixes.includes(destPrefix) ? 'p2sh' :
                                            p2pkhPrefixes.includes(destPrefix) ? 'p2pkh' : 'unknown';

                            if (sourceType === destType && sourceType !== 'unknown') {
                                changeScore += 10;
                                changeReasons.push('Same address type');
                            }
                        }

                        // 5. Amount comparison (change is often smaller than payment in simple transactions)
                        if (relevantTransfers.length === 2) {
                            const otherTransfer = relevantTransfers[1 - index];
                            if (transfer.amount < otherTransfer.amount * 0.5) {
                                changeScore += 10;
                                changeReasons.push('Smaller output');
                            }
                        }

                        // 6. Unnecessary input heuristic (most reliable)
                        // If payment could be made with fewer inputs, there MUST be change
                        if (relevantTransfers.length > 0 && relevantTransfers[0].totalInputAmount) {
                            const totalInputAmount = relevantTransfers[0].totalInputAmount;
                            const inputCount = relevantTransfers[0].inputCount || 0;
                            const inputDetails = relevantTransfers[0].inputDetails || [];

                            // Calculate total output amount
                            const totalOutputAmount = relevantTransfers.reduce((sum, t) => sum + t.amount, 0);

                            // Estimated fee (very rough: ~0.0001 BTC per input)
                            const estimatedFee = inputCount * 0.0001;

                            // Check if we could have made the largest output with fewer inputs
                            if (inputDetails.length > 1 && relevantTransfers.length === 2) {
                                const largestOutput = Math.max(relevantTransfers[0].amount, relevantTransfers[1].amount);

                                // Sort inputs by size (largest first)
                                const sortedInputs = [...inputDetails].sort((a, b) => b.amount - a.amount);

                                // See if we could make the payment with fewer inputs
                                let runningTotal = 0;
                                let neededInputs = 0;

                                for (const input of sortedInputs) {
                                    runningTotal += input.amount;
                                    neededInputs++;

                                    // If we have enough for the largest output plus estimated fee
                                    if (runningTotal >= largestOutput + estimatedFee) {
                                        break;
                                    }
                                }

                                // If we used ALL inputs but only needed some, there MUST be change
                                if (neededInputs < inputCount) {
                                    changeScore += 40; // Very strong indicator
                                    changeReasons.push(`Unnecessary input used (${inputCount} inputs used, only ${neededInputs} needed)`);
                                }
                            }

                            // 7. Perfect change calculation
                            // Change should approximately equal: inputs - other output - fee
                            if (relevantTransfers.length === 2 && totalInputAmount > 0) {
                                const otherOutput = relevantTransfers[1 - index];
                                const expectedChange = totalInputAmount - otherOutput.amount - estimatedFee;
                                const actualAmount = transfer.amount;

                                // If this output is within 10% of expected change amount
                                const difference = Math.abs(expectedChange - actualAmount);
                                if (difference < expectedChange * 0.1 && expectedChange > 0) {
                                    changeScore += 25;
                                    changeReasons.push(`Matches expected change amount (~${expectedChange.toFixed(8)} BTC)`);
                                }
                            }
                        }
                    }

                    // Store change analysis for display
                    transfer.changeScore = changeScore;
                    transfer.changeReasons = changeReasons;

                    // Classification based on score
                    if (isBackToSender) {
                        // Automatic change classification for same-address
                        window.hopWizardData.outputClassifications[index] = 'change';
                        window.hopWizardData.selectedOutputs.push(index);
                    } else if (changeScore >= 40) {
                        // High probability of change
                        window.hopWizardData.outputClassifications[index] = 'change';
                        // Don't auto-select suspected change for tracking (user decides)
                    } else {
                        // Likely payment
                        window.hopWizardData.outputClassifications[index] = 'payment';
                        window.hopWizardData.selectedOutputs.push(index);
                    }
                });

                resultDiv.innerHTML = `
                <div style="background: #fff3e0; border: 2px solid #ff9800; border-radius: 8px; padding: 15px;">
                    <h4 style="margin-top: 0; color: #e65100;">Multiple Outputs Detected - Select All to Track</h4>
                    <p style="margin-bottom: 10px;">This transaction has ${relevantTransfers.length} ${trackingCurrency ? trackingCurrency + ' ' : ''}outputs. Select each output you want to track and classify it:</p>

                    <div style="background: #e3f2fd; border-left: 4px solid #2196f3; padding: 10px; margin-bottom: 15px;">
                        <strong>💡 Change Detection:</strong><br>
                        • Outputs returning to sender address are likely change<br>
                        • Round amounts are likely payments<br>
                        • Decimal amounts are often change<br>
                        • Change creates ORANGE threads (same custody)
                    </div>

                    <div style="max-height: 400px; overflow-y: auto;">
                        ${relevantTransfers.map((transfer, index) => {
                            const isBackToSender = sourceWallet && transfer.to.toLowerCase() === sourceWallet.toLowerCase();
                            const isDefinitelyChange = isBackToSender; // Same address = definitely change
                            const changeScore = transfer.changeScore || 0;
                            const likelyChange = !isDefinitelyChange && changeScore >= 40; // High change probability

                            // Check attribution for this output asynchronously
                            getWalletAttribution(transfer.to).then(attribution => {
                                if (attribution) {
                                    const outputDiv = document.getElementById(`wizardOutput_${index}`);
                                    if (outputDiv) {
                                        // Add attribution badge
                                        let badgeHtml;
                                        if (attribution.isPersonalLabel) {
                                            // Personal label - informational only
                                            badgeHtml = `
                                                <div style="background: #e3f2fd; border: 1px solid #2196f3; border-radius: 4px; padding: 8px; margin-bottom: 10px;">
                                                    <strong style="color: #1565c0;">🏷️ Label: ${attribution.name || attribution.label}</strong><br>
                                                    <small>Personal label | Not a terminal wallet</small>
                                                </div>
                                            `;
                                        } else {
                                            // Actual terminal wallet (exchange/service)
                                            badgeHtml = `
                                                <div style="background: #e1bee7; border: 1px solid #9c27b0; border-radius: 4px; padding: 8px; margin-bottom: 10px;">
                                                    <strong style="color: #6a1b9a;">🟣 Terminal Wallet: ${attribution.name || attribution.label}</strong><br>
                                                    <small>Type: ${attribution.type} | This is an exchange or service</small>
                                                </div>
                                            `;
                                        }
                                        // Insert after the amount div
                                        const amountDiv = outputDiv.querySelector('div[style*="margin-bottom: 10px"]');
                                        if (amountDiv && !outputDiv.querySelector('div[style*="#e1bee7"]')) {
                                            amountDiv.insertAdjacentHTML('afterend', badgeHtml);
                                        }
                                    }
                                }
                            }).catch(err => console.log('Attribution check failed for output:', err));

                            return `
                            <div style="background: white; border: 2px solid #ddd; border-radius: 6px; padding: 15px; margin: 10px 0;" id="wizardOutput_${index}">
                                <div style="display: flex; justify-content: space-between; align-items: start;">
                                    <div style="flex: 1;">
                                        <div style="margin-bottom: 10px;">
                                            <strong style="font-size: 16px;">${transfer.amount} ${transfer.currency}</strong>
                                            ${isDefinitelyChange ?
                                                '<span style="color: #ff9800; margin-left: 10px; font-weight: bold;">🔄 Auto-detected Change (Same Address)</span>' :
                                                likelyChange ?
                                                `<span style="color: #ff9800; margin-left: 10px;">⚠️ Likely Change (Score: ${changeScore}%)</span>` : ''}
                                        </div>
                                        ${transfer.changeReasons && transfer.changeReasons.length > 0 && !isDefinitelyChange ? `
                                        <div style="background: #fff8e1; padding: 8px; border-radius: 4px; margin-bottom: 10px; font-size: 11px;">
                                            <strong>Change indicators:</strong>
                                            <ul style="margin: 5px 0 0 20px; padding: 0;">
                                                ${transfer.changeReasons.map(reason => `<li>${reason}</li>`).join('')}
                                            </ul>
                                        </div>
                                        ` : ''}
                                        <div style="font-size: 12px; color: #666; margin-bottom: 10px;">
                                            <div>From: ${transfer.from.slice(0, 15)}...${transfer.from.slice(-10)}</div>
                                            <div>To: ${transfer.to.slice(0, 15)}...${transfer.to.slice(-10)}</div>
                                        </div>
                                        
                                        <div style="background: #f5f5f5; padding: 10px; border-radius: 4px;">
                                            <label style="display: block; margin-bottom: 5px; font-weight: bold;">
                                                Classification:
                                                ${isDefinitelyChange ?
                                                    '<span style="color: #ff9800; font-size: 12px; margin-left: 10px;">(Automatically set as Change - same address)</span>' : ''}
                                            </label>
                                            <div>
                                                <label style="display: inline-block; margin-right: 15px; cursor: pointer; ${isDefinitelyChange ? 'opacity: 0.5;' : ''}">
                                                    <input type="radio" name="outputType_${index}" value="payment"
                                                           ${!isDefinitelyChange && !likelyChange ? 'checked' : ''}
                                                           ${isDefinitelyChange ? 'disabled' : ''}
                                                           onchange="classifyWizardOutput(${index}, 'payment')">
                                                    <span style="color: #27ae60;">✓ Payment (New Hop)</span>
                                                </label>
                                                <label style="display: inline-block; margin-right: 15px; cursor: pointer;">
                                                    <input type="radio" name="outputType_${index}" value="change"
                                                           ${isDefinitelyChange || likelyChange ? 'checked' : ''}
                                                           ${isDefinitelyChange ? 'disabled checked' : ''}
                                                           onchange="classifyWizardOutput(${index}, 'change')">
                                                    <span style="color: #ff9800;">↻ Change (Same-Hop Thread)</span>
                                                </label>
                                                <label style="display: inline-block; cursor: pointer; ${isDefinitelyChange ? 'opacity: 0.5;' : ''}">
                                                    <input type="radio" name="outputType_${index}" value="ignore"
                                                           ${isDefinitelyChange ? 'disabled' : ''}
                                                           onchange="classifyWizardOutput(${index}, 'ignore')">
                                                    <span style="color: #95a5a6;">✗ Ignore</span>
                                                </label>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <div style="margin-left: 15px;">
                                        <label style="display: block; text-align: center;">
                                            <input type="checkbox"
                                                   id="wizardOutputSelect_${index}"
                                                   value="${index}"
                                                   onchange="toggleWizardOutput(${index})"
                                                   ${isDefinitelyChange ? 'checked' : !likelyChange ? 'checked' : ''}
                                                   style="width: 20px; height: 20px; cursor: pointer;">
                                            <div style="margin-top: 5px; font-size: 12px;">Track</div>
                                        </label>
                                    </div>
                                </div>
                            </div>
                            `;
                        }).join('')}
                    </div>
                    
                    <div style="margin-top: 15px; padding: 15px; background: #f0f0f0; border-radius: 4px;">
                        <strong>Selected Outputs Summary:</strong>
                        <div id="wizardOutputSummary" style="margin-top: 10px;"></div>
                    </div>
                    
                    <button class="btn btn-primary" onclick="confirmWizardOutputSelection()" style="margin-top: 15px; width: 100%;">
                        Confirm Selection and Continue
                    </button>
                </div>
            `;

            // Initialize classifications
            relevantTransfers.forEach((transfer, index) => {
                const isRoundAmount = transfer.amount % 1 === 0 || transfer.amount % 10 === 0;
                const isBackToSender = sourceWallet && transfer.to === sourceWallet;
                const likelyChange = !isRoundAmount || isBackToSender;

                window.hopWizardData.outputClassifications[index] = likelyChange ? 'change' : 'payment';
                if (!likelyChange) {
                    toggleWizardOutput(index);
                }
            });
            
            updateWizardOutputSummary();
            return; // Exit early - multi-output UI will handle the rest
        }
        // If we reach here with a single transfer, fall through to display it
    }

    // Single transfer or non-transfer transaction display
    // This handles both single transfers after filtering and regular transactions
    if (!window.hopWizardData.txData) {
        window.hopWizardData.txData = txData;
    }

    // Check if this might be a DEX swap
    let swapWarning = '';
    let isSwap = false;
    let swapFromCurrency = null;

    if (window.hopWizardData.selectedThreads && window.hopWizardData.selectedThreads.length > 0) {
        const threads = getAvailableSourcesForHop(window.hopWizardData.hopNumber, null);
        const sourceCurrencies = new Set();
        window.hopWizardData.selectedThreads.forEach(threadId => {
            const thread = threads.find(t => t.threadId === threadId);
            if (thread) sourceCurrencies.add(thread.currency);
        });

        // If source currency differs from transaction currency, it's a swap
        if (sourceCurrencies.size === 1) {
            const sourceCurrency = Array.from(sourceCurrencies)[0];
            if (txData.currency && sourceCurrency !== txData.currency) {
                isSwap = true;
                swapFromCurrency = sourceCurrency;
                window.hopWizardData.isSwap = true;
                window.hopWizardData.swapDetails = {
                    fromCurrency: sourceCurrency,
                    toCurrency: txData.currency,
                    fromAmount: Object.values(window.hopWizardData.allocations).reduce((sum, val) => sum + val, 0),
                    toAmount: txData.amount,
                    dexAddress: txData.to
                };

                swapWarning = `
                            <div style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px; padding: 15px; margin-top: 10px;">
                                <h4 style="margin-top: 0; color: #e65100;">🔄 DEX Swap Detected</h4>
                                <div style="margin: 10px 0;">
                                    <strong>Swap Details:</strong><br>
                                    • Input: ${window.hopWizardData.swapDetails.fromAmount} ${sourceCurrency}<br>
                                    • Output: ${txData.amount} ${txData.currency}<br>
                                    • DEX: <span style="font-family: monospace; font-size: 11px;">${txData.to}</span>
                                </div>
                                <div style="background: white; padding: 10px; border-radius: 4px; margin-top: 10px;">
                                    <strong>This will create:</strong><br>
                                    1. A <strong>swap entry</strong> documenting the conversion<br>
                                    2. DEX marked as <span style="color: #8B4513; font-weight: bold;">🟤 BROWN wallet</span><br>
                                    3. Thread converts from ${sourceCurrency} to ${txData.currency} (no hop increment)
                                </div>
                                <div style="margin-top: 10px; padding: 8px; background: #e3f2fd; border-radius: 4px;">
                                    ℹ️ The next hop will continue with ${txData.currency} threads
                                </div>
                            </div>
                `;
            }
        }
    }

    // Check for wallet attributions based on blockchain type
    let attributionAlert = '';
    const isBitcoin = txData.blockchain === 'Bitcoin' || txData.currency === 'BTC';

    // Use appropriate attribution function based on blockchain
    const attributionFunction = isBitcoin ? getBitcoinWalletAttribution : getWalletAttribution;

    // Check the TO address for attribution
    attributionFunction(txData.to).then(attribution => {
        if (attribution) {
            if (attribution.isPersonalLabel) {
                console.log('🏷️ Personal label found in transaction lookup:', attribution);
            } else if (attribution.isSmartContract) {
                console.log('🤖 Smart Contract detected in transaction lookup:', attribution);
            } else {
                console.log('🟣 Terminal wallet detected in transaction lookup:', attribution);
            }

            // Update the result div with attribution alert
            const alertDiv = document.createElement('div');

            if (attribution.isSmartContract) {
                // Smart contract detection alert - treat as conversion wallet
                alertDiv.style.cssText = 'background: #f5e6d3; border: 2px solid #8B4513; border-radius: 8px; padding: 15px; margin-top: 15px;';
                alertDiv.innerHTML = `
                    <h4 style="margin: 0 0 10px 0; color: #8B4513;">🤖 Smart Contract Detected</h4>
                    <div style="font-size: 14px;">
                        <strong>Contract Name:</strong> ${attribution.name || attribution.contractName}<br>
                        <strong>Type:</strong> Conversion Wallet (DEX/Bridge)<br>
                        <strong>Address:</strong> <span style="font-family: monospace; font-size: 12px;">${txData.to}</span><br>
                        <strong>Source:</strong> ${attribution.source || 'Etherscan Verified Contract'}<br>

                        <div style="margin-top: 10px; padding: 10px; background: white; border-radius: 4px;">
                            <strong>🔄 This is a Smart Contract:</strong><br>
                            • Will be treated as a conversion wallet (brown)<br>
                            • Use the 🌉 Log Bridge/Swap button after entry<br>
                            • Track the converted currency output<br>
                            • Does NOT end the trace (not a terminal wallet)
                        </div>

                        <div style="margin-top: 10px; padding: 10px; background: #fff8e1; border-radius: 4px;">
                            <strong>✅ Ready to proceed:</strong><br>
                            This smart contract will be automatically marked as a conversion wallet.
                            You can log the swap/bridge output after creating the entry.
                        </div>
                    </div>
                `;

                // Store in wizard data for entry creation
                window.hopWizardData.detectedAttribution = attribution;
                window.hopWizardData.isSmartContract = true;

            } else if (attribution.isPersonalLabel) {
                // Check if this might be a misidentified exchange
                const suspectedType = attribution.suspectedExchange && attribution.detectionMatches?.length > 0;

                if (suspectedType && attribution.detectionConfidence >= 50) {
                    // Show intelligent detection popup
                    alertDiv.style.cssText = 'background: #fff3cd; border: 2px solid #ff9800; border-radius: 8px; padding: 15px; margin-top: 15px;';
                    alertDiv.innerHTML = `
                        <h4 style="margin: 0 0 10px 0; color: #e65100;">⚠️ Suspected Exchange/Service Detected</h4>
                        <div style="font-size: 14px;">
                            <strong>Label:</strong> ${attribution.name || attribution.label}<br>
                            <strong>Confidence:</strong> <span style="color: ${attribution.detectionConfidence >= 70 ? '#27ae60' : '#e67e22'}; font-weight: bold;">${attribution.detectionConfidence}%</span><br>
                            <strong>Wallet:</strong> <span style="font-family: monospace; font-size: 12px;">${txData.to}</span><br>

                            <div style="margin-top: 15px; padding: 12px; background: white; border-radius: 4px; border-left: 4px solid #ff9800;">
                                <strong>🔍 Detection Analysis:</strong><br>
                                <div style="margin-top: 8px;">
                                    ${attribution.detectionMatches.map(match => `
                                        <div style="margin: 4px 0; padding: 4px 8px; background: #f5f5f5; border-radius: 3px;">
                                            • Found <strong>${match.type}</strong> indicator: <code>${match.name}</code>
                                            <span style="color: #666; font-size: 12px;">(${match.confidence}% confidence)</span>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>

                            <div style="margin-top: 15px; padding: 12px; background: #e8f4fd; border-radius: 4px;">
                                <strong>📊 Recommendation:</strong><br>
                                <p style="margin: 8px 0;">
                                    ${attribution.detectionConfidence >= 85 ?
                                        'This appears to be a known exchange or service. Consider marking it as a terminal wallet.' :
                                        attribution.detectionConfidence >= 70 ?
                                        'This likely represents an exchange or service. Review carefully before proceeding.' :
                                        'Some indicators suggest this might be an exchange. Use your judgment based on investigation context.'}
                                </p>
                            </div>

                            <div style="margin-top: 15px;">
                                <strong>Choose an action:</strong>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px;">
                                    <button class="btn btn-warning" onclick="convertToTerminalWallet()"
                                            style="background: #9c27b0; border-color: #9c27b0; padding: 10px;">
                                        🟣 Mark as Terminal Wallet<br>
                                        <small style="opacity: 0.8;">Funds arrived at exchange</small>
                                    </button>
                                    <button class="btn btn-secondary" onclick="convertToConversionWallet()"
                                            style="background: #8B4513; border-color: #8B4513; padding: 10px;">
                                        🟤 Mark as Bridge/DEX<br>
                                        <small style="opacity: 0.8;">Currency conversion service</small>
                                    </button>
                                    <button class="btn btn-info" onclick="keepAsPersonalLabel()"
                                            style="background: #3498db; border-color: #3498db; padding: 10px; grid-column: span 2;">
                                        🏷️ Keep as Personal Label<br>
                                        <small style="opacity: 0.8;">Not an exchange - just a labeled wallet</small>
                                    </button>
                                </div>
                            </div>
                        </div>
                    `;
                } else {
                    // Regular personal label with low/no exchange indicators
                    alertDiv.style.cssText = 'background: #e3f2fd; border: 2px solid #2196f3; border-radius: 8px; padding: 15px; margin-top: 15px;';
                    alertDiv.innerHTML = `
                        <h4 style="margin: 0 0 10px 0; color: #1565c0;">🏷️ Personal Label Detected</h4>
                        <div style="font-size: 14px;">
                            <strong>Label:</strong> ${attribution.name || attribution.label}<br>
                            <strong>Wallet:</strong> <span style="font-family: monospace; font-size: 12px;">${txData.to}</span><br>
                            <div style="margin-top: 10px; padding: 10px; background: white; border-radius: 4px;">
                                <strong>ℹ️ Note:</strong><br>
                                • This is a personal label, not an exchange<br>
                                • The wallet can still send funds elsewhere<br>
                                • Continue tracing as normal<br>
                                • The label will be added to your entry notes
                            </div>
                            ${attribution.detectionConfidence > 0 ? `
                                <div style="margin-top: 10px; padding: 8px; background: #f0f0f0; border-radius: 4px; font-size: 12px;">
                                    <em>Low confidence (${attribution.detectionConfidence}%) exchange indicators detected.
                                    If you believe this is an exchange, use the buttons below to convert.</em>
                                </div>
                            ` : ''}
                            <div style="margin-top: 15px; padding: 10px; background: #fff3cd; border: 1px solid #ff9800; border-radius: 4px;">
                                <strong>❓ Is this actually an exchange or conversion service?</strong><br>
                                <p style="margin: 8px 0; font-size: 13px;">If this label indicates a centralized exchange or DEX/Bridge, convert it to the appropriate wallet type:</p>
                                <div style="display: flex; gap: 10px; margin-top: 10px;">
                                    <button class="btn btn-warning" onclick="convertToTerminalWallet()" style="background: #9c27b0; border-color: #9c27b0;">
                                        🟣 Convert to Terminal Wallet
                                    </button>
                                    <button class="btn btn-secondary" onclick="convertToConversionWallet()" style="background: #8B4513; border-color: #8B4513;">
                                        🟤 Convert to Conversion Wallet
                                    </button>
                                </div>
                            </div>
                        </div>
                    `;
                }
            } else {
                // Actual terminal wallet (exchange/service)
                alertDiv.style.cssText = 'background: #e1bee7; border: 2px solid #9c27b0; border-radius: 8px; padding: 15px; margin-top: 15px;';

                // Check if this might be a DEX that we're treating as an exchange
                let dexHint = '';
                if (attribution.suspectedDEX || attribution.isDEX) {
                    dexHint = `
                        <div style="margin-top: 10px; padding: 10px; background: #fff8e1; border: 1px solid #ff9800; border-radius: 4px;">
                            <strong>💡 Possible DEX/Bridge Detected:</strong><br>
                            <small>This wallet might be a DEX or bridge service. If you need to track a currency conversion:<br>
                            1. Confirm as terminal wallet first<br>
                            2. Then click "🌉 Log Bridge/Swap" to convert it to a conversion wallet</small>
                        </div>
                    `;
                }

                alertDiv.innerHTML = `
                    <h4 style="margin: 0 0 10px 0; color: #6a1b9a;">🟣 Exchange Wallet Detected - MANDATORY Terminal Entry</h4>
                    <div style="font-size: 14px;">
                        <strong>Exchange/Service:</strong> ${attribution.name || attribution.label}<br>
                        <strong>Type:</strong> ${attribution.type}<br>
                        <strong>Wallet:</strong> <span style="font-family: monospace; font-size: 12px;">${txData.to}</span><br>
                        ${dexHint}
                        <div style="margin-top: 10px; padding: 10px; background: white; border-radius: 4px;">
                            <strong>⚠️ IMPORTANT:</strong><br>
                            • Funds have arrived at a centralized exchange<br>
                            • This MUST be marked as a terminal wallet (PURPLE)<br>
                            • Further recovery requires legal process<br>
                            • The trace ends here for this thread
                        </div>
                        <div style="margin-top: 10px; padding: 10px; background: #fff3cd; border: 1px solid #9c27b0; border-radius: 4px;">
                            <strong>🛑 Exchange Detected - Confirm Terminal Entry:</strong><br>
                            <p style="margin: 10px 0; color: #6a1b9a; font-weight: bold;">
                                You must confirm this terminal wallet to continue.
                            </p>
                            <button class="btn btn-warning" onclick="confirmTerminalWallet()" style="margin-top: 10px; background: #9c27b0; border-color: #9c27b0; font-size: 16px; padding: 10px 20px;">
                                ✅ Confirm Terminal Wallet Entry
                            </button>
                            <button class="btn btn-secondary" onclick="overrideAttribution()" style="margin-top: 10px; margin-left: 10px; background: #6c757d; border-color: #6c757d; font-size: 14px; padding: 8px 15px;">
                                🔄 Override Attribution
                            </button>
                            <div style="margin-top: 10px; font-size: 12px; color: #666;">
                                ⚖️ Legal process (subpoena/court order) will be required to recover funds from ${attribution.name || 'this exchange'}
                            </div>
                        </div>
                    </div>
                `;
            }

            // Insert the alert after the transaction details
            const resultDiv = document.getElementById('wizardTxResult');
            const existingAlert = resultDiv.querySelector('div[style*="#e1bee7"]');
            if (!existingAlert) {
                const transactionBox = resultDiv.querySelector('div[style*="#e8f4f8"]');
                if (transactionBox) {
                    transactionBox.insertAdjacentElement('afterend', alertDiv);
                }
            }

            // Store attribution in wizard data for later use
            if (window.hopWizardData) {
                window.hopWizardData.detectedAttribution = attribution;
            }
        }
    }).catch(err => {
        console.log('Attribution check failed:', err);
    });

    resultDiv.innerHTML = `
        <div style="background: #e8f4f8; border: 1px solid #3498db; border-radius: 8px; padding: 15px;">
            <h4 style="margin-top: 0;">Transaction Found ✓</h4>
            <div style="display: grid; gap: 8px; font-size: 14px;">
                <div><strong>Chain:</strong> ${txData.blockchain}</div>
                <div><strong>Amount:</strong> ${txData.amount} ${txData.currency}</div>
                <div><strong>From:</strong> <span style="font-family: monospace; font-size: 12px;">${txData.from}</span></div>
                <div><strong>To:</strong> <span style="font-family: monospace; font-size: 12px;">${txData.to}</span></div>
                <div><strong>Time:</strong> ${new Date(txData.time).toLocaleString()} UTC</div>
            </div>
            ${swapWarning}
            <div style="margin-top: 15px; padding: 10px; background: #d4edda; border-radius: 4px;">
                <strong>✅ Ready to create entry</strong><br>
                <small>Click "Log Entry" to add this transaction to Hop ${window.hopWizardData.hopNumber}</small>
            </div>
        </div>
    `;

    // Check if terminal wallet was detected
    const hasTerminalWallet = window.hopWizardData && window.hopWizardData.detectedAttribution;

    // Handle button state based on terminal wallet detection
    const nextBtn = document.getElementById('wizardNextBtn');
    if (nextBtn) {
        if (hasTerminalWallet && !window.hopWizardData.isTerminalWallet) {
            // Terminal wallet detected but not confirmed - disable button
            nextBtn.disabled = true;
            nextBtn.textContent = 'Confirm Terminal Wallet First';
            nextBtn.style.background = '#6c757d'; // Gray out the button
        } else {
            // Normal case or terminal confirmed
            nextBtn.disabled = false;
            if (window.hopWizardData.isTerminalWallet) {
                nextBtn.textContent = 'Create Terminal Entry';
                nextBtn.style.background = '#9c27b0'; // Purple for terminal
            } else {
                nextBtn.textContent = 'Log Entry';
                nextBtn.style.background = ''; // Default color
            }
        }
        // Make sure the wizard data has the txData
        if (!window.hopWizardData.txData) {
            window.hopWizardData.txData = txData;
        }
    }

    // Update Step 3 buttons if we're in Step 3
    if (window.hopWizardData && (window.hopWizardData.currentStep === 3 || window.hopWizardData.step === 3) && window.updateStep3Buttons) {
        window.hopWizardData.txHash = txHash; // Store the hash
        window.updateStep3Buttons();
    }

    } catch (error) {
        console.error('Transaction lookup error:', error);

        // Check if wizardData was lost
        if (!window.hopWizardData) {
            resultDiv.innerHTML = `
                <div style="background: #f8d7da; border: 1px solid #f5c6cb; border-radius: 8px; padding: 15px;">
                    <strong>❌ Session Error</strong><br>
                    The wizard session was lost. Please close this wizard and start again.<br>
                    <button class="btn btn-secondary" onclick="closeHopWizard()" style="margin-top: 10px;">Close Wizard</button>
                </div>
            `;
        } else {
            let errorMessage = error.message || 'Unknown error occurred';
            let suggestions = '';
            let isChainMismatch = false;

            // Check for chain mismatch error first
            if (errorMessage.includes('CHAIN MISMATCH')) {
                isChainMismatch = true;
                // Extract the clean error message
                const mismatchParts = errorMessage.split('CHAIN MISMATCH:');
                errorMessage = mismatchParts[1] ? mismatchParts[1].trim() : errorMessage;
                suggestions = '<br><small style="color: #dc3545;"><strong>⚠️ Wrong Blockchain!</strong></small>';
            } else if (error.name === 'AbortError' || errorMessage.includes('timeout')) {
                errorMessage = 'Transaction lookup timed out';
                suggestions = '<br><small>• Check your internet connection<br>• The blockchain API may be slow<br>• Try again in a few moments</small>';
            } else if (errorMessage.includes('HTTP 429')) {
                errorMessage = 'API rate limit exceeded';
                suggestions = '<br><small>• Wait a few seconds before retrying<br>• The API has temporary limits</small>';
            } else if (errorMessage.includes('HTTP 404')) {
                errorMessage = 'Transaction not found';
                suggestions = '<br><small>• Verify the transaction hash is correct<br>• The transaction may not be confirmed yet</small>';
            } else if (errorMessage.includes('Failed to fetch Ethereum') || errorMessage.includes('Failed to fetch Bitcoin') ||
                       errorMessage.includes('Failed to fetch Solana') || errorMessage.includes('Failed to fetch Tron')) {
                // Generic blockchain fetch error - likely wrong chain
                errorMessage = 'Transaction lookup failed';
                suggestions = '<br><small>• Check that the transaction hash is correct<br>• Verify this transaction is on the expected blockchain<br>• The transaction may not exist on this chain</small>';
            } else if (errorMessage.includes('Failed to fetch')) {
                errorMessage = 'Network connection error';
                suggestions = '<br><small>• Check your internet connection<br>• The blockchain API may be unavailable</small>';
            }

            // Use different styling for chain mismatch
            const bgColor = isChainMismatch ? '#fff3cd' : '#f8d7da';
            const borderColor = isChainMismatch ? '#ffc107' : '#f5c6cb';
            const iconEmoji = isChainMismatch ? '⚠️' : '❌';
            const titleText = isChainMismatch ? 'Chain Mismatch' : 'Lookup Failed';

            resultDiv.innerHTML = `
                <div style="background: ${bgColor}; border: 2px solid ${borderColor}; border-radius: 8px; padding: 15px;">
                    <strong>${iconEmoji} ${titleText}</strong><br>
                    ${errorMessage}
                    ${suggestions}
                </div>
            `;
        }
    }
}

function toggleWizardOutput(index) {
    const wizardData = window.hopWizardData;
    if (!wizardData) {
        console.error('Wizard data not available in toggleWizardOutput');
        return;
    }

    const checkbox = document.getElementById(`wizardOutputSelect_${index}`);

    if (!wizardData.selectedOutputs) {
        wizardData.selectedOutputs = [];
    }
    
    if (checkbox.checked) {
        if (!wizardData.selectedOutputs.includes(index)) {
            wizardData.selectedOutputs.push(index);
        }
    } else {
        wizardData.selectedOutputs = wizardData.selectedOutputs.filter(i => i !== index);
    }
    
    updateWizardOutputSummary();
}

function classifyWizardOutput(index, type) {
    if (!window.hopWizardData) {
        console.error('Wizard data not available in classifyWizardOutput');
        return;
    }
    window.hopWizardData.outputClassifications[index] = type;
    
    // Auto-check/uncheck based on classification
    const checkbox = document.getElementById(`wizardOutputSelect_${index}`);
    if (type === 'ignore') {
        checkbox.checked = false;
        toggleWizardOutput(index);
    } else if (!checkbox.checked) {
        checkbox.checked = true;
        toggleWizardOutput(index);
    }
    
    updateWizardOutputSummary();
}

function updateWizardOutputSummary() {
    const wizardData = window.hopWizardData;
    const summaryDiv = document.getElementById('wizardOutputSummary');
    if (!summaryDiv) return;
    
    const selectedOutputs = wizardData.selectedOutputs || [];
    const transfers = wizardData.pendingTransfers || [];
    
    if (selectedOutputs.length === 0) {
        summaryDiv.innerHTML = '<em style="color: #666;">No outputs selected</em>';
        return;
    }
    
    let paymentCount = 0;
    let changeCount = 0;
    let totalAmount = {};
    
    selectedOutputs.forEach(index => {
        const transfer = transfers[index];
        const classification = wizardData.outputClassifications[index];
        
        if (classification === 'payment') paymentCount++;
        if (classification === 'change') changeCount++;
        
        if (!totalAmount[transfer.currency]) {
            totalAmount[transfer.currency] = 0;
        }
        totalAmount[transfer.currency] += transfer.amount;
    });
    
    summaryDiv.innerHTML = `
        <div style="color: #27ae60;">✓ ${paymentCount} Payment${paymentCount !== 1 ? 's' : ''}</div>
        <div style="color: #ff9800;">↻ ${changeCount} Change Output${changeCount !== 1 ? 's' : ''}</div>
        <div style="margin-top: 5px; font-weight: bold;">
            Total: ${Object.entries(totalAmount).map(([curr, amt]) => `${amt} ${curr}`).join(' + ')}
        </div>
    `;
}

function confirmWizardOutputSelection() {
    const wizardData = window.hopWizardData;
    const selectedOutputs = wizardData.selectedOutputs || [];
    
    if (selectedOutputs.length === 0) {
        alert('Please select at least one output to track');
        return;
    }
    
    // Store the selected outputs info for creating multiple entries
    wizardData.multipleOutputs = selectedOutputs.map(index => {
        const transfer = wizardData.pendingTransfers[index];
        const classification = wizardData.outputClassifications[index];
        
        return {
            ...transfer,
            classification: classification,
            isChange: classification === 'change'
        };
    });
    
    // Clear the selection UI and show summary
    const resultDiv = document.getElementById('wizardTxResult');
    resultDiv.innerHTML = `
        <div style="background: #e8f4f8; border: 1px solid #3498db; border-radius: 8px; padding: 15px;">
            <h4 style="margin-top: 0;">✅ ${selectedOutputs.length} Output${selectedOutputs.length !== 1 ? 's' : ''} Selected</h4>
            <div style="margin-top: 10px;">
                ${wizardData.multipleOutputs.map((output, i) => `
                    <div style="padding: 8px; background: white; border-radius: 4px; margin: 5px 0;">
                        <strong>${i + 1}.</strong> ${output.amount} ${output.currency} → 
                        <span style="font-family: monospace; font-size: 11px;">${output.to.slice(0, 8)}...</span>
                        <span style="color: ${output.isChange ? '#ff9800' : '#27ae60'}; margin-left: 10px;">
                            (${output.isChange ? 'CHANGE' : 'PAYMENT'})
                        </span>
                    </div>
                `).join('')}
            </div>
        </div>
    `;
    
    document.getElementById('wizardNextBtn').disabled = false;

    // Update Step 3 buttons if we're in Step 3
    if (window.hopWizardData && (window.hopWizardData.currentStep === 3 || window.hopWizardData.step === 3) && window.updateStep3Buttons) {
        window.updateStep3Buttons();
    }
}

// Keep the old function for backward compatibility but update it
function selectWizardTransfer(index) {
    // This function is now replaced by the multi-select system
    // Convert single selection to multi-select format
    window.hopWizardData.selectedOutputs = [index];
    window.hopWizardData.outputClassifications = { [index]: 'payment' };
    confirmWizardOutputSelection();
}

// [REMOVED: createSwapEntryFromWizard function - redundant with createSwapEntry()]
// The dedicated swap wizard's createSwapEntry function is used instead

function updateThreadsAfterSwap(hop, swapEntry) {
    // This function updates the available threads to reflect the currency conversion
    // Now handles partial swaps - leaving remainder in original thread

    if (!investigation.availableThreads) {
        investigation.availableThreads = {};
    }

    const swapDetails = swapEntry.swapDetails;

    // Handle partial swaps - update or remove source threads based on amounts used
    if (swapEntry.partialSwaps && swapEntry.partialSwaps.length > 0) {
        // Process each partial swap
        swapEntry.partialSwaps.forEach(partial => {
            if (investigation.availableThreads[swapDetails.fromCurrency] &&
                investigation.availableThreads[swapDetails.fromCurrency][partial.threadId]) {

                // Update the original thread to only have the remaining amount
                const thread = investigation.availableThreads[swapDetails.fromCurrency][partial.threadId];
                thread.totalAmount = roundAmount(partial.remainingAmount);

                // If remaining amount is very small (dust), remove the thread
                if (partial.remainingAmount < 0.0001) {
                    delete investigation.availableThreads[swapDetails.fromCurrency][partial.threadId];
                }
            }
        });
    } else {
        // Full swap - remove the old currency threads completely
        if (swapEntry.sourceThreadId) {
            // Single source
            if (investigation.availableThreads[swapDetails.fromCurrency]) {
                delete investigation.availableThreads[swapDetails.fromCurrency][swapEntry.sourceThreadId];
            }
        } else if (swapEntry.multipleSourceThreads) {
            // Multiple sources - remove all
            swapEntry.multipleSourceThreads.forEach(threadId => {
                if (investigation.availableThreads[swapDetails.fromCurrency]) {
                    delete investigation.availableThreads[swapDetails.fromCurrency][threadId];
                }
            });
        }
    }

    // Create new thread(s) in the output currency
    if (!investigation.availableThreads[swapDetails.toCurrency]) {
        investigation.availableThreads[swapDetails.toCurrency] = {};
    }

    // Use the SAME thread ID as the source (no swap suffix)
    const newThreadId = swapEntry.sourceThreadId ||
        (swapEntry.multipleSourceThreads ? swapEntry.multipleSourceThreads.join('+') : null);

    if (!newThreadId) return;

    // Get chain info from the swap entry or inherit from source thread
    let chainId = swapEntry.chain || null;
    let chainName = null;

    // If this is a bridge, use the destination chain
    if (swapDetails.toChain) {
        chainId = swapDetails.toChain;
        chainName = window.blockchainAPIs?.[swapDetails.toChain]?.name || swapDetails.toChain;
    } else if (!chainId && swapEntry.sourceThreadId) {
        // Try to inherit from source thread
        const sourceThreadData = getThreadByNotation(swapEntry.sourceThreadId);
        if (sourceThreadData) {
            chainId = sourceThreadData.chainId || null;
            chainName = sourceThreadData.chainName || null;
        }
    }

    // Create the thread with SAME ID in the output currency
    investigation.availableThreads[swapDetails.toCurrency][newThreadId] = {
        threadId: newThreadId,
        totalAmount: swapDetails.toAmount,
        availableAmount: swapDetails.toAmount, // Important: include availableAmount
        currency: swapDetails.toCurrency,
        sourceWallet: swapEntry.toWallet, // DEX/CEX address becomes the source for the new thread
        sourceType: 'swap_output',
        hopLevel: hop.hopNumber,
        swapConverted: true,
        originalCurrency: swapDetails.fromCurrency,
        partialSwap: swapEntry.partialSwaps && swapEntry.partialSwaps.length > 0,
        isActive: true,
        assignments: [],
        swapDetails: {
            fromCurrency: swapDetails.fromCurrency,
            fromAmount: swapDetails.fromAmount,
            toCurrency: swapDetails.toCurrency,
            toAmount: swapDetails.toAmount,
            provider: swapDetails.providerName || 'Unknown'
        },
        // Chain tracking
        chainId: chainId,
        chainName: chainName
    };

    console.log(`Created swap output thread ${newThreadId} with ${swapDetails.toAmount} ${swapDetails.toCurrency}`);
}

function createSingleHopEntry(hop, wizardData, output, outputIndex) {
    // Handle change outputs - create a same-hop thread (like swaps)
    if (output.isChange) {
        console.log(`Processing change output: ${output.amount} ${output.currency} to ${output.to}`);

        // Create a change entry that generates a same-hop thread
        // This works like a swap - consumes source thread and creates new thread at same hop level

        // Generate the base notation for the change thread
        let changeNotation = '';
        if (wizardData.selectedThreads.length === 1) {
            const baseNotation = wizardData.selectedThreads[0];
            // Change threads stay at same hop level (no -H increment)
            // Extract the base V-T notation without hop
            const vtMatch = baseNotation.match(/^(V\d+-T[\d,]+)/);
            if (vtMatch) {
                changeNotation = vtMatch[1];
                // If source already has hop, keep same hop level
                const hopMatch = baseNotation.match(/-H(\d+)/);
                if (hopMatch) {
                    changeNotation += `-H${hopMatch[1]}`;
                }
            } else {
                changeNotation = baseNotation;
            }
        } else {
            // Commingling - create combined notation
            const threadsByVictim = {};
            wizardData.selectedThreads.forEach(threadId => {
                const match = threadId.match(/V(\d+)-T([\d,]+)/);
                if (match) {
                    const victimId = match[1];
                    const transactionIds = match[2];
                    if (!threadsByVictim[victimId]) {
                        threadsByVictim[victimId] = [];
                    }
                    threadsByVictim[victimId].push(transactionIds);
                }
            });

            const notationParts = [];
            Object.keys(threadsByVictim).sort((a, b) => parseInt(a) - parseInt(b)).forEach(victimId => {
                const transactions = threadsByVictim[victimId].sort().join(',');
                notationParts.push(`(V${victimId}-T${transactions})`);
            });

            // For change, stay at current hop level (not incrementing)
            const currentHopLevel = hop.hopNumber - 1; // Since we're in hop N, threads come from hop N-1
            changeNotation = currentHopLevel > 0 ?
                `${notationParts.join(' ')} H${currentHopLevel}` :
                notationParts.join(' ');
        }

        // Create the change entry
        const changeEntry = {
            id: Date.now() + outputIndex + 1000, // Ensure unique ID
            hopNumber: hop.hopNumber,
            entryType: 'change', // New entry type for change addresses

            // Thread tracking
            sourceThreadInternalId: wizardData.selectedInternalIds && wizardData.selectedInternalIds.length === 1 ?
                wizardData.selectedInternalIds[0] : '',
            multipleSourceInternalIds: wizardData.selectedInternalIds && wizardData.selectedInternalIds.length > 1 ?
                wizardData.selectedInternalIds : [],
            sourceThreadId: wizardData.selectedThreads.length === 1 ? wizardData.selectedThreads[0] : '',
            multipleSourceThreads: wizardData.selectedThreads.length > 1 ? wizardData.selectedThreads : [],

            amount: output.amount.toString(),
            currency: output.currency || 'BTC',
            txHash: wizardData.txHash,
            fromWallet: output.from,
            toWallet: output.to,
            toWalletType: 'orange', // ORANGE for change addresses
            timestamp: wizardData.txData?.time ? new Date(wizardData.txData.time).toISOString() : new Date().toISOString(),
            timezone: 'UTC',
            notes: `Change output: ${output.amount} ${output.currency} sent to ${output.to}\nFunds remain trackable at same hop level (${changeNotation})`,
            notation: changeNotation,
            isChange: true,
            createsSameHopThread: true, // Flag to indicate this creates a same-hop thread
            chain: wizardData.detectedChain || wizardData.txData?.blockchain || null // Store chain info
        };

        // Add to hop entries
        hop.entries.push(changeEntry);

        // The thread will be created by updateThreadAvailabilityFromHop
        // but we need to ensure it's created at the same hop level
        console.log(`Created change entry with notation ${changeNotation} at hop ${hop.hopNumber}`);

        // Don't return - continue to process other outputs
        // But skip the rest of this function for this output
        return;
    }

    // Calculate how much of the source amount goes to this output
    const totalSelectedAmount = Object.values(wizardData.allocations).reduce((sum, val) => sum + val, 0);
    const outputProportion = output.amount / wizardData.multipleOutputs.reduce((sum, o) => sum + o.amount, 0);
    const allocatedAmount = totalSelectedAmount * outputProportion;

    // Check if this is a swap (source currency differs from output currency)
    let isSwap = false;
    let swapDetails = null;
    const threads = getAvailableSourcesForHop(hop.hopNumber, null);
    const sourceCurrencies = new Set();
    wizardData.selectedThreads.forEach(threadId => {
        const thread = threads.find(t => t.threadId === threadId);
        if (thread) sourceCurrencies.add(thread.currency);
    });

    if (sourceCurrencies.size === 1) {
        const sourceCurrency = Array.from(sourceCurrencies)[0];
        if (output.currency && sourceCurrency !== output.currency) {
            isSwap = true;
            swapDetails = {
                fromCurrency: sourceCurrency,
                toCurrency: output.currency,
                type: 'DEX'
            };
        }
    }

    // Generate thread notation
    let notation = '';
    if (wizardData.selectedThreads.length === 1) {
        const baseNotation = wizardData.selectedThreads[0];
        // For change outputs, add -C suffix
        notation = output.isChange ? `${baseNotation}-C` : baseNotation;
    } else {
        // Commingling notation using parentheses format
        const threadsByVictim = {};
        wizardData.selectedThreads.forEach(threadId => {
            const match = threadId.match(/V(\d+)-T([\d,]+)/);
            if (match) {
                const victimId = match[1];
                const transactionIds = match[2];
                if (!threadsByVictim[victimId]) {
                    threadsByVictim[victimId] = [];
                }
                threadsByVictim[victimId].push(transactionIds);
            }
        });

        const notationParts = [];
        Object.keys(threadsByVictim).sort((a, b) => parseInt(a) - parseInt(b)).forEach(victimId => {
            const transactions = threadsByVictim[victimId].sort().join(',');
            notationParts.push(`(V${victimId}-T${transactions})`);
        });
        notation = `${notationParts.join(' ')} H${hop.hopNumber}`;
        if (output.isChange) notation += '-C';
    }

    // Add swap notation if applicable
    if (isSwap && swapDetails) {
        notation += ` [SWAP: ${swapDetails.fromCurrency} → ${swapDetails.toCurrency}]`;
    }

    // Determine wallet type
    let toWalletType = 'black';
    let exchangeAttribution = null;

    // First check if we have detected attribution for this address
    if (wizardData.detectedAttribution && output.to &&
        output.to.toLowerCase() === wizardData.txData.to.toLowerCase()) {
        exchangeAttribution = wizardData.detectedAttribution;
        toWalletType = 'purple'; // PURPLE for exchanges/VASPs
        console.log(`🟣 Using detected terminal wallet: ${exchangeAttribution.name || exchangeAttribution.label}`);
    }
    // Fallback: Check if destination is a known exchange (synchronous check)
    else if (output.to) {
        const attribution = checkExchangeAttribution(output.to);
        if (attribution) {
            exchangeAttribution = attribution;
            toWalletType = 'purple'; // PURPLE for exchanges/VASPs
            if (attribution.isPersonalLabel) {
                console.log(`🏷️ Personal label found: ${attribution.name}`);
            } else {
                console.log(`🟣 Terminal wallet detected: ${exchangeAttribution.name}`);
            }
        }
    }

    // Override with specific types if needed (only if not an exchange)
    if (!exchangeAttribution) {
        if (isSwap) {
            toWalletType = 'brown'; // BROWN for asset conversion/swap
        } else if (output.isChange) {
            toWalletType = 'orange'; // ORANGE for change
        }
    }

    // Create the entry with dual-layer support
    const entry = {
        id: Date.now() + outputIndex, // Ensure unique IDs for multiple outputs
        hopNumber: hop.hopNumber,
        entryType: 'trace',

        // Dual-layer thread tracking
        // Store internal IDs for precise tracking
        sourceThreadInternalId: wizardData.selectedInternalIds && wizardData.selectedInternalIds.length === 1 ?
            wizardData.selectedInternalIds[0] : '',
        multipleSourceInternalIds: wizardData.selectedInternalIds && wizardData.selectedInternalIds.length > 1 ?
            wizardData.selectedInternalIds : [],

        // Keep notations for backward compatibility and display
        sourceThreadId: wizardData.selectedThreads.length === 1 ? wizardData.selectedThreads[0] : '',
        multipleSourceThreads: wizardData.selectedThreads.length > 1 ? wizardData.selectedThreads : [],

        // Update allocations to use internal IDs
        individualSourceAssignments: wizardData.selectedInternalIds && wizardData.selectedInternalIds.length > 1 ?
            Object.fromEntries(Object.entries(wizardData.allocations).map(([k, v]) => [k, v * outputProportion])) : {},

        amount: allocatedAmount.toString(),
        currency: output.currency,
        fromWallet: output.from,
        fromWalletType: 'black',
        toWallet: output.to,
        toWalletType: toWalletType,
        txHash: wizardData.txHash,
        timestamp: wizardData.txData ? new Date(wizardData.txData.time).toISOString().slice(0, 16) : '',
        timezone: 'UTC',
        chain: wizardData.detectedChain || wizardData.txData?.blockchain || null, // Store the chain!
        notes: exchangeAttribution ?
            `Terminal wallet: ${exchangeAttribution.name || exchangeAttribution.label}\nType: ${exchangeAttribution.type}\nAddress: ${output.to}${exchangeAttribution.source ? '\nDetection source: ' + exchangeAttribution.source : ''}` :
            isSwap ?
            `DEX Swap: ${swapDetails.fromCurrency} converted to ${swapDetails.toCurrency} at ${output.to}` :
            `Payment output ${outputIndex + 1} of ${wizardData.multipleOutputs.length}` +
            (wizardData.changeNotes && wizardData.changeNotes.length > 0 ? '\n' + wizardData.changeNotes.join('\n') : ''),
        notation: notation,
        isConvergence: wizardData.selectedThreads.length > 1,
        isChange: output.isChange,
        isSwap: isSwap,
        swapDetails: swapDetails
    };
    
    // Add exchange attribution to entry if detected
    if (exchangeAttribution) {
        entry.exchangeAttribution = exchangeAttribution;
    }

    hop.entries.push(entry);

    // If this is a terminal wallet, add to the terminal wallet index
    if (toWalletType === 'purple' && exchangeAttribution) {
        addToTerminalWalletIndex(entry);
        console.log('🟣 Added terminal wallet arrival to index');
    }

    // Mark entry as wizard-created for auto-collapse
    const entryKey = `${hop.hopNumber}_${entry.id}`;
    window.entryCollapseState = window.entryCollapseState || {};
    window.entryCollapseState[entryKey] = true; // Auto-collapse wizard entries

    console.log(`Created ${output.isChange ? 'CHANGE' : 'PAYMENT'} thread:`, notation, allocatedAmount, output.currency);
}

function validateThreadAllocation(threadId, requestedAmount, currency, excludeEntryId = null, excludeHopId = null) {
    // Validate that a thread assignment won't exceed available amounts
    const maxAvailable = getMaxAssignableAmount(threadId, currency, excludeEntryId, excludeHopId);
    const requested = parseAmount(requestedAmount);

    if (requested > maxAvailable) {
        return {
            valid: false,
            message: `Thread ${threadId} only has ${maxAvailable} ${currency} available, but ${requested} was requested.`,
            maxAvailable: maxAvailable
        };
    }

    return { valid: true };
}

// Function to write off all rounding remainders at once
function writeOffAllRoundingRemainders(hopNumber) {
    if (!hopNumber) {
        showNotification('Error: No hop number specified', 'error');
        return;
    }

    // Get all available threads for this hop
    const currentHopThreads = getAvailableSourcesForHop(hopNumber, null);

    // Filter to only rounding remainders
    const roundingThreads = currentHopThreads.filter(thread => {
        if (thread.availableAmount <= 0.01) return false;

        const original = thread.totalAmount || thread.availableAmount;
        const assigned = original - thread.availableAmount;
        const percentAssigned = original > 0 ? Math.round((assigned / original) * 100) : 0;

        return percentAssigned >= 99 && thread.availableAmount < (original * 0.01);
    });

    if (roundingThreads.length === 0) {
        showNotification('No rounding remainders to write off', 'warning');
        return;
    }

    // Group by currency
    const byCurrency = {};
    roundingThreads.forEach(thread => {
        if (!byCurrency[thread.currency]) {
            byCurrency[thread.currency] = [];
        }
        byCurrency[thread.currency].push(thread);
    });

    // Create a write-off entry for each currency
    Object.entries(byCurrency).forEach(([currency, threads]) => {
        const totalAmount = threads.reduce((sum, t) => sum + t.availableAmount, 0);
        const threadIds = threads.map(t => t.threadId).join(', ');

        // Create the write-off entry
        const entry = {
            id: Date.now() + '_' + Math.random().toString(36).substring(2, 9),
            type: 'writeoff',
            hopNumber: hopNumber,
            amount: totalAmount,
            currency: currency,
            sourceThreadIds: threads.map(t => t.internalId || t.threadId),
            sourceThreadNotations: threadIds,
            notes: `Rounding remainder write-off from ${threads.length} threads (each < 1% of original): ${threadIds}`,
            timestamp: new Date().toISOString(),
            isTerminal: true
        };

        // Add to hop entries
        const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
        if (hop) {
            if (!hop.entries) hop.entries = [];
            hop.entries.push(entry);

            // Update thread allocations
            threads.forEach(thread => {
                updateThreadAllocation(thread.internalId || thread.threadId, thread.availableAmount, currency);
            });

            console.log(`Created rounding write-off for ${totalAmount.toFixed(6)} ${currency} from ${threads.length} threads`);
        }
    });

    // Save and update UI
    saveToStorage();
    pushToUndoStack('Write off rounding remainders');
    updateUI();

    const totalThreads = roundingThreads.length;
    const currencies = Object.keys(byCurrency).join(', ');
    showNotification(`✅ Written off rounding remainders from ${totalThreads} threads (${currencies})`, 'success', 5000);
}

function createWriteoffEntryFromWizard() {
    const wizardData = window.hopWizardData;
    const hop = investigation.hops.find(h => h.hopNumber === wizardData.hopNumber);
    if (!hop) {
        console.error('Hop not found for write-off entry');
        return;
    }

    saveUndoState(`Create write-off entry in Hop ${hop.hopNumber}`);

    // Use the actual transaction amount if available, otherwise use allocations
    const actualTxAmount = wizardData.txData ? parseFloat(wizardData.txData.amount) : 0;
    const totalAmount = actualTxAmount > 0 ? actualTxAmount : Object.values(wizardData.allocations).reduce((sum, val) => sum + val, 0);

    // Get currency from transaction data or first thread
    const threads = getAvailableSourcesForHop(hop.hopNumber, null);
    const firstThreadId = wizardData.selectedThreads[0];
    const thread = threads.find(t => t.threadId === firstThreadId);
    const currency = wizardData.txData?.currency || (thread ? thread.currency : 'USD');

    // Adjust allocations to use actual transaction amount
    const adjustedAllocations = {};
    if (actualTxAmount > 0 && wizardData.selectedThreads.length === 1) {
        // For single thread, use the actual transaction amount
        adjustedAllocations[wizardData.selectedThreads[0]] = totalAmount;
    } else if (actualTxAmount > 0 && wizardData.selectedThreads.length > 1) {
        // For multiple threads, proportionally adjust based on transaction amount
        const allocationTotal = Object.values(wizardData.allocations).reduce((sum, val) => sum + val, 0);
        for (const [threadId, allocation] of Object.entries(wizardData.allocations)) {
            adjustedAllocations[threadId] = (allocation / allocationTotal) * totalAmount;
        }
    } else {
        // No transaction data, use original allocations
        Object.assign(adjustedAllocations, wizardData.allocations);
    }

    // Create write-off entry
    const writeoffEntry = {
        id: Date.now(),
        hopNumber: hop.hopNumber,
        entryType: 'writeoff',
        txHash: wizardData.txHash || '',
        amount: totalAmount.toString(),
        currency: currency === 'CUSTOM' ? 'CUSTOM' : currency,
        customCurrency: currency === 'CUSTOM' ? currency : '',
        category: wizardData.writeoffCategory || 'minimal_amount',
        justification: wizardData.writeoffNotes || `Amount too small to track: ${totalAmount.toLocaleString()} ${currency}`,
        notes: wizardData.manualData?.notes || '',

        // Thread allocation data with adjusted amounts
        sourceThreadId: wizardData.selectedThreads.length === 1 ? wizardData.selectedThreads[0] : '',
        multipleSourceThreads: wizardData.selectedThreads.length > 1 ? wizardData.selectedThreads : null,
        individualSourceAssignments: adjustedAllocations,

        // Transaction details if available
        fromWallet: '',
        toWallet: wizardData.txData?.to || wizardData.manualData?.toWallet || '',
        timestamp: wizardData.txData ? new Date(wizardData.txData.time).toISOString().slice(0, 16) :
                   wizardData.manualData?.timestamp || new Date().toISOString().slice(0, 16),

        // Auto-calculate notation
        victimNumbers: '',
        transactionNumbers: '',
        notation: '',

        // Finalize immediately since it's a write-off
        isFinalized: true
    };

    // Get from wallet from source threads
    if (wizardData.selectedThreads.length === 1) {
        const sourceThread = threads.find(t => t.threadId === wizardData.selectedThreads[0]);
        writeoffEntry.fromWallet = sourceThread ? sourceThread.sourceWallet : '';
    } else if (wizardData.selectedThreads.length > 1) {
        writeoffEntry.fromWallet = 'Multiple Sources';
    }

    // Build source chain from selected threads
    const sourceChain = wizardData.selectedThreads.map(threadId => {
        const thread = threads.find(t => t.threadId === threadId);
        return {
            threadId: threadId,
            amount: wizardData.allocations[threadId] || 0,
            currency: thread ? thread.currency : currency
        };
    });
    writeoffEntry.sourceChain = sourceChain;

    // Calculate victim and transaction numbers
    const victimNums = new Set();
    const transNums = new Set();
    wizardData.selectedThreads.forEach(threadId => {
        const match = threadId.match(/V(\d+)-T(\d+)/);
        if (match) {
            victimNums.add(match[1]);
            transNums.add(match[2]);
        }
    });
    writeoffEntry.victimNumbers = Array.from(victimNums).join(',');
    writeoffEntry.transactionNumbers = Array.from(transNums).join(',');

    // Generate notation with WO suffix
    writeoffEntry.notation = `V${writeoffEntry.victimNumbers}-T${writeoffEntry.transactionNumbers}-H${hop.hopNumber}-WO`;
    writeoffEntry.generatedNotation = writeoffEntry.notation;

    // Mark the writeoff entry as finalized/logged immediately
    writeoffEntry.isFinalized = true;

    // Add entry to hop
    hop.entries.push(writeoffEntry);

    // Mark the writeoff entry as collapsed immediately
    const entryKey = `${hop.hopNumber}_${writeoffEntry.id}`;
    window.entryCollapseState = window.entryCollapseState || {};
    window.entryCollapseState[entryKey] = true;

    // Close wizard
    closeHopWizard();

    // Rebuild and render
    buildAvailableThreadsIndex();
    renderHops();
    saveToStorage();

    // Force collapse the write-off entry after rendering (increased timeout for render completion)
    setTimeout(() => {
        const entryKey = `${hop.hopNumber}_${writeoffEntry.id}`;

        // Make sure the collapse state is set
        window.entryCollapseState[entryKey] = true;

        // Use the correct IDs based on renderCollapsibleHopEntry function
        const entryContent = document.getElementById(`entryContent_${entryKey}`);
        const entrySummary = document.getElementById(`entrySummary_${entryKey}`);

        if (entryContent && entrySummary) {
            entryContent.style.display = 'none';
            entrySummary.style.display = 'block';
            console.log('Successfully collapsed write-off entry:', entryKey);

            // Also update the toggle button if it exists
            const entryElement = document.getElementById(`entry_${hop.hopNumber}_${writeoffEntry.id}`);
            if (entryElement) {
                const toggleBtns = entryElement.querySelectorAll('[onclick*="toggleEntryCollapse"]');
                toggleBtns.forEach(btn => {
                    const arrow = btn.querySelector('span');
                    if (arrow) {
                        arrow.style.transform = 'rotate(0deg)';
                    }
                });
            }
        } else {
            console.warn('Could not find entry elements to collapse:', {
                entryContent: !!entryContent,
                entrySummary: !!entrySummary,
                entryKey
            });
        }

        // Also ensure manual form is hidden if present
        const manualFormElement = document.getElementById(`manualEntryForm_${hop.hopNumber}_${writeoffEntry.id}`);
        if (manualFormElement) {
            manualFormElement.style.display = 'none';
            console.log('Hidden manual form for write-off entry');
        }
    }, 250); // Increased timeout to ensure rendering is complete

    // Do NOT show remaining threads summary for write-offs - it can trigger reopening the wizard
    // The alert below is sufficient

    // Calculate remaining balance in source thread
    let remainingBalance = 'N/A';
    if (wizardData.selectedThreads.length === 1) {
        const sourceThread = threads.find(t => t.threadId === wizardData.selectedThreads[0]);
        if (sourceThread) {
            const originalAmount = sourceThread.amount || 0;
            remainingBalance = (originalAmount - totalAmount).toLocaleString();
        }
    }

    // Show confirmation
    const confirmMsg = `✅ Write-off entry created and logged:\n\n` +
                       `Amount Written Off: ${totalAmount.toLocaleString()} ${currency}\n` +
                       `Transaction: ${wizardData.txHash || 'Not provided'}\n` +
                       `Category: ${wizardData.writeoffCategory || 'minimal_amount'}\n` +
                       `\nThe source thread has been reduced by ${totalAmount.toLocaleString()} ${currency}.\n` +
                       `Remaining traceable amount: ${remainingBalance} ${currency}`;

    // Set a flag to prevent auto-reopening wizard after write-off
    window.justCreatedWriteoff = true;
    setTimeout(() => {
        window.justCreatedWriteoff = false;
    }, 1000);

    // Show confirmation
    alert(confirmMsg);
}

function createHopEntryFromWizard() {
    const wizardData = window.hopWizardData;
    const hop = investigation.hops.find(h => h.hopNumber === wizardData.hopNumber);
    if (!hop) {
        console.error('Hop not found for hopNumber:', wizardData.hopNumber);
        return;
    }

    // CRITICAL VALIDATION: Check for duplicate transaction hash in the same hop
    if (wizardData.txHash && !wizardData.isWriteoff) {
        const duplicateEntry = hop.entries.find(entry =>
            entry.txHash &&
            entry.txHash.toLowerCase() === wizardData.txHash.toLowerCase() &&
            entry.entryType !== 'writeoff'
        );

        if (duplicateEntry) {
            alert(`❌ Transaction hash already used in this hop!\n\nTransaction ${wizardData.txHash} is already logged in entry ${duplicateEntry.id} (${duplicateEntry.notation || 'unnamed'}).\n\nIf multiple threads move in the same transaction, they must all be logged in the same entry using multiple source thread selection.`);
            return;
        }
    }

    // Check if this is a write-off entry
    if (wizardData.isWriteoff) {
        console.log('Creating write-off entry from wizard');
        createWriteoffEntryFromWizard();
        return;
    }

    // Check if this is a swap transaction
    if (wizardData.isSwap && wizardData.swapDetails) {
        // Redirect to the dedicated swap wizard instead of using the old function
        console.log('Swap detected - redirecting to dedicated swap wizard');
        closeHopWizard();
        alert('Swap transaction detected! Please use "Add Entry" → "DEX/Asset Conversion" for proper swap tracking.');
        return;
    }

    // Check if we have multiple outputs to process
    if (wizardData.multipleOutputs && wizardData.multipleOutputs.length > 0) {
        // Create an entry for each selected output
        wizardData.multipleOutputs.forEach((output, index) => {
            createSingleHopEntry(hop, wizardData, output, index);
        });

        // Close wizard FIRST before re-rendering
        closeHopWizard();

        // Rebuild and render
        buildAvailableThreadsIndex();
        renderHops();
        saveToStorage();
        checkHopCompletionStatus(hop);

        // Ensure entries are collapsed (double-check after render)
        setTimeout(() => {
            wizardData.multipleOutputs.forEach((output, index) => {
                if (!output.isChange) { // Only for actual entries, not change
                    const entryId = Date.now() + index;
                    const entryKey = `${hop.hopNumber}_${entryId}`;
                    window.entryCollapseState[entryKey] = true;

                    // Force collapse if element exists
                    const entryElement = document.querySelector(`[id*="${entryKey}"]`);
                    if (entryElement) {
                        const content = entryElement.querySelector('.entry-content');
                        const summary = entryElement.querySelector('.entry-summary');
                        if (content) content.style.display = 'none';
                        if (summary) summary.style.display = 'block';
                    }
                }
            });
        }, 100);

        return; // Exit to prevent manual form from appearing
    }

    // Original single entry logic continues below...

    // Determine data source based on entry mode
    let fromWallet, toWallet, timestamp, currency, amount;

    // Get the transaction data if available
    const txData = wizardData.txData;

    if (wizardData.entryMode === 'manual') {
        // Get from wallet from the source thread(s)
        const threads = getAvailableSourcesForHop(hop.hopNumber, null);
        if (wizardData.selectedThreads.length === 1) {
            const thread = threads.find(t => t.threadId === wizardData.selectedThreads[0]);
            fromWallet = thread ? thread.sourceWallet : '';
        } else {
            // For multiple sources, use the first one or combine them
            fromWallet = 'Multiple Sources';
        }
        toWallet = wizardData.manualData?.toWallet || '';
        timestamp = wizardData.manualData?.timestamp || '';
    } else {
        fromWallet = wizardData.txData?.from || '';
        toWallet = wizardData.txData?.to || '';
        timestamp = wizardData.txData ? new Date(wizardData.txData.time).toISOString().slice(0, 16) : '';
    }
    
    // Validate thread allocations before proceeding
    let totalAmount = Object.values(wizardData.allocations).reduce((sum, val) => sum + val, 0);

    // Calculate total available across all selected threads
    const threads = getAvailableSourcesForHop(hop.hopNumber, null);
    let totalAvailable = 0;
    let currencies = new Set();

    wizardData.selectedThreads.forEach(threadId => {
        const thread = threads.find(t => t.threadId === threadId);
        if (thread) {
            totalAvailable += thread.availableAmount;
            currencies.add(thread.currency);
        }
    });

    // Ensure we're not trying to allocate more than we have
    if (totalAmount > totalAvailable) {
        console.log(`Allocation exceeds available: Requested ${totalAmount}, Available ${totalAvailable}`);
        console.log(`Capping allocation at available amount: ${totalAvailable}`);

        // Simply cap at what's available - this is our maximum claim
        wizardData.allocations = applyPIFOAllocation(totalAvailable, wizardData.selectedThreads);
        totalAmount = totalAvailable;

        console.log('Adjusted allocations to available amount:', wizardData.allocations);
    }

    // For partial traces, we only claim what we have, not the full transaction
    // The transaction amount is informational but doesn't dictate our allocation
    if (wizardData.txData && wizardData.txData.amount) {
        const txAmount = parseFloat(wizardData.txData.amount);

        // Only adjust if we're trying to allocate MORE than the transaction
        // Never force allocation UP to match transaction (that would be claiming funds we don't have)
        if (totalAmount > txAmount) {
            console.log(`Capping allocation at transaction amount: ${txAmount} (was trying to allocate ${totalAmount})`);

            // Cap at transaction amount - can't claim more than what moved
            wizardData.allocations = applyPIFOAllocation(txAmount, wizardData.selectedThreads);
            totalAmount = txAmount;

            console.log('Capped allocations at transaction amount:', wizardData.allocations);
        } else if (txAmount > totalAmount) {
            // This is a partial trace - we're only following our portion
            console.log(`Partial trace: Following ${totalAmount} of ${txAmount} total transaction`);
            // Keep our allocations as-is, don't try to match the full transaction
        }
    }

    // Check if mixing currencies (which shouldn't be allowed)
    if (currencies.size > 1 && !wizardData.isSwap) {
        alert(`⚠️ Currency Mismatch!\n\nYou cannot mix different currencies in a single entry unless it's a swap.\nCurrencies found: ${Array.from(currencies).join(', ')}\n\nPlease select threads with the same currency or use the swap wizard.`);
        return; // Hard block
    }

    // Check if this is partial tracing (transaction amount exceeds our allocation)
    let partialTraceNote = '';
    if (wizardData.txData && wizardData.txData.amount && wizardData.txData.amount > totalAmount) {
        // This is partial tracing - we're only following our portion
        partialTraceNote = `Partial trace: Following ${totalAmount} of ${wizardData.txData.amount} ${wizardData.txData.currency || ''} (transaction total)`;
        console.log('Partial trace detected:', partialTraceNote);
    }

    // Auto-cap individual thread allocations at available amounts
    // Don't block - just cap at what's available (handles floating point precision issues)
    let hadAutoCap = false;
    for (const [threadId, allocation] of Object.entries(wizardData.allocations)) {
        // Determine currency from the thread
        const threads = getAvailableSourcesForHop(hop.hopNumber, null);
        const thread = threads.find(t => t.threadId === threadId);
        if (thread) {
            const validation = validateThreadAllocation(
                threadId,
                allocation,
                thread.currency,
                wizardData.isEditMode ? wizardData.entryId : null,
                wizardData.isEditMode ? wizardData.hopNumber : null
            );

            if (!validation.valid) {
                // Auto-cap at available amount instead of blocking
                const cappedAmount = validation.maxAvailable;
                console.log(`⚠️ Auto-capping ${threadId}: requested ${allocation}, capped to ${cappedAmount} (available)`);
                wizardData.allocations[threadId] = cappedAmount;
                hadAutoCap = true;
            }
        }
    }

    // Recalculate total if we had to cap anything
    if (hadAutoCap) {
        totalAmount = Object.values(wizardData.allocations).reduce((sum, val) => sum + val, 0);
        console.log(`✅ Total amount after auto-capping: ${totalAmount}`);
    }

    // Check if we're in edit mode
    if (wizardData.isEditMode && wizardData.entryId) {
        // Update existing entry
        const existingEntry = hop.entries.find(e => e.id === wizardData.entryId);
        if (existingEntry) {
            saveUndoState(`Update trace entry in Hop ${hop.hopNumber}`);

            // Update the existing entry
            existingEntry.txHash = wizardData.txHash;
            existingEntry.fromWallet = fromWallet;
            existingEntry.toWallet = toWallet;
            existingEntry.toWalletType = wizardData.manualData?.walletType || existingEntry.toWalletType || 'black';
            existingEntry.timestamp = timestamp;
            existingEntry.amount = totalAmount.toString();
            existingEntry.sourceThreadId = wizardData.selectedThreads.length === 1 ? wizardData.selectedThreads[0] : '';
            existingEntry.multipleSourceThreads = wizardData.selectedThreads.length > 1 ? wizardData.selectedThreads : [];
            existingEntry.individualSourceAssignments = wizardData.selectedThreads.length > 1 ? wizardData.allocations : {};
            
            // Update currency if single source
            if (wizardData.selectedThreads.length === 1) {
                const source = getAvailableSourcesForHop(hop.hopNumber, null).find(t => t.threadId === wizardData.selectedThreads[0]);
                if (source) {
                    existingEntry.currency = source.currency;
                }
            }
            
            closeHopWizard();
            
            // Rebuild thread index to ensure available amounts are updated
            buildAvailableThreadsIndex();
            
            renderHops();
            saveToStorage();
            
            // Log the thread usage update
            console.log(`✅ Updated hop entry threads:`, wizardData.selectedThreads);
            console.log(`   Total amount: ${Object.values(wizardData.allocations).reduce((sum, val) => sum + val, 0)}`);
            console.log(`   Thread allocations:`, wizardData.allocations);
            
            // Scroll to the updated entry
            setTimeout(() => {
                const entryElement = document.getElementById(`entry_${hop.hopNumber}_${existingEntry.id}`);
                if (entryElement) {
                    entryElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    entryElement.style.border = '3px solid #27ae60';
                    setTimeout(() => {
                        entryElement.style.border = '';
                    }, 2000);
                }
            }, 100);
            
            return;
        }
    }
    
    // Apply Sequential Hop Rule for convergence
    let effectiveHopNumber = hop.hopNumber;
    let convergenceData = null;
    
    if (wizardData.selectedThreads.length > 1) {
        // This is a convergence - apply Sequential Hop Rule
        let maxSourceHopNumber = 0;
        wizardData.selectedThreads.forEach(threadId => {
            const threadMatch = threadId.match(/-H(\d+)$/);
            if (threadMatch) {
                const sourceHopNumber = parseInt(threadMatch[1]);
                maxSourceHopNumber = Math.max(maxSourceHopNumber, sourceHopNumber);
            }
        });
        
        if (investigation.tracingMethod === 'PIFO') {
            // Sequential Hop Rule: convergence output is at max source hop + 1
            effectiveHopNumber = maxSourceHopNumber + 1;
            
            convergenceData = {
                sourceCount: wizardData.selectedThreads.length,
                maxSourceHop: maxSourceHopNumber,
                sequentialHopRuleApplied: true
            };
            
            showNotification(
                `Sequential Hop Rule applied: Convergence of ${wizardData.selectedThreads.length} sources, output at hop ${effectiveHopNumber}`,
                'info'
            );
        }
    }
    
    // Determine currency from transaction data or source threads
    let entryCurrency = '';
    let isSwap = false;
    let swapDetails = null;

    // First check if we have transaction data with currency
    if (txData && txData.currency) {
        entryCurrency = txData.currency;
    }

    // Check if source threads have different currency than the transaction
    if (wizardData.selectedThreads.length === 1) {
        const sourceThread = getAvailableSourcesForHop(hop.hopNumber, null).find(t => t.threadId === wizardData.selectedThreads[0]);
        if (sourceThread) {
            if (!entryCurrency) {
                entryCurrency = sourceThread.currency;
            } else if (sourceThread.currency !== entryCurrency) {
                // This is a swap - source currency differs from transaction currency
                isSwap = true;
                swapDetails = {
                    fromCurrency: sourceThread.currency,
                    toCurrency: entryCurrency,
                    type: 'DEX'
                };
            }
        }
    } else if (wizardData.selectedThreads.length > 1) {
        // Multiple sources - check if they all have same currency
        const threads = getAvailableSourcesForHop(hop.hopNumber, null);
        const sourceCurrencies = new Set();
        wizardData.selectedThreads.forEach(threadId => {
            const thread = threads.find(t => t.threadId === threadId);
            if (thread) sourceCurrencies.add(thread.currency);
        });

        if (sourceCurrencies.size === 1) {
            const sourceCurrency = Array.from(sourceCurrencies)[0];
            if (!entryCurrency) {
                entryCurrency = sourceCurrency;
            } else if (sourceCurrency !== entryCurrency) {
                // Swap from single source currency to different output
                isSwap = true;
                swapDetails = {
                    fromCurrency: sourceCurrency,
                    toCurrency: entryCurrency,
                    type: 'DEX'
                };
            }
        }
    }

    // Generate notation based on selected threads
    let notation = '';
    if (wizardData.selectedThreads.length === 1) {
        // Extract base thread ID without hop suffix
        const threadId = wizardData.selectedThreads[0];
        const baseThread = threadId.match(/^(V\d+-T[\d,]+)/)?.[1] || threadId;
        notation = `${baseThread}-H${effectiveHopNumber}`;
    } else if (wizardData.selectedThreads.length > 1) {
        // For commingling, use parentheses format: (V1-T1) (V2-T1) H2
        // Group threads by victim
        const threadsByVictim = {};
        wizardData.selectedThreads.forEach(threadId => {
            // Parse thread ID like "V1-T2-H1" or "V1-T2"
            const match = threadId.match(/V(\d+)-T([\d,]+)/);
            if (match) {
                const victimId = match[1];
                const transactionIds = match[2];
                if (!threadsByVictim[victimId]) {
                    threadsByVictim[victimId] = [];
                }
                threadsByVictim[victimId].push(transactionIds);
            }
        });

        // Build notation with parentheses
        const notationParts = [];
        Object.keys(threadsByVictim).sort((a, b) => parseInt(a) - parseInt(b)).forEach(victimId => {
            const transactions = threadsByVictim[victimId].sort().join(',');
            notationParts.push(`(V${victimId}-T${transactions})`);
        });
        notation = `${notationParts.join(' ')} H${effectiveHopNumber}`;
    }

    // Add swap notation if applicable
    if (isSwap && swapDetails) {
        notation += ` [SWAP: ${swapDetails.fromCurrency} → ${swapDetails.toCurrency}]`;
    }

    // Determine wallet type - BROWN for swaps/DEX, otherwise use manual selection or default
    let toWalletType = 'black';
    let isBridgeEntry = false;
    if (isSwap) {
        toWalletType = 'brown'; // BROWN indicates asset conversion/DEX swap
        isBridgeEntry = true; // Mark as bridge immediately for proper thread handling
    } else if (wizardData.manualData?.walletType) {
        toWalletType = wizardData.manualData.walletType;
        // Also check if manually set to brown (conversion wallet)
        if (toWalletType === 'brown') {
            isBridgeEntry = true;
        }
    }

    // Calculate the amount to trace - should match allocations which already match transaction
    let totalAllocated = Object.values(wizardData.allocations).reduce((sum, val) => sum + val, 0);
    let traceAmount = totalAllocated;

    // The allocations have already been adjusted to match transaction amount above
    // No need to re-adjust here
    console.log(`Trace amount: ${traceAmount} from allocations:`, wizardData.allocations);

    // Check if this is a terminal wallet or smart contract
    let isTerminalWallet = false;
    let terminalAttribution = null;
    let isSmartContract = false;

    if (wizardData.isTerminalWallet || wizardData.terminalWalletType === 'purple') {
        isTerminalWallet = true;
        terminalAttribution = wizardData.detectedAttribution;
        toWalletType = 'purple';
    } else if (wizardData.detectedAttribution && toWallet &&
               toWallet.toLowerCase() === (wizardData.txData?.to || '').toLowerCase()) {
        // Auto-detect wallet type based on attribution
        const attribution = wizardData.detectedAttribution;
        if (attribution && attribution.isSmartContract) {
            // Smart contract detected - treat as conversion wallet (brown)
            console.log('Smart contract detected, marking as conversion wallet:', attribution.name);
            isSmartContract = true;
            toWalletType = 'brown';  // Brown for conversions/bridges
            isBridgeEntry = true; // Mark as bridge for proper thread handling
            // We'll show the bridge/swap button similar to terminal wallets
        } else if (attribution && attribution.isExchange && !attribution.isPersonalLabel) {
            // This is a real exchange/service - mark as terminal wallet (purple)
            isTerminalWallet = true;
            terminalAttribution = attribution;
            toWalletType = 'purple';
        } else if (attribution && attribution.isPersonalLabel) {
            // This is just a personal label - add to notes but don't mark as terminal
            console.log('Personal label detected, not marking as terminal:', attribution.name);
            // Explicitly ensure it's not marked as terminal
            isTerminalWallet = false;
            terminalAttribution = null;
            // Reset wallet type to regular yellow if it was set to purple
            if (toWalletType === 'purple') {
                toWalletType = 'yellow';
            }
            // The label will be added to notes below
        }
    }

    // Handle terminal wallet, smart contract, and attribution notes
    let entryNotes = wizardData.manualData?.notes || '';
    if (isTerminalWallet && terminalAttribution) {
        const terminalNote = `Terminal wallet: ${terminalAttribution.name || terminalAttribution.label}\nType: ${terminalAttribution.type || 'CEX'}\nDetection source: ${terminalAttribution.source || 'detected'}`;
        entryNotes = terminalNote + (entryNotes ? '\n' + entryNotes : '');
    } else if (isSmartContract && wizardData.detectedAttribution) {
        const contractNote = `Smart Contract: ${wizardData.detectedAttribution.name || wizardData.detectedAttribution.contractName}\nType: Conversion Wallet (Bridge/DEX)\nDetection source: ${wizardData.detectedAttribution.source || 'etherscan_verified_contract'}`;
        entryNotes = contractNote + (entryNotes ? '\n' + entryNotes : '');
    } else if (wizardData.detectedAttribution && wizardData.detectedAttribution.isPersonalLabel) {
        // Add personal label to notes (not a terminal wallet)
        const labelNote = wizardData.detectedAttribution.noteText || `Label: ${wizardData.detectedAttribution.name}`;
        entryNotes = labelNote + (entryNotes ? '\n' + entryNotes : '');
    }

    if (isSwap) {
        entryNotes = `DEX Swap: ${swapDetails.fromCurrency} converted to ${swapDetails.toCurrency} at ${toWallet}` + (entryNotes ? '\n' + entryNotes : '');
    }
    if (partialTraceNote) {
        entryNotes += `\n${partialTraceNote}`;
    }
    if (wizardData.pifoNote) {
        entryNotes += `\n${wizardData.pifoNote}`;
    }

    // Create new entry with wizard data
    const entry = {
        id: hop.entries.length + 1,
        hopNumber: wizardData.hopNumber,
        hopNumber: effectiveHopNumber,
        entryType: 'trace',
        notation: notation,
        fromWallet: fromWallet,
        fromWalletType: hop.hopNumber === 1 ? 'red' : 'black',
        fromWalletId: '',
        toWallet: toWallet,
        toWalletType: toWalletType,
        toWalletId: '',
        amount: traceAmount.toString(),
        currency: entryCurrency,
        customCurrency: '',
        txHash: wizardData.txHash,
        timestamp: timestamp,
        timezone: 'UTC',
        notes: entryNotes,
        category: '',
        justification: '',
        // Swap/Bridge tracking
        isSwap: isSwap,
        swapDetails: swapDetails,
        isBridge: isBridgeEntry, // Set immediately for brown wallets to ensure proper thread handling
        // Enhanced fields
        sourceChain: [],
        displayNotation: '',
        summaryNotation: '',
        victimNumbers: '',
        transactionNumbers: '',
        availableSourceAmount: 0,
        sourceThreadId: wizardData.selectedThreads.length === 1 ? wizardData.selectedThreads[0] : '',
        sourceThreadData: null,
        assignmentPercentage: 0,
        generatedNotation: '',
        isConvergence: wizardData.selectedThreads.length > 1,
        convergenceData: convergenceData,
        // New fields for multiple sources
        multipleSourceThreads: wizardData.selectedThreads.length > 1 ? wizardData.selectedThreads : [],
        // IMPORTANT: For single source, also store allocation in individualSourceAssignments
        individualSourceAssignments: wizardData.selectedThreads.length > 1 ? wizardData.allocations :
            wizardData.selectedThreads.length === 1 ? {[wizardData.selectedThreads[0]]: traceAmount} : {}
    };

    // Add terminal wallet or smart contract attribution if present
    if (isTerminalWallet && terminalAttribution) {
        entry.exchangeAttribution = terminalAttribution;
        entry.isTerminalWallet = true;

        // For terminal wallets, we use the allocated amounts (not the full thread amounts)
        // The allocations already respect the transaction amount limits
        console.log(`Terminal wallet entry created with allocated amounts:`, entry.individualSourceAssignments);
    } else if (wizardData.detectedAttribution && wizardData.detectedAttribution.isPersonalLabel) {
        // Explicitly mark personal label entries as NOT terminal
        entry.isTerminalWallet = false;
        console.log(`Entry marked as non-terminal due to personal label: ${wizardData.detectedAttribution.name}`);
    } else if (isSmartContract && wizardData.detectedAttribution) {
        // Smart contract - save attribution and mark as conversion wallet
        entry.exchangeAttribution = wizardData.detectedAttribution;
        entry.isSmartContract = true;
        entry.isConversionWallet = true;
        console.log(`Smart contract entry created as conversion wallet:`, wizardData.detectedAttribution.name);

        // Just log what we're using - don't modify the allocations
        if (entry.individualSourceAssignments) {
            Object.entries(entry.individualSourceAssignments).forEach(([threadId, amount]) => {
                console.log(`Terminal wallet: Using allocated amount ${amount} from thread ${threadId}`);
            });
        }
    }

    // Store internal IDs for proper thread tracking (especially for terminal exhaustion)
    if (wizardData.selectedInternalIds && wizardData.selectedInternalIds.length > 0) {
        entry.sourceThreadIds = wizardData.selectedInternalIds;
        entry.multipleSourceInternalIds = wizardData.selectedInternalIds;
    } else {
        // Fallback to thread notations if internal IDs not available
        entry.sourceThreadIds = wizardData.selectedThreads || [];
    }

    // Save undo state
    saveUndoState(`Add trace entry to Hop ${hop.hopNumber}`);

    hop.entries.push(entry);

    // If this is a terminal wallet, add to the terminal wallet index
    if (isTerminalWallet && terminalAttribution) {
        addToTerminalWalletIndex(entry);
        console.log('🟣 Added terminal wallet arrival to index');
    }

    // Handle remainder thread creation for terminal wallets
    if (isTerminalWallet && totalAllocated > traceAmount) {
        const remainderAmount = totalAllocated - traceAmount;
        console.log(`Creating remainder thread for untraced amount: ${remainderAmount} ${entryCurrency}`);

        // For each source thread that contributed, create a remainder thread
        for (const threadId in wizardData.allocations) {
            const originalAllocation = wizardData.allocations[threadId];
            const usedAmount = originalAllocation * (traceAmount / totalAllocated);
            const threadRemainder = originalAllocation - usedAmount;

            if (threadRemainder > 0.01) { // Only create remainder if significant
                // The remainder stays at the current hop level for future tracing
                console.log(`Thread ${threadId}: Used ${usedAmount}, Remainder ${threadRemainder}`);

                // Update the available threads database to reflect the partial use
                // The buildAvailableThreadsIndex() call later will handle this
            }
        }
    }

    // Mark entry for auto-collapse BEFORE sorting
    const entryKey = `${hop.hopNumber}_${entry.id}`;
    window.entryCollapseState = window.entryCollapseState || {};
    window.entryCollapseState[entryKey] = true;

    // Store the original entry reference before sorting
    const newEntry = entry;

    // Sort entries by timestamp to maintain chronological order
    sortHopEntriesChronologically(hop);

    // Find the entry's new ID after sorting
    const sortedEntryIndex = hop.entries.indexOf(newEntry);
    const sortedEntryId = sortedEntryIndex >= 0 ? hop.entries[sortedEntryIndex].id : entry.id;

    // Update collapse state with sorted ID if different
    if (sortedEntryId !== entry.id) {
        const sortedEntryKey = `${hop.hopNumber}_${sortedEntryId}`;
        window.entryCollapseState[sortedEntryKey] = true;
    }

    // Close wizard BEFORE re-rendering
    closeHopWizard();

    // Rebuild thread index to ensure available amounts are updated
    buildAvailableThreadsIndex();

    // Render with collapsed state already set
    renderHops();
    saveToStorage();

    // Check if hop is now fully accounted for
    checkHopCompletionStatus(hop);

    // Log the thread usage
    console.log(`✅ Created hop entry consuming threads:`, wizardData.selectedThreads);
    console.log(`   Total amount used: ${Object.values(wizardData.allocations).reduce((sum, val) => sum + val, 0)}`);
    console.log(`   Thread allocations:`, wizardData.allocations);

    // Show progress indicator in hop header instead of modal
    updateHopProgressIndicator(hop);

    // Brief highlight animation to show where entry was created
    setTimeout(() => {
        const finalEntryKey = `${hop.hopNumber}_${sortedEntryId}`;
        const entryElement = document.getElementById(`entry_${hop.hopNumber}_${sortedEntryId}`);

        if (entryElement) {
            // Ensure it's collapsed (double-check)
            const content = document.getElementById(`entryContent_${finalEntryKey}`);
            const summary = document.getElementById(`entrySummary_${finalEntryKey}`);

            if (content && summary) {
                content.style.display = 'none';
                summary.style.display = 'block';
            }

            // Scroll to the new entry
            entryElement.scrollIntoView({ behavior: 'smooth', block: 'center' });

            // Add a temporary highlight effect
            entryElement.style.transition = 'box-shadow 0.5s ease';
            entryElement.style.boxShadow = '0 0 10px rgba(76, 175, 80, 0.5)';
            setTimeout(() => {
                entryElement.style.boxShadow = '';
            }, 2000);
        }
    }, 100);

    // Show remaining threads summary after wizard completion
    showRemainingThreadsSummary(hop);

    // Return to prevent any further processing that might open forms
    return;
}
// Calculate remaining ART for write-offs
function calculateRemainingARTForHop(hopNumber, currency) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    if (!hop) return 0;
    
    // Get the starting ART for this hop
    const startingART = hop.artAtStartByCurrency || {};
    const artForCurrency = startingART[currency] || 0;
    
    // Calculate total traced/written off so far in this hop
    let totalAllocated = 0;
    hop.entries.forEach(entry => {
        const entryCurrency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
        if (entryCurrency === currency && parseFloat(entry.amount) > 0) {
            totalAllocated += parseFloat(entry.amount);
        }
    });
    
    const remaining = artForCurrency - totalAllocated;
    console.log(`Hop ${hop.hopNumber} ${currency}: Starting ART ${artForCurrency}, Allocated ${totalAllocated}, Remaining ${remaining}`);
    
    return Math.max(0, remaining); // Don't return negative
}

// Auto-fill max write-off amount
function assignMaxWriteoffAmount(hopNumber, entryId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    
    if (entry.entryType !== 'writeoff') {
        alert('This function is only for write-off entries.');
        return;
    }
    
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    const remainingART = calculateRemainingARTForHop(hopNumber, currency);
    
    if (remainingART <= 0) {
        alert(`No remaining ${currency} to write off in this hop.`);
        return;
    }
    
    entry.amount = remainingART.toString();
    
    const amountInput = document.getElementById(`writeoffAmount_${hopNumber}_${entryId}`);
    if (amountInput) {
        amountInput.value = remainingART;
    }
    
    updateWriteoffPreview(hopNumber, entryId);
    saveToStorage();
    
    // Re-render hops to update validation
    renderHops();
}

// Update write-off preview with balance information
function updateWriteoffPreview(hopNumber, entryId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    const previewElement = document.getElementById(`writeoffPreview_${hopNumber}_${entryId}`);
    
    if (!previewElement || entry.entryType !== 'writeoff') {
        return;
    }
    
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    const amount = parseFloat(entry.amount) || 0;
    const remainingART = calculateRemainingARTForHop(hopNumber, currency);
    const afterWriteoff = remainingART - amount;
    
    let previewHTML = '';
    if (amount > 0) {
        const isValid = amount <= remainingART;
        previewHTML = `
            <div style="background: #f8f9fa; border: 1px solid #ddd; border-radius: 4px; padding: 10px; margin-top: 10px;">
                <div style="font-weight: bold; margin-bottom: 8px; color: #2c3e50;">Write-off Impact:</div>
                <div style="font-size: 12px; color: #666; margin-bottom: 5px;">
                    Remaining ART before write-off: ${remainingART.toLocaleString()} ${currency}
                </div>
                <div style="color: ${isValid ? '#27ae60' : '#e74c3c'}; font-weight: bold;">
                    ${isValid ? '✓' : '⚠'} Writing off: ${amount.toLocaleString()} ${currency}
                </div>
                ${isValid ? `
                    <div style="font-size: 12px; color: #666; margin-top: 5px;">
                        Remaining after write-off: ${afterWriteoff.toLocaleString()} ${currency}
                        ${afterWriteoff === 0 ? ' <span style="color: #27ae60; font-weight: bold;">(Fully balanced!)</span>' : ''}
                    </div>
                ` : `
                    <div style="font-size: 12px; color: #e74c3c; margin-top: 5px;">
                        Cannot write off more than remaining ART!
                    </div>
                `}
            </div>
        `;
    }
    
    previewElement.innerHTML = previewHTML;
}

// Get suggested write-off categories with descriptions
function getSuggestedWriteoffCategory(amount, currency) {
    if (amount < 50) {
        return {
            category: 'dust',
            suggestion: 'Dust - Below practical threshold',
            description: `Amount of ${amount.toLocaleString()} ${currency} is below the typical investigation threshold of $50.`
        };
    } else if (amount < 500) {
        return {
            category: 'operational',
            suggestion: 'Operational - Resource constraints',
            description: `Small amount of ${amount.toLocaleString()} ${currency} may not justify continued investigation resources.`
        };
    } else {
        return {
            category: 'dilution',
            suggestion: 'Dilution - Too diluted to trace',
            description: `Amount may have become too diluted in larger transactions to trace effectively.`
        };
    }
}

// Enhanced write-off section renderer
function renderWriteoffSection(entry) {
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    const amount = parseFloat(entry.amount) || 0;
    const suggestion = amount > 0 ? getSuggestedWriteoffCategory(amount, currency) : null;
    
    return `
        <div class="form-group">
            <label>Write-off Amount</label>
            <div style="display: flex; gap: 10px; align-items: center;">
                <input type="number" step="0.01" 
                       id="writeoffAmount_${hop.hopNumber}_${entry.id}"
                       value="${entry.amount || ''}"
                       onchange="updateWriteoffAmount(${hop.hopNumber}, ${entry.id}, this.value)">
                <button type="button" class="btn btn-secondary" 
                        onclick="assignMaxWriteoffAmount(${hop.hopNumber}, ${entry.id})">
                    Max (Balance ART)
                </button>
            </div>
            <div id="writeoffPreview_${hop.hopNumber}_${entry.id}" 
                 style="font-size: 12px; margin-top: 5px;"></div>
        </div>
        
        <div class="form-group">
            <label>Write-off Category</label>
            <select onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'category', this.value)">
                <option value="">Select category...</option>
                ${Object.entries(writeoffCategories).map(([key, value]) => 
                    `<option value="${key}" ${entry.category === key ? 'selected' : ''}>${value}</option>`
                ).join('')}
            </select>
            ${suggestion ? `
                <div style="margin-top: 8px; padding: 8px; background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px; font-size: 12px;">
                    <strong>💡 Suggestion:</strong> ${suggestion.suggestion}<br>
                    <small style="color: #666;">${suggestion.description}</small>
                </div>
            ` : ''}
        </div>
        
        <div class="form-group" style="grid-column: span 2;">
            <label>Justification</label>
            <textarea rows="3" 
                      placeholder="Detailed explanation for abandoning this trace path. Example: Amount too small to justify continued investigation resources..." 
                      onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'justification', this.value)">${entry.justification || ''}</textarea>
            ${suggestion && !entry.justification ? `
                <div style="margin-top: 5px; font-size: 11px; color: #666;">
                    <strong>Suggested justification:</strong> ${suggestion.description}
                </div>
            ` : ''}
        </div>
    `;
}

// Update write-off amount with validation
function updateWriteoffAmount(hopNumber, entryId, amount) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    
    entry.amount = amount;
    updateWriteoffPreview(hopNumber, entryId);
    updateHopEntry(hopNumber, entryId, 'amount', amount);
}

        function updateHopEntry(hopNumber, entryId, field, value) {
            const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
            const entry = hop.entries.find(e => e.id === entryId);

            // CRITICAL VALIDATION: Check for duplicate transaction hash
            if (field === 'txHash' && value && entry.entryType !== 'writeoff') {
                const duplicateEntry = hop.entries.find(e =>
                    e.id !== entryId &&  // Not the same entry
                    e.txHash &&
                    e.txHash.toLowerCase() === value.toLowerCase() &&
                    e.entryType !== 'writeoff'
                );

                if (duplicateEntry) {
                    alert(`❌ Transaction hash already used in this hop!\n\nTransaction ${value} is already logged in entry ${duplicateEntry.id} (${duplicateEntry.notation || 'unnamed'}).\n\nIf multiple threads move in the same transaction, they must all be logged in the same entry using multiple source thread selection.`);
                    // Reset the input field
                    const inputField = document.getElementById(`txHash_${hopNumber}_${entryId}`);
                    if (inputField) {
                        inputField.value = entry.txHash || '';
                    }
                    return;
                }
            }

            entry[field] = value;

            // If timestamp changed, re-sort entries chronologically
            if (field === 'timestamp') {
                sortHopEntriesChronologically(hop);
            }

            if (field === 'entryType') {
                // Regenerate notation if victim and transaction numbers exist
                if (entry.victimNumbers && entry.transactionNumbers) {
                    generateNotationPreview(hopNumber, entryId);
                }
                renderHops();
                saveToStorage();
                return;
            }
            
            if (field === 'currency') {
                const customInput = document.getElementById(`customEntryCurrency_${hopNumber}_${entryId}`);
                if (customInput) {
                    if (value === 'CUSTOM') {
                        customInput.style.display = 'block';
                        customInput.classList.remove('custom-currency-input');
                    } else {
                        customInput.style.display = 'none';
                        customInput.classList.add('custom-currency-input');
                    }
                }
            }
            
            // Handle wallet address changes
            if (field === 'toWallet' || field === 'fromWallet') {
                // Check if this is a known wallet and auto-set the type
                if (field === 'toWallet' && value) {
                    const knownWallet = investigation.universalWalletIndex?.find(w => w.address === value.trim());
                    if (knownWallet) {
                        // Auto-set the wallet type from UWI
                        entry.toWalletType = knownWallet.permanentType;
                        
                        // Update the wallet type dropdown if it exists
                        const typeSelect = document.querySelector(`select[onchange="updateHopEntryWalletType(${hopNumber}, ${entryId}, this.value)"]`);
                        if (typeSelect) {
                            typeSelect.value = knownWallet.permanentType;
                        }
                    }
                    
                    // Check all attribution sources for the address
                    checkAllAttributions(value.trim()).then(attributions => {
                        if (attributions && attributions.length > 0) {
                            showAttributionModal(attributions, hopNumber, entryId);
                        }
                    });
                }
                
                buildUniversalWalletIndex();
                buildRedWalletIndex();
            }
            
            if (field === 'amount' || field === 'currency' || field === 'toWallet' || field === 'entryType') {
                renderHops();
            }
            
            // If amount changed, mark downstream hops for validation
            if (field === 'amount' && parseFloat(value) !== parseFloat(entry._previousAmount || 0)) {
                entry._previousAmount = value;
                markDownstreamHopsForValidation(hop.hopNumber);
            }
            
            saveToStorage();
            updateValidationStatus();
            buildAvailableThreadsIndex(); // Rebuild thread index when entry is updated
            
            // Update progress indicator
            updateProgressIndicator();
            
            // Check if hop is now fully accounted for
            checkHopCompletionStatus(hop);
        }
        
        // Mark all hops downstream from a given hop number for validation
        function markDownstreamHopsForValidation(fromHopNumber) {
            investigation.hops.forEach(hop => {
                if (hop.hopNumber > fromHopNumber) {
                    hop.needsValidation = true;
                }
            });
        }

        function updateHopEntryWalletType(hopNumber, entryId, walletType) {
            updateHopEntry(hopNumber, entryId, 'toWalletType', walletType);
            
            // If BROWN wallet is selected, open asset conversion modal
            if (walletType === 'brown') {
                openAssetConversionModal(hopNumber, entryId);
            }
        }

        function openAssetConversionModal(hopNumber, entryId) {
            showModal('assetConversionModal');
            
            // Store the hop and entry ID for later use
            window.currentConversionHopId = hopNumber;
            window.currentConversionEntryId = entryId;
            
            // Pre-populate with entry data if available
            const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
            const entry = hop.entries.find(e => e.id === entryId);
            if (entry) {
                // Set from currency based on the entry's current currency
                if (entry.currency === 'CUSTOM') {
                    document.getElementById('conversionFromCurrency').value = 'CUSTOM';
                    document.getElementById('customFromCurrencyGroup').style.display = 'block';
                    document.getElementById('conversionFromCurrencyCustom').value = entry.customCurrency || '';
                } else {
                    document.getElementById('conversionFromCurrency').value = entry.currency || '';
                }
                document.getElementById('conversionFromAmount').value = entry.amount || '';
            }
        }

        function confirmAssetConversion() {
            const hopNumber = window.currentConversionHopId;
            const entryId = window.currentConversionEntryId;
            if (!hopNumber || !entryId) return;
            
            const fromCurrency = document.getElementById('conversionFromCurrency').value;
            const toCurrency = document.getElementById('conversionToCurrency').value;
            const fromAmount = document.getElementById('conversionFromAmount').value;
            const toAmount = document.getElementById('conversionToAmount').value;
            const platform = document.getElementById('conversionPlatform').value;
            const notes = document.getElementById('conversionNotes').value;
            
            // Get custom currencies if selected
            const fromCustom = document.getElementById('conversionFromCurrencyCustom').value;
            const toCustom = document.getElementById('conversionToCurrencyCustom').value;
            
            // Update entry with conversion data
            const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
            const entry = hop.entries.find(e => e.id === entryId);
            if (entry) {
                // Store original currency info for the conversion record
                const originalCurrency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                const originalAmount = entry.amount || fromAmount;
                
                // Update the entry currency to the "to" currency
                entry.currency = toCurrency;
                entry.customCurrency = toCurrency === 'CUSTOM' ? toCustom : '';
                entry.amount = toAmount;
                
                // Add conversion info to notes
                const conversionInfo = `Asset Conversion: ${originalAmount} ${originalCurrency} ${toAmount} ${toCurrency === 'CUSTOM' ? toCustom : toCurrency} via ${platform}. ${notes}`;
                entry.notes = entry.notes ? entry.notes + '\n' + conversionInfo : conversionInfo;
                
                // Mark this as a conversion entry
                entry.isConversion = true;
                entry.conversionData = {
                    fromCurrency: originalCurrency,
                    fromAmount: parseFloat(originalAmount) || 0,
                    toCurrency: toCurrency === 'CUSTOM' ? toCustom : toCurrency,
                    toAmount: parseFloat(toAmount) || 0,
                    platform: platform,
                    conversionRate: parseFloat(toAmount) / parseFloat(originalAmount)
                };
            }
            
            // Store conversion details
            const conversion = {
                id: (investigation.conversions || []).length + 1,
                hopNumber: hopNumber,
                entryId: entryId,
                fromCurrency: fromCurrency === 'CUSTOM' ? fromCustom : fromCurrency,
                toCurrency: toCurrency === 'CUSTOM' ? toCustom : toCurrency,
                fromAmount: parseFloat(fromAmount) || 0,
                toAmount: parseFloat(toAmount) || 0,
                platform: platform,
                notes: notes
            };
            
            if (!investigation.conversions) {
                investigation.conversions = [];
            }
            investigation.conversions.push(conversion);
            
            closeAssetConversionModal();
            
            // Rebuild thread index to ensure new currency is tracked
            buildAvailableThreadsIndex();
            
            // Update ART calculations for the hop
            updateHopARTForConversion(hop, originalCurrency, originalAmount, toCurrency === 'CUSTOM' ? toCustom : toCurrency, toAmount);
            
            renderHops();
            saveToStorage();
        }

        function closeAssetConversionModal() {
            hideModal('assetConversionModal');
            window.currentConversionHopId = null;
            window.currentConversionEntryId = null;
        }
        
        function updateHopARTForConversion(hop, fromCurrency, fromAmount, toCurrency, toAmount) {
            // Ensure hop has ART tracking by currency
            if (!hop.artAtStartByCurrency) {
                hop.artAtStartByCurrency = {};
            }
            
            // For conversions, we need to track both currencies
            // The original currency is consumed and the new currency is created
            
            // If this is the first time we see the new currency in this hop
            if (!hop.artAtStartByCurrency[toCurrency]) {
                hop.artAtStartByCurrency[toCurrency] = 0;
            }
            
            // Mark the hop as having a conversion
            if (!hop.hasConversions) {
                hop.hasConversions = true;
            }
            
            // Store conversion tracking data
            if (!hop.conversions) {
                hop.conversions = [];
            }
            
            hop.conversions.push({
                fromCurrency: fromCurrency,
                fromAmount: parseFloat(fromAmount),
                toCurrency: toCurrency,
                toAmount: parseFloat(toAmount),
                timestamp: new Date().toISOString()
            });
            
            console.log(`Conversion tracked in Hop ${hop.hopNumber}: ${fromAmount} ${fromCurrency} → ${toAmount} ${toCurrency}`);
            console.log('Updated hop ART by currency:', hop.artAtStartByCurrency);
        }
        
        function copyConversionAmount() {
            const fromAmount = document.getElementById('conversionFromAmount').value;
            if (fromAmount) {
                // Copy to clipboard
                navigator.clipboard.writeText(fromAmount).then(() => {
                    // Also populate the converted amount field
                    document.getElementById('conversionToAmount').value = fromAmount;
                    
                    // Show success feedback
                    const button = event.target;
                    const originalText = button.innerHTML;
                    button.innerHTML = '✅ Copied!';
                    button.style.background = '#27ae60';
                    
                    setTimeout(() => {
                        button.innerHTML = originalText;
                        button.style.background = '';
                    }, 1500);
                }).catch(err => {
                    console.error('Failed to copy:', err);
                    // Fallback - just copy to the field
                    document.getElementById('conversionToAmount').value = fromAmount;
                });
            }
        }

        function openConvergenceHelper() {
            if (!investigation.hops || investigation.hops.length < 1) {
                alert('Need at least 1 hop with multiple entries to record convergence.');
                return;
            }
            
            let content = '<div style="margin: 15px 0;"><strong>Select entries that are converging:</strong></div>';
            investigation.hops.forEach(hop => {
                hop.entries.forEach(entry => {
                    if (entry.entryType === 'trace') {
                        content += `
                            <label style="display: block; margin: 8px 0; cursor: pointer;">
                                <input type="checkbox" value="${hop.hopNumber}_${entry.id}" onchange="updateConvergenceSelection()"> 
                                ${entry.notation || 'Entry ' + entry.id} - ${entry.amount} ${entry.currency} (H${entry.hopNumber})
                            </label>
                        `;
                    }
                });
            });
            
            document.getElementById('convergenceTraceSelection').innerHTML = content;
            showModal('convergenceModal');
        }

        function updateConvergenceSelection() {
            const selected = Array.from(document.querySelectorAll('#convergenceTraceSelection input:checked'));
            if (selected.length < 2) return;
            
            const selectedEntries = selected.map(input => {
                const [hopNumber, entryId] = input.value.split('_');
                const hop = investigation.hops.find(h => h.id == hopNumber);
                return hop.entries.find(e => e.id == entryId);
            });
            
            const maxHop = Math.max(...selectedEntries.map(e => e.hopNumber));
            document.getElementById('convergenceHopLevel').value = maxHop + 1;
            
            // Group amounts by currency for convergence
            const amountsByCurrency = {};
            selectedEntries.forEach(entry => {
                const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                if (!amountsByCurrency[currency]) {
                    amountsByCurrency[currency] = 0;
                }
                amountsByCurrency[currency] += parseFloat(entry.amount) || 0;
            });

            // Display all currencies in convergence amount
            const amountDisplay = Object.entries(amountsByCurrency)
                .map(([currency, amount]) => `${amount} ${currency}`)
                .join(' | ');
            document.getElementById('convergenceAmount').value = amountDisplay;
            
            const victimSets = new Set();
            const transactionSets = new Set();
            selectedEntries.forEach(entry => {
                const parts = entry.notation.split('-');
                if (parts.length >= 2) {
                    victimSets.add(parts[0]);
                    transactionSets.add(parts[1]);
                }
            });
            
            const victims = Array.from(victimSets).join(',');
            const transactions = Array.from(transactionSets).join('(') + (transactionSets.size > 1 ? ')' : '');
            const suggestedNotation = `${victims}-${transactions}-H${maxHop + 1}`;
            document.getElementById('convergenceNotation').value = suggestedNotation;
        }

        function createConvergenceTrace() {
            const notation = document.getElementById('convergenceNotation').value;
            const hopLevel = document.getElementById('convergenceHopLevel').value;
            const amount = document.getElementById('convergenceAmount').value;
            
            if (!notation) {
                alert('Please enter the convergence notation.');
                return;
            }
            
            // Create new hop for convergence
            const hop = {
                id: investigation.hops.length + 1,
                hopNumber: parseInt(hopLevel),
                entries: [],
                artAtStartByCurrency: { 'USD': parseFloat(amount) },
                completed: false
            };
            
            // Add convergence entry
            const entry = {
                id: 1,
                hopNumber: hop.hopNumber,
                hopNumber: hop.hopNumber,
                entryType: 'trace',
                notation: notation,
                fromWallet: 'CONVERGENCE',
                fromWalletType: 'yellow',
                toWallet: '',
                toWalletType: 'yellow',
                amount: amount,
                currency: 'USD',
                customCurrency: '',
                txHash: '',
                timestamp: '',
                timezone: 'UTC',
                notes: 'Convergence of multiple traces',
                category: '',
                justification: ''
            };
            
            hop.entries.push(entry);
            
            // Sort entries chronologically
            sortHopEntriesChronologically(hop);
            
            investigation.hops.push(hop);
            
            closeConvergenceModal();
            renderHops();
            saveToStorage();
        }

        function closeConvergenceModal() {
            hideModal('convergenceModal');
        }

        function setupConversionModalListeners() {
            const fromCurrencySelect = document.getElementById('conversionFromCurrency');
            const toCurrencySelect = document.getElementById('conversionToCurrency');
            
            if (fromCurrencySelect) {
                fromCurrencySelect.addEventListener('change', function() {
                    const customGroup = document.getElementById('customFromCurrencyGroup');
                    if (this.value === 'CUSTOM') {
                        customGroup.style.display = 'block';
                    } else {
                        customGroup.style.display = 'none';
                    }
                });
            }
            
            if (toCurrencySelect) {
                toCurrencySelect.addEventListener('change', function() {
                    const customGroup = document.getElementById('customToCurrencyGroup');
                    if (this.value === 'CUSTOM') {
                        customGroup.style.display = 'block';
                    } else {
                        customGroup.style.display = 'none';
                    }
                });
            }
        }

        function removeHop(hopNumber) {
            if (confirm('Are you sure you want to remove this entire hop?')) {
                const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
                saveUndoState(`Remove Hop ${hop.hopNumber}`);
                
                investigation.hops = investigation.hops.filter(h => h.id !== hopNumber);
                renderHops();
                saveToStorage();
                updateValidationStatus();
                updateWorkflowSteps();
            }
        }

        function removeHopEntry(hopNumber, entryId) {
            const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
            const entry = hop.entries.find(e => e.id === entryId);

            saveUndoState(`Remove entry ${entry.notation || `Entry ${entry.id}`} from Hop ${hop.hopNumber}`);

            hop.entries = hop.entries.filter(e => e.id !== entryId);

            // Mark downstream hops for validation since an entry was removed
            markDownstreamHopsForValidation(hop.hopNumber);

            renderHops();
            saveToStorage();
            updateValidationStatus();
        }

        // Log bridge output from terminal wallet (can keep as CEX or convert to DeFi bridge)
        function logBridgeOutput(hopNumber, entryId) {
            const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
            const entry = hop.entries.find(e => e.id === entryId);

            if (!entry || (entry.toWalletType !== 'purple' && entry.toWalletType !== 'brown')) {
                showNotification('❌ Only terminal wallets (purple) or conversion wallets (brown) can log bridge outputs', 'error');
                return;
            }

            // Show bridge output logging modal
            const modal = document.createElement('div');
            modal.id = 'bridgeOutputModal';
            modal.className = 'modal show';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 700px; padding: 30px;">
                    <h2 style="margin-bottom: 20px;">🌉 Log Bridge/CEX Output Transaction</h2>

                    <!-- Transaction Details Section -->
                    <div style="background: #f0f7ff; border: 2px solid #2196f3; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
                        <h3 style="margin-top: 0; color: #0d47a1; font-size: 16px;">Source Transaction Details</h3>

                        <div style="margin-bottom: 15px;">
                            <label style="font-weight: bold; color: #555; display: block; margin-bottom: 5px;">Transaction Hash:</label>
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <input type="text"
                                       value="${entry.txHash || 'Not available'}"
                                       readonly
                                       style="flex: 1; padding: 8px; font-family: monospace; font-size: 12px; background: white; border: 1px solid #ddd; border-radius: 4px;">
                                <button onclick="navigator.clipboard.writeText('${entry.txHash || ''}'); this.textContent = '✓ Copied!'; setTimeout(() => this.textContent = '📋 Copy', 2000);"
                                        style="padding: 8px 12px; background: #2196f3; color: white; border: none; border-radius: 4px; cursor: pointer;">
                                    📋 Copy
                                </button>
                            </div>
                        </div>

                        <div style="margin-bottom: 15px;">
                            <label style="font-weight: bold; color: #555; display: block; margin-bottom: 5px;">Bridge Address (Receiving Wallet):</label>
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <input type="text"
                                       value="${entry.toWallet}"
                                       readonly
                                       style="flex: 1; padding: 8px; font-family: monospace; font-size: 12px; background: white; border: 1px solid #ddd; border-radius: 4px;">
                                <button onclick="navigator.clipboard.writeText('${entry.toWallet}'); this.textContent = '✓ Copied!'; setTimeout(() => this.textContent = '📋 Copy', 2000);"
                                        style="padding: 8px 12px; background: #2196f3; color: white; border: none; border-radius: 4px; cursor: pointer;">
                                    📋 Copy
                                </button>
                            </div>
                        </div>

                        <div style="margin-bottom: 15px;">
                            <label style="font-weight: bold; color: #555; display: block; margin-bottom: 5px;">Amount:</label>
                            <div style="padding: 8px; background: white; border: 1px solid #ddd; border-radius: 4px;">
                                ${entry.amount} ${entry.currency || 'Unknown'}
                            </div>
                        </div>

                        <div>
                            <label style="font-weight: bold; color: #555; display: block; margin-bottom: 5px;">Timestamp (UTC):</label>
                            <div style="padding: 8px; background: white; border: 1px solid #ddd; border-radius: 4px;">
                                ${entry.timestamp ? new Date(entry.timestamp).toLocaleString('en-US', {
                                    timeZone: 'UTC',
                                    year: 'numeric',
                                    month: '2-digit',
                                    day: '2-digit',
                                    hour: '2-digit',
                                    minute: '2-digit',
                                    second: '2-digit',
                                    hour12: false
                                }) + ' UTC' : 'Not available'}
                            </div>
                        </div>
                    </div>

                    <p style="margin: 20px 0; color: #666; background: #fff9e6; padding: 15px; border-radius: 6px; border: 1px solid #ffd666;">
                        <strong>💡 Tip:</strong> Use the transaction hash and address above to search in bridge explorers, CEX records, or the destination chain explorer to find the output transaction.
                    </p>

                    ${entry.toWalletType === 'purple' || entry.toWalletType === 'PURPLE' ? `
                    <div style="background: #fff8f4; padding: 20px; border-radius: 8px; margin-bottom: 20px; border: 2px solid #8b4513;">
                        <h3 style="margin-top: 0; font-size: 16px; color: #8b4513;">🌉 Wallet Classification Update</h3>
                        <p style="margin: 10px 0; color: #6b3410;">
                            <strong>This terminal wallet will be automatically converted to a DeFi Bridge (Brown)</strong>
                        </p>
                        <p style="margin: 0; color: #666; font-size: 14px;">
                            Logging a bridge output indicates this wallet is a bridge/conversion service, not a terminal wallet.
                            The wallet color will change from purple to brown to reflect its true nature as a bridge.
                        </p>
                    </div>
                    ` : entry.toWalletType === 'brown' ? `
                    <div style="background: #e8f5e9; padding: 20px; border-radius: 8px; margin-bottom: 20px; border: 2px solid #4caf50;">
                        <h3 style="margin-top: 0; font-size: 16px; color: #2e7d32;">✅ Conversion Wallet</h3>
                        <p style="margin: 10px 0; color: #2e7d32;">
                            <strong>This wallet is already classified as a bridge/conversion service</strong>
                        </p>
                        <p style="margin: 0; color: #666; font-size: 14px;">
                            The bridge output will be logged and tracked through the conversion process.
                        </p>
                    </div>
                    ` : ''}

                    <div style="border-top: 2px solid #e0e0e0; padding-top: 20px; margin-top: 20px;">
                        <h3 style="font-size: 16px; margin-bottom: 15px; color: #2c3e50;">Destination Transaction Details</h3>

                        <div style="margin-bottom: 20px;">
                            <label style="font-weight: bold; display: block; margin-bottom: 10px; color: #2c3e50;">
                                Select Destination Chain:
                            </label>
                            <select id="bridgeDestChain" onchange="window.bridgeDestChain = this.value"
                                    style="width: 100%; padding: 12px; font-size: 14px; border: 2px solid #ddd; border-radius: 4px;">
                                <option value="">Select blockchain...</option>
                                ${Object.entries(window.blockchainAPIs || {}).map(([key, chain]) =>
                                    `<option value="${key}">${chain.name}</option>`
                                ).join('')}
                            </select>
                        </div>

                        <div style="margin-bottom: 20px;">
                            <label style="font-weight: bold; display: block; margin-bottom: 10px; color: #2c3e50;">
                                Destination Transaction Hash:
                            </label>
                            <div style="display: flex; gap: 10px;">
                                <input type="text"
                                       id="bridgeDestTxHash"
                                       placeholder="Paste the transaction hash from the destination chain"
                                       style="flex: 1; padding: 12px; font-size: 14px; border: 2px solid #ddd; border-radius: 4px;">
                                <button class="btn btn-primary" onclick="lookupBridgeDestTransaction()"
                                        style="padding: 12px 20px; font-size: 14px;">
                                    🔍 Auto-fill
                                </button>
                            </div>
                            <small style="color: #666; display: block; margin-top: 5px;">
                                Enter the hash and click Auto-fill to populate the fields below
                            </small>
                        </div>

                        <!-- Lookup result area -->
                        <div id="bridgeLookupResult" style="display: none; margin-bottom: 20px;">
                            <div style="background: #e8f5e9; border: 1px solid #4caf50; border-radius: 6px; padding: 10px; color: #2e7d32;">
                                ✅ Transaction found! Fields have been auto-filled.
                            </div>
                        </div>

                        <div style="background: #f5f5f5; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                            <div style="margin-bottom: 15px;">
                                <label style="font-weight: bold; display: block; margin-bottom: 8px; color: #555;">
                                    Receiving Wallet Address:
                                </label>
                                <input type="text"
                                       id="bridgeDestWallet"
                                       placeholder="Enter or auto-fill the receiving wallet address"
                                       style="width: 100%; padding: 10px; font-family: monospace; font-size: 13px; border: 1px solid #ddd; border-radius: 4px;">
                            </div>

                            <div style="display: flex; gap: 15px;">
                                <div style="flex: 2;">
                                    <label style="font-weight: bold; display: block; margin-bottom: 8px; color: #555;">
                                        Amount Received:
                                    </label>
                                    <input type="number"
                                           id="bridgeDestAmount"
                                           placeholder="0.00"
                                           step="0.000001"
                                           style="width: 100%; padding: 10px; font-size: 14px; border: 1px solid #ddd; border-radius: 4px;">
                                </div>

                                <div style="flex: 1;">
                                    <label style="font-weight: bold; display: block; margin-bottom: 8px; color: #555;">
                                        Asset/Currency:
                                    </label>
                                    <input type="text"
                                           id="bridgeDestAsset"
                                           placeholder="e.g., ETH, USDT"
                                           value="${entry.currency || ''}"
                                           style="width: 100%; padding: 10px; font-size: 14px; border: 1px solid #ddd; border-radius: 4px;">
                                </div>
                            </div>

                            <small style="color: #666; display: block; margin-top: 10px;">
                                These fields will be auto-filled when you lookup the transaction, or you can enter them manually
                            </small>
                        </div>

                        <!-- Proportional Attribution Calculator -->
                        <div id="proportionalAttributionSection" style="display: none; background: #f3e5f5; border: 2px solid #9c27b0; border-radius: 8px; padding: 15px; margin: 20px 0;">
                            <h4 style="margin: 0 0 10px 0; color: #6a1b9a; font-size: 16px;">
                                🧮 Proportional Attribution Calculator
                            </h4>
                            <div style="background: white; padding: 10px; border-radius: 4px; margin-bottom: 10px;">
                                <p style="margin: 0 0 10px 0; color: #555;">
                                    <strong>Commingling detected!</strong> Your traced funds were mixed with other funds before conversion.
                                </p>
                                <div id="comminglingDetails" style="font-size: 14px; color: #666;">
                                    <!-- Will be populated dynamically -->
                                </div>
                            </div>

                            <div style="background: #fff9c4; border: 1px solid #f9a825; border-radius: 4px; padding: 10px; margin: 10px 0;">
                                <strong>Suggested Attribution:</strong>
                                <div style="display: flex; gap: 10px; align-items: center; margin-top: 10px;">
                                    <input type="number"
                                           id="attributedAmount"
                                           step="0.000001"
                                           style="flex: 1; padding: 10px; font-size: 16px; font-weight: bold; border: 2px solid #9c27b0; border-radius: 4px;">
                                    <span id="attributedCurrency" style="font-weight: bold; font-size: 16px;"></span>
                                    <button onclick="useFullAmount()" class="btn btn-secondary" style="padding: 8px 12px;">
                                        Use Full Amount
                                    </button>
                                </div>
                                <small style="color: #666; display: block; margin-top: 5px;">
                                    You can accept this calculated amount or adjust it based on your investigation
                                </small>
                            </div>

                            <div id="calculationBreakdown" style="background: #f5f5f5; padding: 10px; border-radius: 4px; font-size: 13px; color: #555;">
                                <!-- Calculation details will go here -->
                            </div>
                        </div>

                        <div style="display: flex; justify-content: center; gap: 10px;">
                            <button class="btn btn-primary" onclick="confirmBridgeOutput(${hopNumber}, ${entryId})"
                                    style="padding: 12px 24px; font-size: 16px;">
                                🌉 Log Output Transaction
                            </button>
                            <button class="btn btn-secondary" onclick="document.getElementById('bridgeOutputModal').remove()"
                                    style="padding: 12px 24px; font-size: 16px;">
                                Cancel
                            </button>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);

            // Auto-fill fields if bridge data was provided
            if (window.pendingBridgeAutoFill) {
                const autoFill = window.pendingBridgeAutoFill;

                // Pre-fill destination chain dropdown
                const chainSelect = document.getElementById('bridgeDestChain');
                if (chainSelect && autoFill.destinationChain) {
                    chainSelect.value = autoFill.destinationChain;
                    window.bridgeDestChain = autoFill.destinationChain;
                }

                // Pre-fill destination transaction hash
                const txHashInput = document.getElementById('bridgeDestTxHash');
                if (txHashInput && autoFill.destinationTxHash) {
                    txHashInput.value = autoFill.destinationTxHash;
                }

                // Pre-fill destination wallet (will be populated by lookupBridgeDestTransaction)
                const walletInput = document.getElementById('bridgeDestWallet');
                if (walletInput && autoFill.destinationWallet) {
                    walletInput.value = autoFill.destinationWallet;
                }

                // Pre-fill destination amount
                const amountInput = document.getElementById('bridgeDestAmount');
                if (amountInput && autoFill.destinationAmount) {
                    amountInput.value = autoFill.destinationAmount;
                }

                // Pre-fill destination asset
                const assetInput = document.getElementById('bridgeDestAsset');
                if (assetInput && autoFill.destinationAsset) {
                    assetInput.value = autoFill.destinationAsset;
                }

                // Show risk warning banner if flagged
                if (autoFill.hasRiskFlag) {
                    const riskBanner = document.createElement('div');
                    riskBanner.style.cssText = 'background: #fff3cd; border: 2px solid #dc3545; border-radius: 8px; padding: 15px; margin: 20px 0;';
                    riskBanner.innerHTML = `
                        <h4 style="margin: 0 0 10px 0; color: #dc3545; font-size: 16px;">
                            ⚠️ RISK FLAG DETECTED
                        </h4>
                        <p style="margin: 0; color: #856404; font-size: 14px;">
                            <strong>Warning:</strong> ${autoFill.refundReason || 'This transaction has been flagged by the bridge provider.'}
                        </p>
                    `;

                    // Insert before the destination details section
                    const detailsSection = modal.querySelector('[style*="border-top: 2px solid"]');
                    if (detailsSection) {
                        detailsSection.insertBefore(riskBanner, detailsSection.firstChild);
                    }
                }

                // Show auto-fill success message
                const lookupResult = document.getElementById('bridgeLookupResult');
                if (lookupResult) {
                    lookupResult.style.display = 'block';
                    lookupResult.innerHTML = `
                        <div style="background: #e8f5e9; border: 1px solid #4caf50; border-radius: 6px; padding: 10px; color: #2e7d32;">
                            ✅ Bridge transaction data auto-loaded from ${entry.bridgeProvider?.name || 'bridge API'}!
                        </div>
                    `;
                }

                // Clear the temporary data
                delete window.pendingBridgeAutoFill;

                console.log('✅ Bridge output dialog pre-filled with API data');
            }

            // Check for commingling and calculate proportional attribution
            checkComminglingAndCalculateAttribution(hopNumber, entryId);
        }

        function checkComminglingAndCalculateAttribution(hopNumber, entryId) {
            const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
            const entry = hop.entries.find(e => e.id === entryId);

            if (!entry) return;

            // Check if this wallet received funds from multiple sources (commingling)
            const walletAddress = entry.toWallet;
            let totalIncoming = 0;
            let ourTracedFunds = parseFloat(entry.amount);
            let otherFundsInWallet = 0;
            let otherSources = [];

            // Look for other transactions to this same wallet in current or previous hops
            // This finds all our traced funds that went to this wallet
            investigation.hops.forEach(h => {
                if (h.hopNumber <= hopNumber) {
                    h.entries.forEach(e => {
                        if (e.entryType === 'trace' && e.toWallet === walletAddress) {
                            totalIncoming += parseFloat(e.amount);
                            if (e.id !== entry.id) {
                                otherSources.push({
                                    amount: parseFloat(e.amount),
                                    currency: e.currency,
                                    from: e.fromWallet,
                                    notation: e.notation
                                });
                            }
                        }
                    });
                }
            });

            // Check if the outgoing swap amount is larger than our total traced funds to this wallet
            // This would indicate the wallet had pre-existing funds (true commingling)
            const swapAmount = parseFloat(document.getElementById('bridgeSourceAmount')?.value || '0');

            // Only show calculator if the swap amount exceeds our traced funds
            // This means the wallet had other funds that are being commingled
            if (swapAmount > totalIncoming && totalIncoming > 0) {
                // Calculate how much of the wallet's funds are NOT from our trace
                otherFundsInWallet = swapAmount - totalIncoming;

                // Update ourAmount to reflect all our traced funds, not just this entry
                const ourAmount = totalIncoming;
                const section = document.getElementById('proportionalAttributionSection');
                if (section) {
                    section.style.display = 'block';

                    // Calculate our percentage of the swap amount
                    const ourPercentage = (ourAmount / swapAmount) * 100;

                    // Update commingling details
                    document.getElementById('comminglingDetails').innerHTML = `
                        <div style="margin-bottom: 8px;">
                            <strong>Your traced funds in wallet:</strong> ${ourAmount.toFixed(6)} ${entry.currency} (${ourPercentage.toFixed(2)}%)
                        </div>
                        <div style="margin-bottom: 8px;">
                            <strong>Pre-existing funds in wallet:</strong> ${otherFundsInWallet.toFixed(6)} ${entry.currency} (${(100 - ourPercentage).toFixed(2)}%)
                        </div>
                        <div>
                            <strong>Total swap amount:</strong> ${swapAmount.toFixed(6)} ${entry.currency}
                        </div>
                    `;

                    // Set up calculation when amount changes
                    const amountInput = document.getElementById('bridgeDestAmount');
                    const assetInput = document.getElementById('bridgeDestAsset');
                    const attributedInput = document.getElementById('attributedAmount');
                    const attributedCurrency = document.getElementById('attributedCurrency');

                    const calculateAttribution = () => {
                        const fullAmount = parseFloat(amountInput.value) || 0;
                        // Use roundAmount to avoid floating point precision issues
                        const attributed = roundAmount(fullAmount * ourPercentage / 100);
                        attributedInput.value = attributed;
                        attributedCurrency.textContent = assetInput.value || 'ASSET';

                        // Update calculation breakdown
                        document.getElementById('calculationBreakdown').innerHTML = `
                            <strong>Calculation:</strong><br>
                            Total Output: ${fullAmount} ${assetInput.value || 'ASSET'}<br>
                            Your Ownership: ${ourPercentage.toFixed(2)}%<br>
                            Formula: ${fullAmount} × ${ourPercentage.toFixed(2)}% = ${attributed} ${assetInput.value || 'ASSET'}<br>
                            <br>
                            <small style="color: #666;">This calculation assumes proportional distribution through the conversion.</small>
                        `;
                    };

                    amountInput.addEventListener('input', calculateAttribution);
                    assetInput.addEventListener('input', calculateAttribution);

                    // Store the attribution data for later use
                    window.comminglingData = {
                        ourAmount: ourAmount,
                        swapAmount: swapAmount,
                        otherFundsInWallet: otherFundsInWallet,
                        ourPercentage: ourPercentage,
                        otherSources: otherSources
                    };
                }
            }
        }

        // Helper function to use full amount instead of attributed
        window.useFullAmount = function() {
            const fullAmount = document.getElementById('bridgeDestAmount').value;
            document.getElementById('attributedAmount').value = fullAmount;
        }

        function showBridgeTransferSelectionModal(transfers) {
            // Store transfers globally
            window.allBridgeTransfers = transfers;
            window.filteredBridgeTransfers = transfers;

            // Get unique assets for filter
            const uniqueAssets = [...new Set(transfers.map(t => t.currency))].sort();

            // Create modal HTML (similar to victim transaction selector)
            const modalHTML = `
                <div id="bridgeTransferModal" class="modal show">
                    <div class="modal-content" style="max-width: 900px;">
                        <div class="modal-header">
                            <h2>Select Bridge Output Transfer</h2>
                            <button class="close" onclick="document.getElementById('bridgeTransferModal').remove()">&times;</button>
                        </div>

                        <p style="margin: 15px 0;">This transaction contains ${transfers.length} transfers. Please select the bridge output:</p>

                        <!-- Filter Section -->
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 15px 0;">
                            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr auto; gap: 10px; align-items: end;">
                                <div>
                                    <label style="display: block; margin-bottom: 5px; font-weight: 500;">Filter by Asset:</label>
                                    <select id="bridgeTransferAssetFilter"
                                           style="width: 100%; padding: 8px; border: 2px solid #e8f0fe; border-radius: 6px;"
                                           onchange="filterBridgeTransfersModal()">
                                        <option value="">All Assets (${uniqueAssets.length})</option>
                                        ${uniqueAssets.map(asset => {
                                            const count = transfers.filter(t => t.currency === asset).length;
                                            return `<option value="${asset}">${asset} (${count})</option>`;
                                        }).join('')}
                                    </select>
                                </div>
                                <div>
                                    <label style="display: block; margin-bottom: 5px; font-weight: 500;">Min Amount:</label>
                                    <input type="number" id="bridgeTransferAmountFilter" placeholder="e.g., 0.01" step="0.000001"
                                           style="width: 100%; padding: 8px; border: 2px solid #e8f0fe; border-radius: 6px;"
                                           oninput="filterBridgeTransfersModal()">
                                </div>
                                <div>
                                    <label style="display: block; margin-bottom: 5px; font-weight: 500;">Filter by Address:</label>
                                    <input type="text" id="bridgeTransferAddressFilter" placeholder="To or From address"
                                           style="width: 100%; padding: 8px; border: 2px solid #e8f0fe; border-radius: 6px;"
                                           oninput="filterBridgeTransfersModal()">
                                </div>
                                <button class="btn btn-secondary" onclick="clearBridgeTransferFilters()" style="padding: 8px 15px;">
                                    Clear Filters
                                </button>
                            </div>

                            <div style="margin-top: 10px; font-size: 14px; color: #666;">
                                <span id="bridgeTransferFilterInfo">Showing ${transfers.length} of ${transfers.length} transfers</span>
                            </div>
                        </div>

                        <!-- Transfers List -->
                        <div id="bridgeTransfersList" style="max-height: 400px; overflow-y: auto;">
                            ${renderBridgeTransferModalCards(transfers)}
                        </div>

                        <div style="text-align: center; margin-top: 20px;">
                            <button class="btn btn-secondary" onclick="document.getElementById('bridgeTransferModal').remove()">
                                Cancel
                            </button>
                        </div>
                    </div>
                </div>
            `;

            // Add modal to body
            document.body.insertAdjacentHTML('beforeend', modalHTML);
        }

        function renderBridgeTransferModalCards(transfers) {
            if (transfers.length === 0) {
                return '<div style="text-align: center; padding: 40px; color: #666;">No transfers match your filters</div>';
            }

            return transfers.map((transfer, filteredIndex) => {
                // Find original index
                const originalIndex = window.allBridgeTransfers.indexOf(transfer);

                return `
                    <div class="transfer-card" style="background: white; border: 2px solid #e8f0fe; border-radius: 8px; padding: 15px; margin-bottom: 10px; cursor: pointer; transition: all 0.2s;"
                         onmouseover="this.style.borderColor='#3498db'; this.style.transform='translateY(-2px)'"
                         onmouseout="this.style.borderColor='#e8f0fe'; this.style.transform='translateY(0)'"
                         onclick="selectBridgeTransferFromModal(${originalIndex})">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                            <div>
                                <div style="font-size: 12px; color: #666; margin-bottom: 4px;">From:</div>
                                <div style="font-family: monospace; font-size: 13px; word-break: break-all;">
                                    ${transfer.from || 'Unknown'}
                                </div>
                            </div>
                            <div>
                                <div style="font-size: 12px; color: #666; margin-bottom: 4px;">To:</div>
                                <div style="font-family: monospace; font-size: 13px; word-break: break-all;">
                                    ${transfer.to || 'Unknown'}
                                </div>
                            </div>
                        </div>
                        <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #f0f0f0;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <span style="font-size: 20px; font-weight: bold; color: #2c3e50;">
                                        ${transfer.amount} ${transfer.currency}
                                    </span>
                                    ${transfer.type ? `<span style="margin-left: 10px; font-size: 12px; color: #666;">(${transfer.type})</span>` : ''}
                                </div>
                                <button class="btn btn-primary" onclick="event.stopPropagation(); selectBridgeTransferFromModal(${originalIndex})">
                                    Select This Transfer
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function filterBridgeTransfersModal() {
            const assetFilter = document.getElementById('bridgeTransferAssetFilter')?.value || '';
            const amountFilter = parseFloat(document.getElementById('bridgeTransferAmountFilter')?.value) || 0;
            const addressFilter = document.getElementById('bridgeTransferAddressFilter')?.value?.toLowerCase() || '';

            let filtered = window.allBridgeTransfers;

            // Filter by asset
            if (assetFilter) {
                filtered = filtered.filter(t => t.currency === assetFilter);
            }

            // Filter by minimum amount
            if (amountFilter > 0) {
                filtered = filtered.filter(t => parseFloat(t.amount) >= amountFilter);
            }

            // Filter by address (to or from)
            if (addressFilter) {
                filtered = filtered.filter(t =>
                    (t.to && t.to.toLowerCase().includes(addressFilter)) ||
                    (t.from && t.from.toLowerCase().includes(addressFilter))
                );
            }

            window.filteredBridgeTransfers = filtered;

            // Update display
            const listContainer = document.getElementById('bridgeTransfersList');
            if (listContainer) {
                listContainer.innerHTML = renderBridgeTransferModalCards(filtered);
            }

            // Update filter info
            const filterInfo = document.getElementById('bridgeTransferFilterInfo');
            if (filterInfo) {
                filterInfo.textContent = `Showing ${filtered.length} of ${window.allBridgeTransfers.length} transfers`;
            }
        }

        function clearBridgeTransferFilters() {
            document.getElementById('bridgeTransferAssetFilter').value = '';
            document.getElementById('bridgeTransferAmountFilter').value = '';
            document.getElementById('bridgeTransferAddressFilter').value = '';
            filterBridgeTransfersModal();
        }

        function selectBridgeTransferFromModal(index) {
            const transfers = window.allBridgeTransfers;
            if (!transfers || !transfers[index]) return;

            const transfer = transfers[index];

            // Auto-fill the fields with selected transfer
            document.getElementById('bridgeDestWallet').value = transfer.to || '';
            document.getElementById('bridgeDestAmount').value = transfer.amount || '';
            document.getElementById('bridgeDestAsset').value = transfer.currency || '';

            // Update result message
            const resultDiv = document.getElementById('bridgeLookupResult');
            if (resultDiv) {
                resultDiv.innerHTML = `
                    <div style="background: #e8f5e9; border: 1px solid #4caf50; border-radius: 6px; padding: 10px; color: #2e7d32;">
                        ✅ Transfer selected: ${transfer.amount} ${transfer.currency} to ${transfer.to ? transfer.to.substring(0, 30) + '...' : 'Unknown'}
                    </div>
                `;
            }

            // Close the modal
            const modal = document.getElementById('bridgeTransferModal');
            if (modal) {
                modal.remove();
            }
        }

        // Keep the old function for backward compatibility but have it call the modal version
        function showBridgeTransferSelection(transfers) {
            const container = document.getElementById('bridgeLookupResult');
            if (!container) return;

            // Store all transfers for filtering
            window.allBridgeTransfers = transfers;
            window.filteredBridgeTransfers = transfers;

            // Get unique assets for filter
            const uniqueAssets = [...new Set(transfers.map(t => t.currency))].sort();

            let selectionHTML = `
                <div style="background: #fff3cd; border: 1px solid #ffc107; border-radius: 6px; padding: 15px; margin-bottom: 15px;">
                    <h4 style="margin: 0 0 15px 0; color: #856404;">Select the Bridge Output Transfer:</h4>

                    <!-- Filters Section -->
                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 6px; padding: 12px; margin-bottom: 15px;">
                        <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                            <div style="flex: 1;">
                                <label style="font-size: 12px; font-weight: bold; color: #495057; display: block; margin-bottom: 4px;">Asset Type:</label>
                                <select id="bridgeAssetFilter" onchange="filterBridgeTransfers()"
                                        style="width: 100%; padding: 6px; border: 1px solid #ced4da; border-radius: 4px;">
                                    <option value="">All Assets (${uniqueAssets.length})</option>
                                    ${uniqueAssets.map(asset => {
                                        const count = transfers.filter(t => t.currency === asset).length;
                                        return `<option value="${asset}">${asset} (${count})</option>`;
                                    }).join('')}
                                </select>
                            </div>
                            <div style="flex: 1;">
                                <label style="font-size: 12px; font-weight: bold; color: #495057; display: block; margin-bottom: 4px;">Min Amount:</label>
                                <input type="number" id="bridgeAmountFilter" placeholder="e.g., 0.01" step="0.000001"
                                       onkeyup="filterBridgeTransfers()"
                                       style="width: 100%; padding: 6px; border: 1px solid #ced4da; border-radius: 4px;">
                            </div>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span id="bridgeFilterInfo" style="font-size: 12px; color: #6c757d;">
                                Showing ${transfers.length} of ${transfers.length} transfers
                            </span>
                            <button class="btn btn-sm" onclick="clearBridgeFilters()"
                                    style="font-size: 12px; padding: 4px 8px; background: #6c757d; color: white; border: none; border-radius: 4px;">
                                Clear Filters
                            </button>
                        </div>
                    </div>

                    <!-- Transfers List -->
                    <div id="bridgeTransfersList" style="max-height: 300px; overflow-y: auto;">
                        ${renderBridgeTransferCards(transfers)}
                    </div>
                </div>
            `;

            container.innerHTML = selectionHTML;
            container.style.display = 'block';
        }

        function renderBridgeTransferCards(transfers) {
            if (transfers.length === 0) {
                return '<div style="text-align: center; padding: 20px; color: #666;">No transfers match your filters</div>';
            }

            return transfers.map((transfer, filteredIndex) => {
                // Find original index
                const originalIndex = window.allBridgeTransfers.indexOf(transfer);

                return `
                    <div style="background: white; border: 1px solid #ddd; border-radius: 4px; padding: 10px; margin-bottom: 8px; cursor: pointer;"
                         onclick="selectBridgeTransfer(${originalIndex})"
                         onmouseover="this.style.backgroundColor='#e3f2fd'"
                         onmouseout="this.style.backgroundColor='white'">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <strong>${transfer.amount} ${transfer.currency}</strong><br>
                                <small style="color: #666;">
                                    To: ${transfer.to ? transfer.to.substring(0, 20) + '...' : 'Unknown'}<br>
                                    ${transfer.type ? `Type: ${transfer.type}` : ''}
                                    ${transfer.from ? `From: ${transfer.from.substring(0, 20)}...` : ''}
                                </small>
                            </div>
                            <button class="btn btn-sm btn-primary" onclick="selectBridgeTransfer(${originalIndex}); event.stopPropagation();">
                                Select
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function filterBridgeTransfers() {
            const assetFilter = document.getElementById('bridgeAssetFilter').value;
            const amountFilter = parseFloat(document.getElementById('bridgeAmountFilter').value) || 0;

            let filtered = window.allBridgeTransfers;

            // Filter by asset
            if (assetFilter) {
                filtered = filtered.filter(t => t.currency === assetFilter);
            }

            // Filter by minimum amount
            if (amountFilter > 0) {
                filtered = filtered.filter(t => parseFloat(t.amount) >= amountFilter);
            }

            window.filteredBridgeTransfers = filtered;

            // Update display
            const listContainer = document.getElementById('bridgeTransfersList');
            listContainer.innerHTML = renderBridgeTransferCards(filtered);

            // Update filter info
            document.getElementById('bridgeFilterInfo').textContent =
                `Showing ${filtered.length} of ${window.allBridgeTransfers.length} transfers`;
        }

        function clearBridgeFilters() {
            document.getElementById('bridgeAssetFilter').value = '';
            document.getElementById('bridgeAmountFilter').value = '';
            filterBridgeTransfers();
        }

        function selectBridgeTransfer(index) {
            const transfers = window.bridgeDestTransfers;
            if (!transfers || !transfers[index]) return;

            const transfer = transfers[index];

            // Auto-fill the fields with selected transfer
            document.getElementById('bridgeDestWallet').value = transfer.to || '';
            document.getElementById('bridgeDestAmount').value = transfer.amount || '';
            document.getElementById('bridgeDestAsset').value = transfer.currency || '';

            // Update result message
            const container = document.getElementById('bridgeLookupResult');
            container.innerHTML = `
                <div style="background: #e8f5e9; border: 1px solid #4caf50; border-radius: 6px; padding: 10px; color: #2e7d32;">
                    ✅ Transfer selected! Fields have been auto-filled with: ${transfer.amount} ${transfer.currency} to ${transfer.to ? transfer.to.substring(0, 20) + '...' : 'Unknown'}
                </div>
            `;
        }

        async function checkArkhamSwapData(txHash, txData, chain) {
            try {
                const arkhamApiKey = window.apiKeys?.arkham || 'd377a526-c9ea-4cb6-a647-775559583ff6';
                if (!arkhamApiKey) return;

                console.log('Checking Arkham for swap data on transaction:', txHash);

                // Map our chain names to Arkham's chain names
                const chainMap = {
                    'ethereum': 'ethereum',
                    'bsc': 'bsc',
                    'polygon': 'polygon',
                    'arbitrum': 'arbitrum_one',
                    'avalanche': 'avalanche',
                    'optimism': 'optimism'
                };

                const arkhamChain = chainMap[chain] || chain;

                // Query the swaps endpoint for this transaction
                // We'll search for swaps involving the from address in the last hour (transaction should be recent)
                const fromAddr = txData.from || '';
                const toAddr = txData.to || '';

                // Try to get swap data using the Arkham swaps endpoint
                // Build URL with proper query string encoding
                const swapParams = new URLSearchParams({
                    endpoint: '/swaps',
                    base: fromAddr,
                    chains: arkhamChain,
                    timeLast: '1h',
                    limit: '50'
                });
                const swapsUrl = `/.netlify/functions/arkham3?${swapParams.toString()}`;

                console.log('Fetching from Arkham swaps endpoint:', swapsUrl);
                console.log('Looking for swaps from address:', fromAddr, 'on chain:', arkhamChain);

                const response = await fetch(swapsUrl, {
                    headers: {
                        'X-Arkham-API-Key': arkhamApiKey
                    }
                });

                console.log('Arkham swaps API response status:', response.status);

                if (response.ok) {
                    const swapData = await response.json();
                    console.log('Arkham swap data received:', swapData);
                    console.log('Number of swaps found:', swapData.swaps ? swapData.swaps.length : 0);

                    if (swapData.swaps && swapData.swaps.length > 0) {
                        // Find the swap matching our transaction
                        // First try to match by transaction hash
                        let matchingSwap = swapData.swaps.find(swap => {
                            // Match by transaction hash if available in the ID
                            return swap.id && swap.id.toLowerCase().includes(txHash.toLowerCase());
                        });

                        // If no exact match, try to find a swap to the same contract address around the same time
                        if (!matchingSwap && swapData.swaps.length === 1) {
                            // If there's only one swap in the recent timeframe, it's likely our swap
                            matchingSwap = swapData.swaps[0];
                            console.log('Using only available swap from recent timeframe');
                        } else if (!matchingSwap) {
                            // Try to match by contract address
                            matchingSwap = swapData.swaps.find(swap => {
                                return swap.contractAddress?.address?.toLowerCase() === toAddr.toLowerCase();
                            });
                            if (matchingSwap) {
                                console.log('Matched swap by contract address');
                            }
                        }

                        if (matchingSwap) {
                            console.log('Found matching swap:', matchingSwap);

                            // Enrich txData with swap information
                            txData.swapData = {
                                protocol: matchingSwap.contractEntityId || 'Unknown DEX',
                                sender: matchingSwap.sender?.address,
                                receiver: matchingSwap.receiver?.address,
                                contractAddress: matchingSwap.contractAddress?.address,
                                token0: matchingSwap.token0Name || matchingSwap.token0Symbol,
                                token1: matchingSwap.token1Name || matchingSwap.token1Symbol,
                                amount0: Math.abs(matchingSwap.unitValue0 || 0),
                                amount1: Math.abs(matchingSwap.unitValue1 || 0),
                                usdValue: matchingSwap.historicalUSD || 0,
                                isSwap: true
                            };

                            // Update the result div to show swap detection
                            const resultDiv = document.getElementById('bridgeLookupResult');
                            if (resultDiv) {
                                const swapInfo = `
                                    <div style="background: #e3f2fd; border: 1px solid #2196f3; border-radius: 6px; padding: 10px; margin-top: 10px;">
                                        🔄 <strong>DEX Swap Detected!</strong><br>
                                        Protocol: ${txData.swapData.protocol}<br>
                                        Swapped: ${txData.swapData.amount0.toFixed(4)} ${txData.swapData.token0} → ${txData.swapData.amount1.toFixed(4)} ${txData.swapData.token1}<br>
                                        USD Value: $${txData.swapData.usdValue.toLocaleString()}
                                    </div>
                                `;

                                // Add to existing content
                                const existingContent = resultDiv.innerHTML;
                                resultDiv.innerHTML = existingContent + swapInfo;
                            }

                            // Auto-fill with the output token data if fields are still empty
                            if (!document.getElementById('bridgeDestAmount').value && txData.swapData.amount1) {
                                document.getElementById('bridgeDestAmount').value = txData.swapData.amount1;
                            }
                            if (!document.getElementById('bridgeDestAsset').value && txData.swapData.token1) {
                                document.getElementById('bridgeDestAsset').value = txData.swapData.token1;
                            }
                        } else {
                            console.log('No matching swap found in Arkham data');
                        }
                    } else {
                        console.log('No swap data returned from Arkham');
                    }
                } else {
                    console.log('Arkham swaps API returned non-OK status:', response.status);
                    try {
                        const errorData = await response.text();
                        console.log('Error response:', errorData);
                    } catch (e) {
                        console.log('Could not read error response');
                    }
                }
            } catch (error) {
                console.log('Could not fetch Arkham swap data:', error);
                // This is optional enrichment, so we don't show an error to the user
            }
        }

        async function lookupBridgeDestTransaction() {
            const txHash = document.getElementById('bridgeDestTxHash').value.trim();
            const destChain = document.getElementById('bridgeDestChain').value;

            if (!txHash) {
                showNotification('❌ Please enter a transaction hash', 'error');
                return;
            }

            if (!destChain) {
                showNotification('❌ Please select the destination blockchain first', 'error');
                return;
            }

            // Show loading state
            const resultDiv = document.getElementById('bridgeLookupResult');
            resultDiv.style.display = 'block';
            resultDiv.innerHTML = `
                <div style="background: #fff3cd; border: 1px solid #ffc107; border-radius: 6px; padding: 10px; color: #856404;">
                    🔍 Looking up transaction...
                </div>
            `;

            try {
                // Use existing transaction lookup logic
                let txData;
                const evmChains = ['ethereum', 'base', 'arbitrum', 'optimism', 'polygon', 'bsc',
                                  'avalanche', 'hyperevm', 'linea', 'scroll', 'mantle', 'blast',
                                  'zksync', 'gnosis', 'celo', 'moonbeam', 'moonriver', 'fraxtal',
                                  'taiko', 'arbitrumnova', 'bittorrent', 'opbnb'];

                if (evmChains.includes(destChain)) {
                    // Temporarily set chain selector for lookup
                    const originalChain = document.getElementById('chainSelector')?.value;
                    if (document.getElementById('chainSelector')) {
                        document.getElementById('chainSelector').value = destChain;
                    }

                    txData = await lookupEthereumTransaction(txHash, destChain);

                    // Restore original chain
                    if (document.getElementById('chainSelector') && originalChain) {
                        document.getElementById('chainSelector').value = originalChain;
                    }
                } else if (destChain === 'bitcoin') {
                    txData = await lookupBitcoinTransaction(txHash);
                } else if (destChain === 'tron') {
                    txData = await lookupTronTransaction(txHash);
                } else if (destChain === 'solana') {
                    txData = await lookupSolanaTransaction(txHash);
                } else if (destChain === 'ripple' || destChain === 'xrp') {
                    txData = await lookupRippleTransaction(txHash);
                } else {
                    throw new Error(`Unsupported blockchain: ${destChain}`);
                }

                if (txData) {
                    console.log('Bridge destination txData:', txData);

                    // Try to get swap data from Arkham if available
                    if (txData && (destChain === 'ethereum' || destChain === 'bsc' || destChain === 'polygon' ||
                                   destChain === 'arbitrum' || destChain === 'avalanche' || destChain === 'optimism')) {
                        await checkArkhamSwapData(txHash, txData, destChain);
                    }

                    // Check if we have multiple transfers (Solana often has these)
                    if (txData.multipleTransfers && txData.transfers && txData.transfers.length > 0) {
                        console.log('Multiple transfers detected:', txData.transfers);

                        // Store transfers for selection
                        window.bridgeDestTransfers = txData.transfers;

                        // Show message about multiple transfers
                        resultDiv.innerHTML = `
                            <div style="background: #fff3cd; border: 1px solid #ffc107; border-radius: 6px; padding: 10px; color: #856404;">
                                ⚠️ ${txData.transfers.length} transfers detected. Opening selection window...
                            </div>
                        `;

                        // Show transfer selection modal (like victim transaction selector)
                        showBridgeTransferSelectionModal(txData.transfers);
                    } else {
                        // Auto-fill the fields
                        document.getElementById('bridgeDestWallet').value = txData.to || '';
                        document.getElementById('bridgeDestAmount').value = txData.amount || '';
                        document.getElementById('bridgeDestAsset').value = txData.currency || '';

                        // Show success message
                        resultDiv.innerHTML = `
                            <div style="background: #e8f5e9; border: 1px solid #4caf50; border-radius: 6px; padding: 10px; color: #2e7d32;">
                                ✅ Transaction found! Fields have been auto-filled.
                            </div>
                        `;
                    }

                    // Store tx data for later use
                    window.bridgeDestTxData = txData;
                } else {
                    throw new Error('Transaction not found');
                }
            } catch (error) {
                console.error('Bridge destination lookup error:', error);
                resultDiv.innerHTML = `
                    <div style="background: #ffebee; border: 1px solid #f44336; border-radius: 6px; padding: 10px; color: #c62828;">
                        ❌ Failed to lookup transaction: ${error.message}
                    </div>
                `;
            }
        }

        async function confirmBridgeOutput(hopNumber, entryId) {
            const txHash = document.getElementById('bridgeDestTxHash').value.trim();
            const destChain = document.getElementById('bridgeDestChain').value;
            const destWallet = document.getElementById('bridgeDestWallet').value.trim();

            // Check if we have commingling and should use attributed amount
            let destAmount = document.getElementById('bridgeDestAmount').value;
            const attributedAmountInput = document.getElementById('attributedAmount');
            const proportionalSection = document.getElementById('proportionalAttributionSection');

            if (proportionalSection && proportionalSection.style.display !== 'none' && attributedAmountInput && attributedAmountInput.value) {
                // Use the attributed amount if commingling was detected
                destAmount = attributedAmountInput.value;
            }

            const destAsset = document.getElementById('bridgeDestAsset').value.trim();
            // Always use brown wallet type for bridges
            const walletType = 'brown';

            if (!txHash || !destChain || !destWallet || !destAmount || !destAsset) {
                showNotification('❌ Please fill in all destination transaction details', 'error');
                return;
            }

            const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
            const entry = hop.entries.find(e => e.id === entryId);

            if (!entry) {
                showNotification('❌ Entry not found', 'error');
                return;
            }

            // Save undo state
            saveUndoState(`Log bridge output from terminal wallet in Hop ${hop.hopNumber}`);

            // Always convert to DeFi bridge when logging bridge output
            // This overwrites the previous purple (terminal) classification
            entry.toWalletType = 'brown'; // Brown for bridges/conversions
            entry.isBridge = true;
            entry.wasTerminalWallet = true; // Track that this was originally classified as terminal
            entry.isTerminalWallet = false; // NO LONGER a terminal wallet - it's a bridge!

            // Don't rebuild here - wait until after the bridge output thread is created

            const noteType = 'BRIDGE OUTPUT';
            const existingNotes = entry.notes || '';

            // Check if we have swap data to include
            let swapInfo = '';
            if (window.bridgeDestTxData && window.bridgeDestTxData.swapData) {
                const swap = window.bridgeDestTxData.swapData;
                swapInfo = `\n  DEX Protocol: ${swap.protocol}` +
                          `\n  Swap: ${swap.amount0} ${swap.token0} → ${swap.amount1} ${swap.token1}` +
                          `\n  USD Value: $${swap.usdValue.toLocaleString()}`;
            }

            // Check if we have commingling attribution data
            let comminglingInfo = '';
            if (window.comminglingData) {
                const fullAmount = document.getElementById('bridgeDestAmount').value;
                comminglingInfo = `\n  PROPORTIONAL ATTRIBUTION APPLIED:` +
                                 `\n    Total conversion output: ${fullAmount} ${destAsset}` +
                                 `\n    Your ownership percentage: ${window.comminglingData.ourPercentage.toFixed(2)}%` +
                                 `\n    Your attributed amount: ${destAmount} ${destAsset}` +
                                 `\n    Calculation: ${fullAmount} × ${window.comminglingData.ourPercentage.toFixed(2)}% = ${destAmount}`;
            }

            // CRITICAL: Work exactly like swaps - replace the thread in the SAME HOP
            // The bridge converts the existing thread from one currency to another

            const inputCurrency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
            const outputCurrency = destAsset;
            const inputAmount = parseFloat(entry.amount);
            let outputAmount = parseFloat(destAmount);

            // CHECK FOR PARTIAL TRACE: Compare our traced amount to the total transaction
            let isPartialTrace = false;
            let proportionalMultiplier = 1.0;
            let fullOutputAmount = outputAmount; // Store the original full amount

            // Check if the entry notes contain information about partial tracing
            if (entry.notes && entry.notes.includes('Partial trace:')) {
                // Extract the total transaction amount from the notes
                const partialMatch = entry.notes.match(/Partial trace: Following ([\d.]+) of ([\d.]+)/);
                if (partialMatch) {
                    const ourAmount = parseFloat(partialMatch[1]);
                    const totalAmount = parseFloat(partialMatch[2]);

                    // Validate to prevent division by zero
                    if (totalAmount > 0) {
                        isPartialTrace = true;
                        proportionalMultiplier = ourAmount / totalAmount;

                        console.log(`🚨 PARTIAL TRACE DETECTED in bridge output:`);
                        console.log(`   Our input: ${ourAmount} ${inputCurrency}`);
                        console.log(`   Total transaction: ${totalAmount} ${inputCurrency}`);
                        console.log(`   Our ownership: ${(proportionalMultiplier * 100).toFixed(2)}%`);

                        // Calculate our proportional share of the output
                        fullOutputAmount = outputAmount; // Save the full amount before adjustment
                        outputAmount = outputAmount * proportionalMultiplier;

                        console.log(`   Full bridge output: ${fullOutputAmount} ${outputCurrency}`);
                        console.log(`   Our proportional share: ${outputAmount} ${outputCurrency}`);

                        // Update the notes to reflect the proportional calculation
                        comminglingInfo = `\n  ⚠️ PARTIAL TRACE PROPORTIONAL CALCULATION:` +
                                         `\n    Your input: ${ourAmount} ${inputCurrency} of ${totalAmount} ${inputCurrency} total` +
                                         `\n    Your ownership: ${(proportionalMultiplier * 100).toFixed(2)}%` +
                                         `\n    Full bridge output: ${fullOutputAmount} ${outputCurrency}` +
                                         `\n    Your proportional output: ${outputAmount.toFixed(6)} ${outputCurrency}`;

                        // Update the destAmount for the thread creation
                        destAmount = outputAmount.toString();
                    } else {
                        console.error('Invalid total amount in partial trace calculation:', totalAmount);
                    }
                }
            }

            // Build the final notes with all calculation details
            let outputAmountNote = `  Output Amount: ${outputAmount.toFixed(6)} ${destAsset}`;
            if (isPartialTrace && proportionalMultiplier > 0) {
                // For partial traces, use the stored fullOutputAmount (no need to recalculate)
                outputAmountNote = `  Full Bridge Output: ${fullOutputAmount.toFixed(6)} ${destAsset}\n` +
                                  `  Our Proportional Share: ${outputAmount.toFixed(6)} ${destAsset}\n` +
                                  `  Calculation: ${fullOutputAmount.toFixed(6)} × ${(proportionalMultiplier * 100).toFixed(4)}% = ${outputAmount.toFixed(6)}`;
            }

            entry.notes = existingNotes + `\n[${noteType}] Wallet reclassified from terminal to bridge:\n` +
                `  Output Chain: ${destChain}\n` +
                `  Output Tx: ${txHash}\n` +
                `  Output Wallet: ${destWallet}\n` +
                outputAmountNote +
                swapInfo +
                comminglingInfo +
                `\n  Reclassified: ${new Date().toISOString()}`;

            // Store bridge details for both types
            // Note: destAmount may have been adjusted for partial traces
            entry.bridgeDetails = {
                sourceChain: entry.chain || 'unknown',
                destinationChain: destChain,
                destinationTxHash: txHash,
                destinationWallet: destWallet,
                destinationAmount: outputAmount,  // Use the potentially adjusted amount
                destinationAsset: destAsset,
                bridgeAddress: entry.toWallet,
                walletType: walletType,
                wasPartialTrace: isPartialTrace,
                proportionalMultiplier: proportionalMultiplier
            };

            // Mark that bridge output has been logged
            entry.bridgeOutputLogged = true;

            console.log(`Processing bridge conversion: ${inputAmount} ${inputCurrency} → ${outputAmount} ${outputCurrency}`);

            // Get the source thread information
            const sourceInternalId = entry.sourceThreadInternalId;
            const sourceNotation = entry.notation;

            // Find and consume the source thread in the input currency
            if (investigation.availableThreads[inputCurrency]) {
                // Look for the source thread
                for (const key in investigation.availableThreads[inputCurrency]) {
                    const thread = investigation.availableThreads[inputCurrency][key];

                    // Check if this is our source thread
                    if (key === sourceInternalId || thread.internalId === sourceInternalId ||
                        thread.notation === sourceNotation || key.includes(sourceNotation)) {

                        // For bridges, we consume the ENTIRE thread (not partial like some swaps)
                        delete investigation.availableThreads[inputCurrency][key];
                        console.log(`Consumed thread ${key} from ${inputCurrency} for bridge conversion`);
                        break;
                    }
                }
            }

            // Create the output thread in the new currency (exactly like swaps do)
            if (!investigation.availableThreads[outputCurrency]) {
                investigation.availableThreads[outputCurrency] = {};
            }

            // For bridge outputs, we need TRULY unique IDs for the dual-layer system
            // Each bridge output is a separate thread with its own unique internal ID
            // The notation stays the same for display, but internal ID must be unique
            // Force unique ID generation for every bridge output
            const outputInternalId = generateInternalThreadId(`bridge_${entryId}`, outputCurrency, true); // Force unique with timestamp

            // For bridge outputs, check if this exact bridge output already exists (same tx hash)
            // Multiple bridge outputs from the same source notation are allowed
            let existingThread = null;
            let existingThreadKey = null;

            // Check if this exact bridge output already exists (using the unique key that includes entry ID)
            if (investigation.availableThreads[outputCurrency][outputInternalId]) {
                existingThread = investigation.availableThreads[outputCurrency][outputInternalId];
                existingThreadKey = outputInternalId;
                console.log(`Found existing bridge output for entry ${entryId}, will update it`);
            }
            // REMOVED: We no longer check for same tx hash across different entries
            // Each bridge conversion entry should create its own thread

            if (existingThread) {
                console.log(`Updating existing thread for ${sourceNotation} in ${outputCurrency}, amount from ${existingThread.totalAmount} to ${outputAmount}`);
                // Update the existing thread - ROUND to avoid floating point artifacts
                existingThread.totalAmount = roundAmount(outputAmount);
                existingThread.availableAmount = roundAmount(outputAmount);
                existingThread.destinationTxHash = txHash;
                existingThread.sourceWallet = destWallet;
                existingThread.chainId = destChain;
                existingThread.chainName = window.blockchainAPIs?.[destChain]?.name || destChain;
                existingThread.sourceType = 'bridge_output';

                // CRITICAL: Update partial trace info to prevent incorrect auto-write-offs
                existingThread.wasPartialTrace = isPartialTrace;
                existingThread.proportionalMultiplier = proportionalMultiplier;
                existingThread.fullOutputAmount = isPartialTrace ? fullOutputAmount : outputAmount;

                // If the thread has a different key, delete it and re-add with correct key
                if (existingThreadKey !== outputInternalId) {
                    delete investigation.availableThreads[outputCurrency][existingThreadKey];
                    investigation.availableThreads[outputCurrency][outputInternalId] = existingThread;
                    existingThread.internalId = outputInternalId;
                }

                showNotification(`✅ Bridge output updated! Thread ${sourceNotation} updated to ${outputAmount} ${outputCurrency} on ${destChain}.`, 'success', 8000);
            } else {
                // Create the bridge output thread (mirrors swap output structure)
                investigation.availableThreads[outputCurrency][outputInternalId] = {
                    // Dual-layer tracking (same as swap outputs)
                    notation: sourceNotation,  // KEEP ORIGINAL NOTATION for audit trail
                    internalId: outputInternalId,
                    entryId: entryId,  // Track which entry created this bridge output

                    // Thread amounts - ROUND to avoid floating point artifacts
                    totalAmount: roundAmount(outputAmount),
                    availableAmount: roundAmount(outputAmount),
                    assignments: [],

                    // Source information
                    sourceWallet: destWallet,  // Bridge destination becomes the source
                    sourceType: 'bridge_output',  // Mark as bridge output (like swap_output)
                    hopLevel: hop.hopNumber,  // SAME HOP LEVEL (critical!)

                    // Tracking information
                    createdAt: new Date().toISOString(),
                    isActive: true,
                    parentThreads: [sourceInternalId || sourceNotation],
                    childThreads: [],
                    currency: outputCurrency,

                    // Chain tracking - use destination chain
                    chainId: destChain,
                    chainName: window.blockchainAPIs?.[destChain]?.name || destChain,

                    // Bridge-specific metadata (like swap metadata)
                    bridgeConverted: true,  // Like swapConverted flag
                    originalCurrency: inputCurrency,
                    bridgeType: walletType === 'brown' ? 'defi' : 'cex',
                    sourceTxHash: entry.txHash,
                    destinationTxHash: txHash,

                    // Bridge details for audit
                    bridgeDetails: {
                        fromChain: entry.chain || 'unknown',
                        toChain: destChain,
                        fromAmount: inputAmount,
                        toAmount: outputAmount,
                        fromCurrency: inputCurrency,
                        toCurrency: outputCurrency,
                        bridgeAddress: entry.toWallet
                    },

                    // CRITICAL: Store partial trace info to prevent incorrect auto-write-offs
                    wasPartialTrace: isPartialTrace,
                    proportionalMultiplier: proportionalMultiplier,
                    fullOutputAmount: isPartialTrace ? fullOutputAmount : outputAmount
                };

                console.log(`Created bridge output thread: ${sourceNotation} with ${outputAmount} ${outputCurrency} on ${destChain} at hop ${hop.hopNumber}`);
                showNotification(`✨ Bridge conversion complete: ${inputAmount} ${inputCurrency} → ${outputAmount} ${outputCurrency} (available in Hop ${hop.hopNumber})`, 'info', 5000);
            }

            // Close modal - find the specific bridge output modal
            const modal = document.getElementById('bridgeOutputModal') || document.querySelector('.modal');
            if (modal) {
                modal.remove();
            }

            // Clean up commingling data
            window.comminglingData = null;
            window.bridgeDestTxData = null;

            // Re-render
            buildAvailableThreadsIndex(); // Rebuild to create output threads
            renderHops();
            saveToStorage();

            // Always shows as bridge since we force brown wallet type
            showNotification(`✅ Bridge output logged! Wallet reclassified to bridge (brown). Thread ${entry.notation} converted to ${outputAmount} ${outputCurrency} on ${destChain}. Continue tracing in Hop ${hop.hopNumber}.`, 'success', 8000);
        }

        function validateTransactionChronology(victim) {
            // Get all transactions with dates
            const transactionsWithDates = victim.transactions
                .filter(t => t.datetime && t.datetime.trim() !== '')
                .map(t => ({
                    id: t.id,
                    datetime: t.datetime,
                    timezone: t.timezone || 'UTC',
                    timestamp: convertToUTC(t.datetime, t.timezone || 'UTC')
                }));
            
            // Check if transactions are in chronological order
            for (let i = 0; i < transactionsWithDates.length - 1; i++) {
                const current = transactionsWithDates[i];
                const next = transactionsWithDates[i + 1];
                
                if (current.timestamp > next.timestamp) {
                    return `Transaction V${victim.id}-T${current.id} (${formatDateTimeDisplay(current.datetime, current.timezone)}) occurs AFTER V${victim.id}-T${next.id} (${formatDateTimeDisplay(next.datetime, next.timezone)}).\n\nTransaction IDs must be in chronological order.`;
                }
            }
            
            return null; // No errors
        }
        
        function convertToUTC(datetime, timezone) {
            // Convert datetime string to UTC timestamp for comparison
            const date = new Date(datetime);
            
            // For better timezone handling, check if the date is in DST period
            const isDST = (d) => {
                const jan = new Date(d.getFullYear(), 0, 1).getTimezoneOffset();
                const jul = new Date(d.getFullYear(), 6, 1).getTimezoneOffset();
                return Math.max(jan, jul) !== d.getTimezoneOffset();
            };
            
            // Timezone offset map with DST handling
            const timezoneOffsets = {
                'UTC': 0,
                'EST': -5,
                'EDT': -4,
                'CST': -6,
                'CDT': -5,
                'MST': -7,
                'MDT': -6,
                'PST': -8,
                'PDT': -7,
                'GMT': 0,
                'CET': 1,
                'CEST': 2,
                'JST': 9,
                // Auto-detect DST for common US timezones
                'ET': isDST(date) ? -4 : -5,  // Eastern Time
                'CT': isDST(date) ? -5 : -6,  // Central Time
                'MT': isDST(date) ? -6 : -7,  // Mountain Time
                'PT': isDST(date) ? -7 : -8   // Pacific Time
            };
            
            const offset = timezoneOffsets[timezone] || 0;
            // Subtract offset to convert to UTC (negative offsets become positive)
            return date.getTime() - (offset * 60 * 60 * 1000);
        }
        
        function formatDateTimeDisplay(datetime, timezone) {
            if (!datetime) return 'No date';
            const date = new Date(datetime);
            const options = { 
                year: 'numeric', 
                month: '2-digit', 
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit'
            };
            return `${date.toLocaleDateString('en-US', options)} ${timezone}`;
        }
        
        // Get timezone offset in hours
        function getTimezoneOffset(timezone) {
            const timezoneOffsets = {
                'UTC': 0,
                'EST': -5,
                'EDT': -4,
                'CST': -6,
                'CDT': -5,
                'MST': -7,
                'MDT': -6,
                'PST': -8,
                'PDT': -7,
                'GMT': 0,
                'CET': 1,
                'CEST': 2,
                'JST': 9,
                'ET': -5,  // Will be handled with DST check
                'CT': -6,  // Will be handled with DST check
                'MT': -7,  // Will be handled with DST check
                'PT': -8   // Will be handled with DST check
            };
            
            return timezoneOffsets[timezone] !== undefined ? timezoneOffsets[timezone] : null;
        }
        
        // Convert datetime between timezones for display
        function convertDateTimeBetweenTimezones(datetime, fromTimezone, toTimezone) {
            if (!datetime) return '';
            
            // First convert to UTC
            const utcTimestamp = convertToUTC(datetime, fromTimezone);
            if (!utcTimestamp) return datetime;
            
            // Then convert to target timezone
            const toOffset = getTimezoneOffset(toTimezone);
            if (toOffset === null) return datetime;
            
            const targetDate = new Date(utcTimestamp + (toOffset * 60 * 60 * 1000));
            
            // Format as YYYY-MM-DDTHH:MM for datetime-local input
            const year = targetDate.getFullYear();
            const month = String(targetDate.getMonth() + 1).padStart(2, '0');
            const day = String(targetDate.getDate()).padStart(2, '0');
            const hours = String(targetDate.getHours()).padStart(2, '0');
            const minutes = String(targetDate.getMinutes()).padStart(2, '0');
            
            return `${year}-${month}-${day}T${hours}:${minutes}`;
        }
        
        // Handle timezone change in UI
        function onTimezoneChange(elementId, entryType, ...ids) {
            const timezoneSelect = event.target;
            const newTimezone = timezoneSelect.value;
            const datetimeInput = document.getElementById(elementId);
            
            if (!datetimeInput || !datetimeInput.value) return;
            
            // Get the current stored timezone
            let currentTimezone;
            if (entryType === 'victim') {
                const [victimId, transactionId] = ids;
                const victim = investigation.victims.find(v => v.id === victimId);
                const transaction = victim?.transactions.find(t => t.id === transactionId);
                currentTimezone = transaction?.timezone || 'UTC';
            } else if (entryType === 'hop') {
                const [hopNumber, entryId] = ids;
                const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
                const entry = hop?.entries.find(e => e.id === entryId);
                currentTimezone = entry?.timezone || 'UTC';
            }
            
            // Convert the displayed time to the new timezone
            const convertedTime = convertDateTimeBetweenTimezones(datetimeInput.value, currentTimezone, newTimezone);
            if (convertedTime && convertedTime !== datetimeInput.value) {
                datetimeInput.value = convertedTime;
            }
            
            // Update the stored timezone
            if (entryType === 'victim') {
                updateTransaction(...ids, 'timezone', newTimezone);
            } else if (entryType === 'hop') {
                updateHopEntry(...ids, 'timezone', newTimezone);
            }
        }

        function updateTransaction(victimId, transactionId, field, value) {
            const victim = investigation.victims.find(v => v.id === victimId);
            const transaction = victim.transactions.find(t => t.id === transactionId);
            
            // Store the old value in case we need to revert
            const oldValue = transaction[field];
            
            // Check for duplicate transaction hash
            if (field === 'txHash' && value && value.trim() !== '') {
                const duplicate = checkTransactionDuplicate(value, victimId, transactionId);
                if (duplicate) {
                    alert(`⚠️ Duplicate Transaction Hash!\n\nThis transaction hash already exists:\n- ${duplicate.victimName}, Transaction ${duplicate.transactionId}\n\nEach transaction hash must be unique.`);
                    // Don't update the value
                    const input = document.getElementById(`txHash_victim_${victimId}_${transactionId}`);
                    if (input) {
                        input.value = oldValue || '';
                    }
                    return;
                }
            }
            
            // Validate wallet address format
            if (field === 'receivingWallet' && value && value.trim() !== '') {
                const currency = getCurrencyFromTransaction(transaction);
                if (currency) {
                    const validation = validateWalletAddress(value, currency);
                    if (!validation.valid) {
                        const message = validation.suggestion ? 
                            `${validation.error}\n\n${validation.suggestion}` : 
                            validation.error;
                        
                        const proceed = confirm(`⚠️ Wallet Address Warning!\n\n${message}\n\nDo you want to use this address anyway?`);
                        
                        if (!proceed) {
                            // Revert the value
                            const input = document.querySelector(`input[onchange*="updateTransaction(${victimId}, ${transactionId}, 'receivingWallet'"]`);
                            if (input) {
                                input.value = oldValue || '';
                            }
                            return;
                        }
                    }
                }
                
                // Check all attribution sources for the address
                checkAllAttributions(value.trim()).then(attributions => {
                    if (attributions && attributions.length > 0) {
                        // Build attribution notes from all sources
                        let attributionNotes = [];
                        let displayInfo = [];
                        
                        attributions.forEach(attr => {
                            const entity = attr.entity;
                            const source = attr.source || 'Arkham';
                            attributionNotes.push(`[${source}] Entity: ${entity.name}${entity.type ? ` (${entity.type})` : ''}${entity.service ? ` - ${entity.service}` : ''}`);
                            displayInfo.push(`${source}: ${entity.name}${entity.type ? ` (${entity.type})` : ''}`);
                        });
                        
                        const attributionNote = attributionNotes.join('\n');
                        const displayText = displayInfo.join('\n');
                        
                        // Show a notification for victim transactions
                        const shouldAddNote = confirm(`🔍 Attribution Found!\n\n${displayText}\n\nWould you like to add this attribution to the transaction notes?`);
                        
                        if (shouldAddNote) {
                            if (transaction.notes) {
                                transaction.notes = attributionNote + '\n' + transaction.notes;
                            } else {
                                transaction.notes = attributionNote;
                            }
                            saveToStorage();
                            renderVictims();
                        }
                    }
                });
            }
            
            transaction[field] = value;
            
            // Validate chronological order when datetime is updated
            if (field === 'datetime' && value) {
                const chronologyError = validateTransactionChronology(victim);
                if (chronologyError) {
                    // Revert the change
                    transaction[field] = oldValue;
                    
                    // Show error message with fix option
                    const shouldFix = confirm(`❌ Chronological Order Error!\n\n${chronologyError}\n\nTransactions must be entered in chronological order for proper PIFO (Proceeds In First Out) compliance and smart allocation features.\n\nWould you like to automatically fix the order?\n\nClick OK to automatically reorder transactions chronologically.\nClick Cancel to revert your change.`);
                    
                    if (shouldFix) {
                        // Fix the order
                        fixVictimTransactionOrder(victimId);
                        return;
                    }
                    
                    // Re-render to show the reverted value
                    renderVictims();
                    return;
                }
            }
            
            // If receiving wallet changed and root total is confirmed, rebuild Universal Wallet Index
            if (field === 'receivingWallet' && investigation.rootTotalConfirmed) {
                buildUniversalWalletIndex();
                buildRedWalletIndex();
                renderHops(); // Re-render to update dropdowns
            }
            
            // Update red wallet index when any transaction field changes
            if (investigation.rootTotalConfirmed) {
                buildRedWalletIndex();
            }
            
            saveToStorage();
            updateValidationStatus();
            updateWorkflowSteps();
            updateGenerateRootSection();
        }

        function removeVictim(victimId) {
            if (confirm('Are you sure you want to remove this victim? This will also reset the root total confirmation.')) {
                investigation.victims = investigation.victims.filter(v => v.id !== victimId);
                investigation.rootTotalConfirmed = false;
                investigation.confirmedRootTotal = 0;
                investigation.confirmedRootTotalsByCurrency = {};
                renderVictims();
                saveToStorage();
                updateValidationStatus();
                updateWorkflowSteps();
            }
        }
        
        function completeVictim(victimId) {
            const victim = investigation.victims.find(v => v.id === victimId);
            if (!victim) return;
            
            // Validate victim has at least one transaction
            const validTransactions = victim.transactions.filter(t => 
                parseFloat(t.amount) > 0 && t.receivingWallet && t.receivingWallet.trim() !== ''
            );
            
            if (validTransactions.length === 0) {
                alert('Please add at least one transaction with amount and receiving wallet before completing this victim.');
                return;
            }
            
            // Validate all transactions have required data
            const incompleteTransactions = victim.transactions.filter(t => 
                parseFloat(t.amount) > 0 && (!t.receivingWallet || t.receivingWallet.trim() === '')
            );
            
            if (incompleteTransactions.length > 0) {
                alert(`Cannot complete victim ${victimId}: ${incompleteTransactions.length} transaction(s) are missing receiving wallet addresses.`);
                return;
            }
            
            if (confirm(`Complete Victim ${victimId}?\n\nThis will minimize the view to show only a summary. You can edit later if needed.`)) {
                victim.isCompleted = true;
                console.log(`Victim ${victimId} marked as completed:`, victim.isCompleted);

                // Build wallet indexes even before root total confirmation to allow early access
                buildUniversalWalletIndex();
                buildRedWalletIndex();

                renderVictims();
                saveToStorage();
                updateWorkflowSteps();
                updateGenerateRootSection();

                // Check if the state actually updated
                console.log('Victim state after completion:', victim);
                console.log('All victims:', investigation.victims);

                // Force a re-check of the Add Victim button
                setTimeout(() => {
                    const addVictimSection = document.getElementById('addVictimSection');
                    if (addVictimSection) {
                        const hasIncompleteVictim = investigation.victims.some(v => !v.isCompleted);
                        console.log('Has incomplete victims after completion:', hasIncompleteVictim);
                    }
                }, 100);
            }
        }
        
        function reopenVictim(victimId) {
            const victim = investigation.victims.find(v => v.id === victimId);
            if (victim) {
                victim.isCompleted = false;
                renderVictims();
                saveToStorage();
            }
        }

        function renderSummary() {
            const container = document.getElementById('summaryContent');
            
            const totalVictims = investigation.victims.length;
            const totalTransactions = investigation.victims.reduce((sum, v) => sum + v.transactions.length, 0);
            
            // Calculate totals by currency
            const rootTotalsByCurrency = investigation.confirmedRootTotalsByCurrency || {};
            const writeoffsByCurrency = {};
            const artByCurrency = {};
            
            // Calculate write-offs by currency from hop entries
            investigation.hops.forEach(hop => {
                hop.entries.forEach(entry => {
                    if (entry.entryType === 'writeoff' && parseFloat(entry.amount) > 0) {
                        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                        if (!writeoffsByCurrency[currency]) {
                            writeoffsByCurrency[currency] = 0;
                        }
                        writeoffsByCurrency[currency] += parseFloat(entry.amount);
                    }
                });
            });
            
            // Calculate ART by currency
            Object.entries(rootTotalsByCurrency).forEach(([currency, rootAmount]) => {
                const writeoffAmount = writeoffsByCurrency[currency] || 0;
                artByCurrency[currency] = rootAmount - writeoffAmount;
            });

            container.innerHTML = `
                <div class="summary-grid">
                    <div class="summary-card">
                        <h3>Total Victims</h3>
                        <div class="value">${totalVictims}</div>
                    </div>
                    <div class="summary-card">
                        <h3>Total Transactions</h3>
                        <div class="value">${totalTransactions}</div>
                    </div>
                    <div class="summary-card">
                        <h3>Total Hops</h3>
                        <div class="value">${investigation.hops.length}</div>
                    </div>
                </div>
                
                <div style="margin: 30px 0;">
                    <h3 style="color: #2c3e50; margin-bottom: 20px;">Financial Summary by Currency</h3>
                    ${Object.keys(rootTotalsByCurrency).length > 0 ? `
                        <div style="background: #f8f9fa; border-radius: 8px; padding: 20px; border: 2px solid #e8f0fe;">
                            ${Object.entries(rootTotalsByCurrency).map(([currency, rootAmount]) => {
                                const writeoffAmount = writeoffsByCurrency[currency] || 0;
                                const artAmount = artByCurrency[currency] || rootAmount - writeoffAmount;
                                return `
                                    <div style="margin-bottom: 20px; padding: 15px; background: white; border-radius: 6px; border-left: 4px solid #3498db;">
                                        <h4 style="color: #2c3e50; margin-bottom: 10px;">${currency}</h4>
                                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; font-size: 14px;">
                                            <div>
                                                <strong>Root Total:</strong><br>
                                                <span style="font-size: 1.2rem; color: #27ae60;">${rootAmount.toLocaleString()}</span>
                                            </div>
                                            <div>
                                                <strong>Write-offs:</strong><br>
                                                <span style="font-size: 1.2rem; color: #e74c3c;">${writeoffAmount.toLocaleString()}</span>
                                            </div>
                                            <div>
                                                <strong>Adjusted Root Total:</strong><br>
                                                <span style="font-size: 1.2rem; color: #3498db;">${artAmount.toLocaleString()}</span>
                                            </div>
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    ` : `
                        <div style="text-align: center; padding: 40px; color: #7f8c8d; background: #f8f9fa; border-radius: 8px; border: 2px dashed #bdc3c7;">
                            <p>No root totals confirmed yet. Please complete the victim setup and confirm your root total.</p>
                        </div>
                    `}
                </div>
            `;
        }

        // Update tracing method (PIFO vs LIBR)
        function updateTracingMethod(method) {
            investigation.tracingMethod = method;

            // Show warning if switching methods mid-investigation
            if (investigation.hops.length > 0) {
                const warning = method === 'LIBR' ?
                    'LIBR method selected: This will arrest asset flow and keep funds in fewer wallets closer to the RED wallet. Useful for stablecoin burn/reissue strategies or when private key access may be obtained. Ensure consistency throughout your investigation.' :
                    'Switched back to PIFO (default method). Ensure all previous entries follow PIFO methodology.';
                showNotification(warning, 'info');
            }

            // Update any UI elements that might display the method
            const methodDisplay = document.getElementById('currentTracingMethod');
            if (methodDisplay) {
                methodDisplay.textContent = method;
            }
        }

        // Show detailed methodology information modal (global)
        window.showMethodologyInfo = function(method) {
            console.log('📋 Opening methodology info for:', method);

            const modal = document.createElement('div');
            modal.className = 'modal-overlay';
            modal.id = 'methodologyInfoModal';
            modal.style.zIndex = '10000';

            let title, color, description, useCases, workflow, whenToUse, example;

            if (method === 'PIFO') {
                title = '📘 PIFO Methodology';
                color = '#2196f3';
                description = 'PIFO (Proceeds In, First Out) is the default tracing methodology where criminal proceeds are assumed to move immediately upon entering a wallet. When traced funds are deposited into a commingled wallet, the very next outbound transaction is presumed to contain those criminal proceeds. This method creates more hops and follows funds through rapid movement patterns, making it ideal for most cryptocurrency fraud investigations where assets move quickly through multiple wallets.';
                useCases = ['Romance scams with rapid fund movement', 'Investment fraud where funds are quickly dispersed', 'Ransomware payments moving through mixing services', 'Most cryptocurrency theft cases', 'Business email compromise with immediate transfers'];
                workflow = 'Criminal proceeds enter wallet → Next outbound transaction contains those proceeds → Create new hop → Repeat for each wallet in the chain';
                whenToUse = 'Use PIFO when funds move rapidly through wallets, when there is frequent transaction activity, or when following a clear chain of custody through multiple intermediaries. This is the recommended methodology for 90%+ of cryptocurrency investigations.';
                example = 'Victim sends 10 BTC to scammer wallet. One hour later, scammer sends 5 BTC to Exchange A and 5 BTC to Wallet B. Under PIFO, both outbound transactions contain the victim\'s proceeds and should be traced as separate hops.';
            } else {
                title = '🔶 LIBR Methodology';
                color = '#ff9800';
                description = 'LIBR (Lowest Intermediate Balance Rule) arrests the flow of criminal proceeds by keeping them in fewer wallets closer to the initial RED wallet. Instead of assuming immediate movement, LIBR monitors wallet balances and only creates new threads when the balance drops below the amount of criminal proceeds held. This methodology is particularly powerful for stablecoin investigations where funds might be burned and reissued, or when there is a possibility of wallet seizure or private key recovery.';
                useCases = ['Stablecoin cases (USDT, USDC) where burn/reissue is possible', 'Investigations where wallet seizure may be feasible', 'Cases where private key access might be obtained', 'Wallets with both criminal and legitimate funds commingled', 'Long-term monitoring scenarios'];
                workflow = 'Criminal proceeds enter wallet → Monitor balance continuously → When balance drops below proceeds amount, identify outbound transactions → Create threads only for balance drops → Wallet remains monitored until proceeds consumed';
                whenToUse = 'Use LIBR when dealing with stablecoins that can be frozen/burned, when there is potential for wallet access or seizure, or when you want to minimize the number of wallets holding criminal proceeds for strategic law enforcement action. LIBR keeps assets concentrated rather than dispersed.';
                example = 'Victim sends 50,000 USDT to scammer wallet that already holds 100,000 USDT (total: 150,000). Scammer sends 30,000 USDT to Exchange A. Balance is now 120,000 - still above the 50,000 criminal proceeds, so NO hop is created yet. The 50,000 USDT remains monitored in the original wallet. Later, scammer sends 80,000 USDT out, dropping balance to 40,000 (below 50,000). Now LIBR identifies this transaction and creates a new thread for the 10,000 USDT of criminal proceeds that moved.';
            }

            modal.innerHTML = '<div class="modal-content" style="max-width: 800px; max-height: 90vh; overflow-y: auto;">' +
                '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 3px solid ' + color + ';">' +
                '<h2 style="color: ' + color + '; margin: 0;">' + title + '</h2>' +
                '<button onclick="closeMethodologyInfoModal()" class="btn-close" style="font-size: 24px; border: none; background: none; cursor: pointer;">✕</button>' +
                '</div>' +

                '<div style="background: #f8f9fa; padding: 20px; border-radius: 8px; border-left: 4px solid ' + color + '; margin-bottom: 20px;">' +
                '<h3 style="color: ' + color + '; margin-top: 0;">Overview</h3>' +
                '<p style="line-height: 1.7; color: #2c3e50; margin: 0;">' + description + '</p>' +
                '</div>' +

                '<div style="background: white; padding: 20px; border-radius: 8px; border: 2px solid #e0e0e0; margin-bottom: 20px;">' +
                '<h3 style="color: #2c3e50; margin-top: 0;">📋 Common Use Cases</h3>' +
                '<ul style="line-height: 1.8; color: #555;">' +
                useCases.map(uc => '<li>' + uc + '</li>').join('') +
                '</ul></div>' +

                '<div style="background: #e8f5e9; padding: 20px; border-radius: 8px; margin-bottom: 20px;">' +
                '<h3 style="color: #2e7d32; margin-top: 0;">🔄 Workflow</h3>' +
                '<p style="line-height: 1.7; color: #2c3e50; margin: 0; font-family: monospace; font-size: 14px;">' + workflow + '</p>' +
                '</div>' +

                '<div style="background: #fff3cd; padding: 20px; border-radius: 8px; margin-bottom: 20px;">' +
                '<h3 style="color: #f57c00; margin-top: 0;">💡 When To Use</h3>' +
                '<p style="line-height: 1.7; color: #2c3e50; margin: 0;">' + whenToUse + '</p>' +
                '</div>' +

                '<div style="background: #e3f2fd; padding: 20px; border-radius: 8px; margin-bottom: 20px;">' +
                '<h3 style="color: #1976d2; margin-top: 0;">📝 Example Scenario</h3>' +
                '<p style="line-height: 1.7; color: #2c3e50; margin: 0; font-style: italic;">' + example + '</p>' +
                '</div>' +

                '<div style="text-align: center; padding: 20px; background: #f5f5f5; border-radius: 8px;">' +
                '<button onclick="closeMethodologyInfoModal()" class="btn btn-primary">Got It, Close</button>' +
                '</div></div>';

            document.body.appendChild(modal);
        }

        window.closeMethodologyInfoModal = function() {
            const modal = document.getElementById('methodologyInfoModal');
            if (modal) modal.remove();
        };
        
        // Apply LIBR (Lowest Intermediate Balance Rule) when needed
        function applyLIBRMethod(walletAddress, startTime, endTime) {
            // LIBR: Find the lowest balance between two time points
            // This is a placeholder for when we implement blockchain lookups
            console.log(`LIBR method would analyze wallet ${walletAddress} between ${startTime} and ${endTime}`);
            
            // For now, return a warning that this needs manual calculation
            showNotification(
                'LIBR method requires manual balance analysis. Please determine the lowest intermediate balance for the wallet during the specified period.',
                'warning'
            );
            
            return null; // Would return the lowest balance amount
        }

        function updateValidationStatus() {
            const validationPanel = document.getElementById('validationStatus');
            
            // Early return if element doesn't exist (it was removed from the UI)
            if (!validationPanel) {
                return;
            }
            
            if (!investigation.rootTotalConfirmed) {
                validationPanel.className = 'validation-panel validation-warning';
                validationPanel.innerHTML = '<div>⚠ Setup Required</div><div>Complete steps 1-3 to begin tracing</div>';
                return;
            }

            const artByCurrency = getCurrentART();
            const currentThreadsByCurrency = {};
            
            // Calculate current thread totals by finding the highest hop entries for each trace path
            // Group entries by V-T notation to track each victim-transaction path
            const tracePathsByCurrency = {};
            
            investigation.hops.forEach(hop => {
                hop.entries.forEach(entry => {
                    if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0 && entry.notation) {
                        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                        
                        // Extract V-T path from notation (e.g., "V1-T1-H3" -> "V1-T1")
                        const pathMatch = entry.notation.match(/^(V\d+-T\d+)/);
                        if (pathMatch) {
                            const vtPath = pathMatch[1];
                            
                            if (!tracePathsByCurrency[currency]) {
                                tracePathsByCurrency[currency] = {};
                            }
                            if (!tracePathsByCurrency[currency][vtPath]) {
                                tracePathsByCurrency[currency][vtPath] = [];
                            }
                            
                            tracePathsByCurrency[currency][vtPath].push({
                                hopNumber: entry.hopNumber,
                                amount: parseFloat(entry.amount),
                                notation: entry.notation,
                                isConvergence: entry.isConvergence || false
                            });
                        }
                    }
                });
            });
            
            // For each currency and path, take only the highest hop number (current thread value)
            Object.entries(tracePathsByCurrency).forEach(([currency, paths]) => {
                if (!currentThreadsByCurrency[currency]) {
                    currentThreadsByCurrency[currency] = 0;
                }
                
                Object.entries(paths).forEach(([vtPath, entries]) => {
                    // Sort by hop number and take the highest (most recent)
                    entries.sort((a, b) => b.hopNumber - a.hopNumber);
                    const currentEntry = entries[0];
                    currentThreadsByCurrency[currency] += currentEntry.amount;
                });
            });
            
            // Check validation for each currency
            let allValid = true;
            let validationDetails = [];
            
            Object.keys(artByCurrency).forEach(currency => {
                const artAmount = artByCurrency[currency];
                const threadAmount = currentThreadsByCurrency[currency] || 0;
                const difference = Math.abs(threadAmount - artAmount);
                
                if (difference >= 0.01) {
                    allValid = false;
                    validationDetails.push(`${currency}: Thread ${threadAmount.toLocaleString()} != ART ${artAmount.toLocaleString()}`);
                } else {
                    validationDetails.push(`${currency}: ✓ ${threadAmount.toLocaleString()}`);
                }
            });
            
            if (allValid && Object.keys(artByCurrency).length > 0) {
                validationPanel.className = 'validation-panel';
                validationPanel.innerHTML = `<div>✓ Validation Passed</div><div>${validationDetails.join('<br>')}</div>`;
            } else {
                validationPanel.className = 'validation-panel validation-error';
                validationPanel.innerHTML = `<div>✗ Validation Failed</div><div>${validationDetails.join('<br>')}</div>`;
            }
        }

        function validateTraces() {
            updateValidationStatus();
        }

        // DUPLICATE FUNCTION REMOVED - Using the global version at line 9714
        /*function getWalletColor(type) {
            const colors = {
                'red': '#e74c3c',
                'pink': '#e91e63', 
                'yellow': '#f1c40f',
                'orange': '#f39c12',
                'brown': '#8d6e63',
                'black': '#2c3e50',
                'blue': '#3498db',
                'purple': '#9b59b6',
                'gray': '#95a5a6',
                'green': '#27ae60'
            };
            return colors[type] || '#3498db';
        }*/

        async function saveInvestigation() {
            if (!investigation.caseId) {
                alert('Please enter a Case ID before saving.');
                return;
            }

            // Ensure all necessary indices are built before saving
            buildAvailableThreadsIndex();

            // The investigation object now includes availableThreads index
            const dataStr = JSON.stringify(investigation, null, 2);
            
            // If we have a file handle from the File System Access API, use it
            if (fileHandle && isFileSystemAvailable) {
                try {
                    const writable = await fileHandle.createWritable();
                    await writable.write(dataStr);
                    await writable.close();
                    
                    showNotification('Investigation saved successfully!', 'success');
                    return;
                } catch (error) {
                    console.error('Error saving with file handle:', error);
                    // Fall back to download if file handle save fails
                }
            }
            
            // Default download method - use case ID as filename
            const filename = `${investigation.caseId}.bats`;
            downloadFile(dataStr, filename, 'application/json');
        }

        function processLoadedFile(content) {
            try {
                console.log('Processing loaded file content...');
                console.log('File read successfully, parsing JSON...');
            
            // Parse JSON
            const loadedData = JSON.parse(content);
            console.log('JSON parsed successfully:', loadedData);
            
            // Validate basic structure
            if (!loadedData.victims || !loadedData.hops) {
                throw new Error('Invalid BATS investigation file - missing required data structure');
            }
            
            console.log('Basic validation passed');
            
            // Initialize enhanced structure if missing
            initializeCompleteIntegration(loadedData);
            
            // Migrate data structure if needed
            migrateToEnhancedStructure(loadedData);
            
            // Set the global investigation object
            investigation = loadedData;

            // Sort all hop entries chronologically after loading
            if (investigation.hops) {
                investigation.hops.forEach(hop => {
                    if (hop.entries && hop.entries.length > 0) {
                        sortHopEntriesChronologically(hop);
                    }
                });
            }

            // Set all hops and entries to collapsed state when loading a saved file
            // This keeps the interface clean when viewing large investigations
            window.hopCollapseState = {};
            window.entryCollapseState = {};
            if (investigation.hops) {
                investigation.hops.forEach(hop => {
                    // Collapse the hop itself
                    window.hopCollapseState[hop.hopNumber] = true; // Start collapsed

                    // Collapse all entries within the hop
                    if (hop.entries) {
                        hop.entries.forEach(entry => {
                            const entryKey = `${hop.hopNumber}_${entry.id}`;
                            window.entryCollapseState[entryKey] = true; // Start collapsed
                        });
                    }
                });
            }
            
            // Update form fields
            updateFormFieldsFromInvestigation();
            
            // Check chronological order of transactions
            const chronologyErrors = [];
            investigation.victims.forEach(victim => {
                const error = validateTransactionChronology(victim);
                if (error) {
                    chronologyErrors.push(`Victim ${victim.id}:\n${error}`);
                }
            });
            
            // Re-render everything
            // IMPORTANT: Rebuild thread index after loading to ensure availability
            buildAvailableThreadsIndex();

            renderAll();
            updateWorkflowSteps();

            // Update investigation completion status to show proper buttons
            updateInvestigationCompletionStatus();

            // Alert about chronology errors after rendering
            if (chronologyErrors.length > 0) {
                setTimeout(() => {
                    alert(`⚠️ WARNING: Transaction Chronology Issues Detected!\n\n${chronologyErrors.join('\n\n')}\n\nThe V-T notation requires transactions to be numbered in chronological order. Please review and correct the transaction order to ensure PIFO (Proceeds In First Out) compliance.\n\nYou can manually adjust the dates or re-number the transactions.`);
                }, 500);
            }

            console.log('Investigation loaded successfully!');
            console.log('Available threads after loading:', investigation.availableThreads);

            // Switch to the hops tab to show the loaded investigation
            if (typeof window.switchTab === 'function') {
                window.switchTab('hops');
            }

            // Check if investigation is complete and show appropriate modal
            const status = analyzeCaseStatus();
            if (status.currentPhase === 'complete') {
                // Show the completion modal for completed investigations
                showEnhancedCompletionModal();
            } else {
                // Show case status dashboard for in-progress investigations
                showCaseStatusDashboard();
            }

        } catch (error) {
            console.error('Error loading file:', error);
            alert('Error loading file: ' + error.message);
        }
    }

        function loadInvestigation(event) {
    const file = event.target.files[0];
    if (!file) {
        console.log('No file selected');
        return;
    }

    console.log('Starting file load:', file.name, 'Size:', file.size, 'Type:', file.type);

    const reader = new FileReader();
    reader.onload = function(e) {
        const content = e.target.result;
        processLoadedFile(content);

        // Clear the file input to allow re-loading the same file
        event.target.value = '';
    };

    reader.onerror = function() {
        console.error('File reading failed');
        alert('Failed to read the file. Please try again.');
        event.target.value = '';
    };
    
    reader.readAsText(file);
}
        function exportReport() {
            const report = generateBATSReport();
            downloadFile(report, 'BATS_Report_' + (investigation.caseId || 'Investigation') + '.html', 'text/html');
        }

        function exportJSON() {
            const data = JSON.stringify(investigation, null, 2);
            const filename = 'BATS_Data_' + (investigation.caseId || 'Investigation') + '.json';
            downloadFile(data, filename, 'application/json');
        }

        function exportCSV() {
            let csv = 'Type,Notation,Amount,Currency,From,To,WalletType,Hop,DateTime,Timezone,Notes\n';

            // Export hop entries (including writeoffs)
            investigation.hops.forEach(hop => {
                hop.entries.forEach(entry => {
                    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                    const utcTimestamp = entry.timestamp ? formatDateTimeForReport(entry.timestamp, entry.timezone || 'UTC') : 'Not specified';
                    csv += [
                        escapeCSVCell(entry.entryType),
                        escapeCSVCell(entry.notation),
                        escapeCSVCell(entry.amount),
                        escapeCSVCell(currency),
                        escapeCSVCell(entry.fromWallet),
                        escapeCSVCell(entry.toWallet),
                        escapeCSVCell(entry.toWalletType),
                        escapeCSVCell(entry.hopNumber),
                        escapeCSVCell(utcTimestamp),
                        escapeCSVCell('UTC'),
                        escapeCSVCell(entry.notes || entry.justification || '')
                    ].join(',') + '\n';
                });
            });

            const filename = 'BATS_Data_' + (investigation.caseId || 'Investigation') + '.csv';
            downloadFile(csv, filename, 'text/csv');
        }

        function generateBATSReport() {
            const totalVictims = investigation.victims.length;
            const rootTotalsByCurrency = investigation.confirmedRootTotalsByCurrency || {};
            
            // Calculate write-offs by currency from hop entries
            const writeoffsByCurrency = {};
            investigation.hops.forEach(hop => {
                hop.entries.forEach(entry => {
                    if (entry.entryType === 'writeoff' && parseFloat(entry.amount) > 0) {
                        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                        if (!writeoffsByCurrency[currency]) {
                            writeoffsByCurrency[currency] = 0;
                        }
                        writeoffsByCurrency[currency] += parseFloat(entry.amount);
                    }
                });
            });

            // Build Red Wallet Index section
            const redWalletSection = investigation.redWalletIndex && investigation.redWalletIndex.length > 0 ? `
                <div class="section">
                    <div class="section-title">Section 2: Red Wallet Index - Victim Deposit Summary</div>
                    <table>
                        <tr>
                            <th>V-T Notation</th>
                            <th>Wallet ID</th>
                            <th>Deposit Date</th>
                            <th>Amount</th>
                            <th>Currency</th>
                            <th>Wallet Address</th>
                            <th>Notes</th>
                        </tr>
                        ${investigation.redWalletIndex.map(entry => `
                            <tr>
                                <td>${entry.vtNotation}</td>
                                <td>${entry.walletId || 'Not assigned'}</td>
                                <td>${entry.depositDate ? formatDateTimeForReport(entry.depositDate, entry.timezone) : 'Not specified'}</td>
                                <td>${entry.amount.toLocaleString()}</td>
                                <td>${entry.currency}</td>
                                <td style="font-family: monospace; font-size: 11px; word-break: break-all;">${entry.walletAddress}</td>
                                <td>${(entry.notes || '') + (entry.investigativeNotes ? ' | ' + entry.investigativeNotes : '')}</td>
                            </tr>
                        `).join('')}
                    </table>
                </div>
            ` : '';

            return `<!DOCTYPE html>
<html>
<head>
    <title>B.A.T.S. Investigation Report - ${investigation.caseId}</title>
    <style>
        body { font-family: 'Segoe UI', Arial, sans-serif; margin: 40px; line-height: 1.6; color: #2c3e50; }
        .header { text-align: center; border-bottom: 3px solid #2c3e50; padding-bottom: 20px; margin-bottom: 30px; }
        .section { margin: 30px 0; }
        .section-title { background: #2c3e50; color: white; padding: 15px; margin-bottom: 20px; font-weight: 600; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        th, td { border: 1px solid #ddd; padding: 12px; text-align: left; }
        th { background: #f8f9fa; font-weight: bold; color: #2c3e50; }
        .summary-box { background: #e8f5e8; border: 2px solid #27ae60; padding: 20px; margin: 20px 0; border-radius: 8px; }
        .currency-section { background: #f8f9fa; border: 1px solid #ddd; padding: 15px; margin: 10px 0; border-radius: 6px; }
    </style>
</head>
<body>
    <div class="header">
        <h1>B.A.T.S. Investigation Report</h1>
        <h2>Block Audit Tracing Standard</h2>
        <p><strong>Case ID:</strong> ${investigation.caseId}</p>
        <p><strong>Investigator:</strong> ${investigation.investigator}</p>
        <p><strong>Report Generated:</strong> ${new Date().toISOString().replace('T', ' ').replace('.000Z', ' UTC')}</p>
        <p style="font-style: italic; color: #666;">All timestamps in this report are displayed in UTC for compliance and consistency.</p>
    </div>

    <div class="section">
        <div class="section-title">Section 1: Case Summary</div>
        <p><strong>Case Type:</strong> ${investigation.caseType}</p>
        <p><strong>Total Victims:</strong> ${totalVictims}</p>
        <p><strong>Investigation Period:</strong> ${new Date(investigation.created).toLocaleDateString()} - ${new Date().toLocaleDateString()}</p>
        ${investigation.caseSynopsis ? `
        <div style="margin-top: 20px;">
            <p><strong>Case Synopsis:</strong></p>
            <div style="background: #f8f9fa; border-left: 4px solid #3498db; padding: 15px; margin-top: 10px;">
                ${investigation.caseSynopsis.replace(/\n/g, '<br>')}
            </div>
        </div>
        ` : ''}
    </div>

    ${redWalletSection}

    ${investigation.hops.length > 0 ? `
    <div class="section">
        <div class="section-title">Section 3: Hop Documentation</div>
        ${investigation.hops.map(hop => `
            <h3>Hop ${hop.hopNumber}</h3>
            <table>
                <tr>
                    <th>Entry Type</th>
                    <th>Notation</th>
                    <th>Amount</th>
                    <th>Currency</th>
                    <th>From Wallet</th>
                    <th>To Wallet</th>
                    <th>Classification</th>
                    <th>Transaction Hash</th>
                    <th>Timestamp</th>
                    <th>Notes</th>
                </tr>
                ${hop.entries.map(entry => `
                    <tr>
                        <td>${entry.entryType}</td>
                        <td>${entry.notation}</td>
                        <td>${(parseFloat(entry.amount) || 0).toLocaleString()}</td>
                        <td>${entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency}</td>
                        <td style="font-family: monospace; font-size: 11px; word-break: break-all;">${entry.fromWallet}</td>
                        <td style="font-family: monospace; font-size: 11px; word-break: break-all;">${entry.toWallet}</td>
                        <td>${walletTypes[entry.toWalletType] || entry.toWalletType}</td>
                        <td style="font-family: monospace; font-size: 11px; word-break: break-all;">${entry.txHash}</td>
                        <td>${entry.timestamp ? formatDateTimeForReport(entry.timestamp, entry.timezone || 'UTC') : 'Not specified'}</td>
                        <td>${entry.notes || entry.justification || ''}</td>
                    </tr>
                `).join('')}
            </table>
        `).join('')}
    </div>
    ` : ''}

    <div class="section">
        <div class="section-title">Section 4: Summary of Findings</div>
        <div class="summary-box">
            <h3>Golden Thread Analysis by Currency</h3>
            ${Object.keys(rootTotalsByCurrency).length > 0 ? Object.entries(rootTotalsByCurrency).map(([currency, rootAmount]) => {
                const writeoffAmount = writeoffsByCurrency[currency] || 0;
                const adjustedTotal = rootAmount - writeoffAmount;
                
                // Calculate traced amount for this currency
                let tracedAmount = 0;
                investigation.hops.forEach(hop => {
                    hop.entries.forEach(entry => {
                        if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0) {
                            const entryCurrency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                            if (entryCurrency === currency) {
                                tracedAmount += parseFloat(entry.amount);
                            }
                        }
                    });
                });
                
                const isValid = Math.abs(tracedAmount - adjustedTotal) < 0.01;
                
                return `
                    <div class="currency-section">
                        <h4>${currency}</h4>
                        <p><strong>Root Total:</strong> ${rootAmount.toLocaleString()}</p>
                        <p><strong>Write-offs:</strong> ${writeoffAmount.toLocaleString()}</p>
                        <p><strong>Adjusted Root Total:</strong> ${adjustedTotal.toLocaleString()}</p>
                        <p><strong>Traced Amount:</strong> ${tracedAmount.toLocaleString()}</p>
                        <p><strong>Mathematical Validation:</strong> <span style="color: ${isValid ? 'green' : 'red'}; font-weight: bold;">${isValid ? 'PASSED' : 'FAILED'}</span></p>
                    </div>
                `;
            }).join('') : '<p>No confirmed root totals available.</p>'}
        </div>
    </div>
</body>
</html>`;
        }

        // Comprehensive Narrative Report Generator for Word/Legal Documentation
        function exportNarrativeReport() {
            const report = generateNarrativeReport();
            const filename = `BATS_Narrative_Report_${investigation.caseId || 'Investigation'}_${new Date().toISOString().split('T')[0]}.doc`;
            downloadFile(report, filename, 'application/msword');
        }

        // Comprehensive Report Function
        function showComprehensiveReport() {
            // Generate all reports and indices
            const narrativeReport = generateNarrativeReport();
            const victimIndex = generateVictimIndex();
            const walletIndex = generateUniversalWalletIndex();
            const terminalReport = generateTerminalWalletReport();
            const redWalletIndex = generateRedWalletIndex();

            // Create modal with all reports
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.8);
                z-index: 10000;
                display: flex;
                justify-content: center;
                align-items: center;
                overflow: auto;
            `;

            const content = document.createElement('div');
            content.style.cssText = `
                background: white;
                width: 90%;
                max-width: 1200px;
                max-height: 90vh;
                overflow-y: auto;
                border-radius: 12px;
                position: relative;
            `;

            // Calculate totals
            let totalsByCurrency = {};
            if (investigation.rootTotals) {
                Object.entries(investigation.rootTotals).forEach(([currency, amount]) => {
                    if (!totalsByCurrency[currency]) totalsByCurrency[currency] = 0;
                    totalsByCurrency[currency] += amount;
                });
            }

            const totalAmount = Object.values(totalsByCurrency).reduce((sum, amount) => sum + amount, 0);
            const currencyBreakdown = Object.entries(totalsByCurrency)
                .map(([currency, amount]) => `${amount.toFixed(6)} ${currency}`)
                .join(' + ');

            content.innerHTML = `
                <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; border-radius: 12px 12px 0 0;">
                    <button onclick="this.closest('[style*=\\"z-index: 10000\\"]').remove()" style="position: absolute; right: 15px; top: 15px; background: rgba(255,255,255,0.2); border: none; color: white; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 16px;">✕</button>
                    <h2 style="margin: 0 0 10px 0; font-size: 2rem;">📋 Comprehensive Investigation Report</h2>
                    <p style="margin: 0; opacity: 0.95;">Complete analysis with all indices, narratives, and terminal wallet tracking</p>
                    <div style="margin-top: 15px; padding: 15px; background: rgba(255,255,255,0.1); border-radius: 8px;">
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                            <div>
                                <div style="opacity: 0.8; font-size: 12px;">Total Traced</div>
                                <div style="font-size: 20px; font-weight: bold;">${totalAmount.toFixed(2)}</div>
                                <div style="opacity: 0.8; font-size: 11px;">${currencyBreakdown}</div>
                            </div>
                            <div>
                                <div style="opacity: 0.8; font-size: 12px;">Victims</div>
                                <div style="font-size: 20px; font-weight: bold;">${investigation.victims ? investigation.victims.length : 0}</div>
                            </div>
                            <div>
                                <div style="opacity: 0.8; font-size: 12px;">Hops Traced</div>
                                <div style="font-size: 20px; font-weight: bold;">${investigation.hops ? investigation.hops.length : 0}</div>
                            </div>
                            <div>
                                <div style="opacity: 0.8; font-size: 12px;">Terminal Wallets</div>
                                <div style="font-size: 20px; font-weight: bold;">${investigation.terminalWalletIndex ? investigation.terminalWalletIndex.length : 0}</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div style="padding: 20px;">
                    <!-- Navigation Tabs -->
                    <div style="display: flex; gap: 5px; margin-bottom: 20px; border-bottom: 2px solid #e0e0e0;">
                        <button onclick="showReportSection('narrative')" class="report-tab-btn active" style="padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 8px 8px 0 0; cursor: pointer;">📖 Narrative</button>
                        <button onclick="showReportSection('victims')" class="report-tab-btn" style="padding: 10px 20px; background: #f0f0f0; color: #333; border: none; border-radius: 8px 8px 0 0; cursor: pointer;">👥 Victims</button>
                        <button onclick="showReportSection('wallets')" class="report-tab-btn" style="padding: 10px 20px; background: #f0f0f0; color: #333; border: none; border-radius: 8px 8px 0 0; cursor: pointer;">💼 All Wallets</button>
                        <button onclick="showReportSection('terminals')" class="report-tab-btn" style="padding: 10px 20px; background: #f0f0f0; color: #333; border: none; border-radius: 8px 8px 0 0; cursor: pointer;">🏦 Exchanges</button>
                        <button onclick="showReportSection('redwallets')" class="report-tab-btn" style="padding: 10px 20px; background: #f0f0f0; color: #333; border: none; border-radius: 8px 8px 0 0; cursor: pointer;">🚨 Red Wallets</button>
                    </div>

                    <!-- Report Sections -->
                    <div id="narrative-section" class="report-section" style="display: block;">
                        <h3>📖 Narrative Report</h3>
                        <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; max-height: 500px; overflow-y: auto;">
                            ${narrativeReport}
                        </div>
                    </div>

                    <div id="victims-section" class="report-section" style="display: none;">
                        <h3>👥 Victim Index</h3>
                        <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; max-height: 500px; overflow-y: auto;">
                            ${victimIndex}
                        </div>
                    </div>

                    <div id="wallets-section" class="report-section" style="display: none;">
                        <h3>💼 Universal Wallet Index</h3>
                        <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; max-height: 500px; overflow-y: auto;">
                            ${walletIndex}
                        </div>
                    </div>

                    <div id="terminals-section" class="report-section" style="display: none;">
                        <h3>🏦 Terminal Wallet Report</h3>
                        <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; max-height: 500px; overflow-y: auto;">
                            ${terminalReport}
                        </div>
                    </div>

                    <div id="redwallets-section" class="report-section" style="display: none;">
                        <h3>🚨 Red Wallet Index</h3>
                        <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; max-height: 500px; overflow-y: auto;">
                            ${redWalletIndex}
                        </div>
                    </div>

                    <!-- Export Buttons -->
                    <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #e0e0e0; display: flex; gap: 10px; justify-content: center;">
                        <button onclick="exportComprehensiveReport('pdf')" class="btn btn-primary">📄 Export as PDF</button>
                        <button onclick="exportComprehensiveReport('html')" class="btn btn-success">🌐 Export as HTML</button>
                        <button onclick="copyComprehensiveReport()" class="btn btn-info">📋 Copy to Clipboard</button>
                        <button onclick="printComprehensiveReport()" class="btn btn-secondary">🖨️ Print Report</button>
                    </div>
                </div>
            `;

            modal.appendChild(content);
            document.body.appendChild(modal);

            // Add styles for tab switching
            const style = document.createElement('style');
            style.textContent = `
                .report-tab-btn.active {
                    background: #667eea !important;
                    color: white !important;
                }
                .report-section {
                    animation: fadeIn 0.3s ease;
                }
                @keyframes fadeIn {
                    from { opacity: 0; }
                    to { opacity: 1; }
                }
            `;
            document.head.appendChild(style);
        }

        // Function to switch between report sections
        window.showReportSection = function(section) {
            // Hide all sections
            document.querySelectorAll('.report-section').forEach(s => s.style.display = 'none');
            // Show selected section
            document.getElementById(`${section}-section`).style.display = 'block';
            // Update tab buttons
            document.querySelectorAll('.report-tab-btn').forEach(btn => {
                btn.classList.remove('active');
                btn.style.background = '#f0f0f0';
                btn.style.color = '#333';
            });
            event.target.classList.add('active');
            event.target.style.background = '#667eea';
            event.target.style.color = 'white';
        };

        // Export comprehensive report function
        window.exportComprehensiveReport = function(format) {
            const allReports = {
                narrative: generateNarrativeReport(),
                victims: generateVictimIndex(),
                wallets: generateUniversalWalletIndex(),
                terminals: generateTerminalWalletReport(),
                redWallets: generateRedWalletIndex()
            };

            if (format === 'html') {
                const htmlContent = `
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <title>BATS Investigation Report - ${investigation.metadata?.caseNumber || 'Investigation'}</title>
                        <style>
                            body { font-family: Arial, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; }
                            h1 { color: #667eea; }
                            h2 { color: #764ba2; border-bottom: 2px solid #e0e0e0; padding-bottom: 10px; }
                            .section { margin-bottom: 40px; }
                            table { width: 100%; border-collapse: collapse; }
                            th, td { padding: 8px; text-align: left; border: 1px solid #ddd; }
                            th { background: #f0f0f0; }
                        </style>
                    </head>
                    <body>
                        <h1>Comprehensive Investigation Report</h1>
                        <div class="section">
                            <h2>Narrative Report</h2>
                            ${allReports.narrative}
                        </div>
                        <div class="section">
                            <h2>Victim Index</h2>
                            ${allReports.victims}
                        </div>
                        <div class="section">
                            <h2>Universal Wallet Index</h2>
                            ${allReports.wallets}
                        </div>
                        <div class="section">
                            <h2>Terminal Wallet Report</h2>
                            ${allReports.terminals}
                        </div>
                        <div class="section">
                            <h2>Red Wallet Index</h2>
                            ${allReports.redWallets}
                        </div>
                    </body>
                    </html>
                `;
                const blob = new Blob([htmlContent], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `BATS_Report_${investigation.metadata?.caseNumber || 'Investigation'}_${new Date().toISOString().split('T')[0]}.html`;
                a.click();
            } else if (format === 'pdf') {
                alert('PDF export requires print functionality. Please use Print Report and select "Save as PDF" in the print dialog.');
            }
        };

        // Copy comprehensive report to clipboard
        window.copyComprehensiveReport = function() {
            const allReports = `
COMPREHENSIVE INVESTIGATION REPORT
Generated: ${new Date().toISOString()}

=== NARRATIVE REPORT ===
${generateNarrativeReport().replace(/<[^>]*>/g, '')}

=== VICTIM INDEX ===
${generateVictimIndex().replace(/<[^>]*>/g, '')}

=== UNIVERSAL WALLET INDEX ===
${generateUniversalWalletIndex().replace(/<[^>]*>/g, '')}

=== TERMINAL WALLET REPORT ===
${generateTerminalWalletReport().replace(/<[^>]*>/g, '')}

=== RED WALLET INDEX ===
${generateRedWalletIndex().replace(/<[^>]*>/g, '')}
            `;
            navigator.clipboard.writeText(allReports);
            alert('Comprehensive report copied to clipboard!');
        };

        // Print comprehensive report
        window.printComprehensiveReport = function() {
            const printWindow = window.open('', '_blank');
            const allReports = {
                narrative: generateNarrativeReport(),
                victims: generateVictimIndex(),
                wallets: generateUniversalWalletIndex(),
                terminals: generateTerminalWalletReport(),
                redWallets: generateRedWalletIndex()
            };

            printWindow.document.write(`
                <!DOCTYPE html>
                <html>
                <head>
                    <title>BATS Investigation Report</title>
                    <style>
                        body { font-family: Arial, sans-serif; }
                        h1, h2 { color: #333; }
                        table { width: 100%; border-collapse: collapse; margin-bottom: 20px; }
                        th, td { padding: 8px; text-align: left; border: 1px solid #ddd; }
                        th { background: #f0f0f0; }
                        .section { margin-bottom: 40px; page-break-inside: avoid; }
                    </style>
                </head>
                <body>
                    <h1>Comprehensive Investigation Report</h1>
                    <div class="section">
                        <h2>Narrative Report</h2>
                        ${allReports.narrative}
                    </div>
                    <div class="section">
                        <h2>Victim Index</h2>
                        ${allReports.victims}
                    </div>
                    <div class="section">
                        <h2>Universal Wallet Index</h2>
                        ${allReports.wallets}
                    </div>
                    <div class="section">
                        <h2>Terminal Wallet Report</h2>
                        ${allReports.terminals}
                    </div>
                    <div class="section">
                        <h2>Red Wallet Index</h2>
                        ${allReports.redWallets}
                    </div>
                </body>
                </html>
            `);
            printWindow.document.close();
            printWindow.print();
        };

        function generateNarrativeReport() {
            const reportDate = new Date().toISOString().split('T')[0];
            const reportTime = new Date().toISOString().split('T')[1].replace('.000Z', ' UTC');

            // Helper function to format currency amounts
            const formatAmount = (amount, currency) => {
                const val = parseFloat(amount);
                return `${val.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 6 })} ${currency}`;
            };

            // Helper function to format wallet addresses
            const formatWallet = (address) => {
                if (!address) return 'N/A';
                return `${address.substring(0, 10)}...${address.substring(address.length - 8)}`;
            };

            // Build victim narrative section
            const victimNarratives = investigation.victims.map(victim => {
                const totalLoss = parseFloat(victim.totalLoss);
                const transactions = victim.transactions.map(tx => {
                    const currency = tx.currency === 'CUSTOM' ? tx.customCurrency : tx.currency;
                    return `Transaction ${tx.id} occurred on ${formatDateTimeForReport(tx.datetime, tx.timezone || 'UTC')}, ` +
                           `transferring ${formatAmount(tx.amount, currency)} to wallet ${formatWallet(tx.receivingWallet)}` +
                           (tx.notes ? `. ${tx.notes}` : '.');
                }).join(' ');

                return `<p><strong>Victim ${victim.id}: ${victim.name}</strong><br/>
                Contact: ${victim.contactInfo}<br/>
                Total Loss: ${formatAmount(totalLoss, 'USD equivalent')}<br/>
                ${victim.notes ? `Background: ${victim.notes}<br/>` : ''}
                <br/>
                ${transactions}</p>`;
            }).join('\n');

            // Build hop-by-hop narrative
            let hopNarratives = '';
            let previousWallets = new Set();

            investigation.hops.forEach(hop => {
                const hopART = hop.artAtStartByCurrency || {};
                const hopStartAmounts = Object.entries(hopART).map(([currency, amount]) =>
                    formatAmount(amount, currency)
                ).join(', ');

                hopNarratives += `<h3>Hop ${hop.hopNumber}: Movement Analysis</h3>\n`;
                hopNarratives += `<p><em>Starting ART (Adjusted Root Total): ${hopStartAmounts}</em></p>\n`;

                const narrativeEntries = hop.entries.map(entry => {
                    let narrative = '';
                    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                    const amount = formatAmount(entry.amount, currency);

                    if (entry.entryType === 'trace') {
                        const walletType = walletTypes[entry.toWalletType] || entry.toWalletType;
                        narrative = `On ${formatDateTimeForReport(entry.timestamp, entry.timezone || 'UTC')}, ` +
                                  `traced funds totaling ${amount} moving from wallet ${formatWallet(entry.fromWallet)} ` +
                                  `to wallet ${formatWallet(entry.toWallet)} (classified as ${walletType}). ` +
                                  `Transaction hash: ${entry.txHash || 'Not provided'}. `;

                        if (entry.isTerminalWallet) {
                            const exchangeName = entry.exchangeName || 'Unknown Exchange';
                            narrative += `<strong>TERMINAL WALLET DETECTED:</strong> These funds have arrived at ${exchangeName}. `;
                        }

                        if (entry.notes) {
                            narrative += `<em>Investigator's notes: ${entry.notes}</em> `;
                        }
                    } else if (entry.entryType === 'swap') {
                        const outputAmount = formatAmount(entry.outputAmount || entry.swapDetails?.toAmount,
                                                         entry.outputCurrency || entry.swapDetails?.toCurrency);
                        const dexName = entry.swapDetails?.dexName || 'Unknown DEX';

                        narrative = `On ${formatDateTimeForReport(entry.timestamp, entry.timezone || 'UTC')}, ` +
                                  `observed a currency swap on ${dexName} converting ${amount} to ${outputAmount}. ` +
                                  `The swap occurred within wallet ${formatWallet(entry.fromWallet)}. ` +
                                  `Transaction hash: ${entry.txHash || 'Not provided'}. `;

                        if (entry.notes) {
                            narrative += `<em>Investigator's notes: ${entry.notes}</em> `;
                        }
                    } else if (entry.entryType === 'writeoff') {
                        const category = entry.category || 'unspecified';
                        narrative = `Write-off documented: ${amount} marked as unrecoverable (Category: ${category}). ` +
                                  `Justification: ${entry.justification || 'No justification provided'}. `;

                        if (entry.notes) {
                            narrative += `<em>Additional notes: ${entry.notes}</em> `;
                        }
                    } else if (entry.entryType === 'cold_storage') {
                        narrative = `Cold storage identified: ${amount} moved to cold storage wallet ${formatWallet(entry.toWallet)}. ` +
                                  `Transaction hash: ${entry.txHash || 'Not provided'}. `;

                        if (entry.notes) {
                            narrative += `<em>Investigator's notes: ${entry.notes}</em> `;
                        }
                    }

                    // Add source thread information
                    if (entry.sourceThreadId) {
                        narrative += `[Source: Thread ${entry.sourceThreadId}] `;
                    }

                    return `<p>${narrative}</p>`;
                }).join('\n');

                hopNarratives += narrativeEntries;

                if (hop.completed) {
                    hopNarratives += `<p><strong>Hop ${hop.hopNumber} Status:</strong> COMPLETED</p>\n`;
                } else {
                    hopNarratives += `<p><strong>Hop ${hop.hopNumber} Status:</strong> IN PROGRESS</p>\n`;
                }

                hopNarratives += '<hr/>\n';
            });

            // Build terminal wallet summary
            let terminalWalletNarrative = '';
            if (investigation.terminalWalletIndex && investigation.terminalWalletIndex.length > 0) {
                const groupedByExchange = {};
                investigation.terminalWalletIndex.forEach(terminal => {
                    const exchange = terminal.exchangeName || 'Unknown Exchange';
                    if (!groupedByExchange[exchange]) {
                        groupedByExchange[exchange] = [];
                    }
                    groupedByExchange[exchange].push(terminal);
                });

                terminalWalletNarrative = '<h2>Terminal Wallet Analysis</h2>\n';
                terminalWalletNarrative += '<p>The following funds have been traced to cryptocurrency exchanges where legal process may be required for recovery:</p>\n';

                Object.entries(groupedByExchange).forEach(([exchange, terminals]) => {
                    const totalByExchange = {};
                    terminals.forEach(t => {
                        if (!totalByExchange[t.currency]) {
                            totalByExchange[t.currency] = 0;
                        }
                        totalByExchange[t.currency] += parseFloat(t.amount);
                    });

                    terminalWalletNarrative += `<h3>${exchange}</h3>\n`;
                    terminalWalletNarrative += '<ul>\n';

                    terminals.forEach(terminal => {
                        terminalWalletNarrative += `<li>${formatDateTimeForReport(terminal.timestamp, 'UTC')}: ` +
                                                  `${formatAmount(terminal.amount, terminal.currency)} ` +
                                                  `received at wallet ${formatWallet(terminal.toWallet)} ` +
                                                  `(Transaction: ${terminal.txHash})</li>\n`;
                    });

                    terminalWalletNarrative += '</ul>\n';
                    terminalWalletNarrative += '<p><strong>Total at ' + exchange + ':</strong> ';
                    terminalWalletNarrative += Object.entries(totalByExchange).map(([curr, amt]) =>
                        formatAmount(amt, curr)
                    ).join(', ');
                    terminalWalletNarrative += '</p>\n';
                });
            }

            // Build investigation summary
            const rootTotalsByCurrency = investigation.confirmedRootTotalsByCurrency || {};
            const summaryByCurrency = Object.entries(rootTotalsByCurrency).map(([currency, amount]) => {
                return formatAmount(amount, currency);
            }).join(', ');

            // Calculate total traced and write-offs
            let tracedByCurrency = {};
            let writeoffByCurrency = {};

            investigation.hops.forEach(hop => {
                hop.entries.forEach(entry => {
                    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                    if (entry.entryType === 'trace' && entry.isTerminalWallet) {
                        if (!tracedByCurrency[currency]) tracedByCurrency[currency] = 0;
                        tracedByCurrency[currency] += parseFloat(entry.amount);
                    } else if (entry.entryType === 'writeoff') {
                        if (!writeoffByCurrency[currency]) writeoffByCurrency[currency] = 0;
                        writeoffByCurrency[currency] += parseFloat(entry.amount);
                    }
                });
            });

            // Generate the full Word-compatible HTML report
            return `<!DOCTYPE html>
<html xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:w="urn:schemas-microsoft-com:office:word" xmlns:m="http://schemas.microsoft.com/office/2004/12/omml" xmlns="http://www.w3.org/TR/REC-html40">
<head>
    <meta charset="UTF-8">
    <title>B.A.T.S. Investigation Narrative Report - ${investigation.caseId}</title>
    <style>
        @page {
            size: 8.5in 11in;
            margin: 1in;
        }
        body {
            font-family: 'Times New Roman', serif;
            font-size: 12pt;
            line-height: 1.5;
            color: #000000;
            background: white;
            margin: 0;
            padding: 20px;
        }
        h1 {
            font-size: 18pt;
            text-align: center;
            margin-bottom: 12pt;
            font-weight: bold;
            text-transform: uppercase;
        }
        h2 {
            font-size: 14pt;
            margin-top: 18pt;
            margin-bottom: 12pt;
            font-weight: bold;
            border-bottom: 2px solid #000;
            padding-bottom: 4pt;
        }
        h3 {
            font-size: 12pt;
            margin-top: 12pt;
            margin-bottom: 8pt;
            font-weight: bold;
            font-style: italic;
        }
        p {
            margin: 8pt 0;
            text-align: justify;
        }
        .header-info {
            text-align: center;
            margin-bottom: 24pt;
            border: 2px solid #000;
            padding: 12pt;
        }
        .header-info p {
            margin: 4pt 0;
            text-align: center;
        }
        strong {
            font-weight: bold;
        }
        em {
            font-style: italic;
            color: #444;
        }
        ul {
            margin-left: 24pt;
        }
        li {
            margin: 6pt 0;
        }
        hr {
            border: none;
            border-top: 1px solid #ccc;
            margin: 12pt 0;
        }
        .executive-summary {
            background: #f5f5f5;
            border: 1px solid #ccc;
            padding: 12pt;
            margin: 18pt 0;
        }
        .conclusion {
            margin-top: 24pt;
            padding-top: 12pt;
            border-top: 2px solid #000;
        }
        @media print {
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <h1>B.A.T.S. CRYPTOCURRENCY INVESTIGATION<br/>NARRATIVE REPORT</h1>

    <div class="header-info">
        <p><strong>CASE IDENTIFIER:</strong> ${investigation.caseId}</p>
        <p><strong>CASE TITLE:</strong> ${investigation.caseTitle || 'Cryptocurrency Fraud Investigation'}</p>
        <p><strong>LEAD INVESTIGATOR:</strong> ${investigation.investigator}</p>
        <p><strong>INVESTIGATION PERIOD:</strong> ${new Date(investigation.startDate || investigation.created).toLocaleDateString()} - ${new Date().toLocaleDateString()}</p>
        <p><strong>REPORT GENERATED:</strong> ${reportDate} at ${reportTime}</p>
        <p><strong>CLASSIFICATION:</strong> ${investigation.caseType || 'Financial Crime Investigation'}</p>
    </div>

    <div class="executive-summary">
        <h2>EXECUTIVE SUMMARY</h2>
        <p>This report documents the comprehensive blockchain analysis conducted as part of investigation ${investigation.caseId}.
        The investigation encompasses ${investigation.victims.length} victim(s) with confirmed losses totaling ${summaryByCurrency}.
        Through systematic application of the Block Audit Tracing Standard (B.A.T.S.) methodology,
        ${investigation.hops.length} transaction hops were analyzed to trace the movement of stolen cryptocurrency assets.</p>

        ${investigation.caseSynopsis ? `
        <p><strong>Case Synopsis:</strong><br/>
        ${investigation.caseSynopsis.replace(/\n/g, '<br/>')}</p>
        ` : ''}
    </div>

    <h2>SECTION 1: VICTIM IMPACT ASSESSMENT</h2>
    ${victimNarratives}

    <div class="page-break"></div>

    <h2>SECTION 2: BLOCKCHAIN TRANSACTION ANALYSIS</h2>
    <p>The following section provides a detailed chronological narrative of all cryptocurrency movements identified during the investigation.
    Each "hop" represents a distinct phase in the money laundering chain, with funds being transferred between different blockchain addresses
    in an attempt to obfuscate their origin.</p>

    ${hopNarratives}

    ${terminalWalletNarrative}

    <div class="page-break"></div>

    <h2>SECTION 3: FINANCIAL RECONCILIATION</h2>

    <h3>Root Total Analysis</h3>
    <p>The confirmed root total for this investigation is: <strong>${summaryByCurrency}</strong></p>

    ${Object.keys(tracedByCurrency).length > 0 ? `
    <h3>Funds Successfully Traced to Exchanges</h3>
    <ul>
        ${Object.entries(tracedByCurrency).map(([currency, amount]) =>
            `<li>${formatAmount(amount, currency)}</li>`
        ).join('\n')}
    </ul>
    ` : ''}

    ${Object.keys(writeoffByCurrency).length > 0 ? `
    <h3>Unrecoverable Funds (Write-offs)</h3>
    <ul>
        ${Object.entries(writeoffByCurrency).map(([currency, amount]) =>
            `<li>${formatAmount(amount, currency)}</li>`
        ).join('\n')}
    </ul>
    ` : ''}

    <div class="conclusion">
        <h2>SECTION 4: INVESTIGATIVE CONCLUSIONS</h2>

        <p>This investigation has successfully traced cryptocurrency transactions through ${investigation.hops.length} distinct hops,
        documenting the flow of funds from initial victim deposits through various intermediary wallets
        ${investigation.terminalWalletIndex && investigation.terminalWalletIndex.length > 0 ?
            `to their current location at identified cryptocurrency exchange(s)` :
            'to their current locations'}.</p>

        ${investigation.terminalWalletIndex && investigation.terminalWalletIndex.length > 0 ? `
        <h3>Recommended Legal Actions</h3>
        <p>Based on the terminal wallet analysis, the following legal processes are recommended:</p>
        <ol>
            <li><strong>Immediate Asset Preservation:</strong> Issue preservation orders to identified exchanges to prevent withdrawal of traced funds.</li>
            <li><strong>Subpoena Requirements:</strong> Obtain court orders for KYC (Know Your Customer) information from exchanges holding terminal wallets.</li>
            <li><strong>International Cooperation:</strong> If exchanges operate in foreign jurisdictions, coordinate with appropriate international law enforcement agencies.</li>
            <li><strong>Civil Recovery:</strong> Initiate civil asset recovery proceedings based on the documented fund flow.</li>
        </ol>
        ` : ''}

        <h3>Methodology Statement</h3>
        <p>All blockchain analysis was conducted using industry-standard forensic techniques and the B.A.T.S. (Block Audit Tracing Standard) methodology.
        Transaction data was verified against multiple blockchain explorers and validated through mathematical reconciliation.
        This report represents a true and accurate accounting of cryptocurrency movements as recorded on the relevant blockchain(s).</p>

        <h3>Certification</h3>
        <p>I, ${investigation.investigator}, certify that the information contained in this report is true and accurate to the best of my knowledge,
        based on blockchain data available as of ${reportDate}. This report was generated using validated blockchain forensic methodologies
        and may be used for legal proceedings, regulatory compliance, and asset recovery efforts.</p>

        <br/><br/>
        <p>_________________________________<br/>
        ${investigation.investigator}<br/>
        Lead Investigator<br/>
        ${reportDate}</p>
    </div>

    <div style="margin-top: 40pt; padding-top: 20pt; border-top: 1px solid #ccc; font-size: 10pt; color: #666;">
        <p><em>This report was generated using the B.A.T.S. Tool - Block Audit Tracing Standard<br/>
        Report Version: 1.0 | Tool Version: ${investigation.version || '2.0'}<br/>
        All timestamps are in ${investigation.defaultTimezone || 'UTC'} unless otherwise specified</em></p>
    </div>
</body>
</html>`;
        }
// =================================
// PART 4: ENHANCED EXPORT FUNCTIONS
// Add these functions to your existing JavaScript
// =================================

function generateSourceChainReport() {
    console.log(' Generating source chain report...');
    
    const report = {
        timestamp: new Date().toISOString(),
        caseId: investigation.caseId,
        investigator: investigation.investigator,
        sourceChains: [],
        statistics: {
            totalChains: 0,
            totalConvergences: 0,
            totalSingleSource: 0,
            currenciesAnalyzed: new Set()
        }
    };
    
    // Analyze source chains for each trace entry
    investigation.hops.forEach(hop => {
        hop.entries.forEach(entry => {
            if (entry.entryType === 'trace' && entry.sourceChain && entry.sourceChain.length > 0) {
                const chainAnalysis = {
                    notation: entry.notation,
                    hopNumber: entry.hopNumber,
                    targetAmount: parseFloat(entry.amount),
                    currency: entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency,
                    sourceCount: entry.sourceChain.length,
                    isConvergence: entry.sourceChain.length > 1,
                    sources: entry.sourceChain.map(source => ({
                        sourceNotation: source.sourceNotation,
                        amount: source.amount,
                        percentage: (source.amount / parseFloat(entry.amount)) * 100,
                        currency: source.currency
                    })),
                    displayNotation: entry.displayNotation || '',
                    summaryNotation: entry.summaryNotation || '',
                    toWallet: entry.toWallet,
                    toWalletType: entry.toWalletType
                };
                
                report.sourceChains.push(chainAnalysis);
                report.statistics.totalChains++;
                report.statistics.currenciesAnalyzed.add(chainAnalysis.currency);
                
                if (chainAnalysis.isConvergence) {
                    report.statistics.totalConvergences++;
                } else {
                    report.statistics.totalSingleSource++;
                }
            }
        });
    });
    
    // Convert Set to Array for JSON serialization
    report.statistics.currenciesAnalyzed = Array.from(report.statistics.currenciesAnalyzed);
    
    // Store the report
    investigation.sourceChainReports.push(report);
    
    console.log(' Source chain report generated:', report);
    return report;
}

function exportEnhancedReport() {
    console.log('Generating enhanced B.A.T.S. report...');
    
    // Run latest validation
    const validationResults = validateTracesEnhanced();
    
    // Generate source chain report
    const sourceChainReport = generateSourceChainReport();
    
    // Generate enhanced HTML report
    const enhancedReport = generateEnhancedBATSReport(validationResults, sourceChainReport);
    
    const filename = `Enhanced_BATS_Report_${investigation.caseId || 'Investigation'}_${new Date().toISOString().slice(0,10)}.html`;
    downloadFile(enhancedReport, filename, 'text/html');
}

function exportSourceChainReport() {
    const sourceChainReport = generateSourceChainReport();
    const filename = `Source_Chain_Analysis_${investigation.caseId || 'Investigation'}_${new Date().toISOString().slice(0,10)}.json`;
    downloadFile(JSON.stringify(sourceChainReport, null, 2), filename, 'application/json');
}

function generateEnhancedBATSReport(validationResults, sourceChainReport) {
    const timestamp = new Date().toLocaleString();
    
    return `<!DOCTYPE html>
<html>
<head>
    <title>Enhanced B.A.T.S. Investigation Report - ${investigation.caseId}</title>
    <style>
        body { font-family: 'Segoe UI', Arial, sans-serif; margin: 40px; line-height: 1.6; color: #2c3e50; }
        .header { text-align: center; border-bottom: 3px solid #2c3e50; padding-bottom: 20px; margin-bottom: 30px; }
        .section { margin: 30px 0; }
        .section-title { background: #2c3e50; color: white; padding: 15px; margin-bottom: 20px; font-weight: 600; }
        .enhanced-section { background: #3498db; color: white; padding: 15px; margin-bottom: 20px; font-weight: 600; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        th, td { border: 1px solid #ddd; padding: 12px; text-align: left; }
        th { background: #f8f9fa; font-weight: bold; color: #2c3e50; }
        .summary-box { background: #e8f5e8; border: 2px solid #27ae60; padding: 20px; margin: 20px 0; border-radius: 8px; }
        .warning-box { background: #fff3cd; border: 2px solid #ffc107; padding: 20px; margin: 20px 0; border-radius: 8px; }
        .error-box { background: #f8d7da; border: 2px solid #dc3545; padding: 20px; margin: 20px 0; border-radius: 8px; }
        .currency-section { background: #f8f9fa; border: 1px solid #ddd; padding: 15px; margin: 10px 0; border-radius: 6px; }
        .thread-analysis { background: #e8f4f8; border: 1px solid #3498db; padding: 15px; margin: 10px 0; border-radius: 6px; }
        .source-chain { font-family: 'Courier New', monospace; background: #f8f9fa; padding: 10px; border-radius: 4px; margin: 5px 0; }
        .convergence { background: #fff3cd; border-left: 4px solid #ffc107; padding: 10px; margin: 5px 0; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Enhanced B.A.T.S. Investigation Report</h1>
        <h2>Block Audit Tracing Standard - Phase 3 Complete Integration</h2>
        <p><strong>Case ID:</strong> ${investigation.caseId}</p>
        <p><strong>Investigator:</strong> ${investigation.investigator}</p>
        <p><strong>Report Generated:</strong> ${timestamp}</p>
        <p><strong>Integration Version:</strong> ${investigation.integrationVersion}</p>
    </div>

    <div class="section">
        <div class="enhanced-section">Section 1: Enhanced Validation Results</div>
        ${validationResults.overall ? 
            '<div class="summary-box"><h3>✅ Validation Status: PASSED</h3><p>All mathematical balances verified, thread assignments validated, source chains confirmed.</p></div>' :
            '<div class="error-box"><h3>❌ Validation Status: FAILED</h3><p>Critical errors detected in thread tracking or mathematical balance.</p></div>'
        }
        
        <h3>Thread Analysis by Currency</h3>
        ${Object.entries(validationResults.threadAnalysis).map(([currency, analysis]) => `
            <div class="thread-analysis">
                <h4>${currency}</h4>
                <p><strong>Total Threads:</strong> ${analysis.totalThreads}</p>
                <p><strong>Total Available:</strong> ${analysis.totalAvailable.toLocaleString()}</p>
                <p><strong>Total Assigned:</strong> ${analysis.totalAssigned.toLocaleString()}</p>
                ${analysis.unassignedThreads.length > 0 ? `<p style="color: #e67e22;"><strong>Unassigned Threads:</strong> ${analysis.unassignedThreads.join(', ')}</p>` : ''}
                ${analysis.overassignedThreads.length > 0 ? `<p style="color: #dc3545;"><strong>Over-assigned Threads:</strong> ${analysis.overassignedThreads.join(', ')}</p>` : ''}
            </div>
        `).join('')}

        <h3>Mathematical Balance Verification</h3>
        ${Object.entries(validationResults.mathematicalBalance).map(([currency, balance]) => `
            <div class="currency-section">
                <h4>${currency}</h4>
                <p><strong>Root Total:</strong> ${balance.rootTotal.toLocaleString()}</p>
                <p><strong>Write-offs:</strong> ${balance.writeoffAmount.toLocaleString()}</p>
                <p><strong>Adjusted Root Total:</strong> ${balance.adjustedRootTotal.toLocaleString()}</p>
                <p><strong>Current Thread Total:</strong> ${balance.currentThreadTotal.toLocaleString()}</p>
                <p><strong>Difference:</strong> ${balance.difference.toLocaleString()}</p>
                <p><strong>Balance Status:</strong> <span style="color: ${balance.isValid ? 'green' : 'red'}; font-weight: bold;">${balance.isValid ? 'BALANCED' : 'IMBALANCED'}</span></p>
            </div>
        `).join('')}
        
        ${validationResults.errors.length > 0 ? `
            <div class="error-box">
                <h3>Validation Errors</h3>
                <ul>
                    ${validationResults.errors.map(error => `<li>${error}</li>`).join('')}
                </ul>
            </div>
        ` : ''}
        
        ${validationResults.warnings.length > 0 ? `
            <div class="warning-box">
                <h3>Validation Warnings</h3>
                <ul>
                    ${validationResults.warnings.map(warning => `<li>${warning}</li>`).join('')}
                </ul>
            </div>
        ` : ''}
    </div>

    <div class="section">
        <div class="enhanced-section">Section 2: Source Chain Analysis</div>
        <div class="summary-box">
            <h3>Source Chain Statistics</h3>
            <p><strong>Total Source Chains:</strong> ${sourceChainReport.statistics.totalChains}</p>
            <p><strong>Single Source Chains:</strong> ${sourceChainReport.statistics.totalSingleSource}</p>
            <p><strong>Convergence Chains:</strong> ${sourceChainReport.statistics.totalConvergences}</p>
            <p><strong>Currencies Analyzed:</strong> ${sourceChainReport.statistics.currenciesAnalyzed.join(', ')}</p>
        </div>
        
        <h3>Detailed Source Chain Documentation</h3>
        <table>
            <tr>
                <th>Target Notation</th>
                <th>Hop</th>
                <th>Source Type</th>
                <th>Source Chain</th>
                <th>Amount</th>
                <th>Currency</th>
                <th>Target Wallet</th>
            </tr>
            ${sourceChainReport.sourceChains.map(chain => `
                <tr>
                    <td><strong>${chain.notation}</strong></td>
                    <td>${chain.hopNumber}</td>
                    <td>${chain.isConvergence ? '<span class="convergence">CONVERGENCE</span>' : 'Single Source'}</td>
                    <td class="source-chain">
                        ${chain.sources.map(source => 
                            `${source.sourceNotation}(${source.amount.toLocaleString()})`
                        ).join(' + ')} ${chain.notation}
                    </td>
                    <td>${chain.targetAmount.toLocaleString()}</td>
                    <td>${chain.currency}</td>
                    <td style="font-family: monospace; font-size: 11px;">${chain.toWallet}</td>
                </tr>
            `).join('')}
        </table>
    </div>

    <div class="section">
        <div class="enhanced-section">Section 3: Investigation Integrity Assessment</div>
        <div class="summary-box">
            <h3>Golden Thread Verification</h3>
            <p>This enhanced B.A.T.S. report includes mathematical thread tracking that ensures every dollar traced can be accounted for from victim loss to final disposition.</p>
            <p><strong>Validation Timestamp:</strong> ${validationResults.timestamp}</p>
            <p><strong>Thread Tracking Status:</strong> ${validationResults.overall ? 'VERIFIED' : 'REQUIRES ATTENTION'}</p>
            <p><strong>Source Chain Completeness:</strong> ${sourceChainReport.statistics.totalChains > 0 ? 'DOCUMENTED' : 'INCOMPLETE'}</p>
        </div>
    </div>
</body>
</html>`;
}

function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            window.URL.revokeObjectURL(url);
        }

        function clearAll() {
            if (confirm('Are you sure you want to clear all data? This cannot be undone.')) {
                investigation = {
                    caseId: '',
                    investigator: '',
                    caseType: '',
                    victims: [],
                    hops: [],
                    conversions: [],
                    redWalletIndex: [],
                    universalWalletIndex: [],
                    rootTotalConfirmed: false,
                    confirmedRootTotal: 0,
                    confirmedRootTotalsByCurrency: {},
                    currentART: {},
                    created: new Date().toISOString()
                };
                renderAll();
                saveToStorage();
                updateWorkflowSteps();
            }
        }

        function renderAll() {
            renderVictims();
            renderHops();
            updateValidationStatus();
            checkOnboardingState();
        }

        // Storage functions
        function saveToStorage() {
            investigation.caseId = document.getElementById('caseId').value;
            investigation.investigator = document.getElementById('investigator').value;
            investigation.caseType = document.getElementById('caseType').value;
            investigation.caseSynopsis = document.getElementById('caseSynopsis').value || '';
            
            window.batsData = investigation;
            updateWorkflowSteps();
        }
        function saveToStorageEnhanced() {
        // Call existing saveToStorage function
        saveToStorage();
    
        // Additional validation for enhanced structure
        const errors = validateEnhancedDataStructure();
        if (errors.length > 0) {
        console.warn('Data structure validation errors:', errors);
         }
    }
        function loadFromStorage() {
            if (window.batsData) {
                investigation = window.batsData;
                
                // Ensure all hops have entries arrays
                if (investigation.hops) {
                    investigation.hops.forEach(hop => {
                        if (!hop.entries) {
                            hop.entries = [];
                        }
                    });
                }
                
                document.getElementById('caseId').value = investigation.caseId || '';
                document.getElementById('investigator').value = investigation.investigator || '';
                document.getElementById('caseType').value = investigation.caseType || '';
                document.getElementById('caseSynopsis').value = investigation.caseSynopsis || '';
            }
        }

        // Close modals when clicking outside
        window.onclick = function(event) {
            const modals = ['rootTotalModal', 'convergenceModal', 'assetConversionModal', 'excelImportModal'];
            modals.forEach(modalId => {
                const modal = document.getElementById(modalId);
                if (event.target == modal) {
                    modal.style.display = 'none';
                }
            });
        }

        // Excel Import Functions
        let parsedExcelData = null;

        function importExcelTraces(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    let data;
                    if (file.name.endsWith('.csv')) {
                        data = parseCSV(e.target.result);
                    } else {
                        // For Excel files, we'll need to handle this differently
                        // For now, show instructions for CSV format
                        alert('Please export your data as CSV format. Excel support coming soon!');
                        return;
                    }
                    
                    if (data && data.length > 0) {
                        parsedExcelData = data;
                        showImportPreview(data);
                        showModal('excelImportModal');
                    } else {
                        alert('No valid data found in file. Please check the format.');
                    }
                } catch (error) {
                    alert('Error reading file: ' + error.message);
                }
            };
            
            if (file.name.endsWith('.csv')) {
                reader.readAsText(file);
            } else {
                reader.readAsArrayBuffer(file);
            }
        }

        function parseCSV(csvText) {
            const lines = csvText.split('\n').map(line => line.trim()).filter(line => line);
            if (lines.length < 2) return [];
            
            const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
            const data = [];
            
            // Expected headers
            const expectedHeaders = ['hop_notation', 'wallet_address', 'wallet_id', 'amount', 'currency'];
            const headerMap = {};
            
            // Map headers to expected format
            expectedHeaders.forEach(expected => {
                const found = headers.find(h => 
                    h.includes(expected.replace('_', '')) || 
                    h.includes(expected) ||
                    (expected === 'hop_notation' && (h.includes('notation') || h.includes('hop'))) ||
                    (expected === 'wallet_address' && (h.includes('address') || h.includes('wallet'))) ||
                    (expected === 'wallet_id' && h.includes('id')) ||
                    (expected === 'amount' && h.includes('amount')) ||
                    (expected === 'currency' && h.includes('currency'))
                );
                if (found) {
                    headerMap[expected] = headers.indexOf(found);
                }
            });
            
            // Parse data rows
            for (let i = 1; i < lines.length; i++) {
                const row = lines[i].split(',').map(cell => cell.trim().replace(/"/g, ''));
                if (row.length >= 5) {
                    const entry = {
                        hopNotation: row[headerMap.hop_notation] || '',
                        walletAddress: row[headerMap.wallet_address] || '',
                        walletId: row[headerMap.wallet_id] || '',
                        amount: parseFloat(row[headerMap.amount]) || 0,
                        currency: row[headerMap.currency] || 'USD'
                    };
                    
                    if (entry.hopNotation && entry.walletAddress && entry.amount > 0) {
                        data.push(entry);
                    }
                }
            }
            
            return data;
        }

        function showImportPreview(data) {
            const victims = new Set();
            const wallets = new Set();
            const currencies = new Set();
            let totalEntries = data.length;
            let errors = [];
            
            // Analyze the data
            data.forEach((entry, index) => {
                // Extract victim info
                const match = entry.hopNotation.match(/^V(\d+)-T(\d+)/);
                if (match) {
                    victims.add(`V${match[1]}-T${match[2]}`);
                }
                
                wallets.add(entry.walletId);
                currencies.add(entry.currency);
                
                // Validate wallet ID format
                if (!entry.walletId.match(/^(RED|BLACK|BLUE|PURPLE|YELLOW|ORANGE|BROWN|PINK|GRAY|GREEN)\d+$/i)) {
                    errors.push(`Row ${index + 2}: Invalid wallet ID format "${entry.walletId}"`);
                }
            });
            
            // Show summary
            const summary = `
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;">
                    <div><strong>Total Entries:</strong> ${totalEntries}</div>
                    <div><strong>Victim Transactions:</strong> ${victims.size}</div>
                    <div><strong>Unique Wallets:</strong> ${wallets.size}</div>
                    <div><strong>Currencies:</strong> ${Array.from(currencies).join(', ')}</div>
                </div>
                <div style="margin-top: 15px;">
                    <strong>Victims Found:</strong> ${Array.from(victims).join(', ')}
                </div>
            `;
            
            document.getElementById('importSummary').innerHTML = summary;
            document.getElementById('importPreview').style.display = 'block';
            
            if (errors.length > 0) {
                document.getElementById('importErrors').innerHTML = `
                    <div style="background: #fdf2f2; border: 2px solid #e74c3c; border-radius: 6px; padding: 15px; margin-bottom: 15px;">
                        <h4 style="color: #c0392b; margin-bottom: 10px;">⚠️ Validation Errors</h4>
                        ${errors.map(error => `<div style="color: #c0392b; margin-bottom: 5px;">• ${error}</div>`).join('')}
                    </div>
                `;
                document.getElementById('importErrors').style.display = 'block';
            } else {
                document.getElementById('importErrors').style.display = 'none';
                document.getElementById('confirmImportBtn').style.display = 'inline-block';
            }
        }

        function confirmExcelImport() {
            if (!parsedExcelData) return;
            
            try {
                // Clear existing data
                investigation = {
                    caseId: '',
                    investigator: '',
                    caseType: '',
                    victims: [],
                    hops: [],
                    conversions: [],
                    redWalletIndex: [],
                    universalWalletIndex: [],
                    rootTotalConfirmed: false,
                    confirmedRootTotal: 0,
                    confirmedRootTotalsByCurrency: {},
                    currentART: {},
                    created: new Date().toISOString()
                };
                
                // Process the imported data
                processImportedData(parsedExcelData);
                
                // Check chronological order of imported transactions
                const chronologyErrors = [];
                investigation.victims.forEach(victim => {
                    const error = validateTransactionChronology(victim);
                    if (error) {
                        chronologyErrors.push(`Victim ${victim.id}:\n${error}`);
                    }
                });
                
                // Update UI
                renderAll();
                updateWorkflowSteps();
                
                closeExcelImportModal();
                
                // Show success message with chronology warning if needed
                if (chronologyErrors.length > 0) {
                    const shouldFix = confirm(`⚠️ Import Successful with Warnings!\n\nImported ${parsedExcelData.length} entries, but transaction chronology issues were detected:\n\n${chronologyErrors.join('\n\n')}\n\nThe V-T notation requires transactions to be numbered in chronological order.\n\nWould you like to automatically fix the order?\n\nClick OK to reorder transactions chronologically.\nClick Cancel to fix manually later.`);
                    
                    if (shouldFix) {
                        // Fix order for all victims with errors
                        investigation.victims.forEach(victim => {
                            const error = validateTransactionChronology(victim);
                            if (error) {
                                fixVictimTransactionOrder(victim.id);
                            }
                        });
                        alert(` Transactions have been reordered chronologically!`);
                    }
                } else {
                    alert(`Successfully imported ${parsedExcelData.length} entries! Please review and confirm your root total.`);
                }
                
                // Clear the file input
                document.getElementById('excelInput').value = '';
                
            } catch (error) {
                alert('Error processing import: ' + error.message);
            }
        }

        function processImportedData(data) {
            const victimMap = new Map();
            const hopMap = new Map();
            
            // First pass: identify victims and transactions
            data.forEach(entry => {
                const match = entry.hopNotation.match(/^V(\d+)-T(\d+)(?:-H(\d+))?$/);
                if (match) {
                    const victimId = parseInt(match[1]);
                    const transactionId = parseInt(match[2]);
                    const hopNumber = match[3] ? parseInt(match[3]) : 0;
                    
                    if (hopNumber === 0) {
                        // This is a victim transaction
                        if (!victimMap.has(victimId)) {
                            victimMap.set(victimId, {
                                id: victimId,
                                transactions: []
                            });
                        }
                        
                        const victim = victimMap.get(victimId);
                        victim.transactions.push({
                            id: transactionId,
                            amount: entry.amount.toString(),
                            currency: entry.currency,
                            customCurrency: '',
                            receivingWallet: entry.walletAddress,
                            datetime: '',
                            timezone: 'UTC',
                            notes: `Imported from trace data`
                        });
                    } else {
                        // This is a hop entry
                        const hopKey = `${victimId}-${transactionId}-${hopNumber}`;
                        if (!hopMap.has(hopNumber)) {
                            hopMap.set(hopNumber, {
                                id: hopNumber,
                                hopNumber: hopNumber,
                                entries: [],
                                artAtStartByCurrency: {},
                                completed: false
                            });
                        }
                        
                        const hop = hopMap.get(hopNumber);
                        
                        // Find the source wallet from previous hop or victim transaction
                        let fromWallet = '';
                        if (hopNumber === 1) {
                            // Source is the victim transaction wallet
                            fromWallet = data.find(d => d.hopNotation === `V${victimId}-T${transactionId}`)?.walletAddress || '';
                        } else {
                            // Source is from previous hop
                            const prevEntry = data.find(d => d.hopNotation === `V${victimId}-T${transactionId}-H${hopNumber-1}`);
                            fromWallet = prevEntry?.walletAddress || '';
                        }
                        
                        hop.entries.push({
                            id: hop.entries.length + 1,
                            hopNumber: hopNumber,
                            hopNumber: hopNumber,
                            entryType: 'trace',
                            notation: entry.hopNotation,
                            fromWallet: fromWallet,
                            fromWalletType: hopNumber === 1 ? 'red' : 'black',
                            fromWalletId: '',
                            toWallet: entry.walletAddress,
                            toWalletType: parseWalletType(entry.walletId),
                            toWalletId: '',
                            amount: entry.amount.toString(),
                            currency: entry.currency,
                            customCurrency: '',
                            txHash: '',
                            timestamp: '',
                            timezone: 'UTC',
                            notes: `Imported from trace data`,
                            category: '',
                            justification: ''
                        });
                    }
                }
            });
            
            // Convert to arrays
            investigation.victims = Array.from(victimMap.values());
            investigation.hops = Array.from(hopMap.values());
            
            // Calculate root total and ART for each hop
            investigation.confirmedRootTotalsByCurrency = calculateRootTotal();
            investigation.rootTotalConfirmed = true;

            // Keep legacy confirmedRootTotal for backward compatibility (sum of all)
            investigation.confirmedRootTotal = Object.values(investigation.confirmedRootTotalsByCurrency).reduce((sum, amount) => sum + amount, 0);
            
            investigation.hops.forEach(hop => {
                hop.artAtStartByCurrency = getCurrentART();
            });
            
            // Build Universal Wallet Index
            buildUniversalWalletIndex();
            buildRedWalletIndex();
        }

        function parseWalletType(walletId) {
            const match = walletId.match(/^([A-Z]+)\d+$/);
            if (match) {
                return match[1].toLowerCase();
            }
            return 'black';
        }

        function closeExcelImportModal() {
            hideModal('excelImportModal');
            document.getElementById('importPreview').style.display = 'none';
            document.getElementById('confirmImportBtn').style.display = 'none';
            parsedExcelData = null;
        }
        function closeExcelImportModal() {
            hideModal('excelImportModal');
            document.getElementById('importPreview').style.display = 'none';
            document.getElementById('confirmImportBtn').style.display = 'none';
            parsedExcelData = null;
        }

        // ADD THE NEW HELPER FUNCTIONS HERE:
        function updateIndividualSourceAssignment(hopNumber, entryId, sourceId, amount) {
            const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    
    if (!entry.individualSourceAssignments) {
        entry.individualSourceAssignments = {};
    }
    
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    const maxAmount = getMaxAssignableAmount(sourceId, currency, entry.id, entry.hopNumber);
    const assignedAmount = Math.min(parseFloat(amount) || 0, maxAmount);
    
    entry.individualSourceAssignments[sourceId] = assignedAmount;
    
    // Calculate total from all individual assignments
    let totalAssigned = 0;
    Object.values(entry.individualSourceAssignments).forEach(amt => {
        totalAssigned += parseFloat(amt) || 0;
    });
    
    // Update the main amount field
    entry.amount = totalAssigned.toString();
    
    // Update the main amount input field in the UI
    const mainAmountInput = document.getElementById(`assignAmount_${hopNumber}_${entryId}`);
    if (mainAmountInput) {
        mainAmountInput.value = totalAssigned;
    }
}

// DUPLICATE FUNCTION REMOVED - Using the more complete version at line 10336
/*function validateHopCompletion(hopNumber) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    if (!hop) return { valid: false, errors: ['Hop not found'] };
    
    const errors = [];
    const warnings = [];
    
    // Get starting ART by currency for this hop
    const startingART = hop.artAtStartByCurrency || {};
    
    // Calculate totals by currency from all entries in this hop
    const entryTotalsByCurrency = {};
    hop.entries.forEach(entry => {
        if (parseFloat(entry.amount) > 0) {
            const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
            if (!entryTotalsByCurrency[currency]) {
                entryTotalsByCurrency[currency] = 0;
            }
            entryTotalsByCurrency[currency] += parseFloat(entry.amount);
        }
    });
    
    // Validate each currency balances
    Object.entries(startingART).forEach(([currency, startAmount]) => {
        const tracedAmount = entryTotalsByCurrency[currency] || 0;
        const difference = Math.abs(startAmount - tracedAmount);
        
        if (difference >= 0.01) {
            if (tracedAmount > startAmount) {
                errors.push(`${currency}: Traced ${tracedAmount.toLocaleString()} exceeds ART ${startAmount.toLocaleString()}`);
            } else {
                warnings.push(`${currency}: Missing ${(startAmount - tracedAmount).toLocaleString()} (${tracedAmount.toLocaleString()} of ${startAmount.toLocaleString()} traced)`);
            }
        }
    });
    
    // Check for source thread over-assignment
    const sourceThreadUsage = {};
    hop.entries.forEach(entry => {
        if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0) {
            const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
            
            if (entry.sourceThreadId) {
                if (!sourceThreadUsage[currency]) sourceThreadUsage[currency] = {};
                if (!sourceThreadUsage[currency][entry.sourceThreadId]) {
                    sourceThreadUsage[currency][entry.sourceThreadId] = 0;
                }
                sourceThreadUsage[currency][entry.sourceThreadId] += parseFloat(entry.amount);
            }
            
            if (entry.individualSourceAssignments) {
                Object.entries(entry.individualSourceAssignments).forEach(([sourceId, amount]) => {
                    if (!sourceThreadUsage[currency]) sourceThreadUsage[currency] = {};
                    if (!sourceThreadUsage[currency][sourceId]) {
                        sourceThreadUsage[currency][sourceId] = 0;
                    }
                    sourceThreadUsage[currency][sourceId] += parseFloat(amount);
                });
            }
        }
    });
    
    // Validate source thread assignments don't exceed availability
    Object.entries(sourceThreadUsage).forEach(([currency, threads]) => {
        Object.entries(threads).forEach(([threadId, usedAmount]) => {
            if (investigation.availableThreads[currency] && investigation.availableThreads[currency][threadId]) {
                const totalAvailable = investigation.availableThreads[currency][threadId].totalAmount;
                if (usedAmount > totalAvailable + 0.01) {
                    errors.push(`${threadId}: Assigned ${usedAmount.toLocaleString()} exceeds available ${totalAvailable.toLocaleString()} ${currency}`);
                }
            }
        });
    });
    
    return {
        valid: errors.length === 0,
        errors: errors,
        warnings: warnings,
        balanceStatus: entryTotalsByCurrency
    };
}*/

function autoGenerateNotationFromSource(hopNumber, entryId, sourceThreadId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);

    console.log(` Auto-generating notation from source: ${sourceThreadId}`);

    // Parse the source thread ID (e.g., "V1-T1" or "V1-T1-H2" or "V(1)-T(1)-H1" or "V(1,2)-T(1,2,2)")
    const match = sourceThreadId.match(/^V([^-]+)-T([^-]+)/);
    if (match) {
        let victimPart = match[1];
        let transactionPart = match[2];

        console.log(` Parsed victim: ${victimPart}, transaction: ${transactionPart}`);

        // Parse and deduplicate numbers from parenthesized format like (1,2,2,2)
        const parseAndDedupe = (part) => {
            // Extract all numbers from formats like: (1), (1)(2), (1,2,2,2)
            const numbers = part.match(/\d+/g);
            if (numbers) {
                // Get unique numbers and sort
                const unique = [...new Set(numbers.map(n => parseInt(n)))].sort((a, b) => a - b);
                return unique.map(n => `(${n})`).join('');
            }
            return part;
        };

        victimPart = parseAndDedupe(victimPart);
        transactionPart = parseAndDedupe(transactionPart);

        console.log(` Deduplicated - victim: ${victimPart}, transaction: ${transactionPart}`);

        // Auto-fill notation fields
        entry.victimNumbers = victimPart;
        entry.transactionNumbers = transactionPart;
        
        // Generate the notation
        generateNotationPreview(hopNumber, entryId);
        
        // Update the UI fields
        updateNotationFieldsInUI(hopNumber, entryId);
        
        console.log(` Notation auto-generated: ${entry.notation}`);
    } else {
        console.log(`⚠️ Could not parse source thread ID: ${sourceThreadId}`);
    }
}

function autoGenerateNotationFromMultipleSources(hopNumber, entryId, selectedSources) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    
    console.log(` Auto-generating notation from multiple sources:`, selectedSources);
    
    const victimNumbers = new Set();
    const transactionNumbers = new Set();
    
    // Parse all selected source thread IDs
    selectedSources.forEach(sourceId => {
        const match = sourceId.match(/^V(\d+)-T(\d+)/);
        if (match) {
            victimNumbers.add(match[1]);
            transactionNumbers.add(match[2]);
            console.log(` Parsed from ${sourceId}: V${match[1]}, T${match[2]}`);
        }
    });
    
    // Convert to sorted arrays and format with parentheses
    const sortedVictims = Array.from(victimNumbers).sort((a, b) => parseInt(a) - parseInt(b));
    const sortedTransactions = Array.from(transactionNumbers).sort((a, b) => parseInt(a) - parseInt(b));
    
    // Format with individual parentheses: V(1)(2) - T(1)(3)
    entry.victimNumbers = sortedVictims.map(v => `(${v})`).join('');
    entry.transactionNumbers = sortedTransactions.map(t => `(${t})`).join('');
    
    console.log(` Generated victim numbers: ${entry.victimNumbers}, transaction numbers: ${entry.transactionNumbers}`);
    
    // Generate the notation
    generateNotationPreview(hopNumber, entryId);
    
    console.log(` Final notation: ${entry.notation}`);
    
    // Update the UI fields
    updateNotationFieldsInUI(hopNumber, entryId);
}

function clearNotationFields(hopNumber, entryId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    
    entry.victimNumbers = '';
    entry.transactionNumbers = '';
    entry.notation = '';
    entry.generatedNotation = '';
    
    updateNotationFieldsInUI(hopNumber, entryId);
}

function updateNotationFieldsInUI(hopNumber, entryId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    
    console.log(`Updating notation UI for hop ${hopNumber} entry ${entryId}:`, {
        victimNumbers: entry.victimNumbers,
        transactionNumbers: entry.transactionNumbers,
        notation: entry.notation
    });
    
    // Find and update the victim numbers input - try multiple selectors
    let victimInput = document.querySelector(`input[onchange*="updateNotationField(${hopNumber}, ${entryId}, 'victims'"]`);
    if (!victimInput) {
        // Try finding by ID pattern
        const inputs = document.querySelectorAll('input');
        inputs.forEach(input => {
            if (input.getAttribute('onchange') && input.getAttribute('onchange').includes(`updateNotationField(${hopNumber}, ${entryId}, 'victims'`)) {
                victimInput = input;
            }
        });
    }
    
    if (victimInput) {
        victimInput.value = entry.victimNumbers || '';
        console.log(` Updated victim input to: ${entry.victimNumbers}`);
    } else {
        console.log(` Could not find victim input for hop ${hopNumber} entry ${entryId}`);
    }
    
    // Find and update the transaction numbers input
    let transactionInput = document.querySelector(`input[onchange*="updateNotationField(${hopNumber}, ${entryId}, 'transactions'"]`);
    if (!transactionInput) {
        // Try finding by ID pattern
        const inputs = document.querySelectorAll('input');
        inputs.forEach(input => {
            if (input.getAttribute('onchange') && input.getAttribute('onchange').includes(`updateNotationField(${hopNumber}, ${entryId}, 'transactions'`)) {
                transactionInput = input;
            }
        });
    }
    
    if (transactionInput) {
        transactionInput.value = entry.transactionNumbers || '';
        console.log(` Updated transaction input to: ${entry.transactionNumbers}`);
    } else {
        console.log(` Could not find transaction input for hop ${hopNumber} entry ${entryId}`);
    }
    
    // Update the preview
    const previewElement = document.getElementById(`notation_preview_${hopNumber}_${entryId}`);
    if (previewElement) {
        previewElement.textContent = entry.notation || 'Enter V and T numbers';
        console.log(` Updated preview to: ${entry.notation}`);
    } else {
        console.log(` Could not find preview element`);
    }
}
function assignMaxToIndividualSource(hopNumber, entryId, sourceId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    
    // Get REAL-TIME maximum amount available
    const maxAmount = getMaxAssignableAmount(sourceId, currency, entry.id, entry.hopNumber);
    
    updateIndividualSourceAssignment(hopNumber, entryId, sourceId, maxAmount);
    
    // Also update the input field in the UI immediately
    const inputField = document.querySelector(`input[onchange*="updateIndividualSourceAssignment(${hopNumber}, ${entryId}, '${sourceId}'"]`);
    if (inputField) {
        inputField.value = maxAmount;
        inputField.max = maxAmount; // Update the max attribute too
    }
}
function toggleSourceSelection(hopNumber, entryId, sourceId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    
    if (!entry.multipleSourceThreads) {
        entry.multipleSourceThreads = [];
    }
    if (!entry.individualSourceAssignments) {
        entry.individualSourceAssignments = {};
    }
    
    const isCurrentlySelected = entry.multipleSourceThreads.includes(sourceId);
    
    if (isCurrentlySelected) {
        // Remove from selection
        entry.multipleSourceThreads = entry.multipleSourceThreads.filter(id => id !== sourceId);
        delete entry.individualSourceAssignments[sourceId];
        
        // If no sources are selected anymore, clear the currency
        if (entry.multipleSourceThreads.length === 0) {
            entry.currency = '';
            entry.customCurrency = '';
        }
    } else {
        // Before adding, check if currencies match
        const availableSourceThreads = getAvailableSourcesForHop(entry.hopNumber, null);
        const newSource = availableSourceThreads.find(s => s.threadId === sourceId);
        
        if (newSource && entry.multipleSourceThreads.length > 0) {
            // Check if the new source has the same currency as existing sources
            const existingCurrencies = new Set();
            entry.multipleSourceThreads.forEach(existingId => {
                const existingSource = availableSourceThreads.find(s => s.threadId === existingId);
                if (existingSource) {
                    existingCurrencies.add(existingSource.currency);
                }
            });
            
            if (existingCurrencies.size > 0 && !existingCurrencies.has(newSource.currency)) {
                alert(`ERROR:  Cannot mix different asset types!\n\nSelected threads have: ${Array.from(existingCurrencies).join(', ')}\nThis thread has: ${newSource.currency}\n\nPlease select threads with the same currency only.`);
                
                // Uncheck the checkbox
                const checkbox = document.querySelector(`#smartAllocationModal input[data-source-id="${sourceId}"]`);
                if (checkbox) {
                    checkbox.checked = false;
                }
                return;
            }
        }
        
        // Add to selection
        entry.multipleSourceThreads.push(sourceId);
        entry.individualSourceAssignments[sourceId] = 0; // Start with 0
        
        // Auto-update currency from the first selected source
        if (entry.multipleSourceThreads.length === 1) {
            const sourceThread = availableSourceThreads.find(s => s.threadId === sourceId);
            
            if (sourceThread) {
                const currency = sourceThread.currency;
                const isCustomCurrency = !Object.keys(currencies).includes(currency);
                
                if (isCustomCurrency) {
                    entry.currency = 'CUSTOM';
                    entry.customCurrency = currency;
                } else {
                    entry.currency = currency;
                    entry.customCurrency = '';
                }
            }
        }
    }
    
    // Clear the committed amounts since we're changing the selection
    entry.amount = '';
    const mainAmountInput = document.getElementById(`assignAmount_${hopNumber}_${entryId}`);
    if (mainAmountInput) {
        mainAmountInput.value = '';
    }
    
    // Re-render to show/hide amount inputs
    renderHops();
    saveToStorage();
}

function updateProposedAmount(hopNumber, entryId, sourceId, amount) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    
    if (!entry.individualSourceAssignments) {
        entry.individualSourceAssignments = {};
    }
    
    // Get the currency from the source thread, not the entry
    const availableSourceThreads = getAvailableSourcesForHop(entry.hopNumber, null);
    const sourceThread = availableSourceThreads.find(s => s.threadId === sourceId);
    
    if (!sourceThread) {
        alert(`Source thread ${sourceId} not found.`);
        return;
    }
    
    const currency = sourceThread.currency;
    
    // Auto-update entry currency to match source thread if needed
    if (entry.currency !== currency || (entry.currency === 'CUSTOM' && entry.customCurrency !== currency)) {
        const isCustomCurrency = !Object.keys(currencies).includes(currency);
        
        if (isCustomCurrency) {
            entry.currency = 'CUSTOM';
            entry.customCurrency = currency;
        } else {
            entry.currency = currency;
            entry.customCurrency = '';
        }
    }
    
    const maxAmount = getMaxAssignableAmount(sourceId, currency, entry.id, entry.hopNumber);
    const proposedAmount = Math.min(parseFloat(amount) || 0, maxAmount);
    
    entry.individualSourceAssignments[sourceId] = proposedAmount;
    
    // Update the proposed summary
    updateProposedSummary(hopNumber, entryId);
    saveToStorage();
}

function proposeMaxAmount(hopNumber, entryId, sourceId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    const maxAmount = getMaxAssignableAmount(sourceId, currency, entry.id, entry.hopNumber);
    
    updateProposedAmount(hopNumber, entryId, sourceId, maxAmount);
    
    // Update the input field
    const inputField = document.querySelector(`input[onchange*="updateProposedAmount(${hopNumber}, ${entryId}, '${sourceId}'"]`);
    if (inputField) {
        inputField.value = maxAmount;
    }
}

function updateProposedSummary(hopNumber, entryId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    const summaryElement = document.getElementById(`proposedSummary_${hopNumber}_${entryId}`);
    
    if (!summaryElement || !entry.individualSourceAssignments) return;
    
    // GET THE CORRECT CURRENCY FROM THE ENTRY (not defaulting to USD)
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    let totalProposed = 0;
    let summaryHTML = '';
    
    Object.entries(entry.individualSourceAssignments).forEach(([sourceId, amount]) => {
        if (amount > 0) {
            totalProposed += amount;
            summaryHTML += `<div style="font-size: 12px; margin-bottom: 3px;">• ${sourceId}: ${amount.toLocaleString()} ${currency}</div>`;
        }
    });
    
    summaryHTML += `<div style="font-weight: bold; margin-top: 8px; padding-top: 8px; border-top: 1px solid #ddd;">Total Proposed: ${totalProposed.toLocaleString()} ${currency}</div>`;
    
    summaryElement.innerHTML = summaryHTML;
}

function commitAssignmentToEntry(hopNumber, entryId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    
    if (!entry.individualSourceAssignments) {
        alert('No amounts proposed for assignment.');
        return;
    }
    
    // Calculate total proposed amount
    let totalAmount = 0;
    Object.values(entry.individualSourceAssignments).forEach(amount => {
        totalAmount += parseFloat(amount) || 0;
    });
    
    if (totalAmount <= 0) {
        alert('Please specify amounts to assign from selected sources.');
        return;
    }
    
    // Commit the assignment
    entry.amount = totalAmount.toString();
    
    // Update the main amount input field
    const mainAmountInput = document.getElementById(`assignAmount_${hopNumber}_${entryId}`);
    if (mainAmountInput) {
        mainAmountInput.value = totalAmount;
    }
    
    // Generate notation if needed
    if (entry.multipleSourceThreads && entry.multipleSourceThreads.length > 0) {
        autoGenerateNotationFromMultipleSources(hopNumber, entryId, entry.multipleSourceThreads);
    }
    
    // Update full notation display
    updateFullNotationDisplayMultiple(hopNumber, entryId);
    
    alert(` Assignment committed! New thread total: ${totalAmount.toLocaleString()} ${entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency}`);
    
    saveToStorage();
    
    // Re-render all hops to update availability for other entries
    renderHops();
}
// ADD THESE MISSING FUNCTIONS

function validateTracesEnhanced() {
    console.log(' Running enhanced validation...');
    
    const errors = [];
    const warnings = [];
    const threadAnalysis = {};
    const mathematicalBalance = {};
    
    // Build analysis by currency
    Object.keys(investigation.confirmedRootTotalsByCurrency || {}).forEach(currency => {
        threadAnalysis[currency] = {
            totalThreads: 0,
            totalAvailable: 0,
            totalAssigned: 0,
            unassignedThreads: [],
            overassignedThreads: []
        };
        
        mathematicalBalance[currency] = {
            rootTotal: investigation.confirmedRootTotalsByCurrency[currency] || 0,
            writeoffAmount: 0,
            adjustedRootTotal: 0,
            currentThreadTotal: 0,
            difference: 0,
            isValid: false
        };
    });
    
    // Calculate write-offs
    investigation.hops.forEach(hop => {
        hop.entries.forEach(entry => {
            if (entry.entryType === 'writeoff' && parseFloat(entry.amount) > 0) {
                const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                if (mathematicalBalance[currency]) {
                    mathematicalBalance[currency].writeoffAmount += parseFloat(entry.amount);
                }
            }
        });
    });
    
    // Complete balance calculations
    Object.keys(mathematicalBalance).forEach(currency => {
        const balance = mathematicalBalance[currency];
        balance.adjustedRootTotal = balance.rootTotal - balance.writeoffAmount;
        
        // Calculate current thread total
        let currentTotal = 0;
        investigation.hops.forEach(hop => {
            hop.entries.forEach(entry => {
                if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0) {
                    const entryCurrency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                    if (entryCurrency === currency) {
                        currentTotal += parseFloat(entry.amount);
                    }
                }
            });
        });
        
        balance.currentThreadTotal = currentTotal;
        balance.difference = Math.abs(balance.adjustedRootTotal - balance.currentThreadTotal);
        balance.isValid = balance.difference < 0.01;
        
        if (!balance.isValid) {
            errors.push(`${currency}: Balance mismatch - ART: ${balance.adjustedRootTotal}, Current: ${balance.currentThreadTotal}`);
        }
    });
    
    return {
        overall: errors.length === 0,
        errors: errors,
        warnings: warnings,
        threadAnalysis: threadAnalysis,
        mathematicalBalance: mathematicalBalance,
        timestamp: new Date().toISOString()
    };
}

function distributeProportionally(hopNumber, entryId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    
    if (!entry.multipleSourceThreads || entry.multipleSourceThreads.length === 0) return;
    
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    let totalAvailable = 0;
    
    // Calculate total available
    entry.multipleSourceThreads.forEach(sourceId => {
        totalAvailable += getMaxAssignableAmount(sourceId, currency);
    });
    
    if (totalAvailable <= 0) return;
    
    // Apply PIFO allocation instead of proportional distribution
    let remainingToAllocate = totalAvailable;
    if (!entry.individualSourceAssignments) {
        entry.individualSourceAssignments = {};
    }

    // Sort threads for PIFO order (V1-T1 before V1-T2, etc.)
    const sortedThreads = [...entry.multipleSourceThreads].sort((a, b) => {
        const parseThreadId = (id) => {
            const parts = id.match(/V(\d+)-T(\d+)/);
            if (parts) {
                return { victim: parseInt(parts[1]), transaction: parseInt(parts[2]) };
            }
            return { victim: 999, transaction: 999 };
        };
        const threadA = parseThreadId(a);
        const threadB = parseThreadId(b);
        if (threadA.victim !== threadB.victim) {
            return threadA.victim - threadB.victim;
        }
        return threadA.transaction - threadB.transaction;
    });

    // Apply PIFO allocation
    sortedThreads.forEach(sourceId => {
        if (remainingToAllocate <= 0) {
            entry.individualSourceAssignments[sourceId] = 0;
            return;
        }

        const available = getMaxAssignableAmount(sourceId, currency);
        const toAllocate = Math.min(available, remainingToAllocate);

        entry.individualSourceAssignments[sourceId] = toAllocate;
        remainingToAllocate -= toAllocate;

        console.log(`PIFO allocation for ${sourceId}: ${toAllocate}/${available} ${currency}`);
    });
    
    // Update total
    entry.amount = totalAvailable.toString();
    updateMultipleSourcePreview(hopNumber, entryId);
    saveToStorage();
}

function depleteInOrder(hopNumber, entryId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    
    if (!entry.multipleSourceThreads || entry.multipleSourceThreads.length === 0) return;
    
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    
    if (!entry.individualSourceAssignments) {
        entry.individualSourceAssignments = {};
    }
    
    // Deplete each source in order
    entry.multipleSourceThreads.forEach(sourceId => {
        const maxAmount = getMaxAssignableAmount(sourceId, currency, entry.id, entry.hopNumber);
        entry.individualSourceAssignments[sourceId] = maxAmount;
    });
    
    // Calculate total
    let total = 0;
    Object.values(entry.individualSourceAssignments).forEach(amount => {
        total += parseFloat(amount) || 0;
    });
    
    entry.amount = total.toString();
    updateMultipleSourcePreview(hopNumber, entryId);
    saveToStorage();
}

function clearAllAssignments(hopNumber, entryId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    
    if (entry.individualSourceAssignments) {
        Object.keys(entry.individualSourceAssignments).forEach(sourceId => {
            entry.individualSourceAssignments[sourceId] = 0;
        });
    }
    
    entry.amount = '0';
    updateMultipleSourcePreview(hopNumber, entryId);
    saveToStorage();
}

// Blockchain API Integration Functions
function formatDatetimeLocal(timestamp) {
    return new Date(timestamp).toISOString().slice(0, 16);
}

function detectBlockchainFromHash(hash) {
    const detectedDiv = document.getElementById('detectedBlockchain');
    const chainSelector = document.getElementById('chainSelector');
    
    // If a chain is manually selected, don't auto-detect
    if (chainSelector && chainSelector.value) {
        return chainSelector.value;
    }
    
    if (!hash || hash.length < 10) {
        detectedDiv.innerHTML = '';
        return null;
    }
    
    // Check each blockchain pattern
    for (const [chain, config] of Object.entries(blockchainAPIs)) {
        if (config.txPattern.test(hash)) {
            detectedDiv.innerHTML = `<span style="color: #27ae60;">✓ Detected: ${config.name} transaction</span>`;
            return chain;
        }
    }
    
    detectedDiv.innerHTML = '<span style="color: #e74c3c;">✗ Unknown transaction format</span>';
    return null;
}

function updateChainDisplay() {
    const chainSelector = document.getElementById('chainSelector');
    const detectedDiv = document.getElementById('detectedBlockchain');
    
    if (chainSelector.value) {
        const config = blockchainAPIs[chainSelector.value];
        detectedDiv.innerHTML = `<span style="color: #3498db;">ℹ️ Selected: ${config.name}</span>`;
    } else {
        // Re-detect from hash if present
        const txHash = document.getElementById('txHashInput').value;
        if (txHash) {
            detectBlockchainFromHash(txHash);
        } else {
            detectedDiv.innerHTML = '';
        }
    }
}

function openBlockchainLookup(hopNumber, entryId) {
    // Store context for applying data later
    targetEntryContext = { hopNumber, entryId };

    // Clear previous data
    currentTxData = null;
    document.getElementById('txHashInput').value = '';
    document.getElementById('detectedBlockchain').innerHTML = '';
    document.getElementById('lookupResult').style.display = 'none';
    document.getElementById('lookupError').style.display = 'none';
    document.getElementById('applyTxDataBtn').style.display = 'none';

    // Try to detect chain from source thread
    let detectedChain = '';
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop?.entries.find(e => e.id === entryId);

    if (entry?.sourceThreadId) {
        // Parse the source thread notation to get victim and transaction IDs
        const match = entry.sourceThreadId.match(/V(\d+)-T(\d+)/);
        if (match) {
            const victimId = parseInt(match[1]);
            const transactionId = parseInt(match[2]);

            // Find the victim transaction
            const victim = investigation.victims.find(v => v.id === victimId);
            const transaction = victim?.transactions.find(t => t.id === transactionId);

            // Get the chain from the transaction
            if (transaction?.chain) {
                detectedChain = transaction.chain;
                console.log(`Detected chain '${detectedChain}' from source thread ${entry.sourceThreadId}`);
            }
        }
    }

    // Set the chain selector if we detected a chain
    document.getElementById('chainSelector').value = detectedChain;
    if (detectedChain) {
        const chainConfig = blockchainAPIs[detectedChain];
        if (chainConfig) {
            document.getElementById('detectedBlockchain').innerHTML =
                `<span style="color: #27ae60;">✓ Auto-selected ${chainConfig.name} based on source thread</span>`;
        }
    }

    showModal('blockchainLookupModal');
}

function closeBlockchainLookupModal() {
    hideModal('blockchainLookupModal');
    targetEntryContext = null;
    currentTxData = null;
}

async function lookupTransaction() {
    const txHash = document.getElementById('txHashInput').value.trim();
    const selectedChain = document.getElementById('chainSelector').value;
    let detectedChain = selectedChain || detectBlockchainFromHash(txHash);
    
    if (!txHash) {
        showLookupError('Please enter a transaction hash');
        return;
    }
    
    if (!detectedChain) {
        showLookupError('Please select a blockchain or enter a valid transaction hash');
        return;
    }
    
    const config = blockchainAPIs[detectedChain];
    // Disable CORS proxy to avoid CSP issues - APIs should handle CORS natively
    const corsEnabled = false;
    const corsProxyUrl = '';
    
    // Show loading
    document.getElementById('lookupLoading').style.display = 'block';
    document.getElementById('lookupError').style.display = 'none';
    document.getElementById('lookupResult').style.display = 'none';
    
    // Build array of URLs to try (primary + fallbacks)
    const urlsToTry = [config.apiUrl, ...(config.fallbackUrls || [])];
    let lastError = null;
    
    for (let apiUrl of urlsToTry) {
        try {
            let data;
            let url;
            let tokenData = null; // Define tokenData at this scope
            
            if (detectedChain === 'bitcoin') {
                url = apiUrl + txHash;
                if (config.apiKey) {
                    url += `?api_key=${config.apiKey}`;
                }
                if (corsEnabled) url = corsProxyUrl + url;
                
                const response = await fetch(url);
                if (!response.ok) throw new Error('Transaction not found');
                data = await response.json();
                
            } else if (detectedChain === 'ethereum') {
                const apiKey = localStorage.getItem('bats_etherscan_api_key') || config.apiKey || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8';
                
                // First get the basic transaction
                url = `${apiUrl}${txHash}&apikey=${apiKey}`;
                if (corsEnabled) url = corsProxyUrl + url;
                
                const response = await fetch(url);
                if (!response.ok) throw new Error('API request failed');
                data = await response.json();
                if (!data.result || data.result === null) throw new Error('Transaction not found');
                
                // Get block data for timestamp - but don't let it block token transfers
                let blockData = null;
                if (data.result && data.result.blockNumber) {
                    try {
                        const blockUrl = corsEnabled ?
                            corsProxyUrl + `${config.blockApiUrl}${data.result.blockNumber}&boolean=true&apikey=${apiKey}` :
                            `${config.blockApiUrl}${data.result.blockNumber}&boolean=true&apikey=${apiKey}`;
                        
                        const blockResponse = await fetch(blockUrl);
                        if (blockResponse.ok) {
                            blockData = await blockResponse.json();
                            if (blockData && blockData.result && blockData.result.timestamp) {
                                blockTimestamp = parseInt(blockData.result.timestamp, 16) * 1000;
                                console.log('Got block timestamp:', new Date(blockTimestamp).toISOString());
                            }
                        }
                    } catch (err) {
                        console.log('Failed to fetch block timestamp, will proceed without it:', err);
                    }
                }
                
                // Small delay to avoid rate limit
                if (blockTimestamp) {
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
                
                // Also check for token transfers
                let tokenData = null;
                try {
                    const tokenUrl = corsEnabled ? 
                        corsProxyUrl + `${config.tokenApiUrl}${txHash}&apikey=${apiKey}` :
                        `${config.tokenApiUrl}${txHash}&apikey=${apiKey}`;
                    
                    const tokenResponse = await fetch(tokenUrl).catch(err => {
                        console.warn(`Token fetch failed:`, err);
                        return null;
                    });
                    if (tokenResponse && tokenResponse.ok) {
                        tokenData = await tokenResponse.json();
                        console.log('Receipt/Token data received:', tokenData);
                        
                        // Check if Etherscan returned an error
                        if (tokenData && tokenData.status === '0' && tokenData.message === 'NOTOK') {
                            console.error('Etherscan API error:', tokenData.result);
                            throw new Error(tokenData.result);
                        }
                    }
                } catch (err) {
                    console.log('No token transfers found');
                }
                
            } else if (detectedChain === 'tron') {
                url = apiUrl + txHash;
                if (config.apiKey) {
                    // TronGrid uses header authentication
                    const headers = { 'TRON-PRO-API-KEY': config.apiKey };
                    if (corsEnabled) url = corsProxyUrl + url;
                    
                    const response = await fetch(url, { headers });
                    if (!response.ok) throw new Error('Transaction not found');
                    data = await response.json();
                } else {
                    if (corsEnabled) url = corsProxyUrl + url;
                    const response = await fetch(url);
                    if (!response.ok) throw new Error('Transaction not found');
                    data = await response.json();
                }
                
            } else if (detectedChain === 'solana') {
                url = apiUrl;
                if (corsEnabled) url = corsProxyUrl + url;

                // Solana RPC call
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        jsonrpc: '2.0',
                        id: 1,
                        method: 'getTransaction',
                        params: [txHash, { encoding: 'json', maxSupportedTransactionVersion: 0 }]
                    })
                });
                if (!response.ok) throw new Error('RPC request failed');
                data = await response.json();
                if (data.error) throw new Error(data.error.message);
            } else if (detectedChain === 'sui') {
                url = apiUrl;
                if (corsEnabled) url = corsProxyUrl + url;

                // Sui JSON-RPC call
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        jsonrpc: '2.0',
                        id: 1,
                        method: 'sui_getTransactionBlock',
                        params: [txHash, {
                            showInput: true,
                            showEffects: true,
                            showEvents: true,
                            showObjectChanges: true,
                            showBalanceChanges: true
                        }]
                    })
                });
                if (!response.ok) throw new Error('RPC request failed');
                data = await response.json();
                if (data.error) throw new Error(data.error.message);
            } else {
                // Generic REST API handler for XRP, THORChain, and other chains
                url = apiUrl + txHash;
                if (config.apiKey) {
                    url += (url.includes('?') ? '&' : '?') + `apikey=${config.apiKey}`;
                }
                if (corsEnabled) url = corsProxyUrl + url;

                const response = await fetch(url);
                if (!response.ok) throw new Error('Transaction not found');
                data = await response.json();
            }

            // Parse the response (pass tokenData and blockTimestamp for EVM chains)
            const isEVMChain = ['ethereum', 'base', 'arbitrum', 'optimism', 'polygon', 'bsc',
                               'avalanche', 'hyperevm', 'linea', 'scroll', 'mantle', 'blast',
                               'zksync', 'gnosis', 'celo', 'moonbeam', 'moonriver', 'fraxtal',
                               'taiko', 'arbitrumnova', 'bittorrent', 'opbnb', 'unichain',
                               'sonic', 'abstract', 'memecore', 'sophon', 'berachain'].includes(detectedChain);
            currentTxData = isEVMChain ?
                config.parseResponse(data, tokenData, blockTimestamp, config) :
                config.parseResponse(data);
            if (!currentTxData) throw new Error('Failed to parse transaction data');
            
            currentTxData.blockchain = config.name;
            currentTxData.rawHash = txHash;
            
            // Display the results
            displayTransactionData(currentTxData);
            
            // Success! Break out of the loop
            return;
            
        } catch (error) {
            console.error(`Failed with ${apiUrl}:`, error);
            lastError = error;
            // Continue to next URL
        }
    }
    
    // If we get here, all URLs failed
    const errorMsg = lastError ? lastError.message : 'Failed to fetch transaction';
    if (errorMsg.includes('CORS') || errorMsg.includes('Failed to fetch')) {
        showLookupError(`${errorMsg}\n\nTip: The app will retry with different connection methods automatically.`);
    } else {
        showLookupError(`Failed to fetch transaction: ${errorMsg}`);
    }
    
    document.getElementById('lookupLoading').style.display = 'none';
}

function showLookupError(message) {
    // Show error in existing error div if it exists
    const existingErrorDiv = document.getElementById('lookupError');
    if (existingErrorDiv) {
        existingErrorDiv.textContent = message;
        existingErrorDiv.style.display = 'block';
        return;
    }

    // Otherwise create a modal
    const errorDiv = document.createElement('div');
    errorDiv.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: #ff6b6b;
        color: white;
        padding: 20px;
        border-radius: 8px;
        z-index: 10000;
        max-width: 500px;
        text-align: center;
        box-shadow: 0 10px 40px rgba(0,0,0,0.3);
    `;

    // Check if it's a network/API issue
    const isNetworkIssue = message && (
        message.includes('Network') ||
        message.includes('timeout') ||
        message.includes('API') ||
        message.includes('rate')
    );

    errorDiv.innerHTML = `
        <h3>🔄 Lookup Failed</h3>
        <p style="white-space: pre-line;">${message || 'Network connection error'}</p>
        ${isNetworkIssue ? `
        <div style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 6px; margin: 15px 0; text-align: left;">
            <strong>Quick Solutions:</strong>
            <ul style="margin: 10px 0; padding-left: 20px;">
                <li>Wait 30 seconds if rate limited</li>
                <li>Try using a VPN if blocked</li>
                <li>Check transaction on Etherscan directly</li>
                <li>Use manual entry as fallback</li>
            </ul>
        </div>
        <div style="display: flex; gap: 10px; justify-content: center; margin-top: 15px;">
            <button onclick="this.parentElement.parentElement.remove(); setTimeout(() => document.querySelector('[onclick*=lookupWizardTransaction]')?.click(), 100)"
                    class="btn btn-primary" style="background: white; color: #ff6b6b;">🔄 Retry Lookup</button>
            <button onclick="this.parentElement.parentElement.remove()"
                    class="btn btn-secondary" style="background: rgba(255,255,255,0.2);">Close</button>
        </div>
        ` : `
        <button onclick="this.parentElement.remove()" class="btn btn-secondary" style="margin-top: 15px;">Close</button>
        `}
    `;

    document.body.appendChild(errorDiv);

    // Auto-remove after 30 seconds
    setTimeout(() => {
        if (errorDiv.parentElement) {
            errorDiv.remove();
        }
    }, 30000);
}

function displayTransactionData(txData) {
    const displayDiv = document.getElementById('txDetailsDisplay');
    
    const timeFormatted = new Date(txData.time).toLocaleString();
    
    displayDiv.innerHTML = `
        <div style="display: grid; gap: 10px;">
            <div><strong>Blockchain:</strong> ${txData.blockchain}</div>
            <div><strong>Hash:</strong> <span style="font-family: monospace; font-size: 12px; word-break: break-all;">${txData.rawHash}</span></div>
            <div><strong>Time:</strong> ${timeFormatted} (UTC)</div>
            <div><strong>Amount:</strong> ${txData.amount.toFixed(8)} ${txData.currency}</div>
            <div><strong>From:</strong> <span style="font-family: monospace; font-size: 12px; word-break: break-all;">${txData.from}</span></div>
            <div><strong>To:</strong> <span style="font-family: monospace; font-size: 12px; word-break: break-all;">${txData.to}</span></div>
            ${txData.fee ? `<div><strong>Fee:</strong> ${txData.fee} ${txData.currency}</div>` : ''}
        </div>
    `;
    
    document.getElementById('lookupResult').style.display = 'block';

    // Validate against source thread wallet and show appropriate warnings
    if (targetEntryContext && currentTxData) {
        const { hopNumber, entryId } = targetEntryContext;
        const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
        const entry = hop?.entries.find(e => e.id === entryId);

        if (entry?.sourceThreadId) {
            const sourceThread = getThreadByNotation(entry.sourceThreadId);
            if (sourceThread?.sourceWallet) {
                const threadWallet = sourceThread.sourceWallet.toLowerCase();
                const txFromWallet = currentTxData.from.toLowerCase();

                if (threadWallet !== txFromWallet) {
                    // Add wallet mismatch warning
                    const warningHtml = `
                        <div style="background: #ffebee; border: 2px solid #f44336; border-radius: 4px; padding: 12px; margin: 10px 0;">
                            <strong style="color: #c62828; font-size: 14px;">⚠️ WALLET MISMATCH DETECTED!</strong><br>
                            <div style="margin-top: 8px; color: #d32f2f;">
                                This transaction does NOT spend from thread ${entry.sourceThreadId}
                            </div>
                            <div style="margin-top: 8px; font-size: 12px; color: #666;">
                                <div><strong>Expected wallet (where thread exists):</strong></div>
                                <div style="font-family: monospace; font-size: 11px; margin: 2px 0;">${threadWallet}</div>
                                <div style="margin-top: 5px;"><strong>Transaction from wallet:</strong></div>
                                <div style="font-family: monospace; font-size: 11px; margin: 2px 0;">${txFromWallet}</div>
                            </div>
                            <div style="margin-top: 10px; font-size: 11px; color: #666; border-top: 1px solid #ffcdd2; padding-top: 8px;">
                                ⚠️ This transaction cannot be used as it doesn't continue the fund flow from the selected source thread.
                            </div>
                        </div>
                    `;
                    document.getElementById('lookupResult').innerHTML += warningHtml;

                    // Change button appearance to indicate issue
                    document.getElementById('applyTxDataBtn').style.display = 'inline-block';
                    document.getElementById('applyTxDataBtn').style.background = '#f44336';
                    document.getElementById('applyTxDataBtn').textContent = '⚠️ Cannot Apply - Wrong Wallet';
                    document.getElementById('applyTxDataBtn').disabled = false; // Allow click to show detailed error
                } else {
                    // Add success validation message
                    const successHtml = `
                        <div style="background: #e8f5e9; border: 2px solid #4caf50; border-radius: 4px; padding: 12px; margin: 10px 0;">
                            <strong style="color: #2e7d32; font-size: 14px;">✓ Wallet Verification Passed!</strong><br>
                            <div style="margin-top: 8px; color: #388e3c;">
                                Transaction correctly spends from thread ${entry.sourceThreadId}
                            </div>
                            <div style="margin-top: 5px; font-size: 11px; color: #666;">
                                Source wallet matches: ${threadWallet.substring(0, 20)}...
                            </div>
                        </div>
                    `;
                    document.getElementById('lookupResult').innerHTML += successHtml;

                    document.getElementById('applyTxDataBtn').style.display = 'inline-block';
                    document.getElementById('applyTxDataBtn').style.background = '';
                    document.getElementById('applyTxDataBtn').textContent = 'Apply to Entry';
                    document.getElementById('applyTxDataBtn').disabled = false;
                }
            } else {
                // Source thread found but no wallet info - show normal button
                document.getElementById('applyTxDataBtn').style.display = 'inline-block';
                document.getElementById('applyTxDataBtn').textContent = 'Apply to Entry';
            }
        } else {
            // No source thread - show normal button
            document.getElementById('applyTxDataBtn').style.display = 'inline-block';
            document.getElementById('applyTxDataBtn').textContent = 'Apply to Entry';
        }
    } else {
        document.getElementById('applyTxDataBtn').style.display = 'inline-block';
        document.getElementById('applyTxDataBtn').textContent = 'Apply to Entry';
    }
}

function applyTransactionData() {
    if (!currentTxData || !targetEntryContext) return;

    const { hopNumber, entryId } = targetEntryContext;
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);

    // CRITICAL VALIDATION: Verify the transaction spends from the source thread's wallet
    if (entry.sourceThreadId) {
        // Get the source thread to find its wallet
        const sourceThread = getThreadByNotation(entry.sourceThreadId);
        if (sourceThread && sourceThread.sourceWallet) {
            // Normalize wallet addresses for comparison (lowercase)
            const threadWallet = sourceThread.sourceWallet.toLowerCase();
            const txFromWallet = currentTxData.from.toLowerCase();

            if (threadWallet !== txFromWallet) {
                // Show detailed error with wallet information
                const errorMessage = `❌ WALLET MISMATCH DETECTED!\n\n` +
                    `This transaction DOES NOT spend from the source thread's wallet.\n\n` +
                    `Source Thread: ${entry.sourceThreadId}\n` +
                    `Expected Wallet (where thread exists):\n${threadWallet}\n\n` +
                    `Transaction From Wallet:\n${txFromWallet}\n\n` +
                    `This transaction cannot be used because it doesn't continue the fund flow from thread ${entry.sourceThreadId}.\n\n` +
                    `Possible issues:\n` +
                    `• Wrong transaction hash entered\n` +
                    `• Transaction from a different wallet\n` +
                    `• Incorrect source thread selected\n\n` +
                    `Please verify you have the correct transaction hash or select the appropriate source thread.`;

                alert(errorMessage);

                // Don't apply the data - keep the modal open for correction
                return;
            }

            // Additional validation: Check if amount exceeds available thread amount
            const availableAmount = sourceThread.availableAmount || 0;
            const requestedAmount = parseFloat(currentTxData.amount);

            if (requestedAmount > availableAmount + 0.01) { // Small tolerance for rounding
                const warningMessage = `⚠️ AMOUNT WARNING!\n\n` +
                    `This transaction amount (${requestedAmount} ${currentTxData.currency}) ` +
                    `exceeds the available amount in thread ${entry.sourceThreadId} ` +
                    `(${availableAmount} ${sourceThread.currency}).\n\n` +
                    `Do you want to proceed anyway?\n\n` +
                    `Note: This might indicate:\n` +
                    `• Additional funds were added to this wallet\n` +
                    `• You may need to trace other sources\n` +
                    `• Possible commingling of funds`;

                if (!confirm(warningMessage)) {
                    return;
                }
            }
        }
    }

    // Apply the data to the entry (validation passed)
    entry.txHash = currentTxData.rawHash;
    entry.timestamp = new Date(currentTxData.time).toISOString().slice(0, 16); // Format for datetime-local
    entry.timezone = 'UTC';
    entry.amount = currentTxData.amount.toString();
    entry.currency = currentTxData.currency;
    entry.fromWallet = currentTxData.from;
    entry.toWallet = currentTxData.to;

    // Update the form fields
    document.getElementById(`txHash_${hopNumber}_${entryId}`).value = entry.txHash;
    document.getElementById(`timestamp_${hopNumber}_${entryId}`).value = entry.timestamp;
    document.getElementById(`assignAmount_${hopNumber}_${entryId}`).value = entry.amount;
    document.getElementById(`toWallet_${hopNumber}_${entryId}`).value = entry.toWallet;

    // Note: fromWallet is stored but not displayed in the form
    // It's used internally for transaction tracking

    // Update currency dropdown
    const currencySelect = document.querySelector(`select[onchange*="updateEntry(${hopNumber}, ${entryId}, 'currency'"]`);
    if (currencySelect) {
        // Check if the currency option exists, if not add it
        const optionExists = Array.from(currencySelect.options).some(opt => opt.value === entry.currency);
        if (!optionExists && entry.currency !== 'CUSTOM') {
            const newOption = document.createElement('option');
            newOption.value = entry.currency;
            newOption.textContent = entry.currency;
            currencySelect.appendChild(newOption);
        }
        currencySelect.value = entry.currency;
    }

    saveToStorage();
    closeBlockchainLookupModal();

    let alertMessage = `✅ Transaction data applied successfully!\n\n` +
        `Amount: ${entry.amount} ${entry.currency}\n` +
        `From: ${entry.fromWallet.slice(0, 20)}...\n` +
        `To: ${entry.toWallet.slice(0, 20)}...\n\n` +
        `✓ Wallet validation passed - transaction spends from thread ${entry.sourceThreadId}`;

    if (currentTxData.hasRealTimestamp === false) {
        alertMessage += '\n\n⚠️ WARNING: Could not retrieve actual transaction timestamp. Please manually verify and update the date/time field!';
    }

    alert(alertMessage);
}

// API Settings Management Functions
function openApiSettings() {
    // Load saved settings
    const savedEtherscan = localStorage.getItem('bats_etherscan_api_key');
    const savedBlockchain = localStorage.getItem('bats_blockchain_api_key');
    const savedTrongrid = localStorage.getItem('bats_trongrid_api_key');
    const savedSolscan = localStorage.getItem('bats_solscan_api_key');
    const savedSolanaRpc = localStorage.getItem('bats_solana_rpc_endpoint');
    const savedArkham = localStorage.getItem('bats_arkham_api_key');
    const savedArkhamAutoCheck = localStorage.getItem('bats_arkham_auto_check') !== 'false';
    const savedCorsEnabled = localStorage.getItem('bats_cors_proxy_enabled') === 'true';
    const savedCorsUrl = localStorage.getItem('bats_cors_proxy_url');
    
    // Populate form fields
    document.getElementById('etherscanApiKey').value = savedEtherscan || '';
    document.getElementById('blockchainApiKey').value = savedBlockchain || '';
    document.getElementById('trongridApiKey').value = savedTrongrid || '';
    if (document.getElementById('solscanApiKey')) {
        document.getElementById('solscanApiKey').value = savedSolscan || '';
    }
    document.getElementById('solanaRpcEndpoint').value = savedSolanaRpc || 'https://api.mainnet-beta.solana.com';
    document.getElementById('arkhamApiKey').value = savedArkham || '';
    document.getElementById('arkhamAutoCheck').checked = savedArkhamAutoCheck;
    
    // Show modal
    showModal('apiSettingsModal');
}

function closeApiSettingsModal() {
    hideModal('apiSettingsModal');
}

function saveApiSettings() {
    // Get values from form
    const etherscanKey = document.getElementById('etherscanApiKey').value.trim();
    const blockchainKey = document.getElementById('blockchainApiKey').value.trim();
    const trongridKey = document.getElementById('trongridApiKey').value.trim();
    const solscanKey = document.getElementById('solscanApiKey') ? document.getElementById('solscanApiKey').value.trim() : '';
    const solanaRpc = document.getElementById('solanaRpcEndpoint').value.trim();
    const arkhamKey = document.getElementById('arkhamApiKey').value.trim();
    const arkhamAutoCheck = document.getElementById('arkhamAutoCheck').checked;
    // Disable CORS proxy to avoid CSP issues
    const corsEnabled = false;
    const corsUrl = '';
    
    // Save to localStorage
    if (etherscanKey) localStorage.setItem('bats_etherscan_api_key', etherscanKey);
    else localStorage.removeItem('bats_etherscan_api_key');
    
    if (blockchainKey) localStorage.setItem('bats_blockchain_api_key', blockchainKey);
    else localStorage.removeItem('bats_blockchain_api_key');
    
    if (trongridKey) localStorage.setItem('bats_trongrid_api_key', trongridKey);
    else localStorage.removeItem('bats_trongrid_api_key');

    if (solscanKey) localStorage.setItem('bats_solscan_api_key', solscanKey);
    else localStorage.removeItem('bats_solscan_api_key');

    if (solanaRpc) localStorage.setItem('bats_solana_rpc_endpoint', solanaRpc);
    else localStorage.removeItem('bats_solana_rpc_endpoint');
    
    if (arkhamKey) localStorage.setItem('bats_arkham_api_key', arkhamKey);
    else localStorage.removeItem('bats_arkham_api_key');
    
    localStorage.setItem('bats_arkham_auto_check', arkhamAutoCheck.toString());
    localStorage.setItem('bats_cors_proxy_enabled', corsEnabled.toString());
    
    if (corsUrl) localStorage.setItem('bats_cors_proxy_url', corsUrl);
    else localStorage.removeItem('bats_cors_proxy_url');
    
    // Update blockchain API configurations
    blockchainAPIs.ethereum.apiKey = etherscanKey || null;
    blockchainAPIs.bitcoin.apiKey = blockchainKey || null;
    blockchainAPIs.tron.apiKey = trongridKey || null;
    blockchainAPIs.solana.apiUrl = solanaRpc || 'https://api.mainnet-beta.solana.com';
    
    closeApiSettingsModal();
    alert(' API settings saved successfully!');
}

// Enable/disable CORS proxy URL input based on checkbox
document.addEventListener('DOMContentLoaded', function() {
    // Auto-save CORS settings on init if not already saved
    // Remove any existing CORS proxy settings to avoid CSP issues
    localStorage.removeItem('bats_cors_proxy_enabled');
    localStorage.removeItem('bats_cors_proxy_url');
    
    // Load API settings on startup
    loadApiSettingsOnStartup();
});

async function loadApiSettingsOnStartup() {
    // Priority order for API keys:
    // 1. Netlify environment variables (production - most secure)
    // 2. localStorage (user override in Settings)
    // 3. Hardcoded defaults (fallback for local dev)

    // Try to load from Netlify environment variables first
    try {
        const response = await fetch('/.netlify/functions/get-api-keys');
        if (response.ok) {
            const data = await response.json();
            if (data.success && data.keys) {
                console.log('✅ Loaded API keys from Netlify environment variables');

                // Apply environment variable keys if they exist
                if (data.keys.etherscan) {
                    blockchainAPIs.ethereum.apiKey = data.keys.etherscan;
                    // Update all EVM chains
                    if (blockchainAPIs.base) blockchainAPIs.base.apiKey = data.keys.etherscan;
                    if (blockchainAPIs.arbitrum) blockchainAPIs.arbitrum.apiKey = data.keys.etherscan;
                    if (blockchainAPIs.optimism) blockchainAPIs.optimism.apiKey = data.keys.etherscan;
                    if (blockchainAPIs.polygon) blockchainAPIs.polygon.apiKey = data.keys.etherscan;
                    if (blockchainAPIs.bsc) blockchainAPIs.bsc.apiKey = data.keys.etherscan;
                }
                if (data.keys.blockchain) blockchainAPIs.bitcoin.apiKey = data.keys.blockchain;
                if (data.keys.trongrid) blockchainAPIs.tron.apiKey = data.keys.trongrid;
                if (data.keys.solana) blockchainAPIs.solana.apiUrl = data.keys.solana;
                if (data.keys.arkham) window.apiKeys.arkham = data.keys.arkham;

                // Still check localStorage for user overrides
                const savedEtherscan = localStorage.getItem('bats_etherscan_api_key');
                const savedBlockchain = localStorage.getItem('bats_blockchain_api_key');
                const savedTrongrid = localStorage.getItem('bats_trongrid_api_key');
                const savedSolanaRpc = localStorage.getItem('bats_solana_rpc_endpoint');
                const savedArkham = localStorage.getItem('bats_arkham_api_key');

                if (savedEtherscan) blockchainAPIs.ethereum.apiKey = savedEtherscan;
                if (savedBlockchain) blockchainAPIs.bitcoin.apiKey = savedBlockchain;
                if (savedTrongrid) blockchainAPIs.tron.apiKey = savedTrongrid;
                if (savedSolanaRpc) blockchainAPIs.solana.apiUrl = savedSolanaRpc;
                if (savedArkham) window.apiKeys.arkham = savedArkham;

                return;
            }
        }
    } catch (error) {
        // Silently fall through to localStorage/defaults
        console.log('ℹ️  Netlify environment not available, using localStorage or defaults');
    }

    // Fallback: Load from localStorage (if user has configured custom keys)
    const savedEtherscan = localStorage.getItem('bats_etherscan_api_key');
    const savedBlockchain = localStorage.getItem('bats_blockchain_api_key');
    const savedTrongrid = localStorage.getItem('bats_trongrid_api_key');
    const savedSolanaRpc = localStorage.getItem('bats_solana_rpc_endpoint');
    const savedArkham = localStorage.getItem('bats_arkham_api_key');

    // Update blockchain API configurations (otherwise uses hardcoded defaults)
    if (savedEtherscan) blockchainAPIs.ethereum.apiKey = savedEtherscan;
    if (savedBlockchain) blockchainAPIs.bitcoin.apiKey = savedBlockchain;
    if (savedTrongrid) blockchainAPIs.tron.apiKey = savedTrongrid;
    if (savedSolanaRpc) blockchainAPIs.solana.apiUrl = savedSolanaRpc;
    if (savedArkham) window.apiKeys.arkham = savedArkham;
}

// PK Converter Functions
function openPKConverter() {
    const modal = document.getElementById('pkConverterModal');
    if (modal) {
        // Force display the modal regardless of parent visibility
        modal.style.display = 'flex';
        modal.style.position = 'fixed';
        modal.style.zIndex = '10001';
        modal.style.top = '0';
        modal.style.left = '0';
        modal.style.width = '100%';
        modal.style.height = '100%';
        modal.style.backgroundColor = 'rgba(0,0,0,0.5)';
        modal.style.alignItems = 'center';
        modal.style.justifyContent = 'center';
    } else {
        console.error('PK Converter modal not found');
    }
}

function closePKConverterModal() {
    const modal = document.getElementById('pkConverterModal');
    if (modal) {
        modal.style.display = 'none';
    }
    // Clear any errors
    const errorDiv = document.getElementById('pkConverterError');
    if (errorDiv) {
        errorDiv.style.display = 'none';
    }
}

// Crypto-js library functions for PK Converter (embedded)
const BASE58_ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';

function base58Encode(bytes) {
    if (bytes.length === 0) return '';
    let num = 0n;
    for (let i = 0; i < bytes.length; i++) {
        num = num * 256n + BigInt(bytes[i]);
    }
    let result = '';
    while (num > 0n) {
        result = BASE58_ALPHABET[Number(num % 58n)] + result;
        num = num / 58n;
    }
    for (let i = 0; i < bytes.length && bytes[i] === 0; i++) {
        result = '1' + result;
    }
    return result;
}

function hexToBytes(hex) {
    const bytes = [];
    for (let i = 0; i < hex.length; i += 2) {
        bytes.push(parseInt(hex.substr(i, 2), 16));
    }
    return new Uint8Array(bytes);
}

function bytesToHex(bytes) {
    return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
}

function sha256Hash(hexString) {
    // Use crypto-js for SHA256
    const hash = CryptoJS.SHA256(CryptoJS.enc.Hex.parse(hexString));
    return hash.toString(CryptoJS.enc.Hex);
}

function ripemd160Hash(hexString) {
    // Use crypto-js for RIPEMD160
    const hash = CryptoJS.RIPEMD160(CryptoJS.enc.Hex.parse(hexString));
    return hash.toString(CryptoJS.enc.Hex);
}

function keccak256Hash(hexString) {
    // Use crypto-js SHA3 for Keccak-256
    const hash = CryptoJS.SHA3(CryptoJS.enc.Hex.parse(hexString), { outputLength: 256 });
    return hash.toString(CryptoJS.enc.Hex);
}

function generateBitcoinAddress(publicKeyHex) {
    try {
        // Step 1: SHA256 of public key
        const sha = sha256Hash(publicKeyHex);

        // Step 2: RIPEMD160 of SHA256
        const pubKeyHash = ripemd160Hash(sha);

        // Step 3: Add version byte (0x00 for mainnet P2PKH)
        const versionedHash = '00' + pubKeyHash;

        // Step 4: Double SHA256 for checksum
        const hash1 = sha256Hash(versionedHash);
        const hash2 = sha256Hash(hash1);

        // Step 5: Take first 4 bytes as checksum
        const checksum = hash2.substring(0, 8);

        // Step 6: Append checksum
        const fullHash = versionedHash + checksum;

        // Step 7: Base58 encode
        const address = base58Encode(hexToBytes(fullHash));

        return address;
    } catch (error) {
        console.error('Error generating Bitcoin address:', error);
        return null;
    }
}

function generateEthereumAddress(publicKeyHex) {
    try {
        // Remove '04' prefix if present (uncompressed key indicator)
        let pubKey = publicKeyHex.startsWith('04') ? publicKeyHex.slice(2) : publicKeyHex;

        // Use Keccak-256 (this is what Ethereum uses, not SHA3)
        const hash = keccak256Hash(pubKey);

        // Take last 20 bytes (40 hex chars)
        const addressHex = hash.slice(-40);

        // Add checksum (EIP-55)
        const address = toChecksumAddress('0x' + addressHex);

        return address;
    } catch (error) {
        console.error('Error generating Ethereum address:', error);
        return null;
    }
}

function toChecksumAddress(address) {
    // EIP-55 checksum
    address = address.toLowerCase().replace('0x', '');
    const hash = keccak256Hash(address);
    let checksumAddress = '0x';

    for (let i = 0; i < address.length; i++) {
        if (parseInt(hash[i], 16) >= 8) {
            checksumAddress += address[i].toUpperCase();
        } else {
            checksumAddress += address[i];
        }
    }
    return checksumAddress;
}

async function convertPKAddresses() {
    const pkInput = document.getElementById('pkInput').value.trim();

    if (!pkInput) {
        showPKError('Please enter a public key');
        return;
    }

    // Validate hex format
    if (!/^[0-9a-fA-F]+$/.test(pkInput)) {
        showPKError('Invalid format. Please enter a valid hexadecimal public key.');
        return;
    }

    // Validate key length (compressed: 66 chars, uncompressed: 130 chars, or 40 chars for hash)
    if (pkInput.length !== 66 && pkInput.length !== 130 && pkInput.length !== 40) {
        showPKError('Invalid public key length. Expected 33 bytes (compressed), 65 bytes (uncompressed), or 20 bytes (hash).');
        return;
    }

    // Show loading
    document.getElementById('pkConverterLoading').style.display = 'block';
    document.getElementById('pkConverterResults').style.display = 'none';
    document.getElementById('pkConverterError').style.display = 'none';

    try {
        // Generate addresses for different blockchains
        const addresses = generateAddresses(pkInput);

        // Check activity on each blockchain
        const addressesWithActivity = await checkAddressActivity(addresses);

        // Display results
        displayPKResults(addressesWithActivity);

    } catch (error) {
        console.error('PK Converter error:', error);
        showPKError('Error converting public key: ' + error.message);
    } finally {
        document.getElementById('pkConverterLoading').style.display = 'none';
    }
}

function generateAddresses(publicKeyHex) {
    const addresses = [];

    // Bitcoin
    const btcAddress = generateBitcoinAddress(publicKeyHex);
    if (btcAddress) {
        addresses.push({
            blockchain: 'Bitcoin',
            address: btcAddress,
            explorer: `https://www.blockchain.com/btc/address/${btcAddress}`,
            icon: '₿',
            color: '#f7931a'
        });
    }

    // Ethereum and EVM-compatible chains
    const ethAddress = generateEthereumAddress(publicKeyHex);
    if (ethAddress) {
        // Ethereum
        addresses.push({
            blockchain: 'Ethereum',
            address: ethAddress,
            explorer: `https://etherscan.io/address/${ethAddress}`,
            icon: 'Ξ',
            color: '#627eea'
        });

        // Binance Smart Chain (same address format)
        addresses.push({
            blockchain: 'BSC',
            address: ethAddress,
            explorer: `https://bscscan.com/address/${ethAddress}`,
            icon: '⟠',
            color: '#f3ba2f'
        });

        // Polygon (same address format)
        addresses.push({
            blockchain: 'Polygon',
            address: ethAddress,
            explorer: `https://polygonscan.com/address/${ethAddress}`,
            icon: '⬡',
            color: '#8247e5'
        });

        // Arbitrum (same address format)
        addresses.push({
            blockchain: 'Arbitrum',
            address: ethAddress,
            explorer: `https://arbiscan.io/address/${ethAddress}`,
            icon: '🔷',
            color: '#28a0f0'
        });

        // Optimism (same address format)
        addresses.push({
            blockchain: 'Optimism',
            address: ethAddress,
            explorer: `https://optimistic.etherscan.io/address/${ethAddress}`,
            icon: '⭕',
            color: '#ff0420'
        });
    }

    if (addresses.length === 0) {
        throw new Error('Unable to generate any addresses from the provided public key');
    }

    return addresses;
}

async function checkAddressActivity(addresses) {
    // Check each address for activity using existing BATS APIs
    const results = [];

    for (const addr of addresses) {
        let hasActivity = false;
        let balance = 'Checking...';
        let txCount = 0;

        try {
            if (addr.blockchain === 'Bitcoin') {
                // Use blockchain.info API
                const response = await fetch(`https://blockchain.info/rawaddr/${addr.address}?limit=1`);
                if (response.ok) {
                    const data = await response.json();
                    hasActivity = data.n_tx > 0;
                    txCount = data.n_tx;
                    balance = (data.final_balance / 100000000).toFixed(8) + ' BTC';
                }
            } else if (addr.blockchain === 'Ethereum' || addr.blockchain === 'BSC' || addr.blockchain === 'Polygon') {
                // Use Etherscan API
                const apiKey = localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8';
                let apiUrl = '';

                if (addr.blockchain === 'Ethereum') {
                    apiUrl = `https://api.etherscan.io/api?module=account&action=balance&address=${addr.address}&tag=latest&apikey=${apiKey}`;
                } else if (addr.blockchain === 'BSC') {
                    apiUrl = `https://api.bscscan.com/api?module=account&action=balance&address=${addr.address}&tag=latest&apikey=${apiKey}`;
                } else if (addr.blockchain === 'Polygon') {
                    apiUrl = `https://api.polygonscan.com/api?module=account&action=balance&address=${addr.address}&tag=latest&apikey=${apiKey}`;
                }

                const response = await fetch(apiUrl);
                if (response.ok) {
                    const data = await response.json();
                    if (data.status === '1') {
                        const bal = parseFloat(data.result) / 1e18;
                        hasActivity = bal > 0;
                        balance = bal.toFixed(4) + ' ' + (addr.blockchain === 'BSC' ? 'BNB' : addr.blockchain === 'Polygon' ? 'MATIC' : 'ETH');
                    }
                }

                // Get transaction count
                const txUrl = apiUrl.replace('action=balance', 'action=txlist');
                const txResponse = await fetch(txUrl);
                if (txResponse.ok) {
                    const txData = await txResponse.json();
                    if (txData.status === '1') {
                        txCount = txData.result.length;
                        hasActivity = txCount > 0;
                    }
                }
            }
        } catch (error) {
            console.error(`Error checking ${addr.blockchain} activity:`, error);
            balance = 'Error';
        }

        results.push({
            ...addr,
            hasActivity,
            balance,
            txCount,
            status: hasActivity ? 'ACTIVE' : 'NO ACTIVITY'
        });
    }

    return results;
}

function displayPKResults(addresses) {
    const resultsDiv = document.getElementById('pkConverterResults');
    const gridDiv = document.getElementById('pkAddressGrid');

    gridDiv.innerHTML = '';

    addresses.forEach(addr => {
        const card = document.createElement('div');
        card.style.cssText = `
            background: white;
            border: 2px solid ${addr.hasActivity ? '#27ae60' : '#ddd'};
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
        `;

        card.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h4 style="color: ${addr.color}; margin: 0; display: flex; align-items: center; gap: 8px;">
                    <span style="font-size: 24px;">${addr.icon}</span>
                    ${addr.blockchain}
                </h4>
                <span style="
                    background: ${addr.hasActivity ? '#27ae60' : '#95a5a6'};
                    color: white;
                    padding: 4px 12px;
                    border-radius: 12px;
                    font-size: 12px;
                    font-weight: 600;
                ">${addr.status}</span>
            </div>

            <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 15px;">
                <div style="font-size: 12px; color: #666; margin-bottom: 5px;">Address:</div>
                <div style="font-family: 'Courier New', monospace; font-size: 11px; word-break: break-all; color: #2c3e50;">
                    ${addr.address}
                </div>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                <div>
                    <div style="font-size: 12px; color: #666;">Balance:</div>
                    <div style="font-weight: 600; color: #2c3e50;">${addr.balance}</div>
                </div>
                <div>
                    <div style="font-size: 12px; color: #666;">Transactions:</div>
                    <div style="font-weight: 600; color: #2c3e50;">${addr.txCount}</div>
                </div>
            </div>

            <div style="display: flex; gap: 10px;">
                <button onclick="window.open('${addr.explorer}', '_blank')"
                        style="flex: 1; padding: 8px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                    View Explorer
                </button>
                <button onclick="navigator.clipboard.writeText('${addr.address}')"
                        style="padding: 8px 16px; background: #95a5a6; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                    Copy
                </button>
            </div>
        `;

        gridDiv.appendChild(card);
    });

    resultsDiv.style.display = 'block';
}

function showPKError(message) {
    const errorDiv = document.getElementById('pkConverterError');
    errorDiv.textContent = message;
    errorDiv.style.display = 'block';
}

// Address Finder Functions
function openAddressFinder() {
    const modal = document.getElementById('addressFinderModal');
    if (modal) {
        // Force display the modal regardless of parent visibility
        modal.style.display = 'flex';
        modal.style.position = 'fixed';
        modal.style.zIndex = '10001';
        modal.style.top = '0';
        modal.style.left = '0';
        modal.style.width = '100%';
        modal.style.height = '100%';
        modal.style.backgroundColor = 'rgba(0,0,0,0.5)';
        modal.style.alignItems = 'center';
        modal.style.justifyContent = 'center';
    } else {
        console.error('Address Finder modal not found');
    }
}

function closeAddressFinderModal() {
    const modal = document.getElementById('addressFinderModal');
    if (modal) {
        modal.style.display = 'none';
    }
    // Clear any errors
    const errorDiv = document.getElementById('addressFinderError');
    if (errorDiv) {
        errorDiv.style.display = 'none';
    }
}

function updateAddressFinderInputs() {
    const searchType = document.getElementById('addressFinderType').value;
    const singleInput = document.getElementById('singleInput');
    const doubleInput = document.getElementById('doubleInput');

    if (searchType === 'both') {
        singleInput.style.display = 'none';
        doubleInput.style.display = 'flex';
    } else {
        singleInput.style.display = 'flex';
        doubleInput.style.display = 'none';

        // Update placeholder based on search type
        const addressPrefix = document.getElementById('addressPrefix');
        if (searchType === 'prefix') {
            addressPrefix.placeholder = 'Enter first characters (e.g., 1A2B3C or bc1qxy)';
        } else if (searchType === 'suffix') {
            addressPrefix.placeholder = 'Enter last characters (e.g., XyZ9)';
        } else if (searchType === 'contains') {
            addressPrefix.placeholder = 'Enter characters to search anywhere in address';
        }
    }
}

window.searchAddresses = async function() {
    console.log('Search button clicked!');
    let chain = document.getElementById('addressFinderChain').value;
    const searchType = document.getElementById('addressFinderType').value;
    const activeOnly = document.getElementById('activeOnly').checked;

    let searchPattern = '';

    if (searchType === 'both') {
        const prefix = document.getElementById('addressPrefixDouble').value.trim();
        const suffix = document.getElementById('addressSuffix').value.trim();
        if (!prefix || !suffix) {
            showAddressFinderError('Please enter both first and last characters');
            return;
        }
        searchPattern = { prefix, suffix };
    } else {
        const input = document.getElementById('addressPrefix').value.trim();
        if (!input) {
            showAddressFinderError('Please enter characters to search');
            return;
        }
        searchPattern = input;
    }

    // Auto-detect chain based on address pattern
    const patternStr = typeof searchPattern === 'string' ? searchPattern : searchPattern.prefix;
    if (patternStr.toLowerCase().startsWith('0x')) {
        // Ethereum/EVM address
        if (chain === 'bitcoin' || chain === 'tron' || chain === 'solana') {
            console.log('Auto-detected Ethereum address, switching to Ethereum chain');
            chain = 'ethereum';
            document.getElementById('addressFinderChain').value = 'ethereum';
        }
    } else if (patternStr.startsWith('T') && patternStr.length > 10) {
        // Likely Tron address
        if (chain !== 'tron') {
            console.log('Auto-detected Tron address, switching to Tron chain');
            chain = 'tron';
            document.getElementById('addressFinderChain').value = 'tron';
        }
    } else if (patternStr.match(/^[1-9A-HJ-NP-Za-km-z]{32,44}$/) && !patternStr.startsWith('0x')) {
        // Likely Solana address (base58, 32-44 chars)
        if (chain !== 'solana' && patternStr.length > 30) {
            console.log('Auto-detected Solana address, switching to Solana chain');
            chain = 'solana';
            document.getElementById('addressFinderChain').value = 'solana';
        }
    } else if (patternStr.match(/^[13]/) || patternStr.toLowerCase().startsWith('bc1')) {
        // Bitcoin address
        if (chain !== 'bitcoin') {
            console.log('Auto-detected Bitcoin address, switching to Bitcoin chain');
            chain = 'bitcoin';
            document.getElementById('addressFinderChain').value = 'bitcoin';
        }
    }

    // Show loading
    document.getElementById('addressFinderLoading').style.display = 'block';
    document.getElementById('addressFinderResults').style.display = 'none';
    document.getElementById('addressFinderError').style.display = 'none';

    try {
        // Search for addresses based on pattern
        console.log('Searching for addresses:', { chain, searchType, searchPattern, activeOnly });
        const addresses = await findAddressesByPattern(chain, searchType, searchPattern, activeOnly);
        console.log('Found addresses:', addresses);

        // Display results
        await displayAddressFinderResults(addresses, chain);

    } catch (error) {
        console.error('Address search error:', error);
        showAddressFinderError('Error searching addresses: ' + error.message);
    } finally {
        document.getElementById('addressFinderLoading').style.display = 'none';
    }
}

async function findAddressesByPattern(chain, searchType, pattern, activeOnly) {
    console.log('findAddressesByPattern called with:', { chain, searchType, pattern, activeOnly });
    const results = [];

    // For demonstration, we'll use different strategies based on blockchain
    // In production, you'd use specialized blockchain indexing services

    try {
        if (chain === 'bitcoin') {
            console.log('Calling searchBitcoinAddresses...');
            // For Bitcoin, we can use blockchain.info's search functionality
            // Note: This is a simplified approach. In production, use specialized services
            results.push(...await searchBitcoinAddresses(searchType, pattern));
        } else if (chain === 'ethereum' || chain === 'bsc' || chain === 'polygon') {
            console.log('Calling searchEVMAddresses...');
            // For EVM chains, use Etherscan-like APIs
            const evmResults = await searchEVMAddresses(chain, searchType, pattern);
            console.log('searchEVMAddresses returned:', evmResults);
            if (evmResults && evmResults.length > 0) {
                console.log('Adding', evmResults.length, 'EVM results to main results array');
                results.push(...evmResults);
            } else {
                console.log('No EVM results to add');
            }
        } else if (chain === 'tron') {
            // For Tron, use TronGrid API
            results.push(...await searchTronAddresses(searchType, pattern));
        } else if (chain === 'solana') {
            // For Solana, use specialized search or RPC endpoints
            results.push(...await searchSolanaAddresses(searchType, pattern));
        }

        // Filter by activity if requested
        if (activeOnly) {
            console.log('Filtering by activity. Results before filter:', results.length);
            console.log('Full results array:', JSON.stringify(results, null, 2));
            const activeAddresses = [];
            for (const addr of results) {
                console.log('Checking address:', addr);
                console.log('  - entity:', addr.entity);
                console.log('  - type:', addr.type);
                console.log('  - hasActivity:', addr.hasActivity);

                // Always include addresses with attribution (exchanges, known entities, etc.)
                // Or if they already have the hasActivity flag set
                if ((addr.entity && addr.entity !== 'Unknown' && addr.entity !== 'EOA' && addr.entity !== 'EOA (Wallet)') ||
                    addr.hasActivity === true) {
                    console.log('✓ Including address:', addr.address, 'Reason:',
                        addr.hasActivity ? 'Has activity' : `Has attribution: ${addr.entity}`);
                    activeAddresses.push(addr);
                } else {
                    // Check activity for non-attributed addresses
                    console.log('Checking activity for address without attribution:', addr.address);
                    const hasActivity = await checkAddressHasActivity(addr.address, chain);
                    if (hasActivity) {
                        console.log('✓ Address has on-chain activity');
                        activeAddresses.push(addr);
                    } else {
                        console.log('✗ Filtered out inactive address:', addr.address);
                    }
                }
            }
            console.log('Returning', activeAddresses.length, 'active addresses from findAddressesByPattern');
            return activeAddresses;
        }

        console.log('Returning', results.length, 'total results from findAddressesByPattern:', results);
        return results;

    } catch (error) {
        console.error('Pattern search error:', error);
        // Return empty array instead of demo data
        return [];
    }
}

async function searchBitcoinAddresses(searchType, pattern) {
    const addresses = [];
    const foundAddresses = new Set(); // Prevent duplicates

    try {
        // Check if we have Arkham API key for partial searches
        // Use the same default key that's used elsewhere in the tool
        const arkhamKey = window.apiKeys?.arkham || 'd377a526-c9ea-4cb6-a647-775559583ff6';

        // Determine pattern length for validation
        const effectivePatternLength = (typeof pattern === 'object' && pattern.prefix)
            ? (pattern.prefix.length + pattern.suffix.length)
            : (typeof pattern === 'string' ? pattern.length : 0);

        // Only show guidance if we don't have Arkham API and pattern is too short
        if (!arkhamKey && effectivePatternLength < 26) {
            console.log(`Pattern too short without Arkham API. Bitcoin addresses are typically 26-35 characters. Current pattern: ${effectivePatternLength} chars`);

            // Return informative message for UI only if no Arkham API
            return [{
                address: `Need ${26 - effectivePatternLength} more characters`,
                type: 'Info',
                entity: 'No Arkham API configured',
                name: 'Configure Arkham API key in settings for partial search',
                firstSeen: 'Or provide complete address (26-35 chars)',
                lastSeen: 'Bitcoin addresses need 26+ characters'
            }];
        }

        // Strategy 1: Try Arkham Intelligence API FIRST (best for partial matches)
        // Handle both simple pattern string and {prefix, suffix} object
        const arkhamSearchTerm = (typeof pattern === 'object' && pattern.prefix) ? pattern.prefix : pattern;
        const patternLength = (typeof pattern === 'object' && pattern.prefix) ? pattern.prefix.length : (typeof pattern === 'string' ? pattern.length : 0);

        if (arkhamKey && arkhamSearchTerm && patternLength >= 3) {
            try {
                console.log(`Searching Arkham for pattern: ${arkhamSearchTerm} (type: ${searchType})`);

                // Note: Arkham's search endpoint appears to be unavailable (returns 405)
                // Skip Arkham search for now - only use for attribution
                const arkhamResponse = null; // Disabled until we find the correct search endpoint

                if (arkhamResponse && arkhamResponse.ok) {
                    const arkhamData = await arkhamResponse.json();
                    if (arkhamData && arkhamData.addresses) {
                        console.log(`Arkham found ${arkhamData.addresses.length} addresses for pattern: ${pattern}`);

                        for (const addr of arkhamData.addresses) {
                            // Check if address matches our search pattern based on search type
                            let matchesPattern = false;

                            if (searchType === 'prefix') {
                                matchesPattern = addr.address.toLowerCase().startsWith(pattern.toLowerCase());
                            } else if (searchType === 'suffix') {
                                matchesPattern = addr.address.toLowerCase().endsWith(pattern.toLowerCase());
                            } else if (searchType === 'contains') {
                                matchesPattern = addr.address.toLowerCase().includes(pattern.toLowerCase());
                            } else if (searchType === 'both' && pattern.prefix && pattern.suffix) {
                                matchesPattern = addr.address.toLowerCase().startsWith(pattern.prefix.toLowerCase()) &&
                                               addr.address.toLowerCase().endsWith(pattern.suffix.toLowerCase());
                            }

                            if (matchesPattern && !foundAddresses.has(addr.address)) {
                                foundAddresses.add(addr.address);
                                addresses.push({
                                    address: addr.address,
                                    type: addr.address.startsWith('1') ? 'P2PKH' :
                                          addr.address.startsWith('3') ? 'P2SH' :
                                          addr.address.startsWith('bc1') ? 'Bech32' : 'Bitcoin',
                                    entity: addr.entity || addr.name || 'Unknown',
                                    name: addr.label || addr.name || '',
                                    firstSeen: addr.firstSeen || 'Unknown',
                                    lastSeen: addr.lastSeen || new Date().toISOString().split('T')[0]
                                });
                            }
                        }
                    }
                } else if (arkhamResponse) {
                    console.log('Arkham API response not OK:', arkhamResponse.status);
                }
            } catch (e) {
                console.log('Arkham search error:', e);
            }
        }

        // Strategy 2: Try WalletExplorer firstbits for partial address completion
        // Note: This only returns the FIRST chronological match
        if (typeof pattern === 'string' && pattern.length >= 3 && pattern.length < 26) {
            try {
                console.log(`Trying WalletExplorer firstbits for prefix: ${pattern}`);
                const firstbitsUrl = `https://www.walletexplorer.com/api/1/firstbits?prefix=${pattern}`;
                const response = await fetch(firstbitsUrl);

                if (response.ok) {
                    const data = await response.json();
                    if (data.found && data.address && !foundAddresses.has(data.address)) {
                        foundAddresses.add(data.address);

                        // Get attribution from Arkham for the found address
                        let entity = 'Unknown';
                        let name = '';

                        if (arkhamKey) {
                            try {
                                const arkhamUrl = `/.netlify/functions/arkham3?endpoint=/intelligence/address/${data.address}`;
                                const arkhamResp = await fetch(arkhamUrl, {
                                    headers: {
                                        'X-Arkham-API-Key': arkhamKey
                                    }
                                });

                                if (arkhamResp.ok) {
                                    const arkhamData = await arkhamResp.json();
                                    if (arkhamData.arkhamEntity) {
                                        entity = arkhamData.arkhamEntity.name || entity;
                                        name = arkhamData.arkhamEntity.name || '';
                                        console.log(`Arkham attribution for ${data.address}: ${entity}`);
                                    }
                                }
                            } catch (e) {
                                console.log('Arkham attribution failed:', e);
                            }
                        }

                        // If no Arkham attribution, try WalletExplorer as fallback
                        if (entity === 'Unknown') {
                            try {
                                const walletLookupUrl = `https://www.walletexplorer.com/api/1/address-lookup?address=${data.address}`;
                                const walletResp = await fetch(walletLookupUrl);
                                if (walletResp.ok) {
                                    const walletData = await walletResp.json();
                                    if (walletData.found && walletData.wallet && walletData.wallet.name) {
                                        entity = walletData.wallet.name;
                                        name = walletData.wallet.name;
                                        console.log(`WalletExplorer attribution for ${data.address}: ${entity}`);
                                    }
                                }
                            } catch (e) {
                                console.log('WalletExplorer attribution failed:', e);
                            }
                        }

                        addresses.push({
                            address: data.address,
                            type: data.address.startsWith('1') ? 'P2PKH' :
                                  data.address.startsWith('3') ? 'P2SH' :
                                  data.address.startsWith('bc1') ? 'Bech32' : 'Bitcoin',
                            entity: entity,
                            name: name || '⚠️ First chronological match only',
                            firstSeen: data.firstSeen || 'Unknown',
                            source: 'WalletExplorer Firstbits'
                        });
                        console.log(`WalletExplorer firstbits found address: ${data.address} for prefix: ${pattern}`);

                        // Add guidance for more specific search
                        if (pattern.length < 8) {
                            addresses.push({
                                address: 'Need more characters for additional matches',
                                type: 'Info',
                                entity: 'Search Tip',
                                name: `Add ${8 - pattern.length} more characters for better results`,
                                firstSeen: 'Or use first + last characters',
                                source: 'Guidance'
                            });
                        }
                    }
                }
            } catch (e) {
                console.log('WalletExplorer firstbits search failed:', e);
            }
        }

        // Strategy 3: Try BlockCypher API for complete addresses AND get Arkham attribution
        if (typeof pattern === 'string' && pattern.length >= 26 && pattern.length <= 35) {
            try {
                // First get basic address info from BlockCypher
                const blockcypherUrl = `https://api.blockcypher.com/v1/btc/main/addrs/${pattern}/balance`;
                const response = await fetch(blockcypherUrl).catch(() => null);

                if (response && response.ok) {
                    const data = await response.json();
                    if (data.address) {
                        let entity = 'Validated Address';
                        let name = `Balance: ${(data.balance / 100000000).toFixed(8)} BTC`;

                        // Try to get attribution from Arkham for complete address
                        if (arkhamKey) {
                            try {
                                const arkhamUrl = `/.netlify/functions/arkham3?endpoint=/intelligence/address/${pattern}`;
                                const arkhamResp = await fetch(arkhamUrl, {
                                    headers: {
                                        'X-Arkham-API-Key': arkhamKey
                                    }
                                });

                                if (arkhamResp.ok) {
                                    const arkhamData = await arkhamResp.json();
                                    if (arkhamData.arkhamEntity) {
                                        entity = arkhamData.arkhamEntity.name || entity;
                                        name = `${arkhamData.arkhamEntity.name} | Balance: ${(data.balance / 100000000).toFixed(8)} BTC`;
                                        console.log(`Found Arkham attribution for ${pattern}: ${entity}`);
                                    }
                                }
                            } catch (e) {
                                console.log('Failed to get Arkham attribution:', e);
                            }
                        }

                        addresses.push({
                            address: data.address,
                            type: 'Bitcoin Address',
                            entity: entity,
                            name: name,
                            firstSeen: 'Active',
                            lastSeen: new Date().toISOString().split('T')[0]
                        });
                        foundAddresses.add(data.address);
                    }
                } else if (response && response.status === 404) {
                    // Address format is valid but not found on blockchain
                    addresses.push({
                        address: pattern,
                        type: 'Bitcoin Address',
                        entity: 'Not Found',
                        name: 'Valid format but no activity',
                        firstSeen: 'Never',
                        lastSeen: 'No blockchain activity'
                    });
                }
            } catch (e) {
                console.log('BlockCypher API error:', e);
            }
        }

        // (Arkham API already checked above as Strategy 1)

        // Strategy 2: For complete addresses (26+ chars), use blockchain.info
        // Only check if pattern is a string (not an object) and is long enough
        if (typeof pattern === 'string' && pattern.length >= 26 && !foundAddresses.has(pattern)) {
            try {
                const checkUrl = `https://blockchain.info/rawaddr/${pattern}?limit=1`;
                const response = await fetch(checkUrl, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json'
                    }
                }).catch(err => {
                    console.log('Not a valid complete address:', pattern);
                    return null;
                });

                if (response && response.ok) {
                    const data = await response.json();
                    if (data && data.address && !foundAddresses.has(data.address)) {
                        let entity = 'Unknown';
                        let name = '';

                        // Try to get Arkham attribution for this address
                        if (arkhamKey) {
                            try {
                                const arkhamUrl = `/.netlify/functions/arkham3?endpoint=/intelligence/address/${data.address}`;
                                const arkhamResp = await fetch(arkhamUrl, {
                                    headers: {
                                        'X-Arkham-API-Key': arkhamKey
                                    }
                                });

                                if (arkhamResp.ok) {
                                    const arkhamData = await arkhamResp.json();
                                    if (arkhamData.arkhamEntity) {
                                        entity = arkhamData.arkhamEntity.name || entity;
                                        name = arkhamData.arkhamEntity.name || '';
                                        console.log(`Found Arkham attribution for ${data.address}: ${entity}`);
                                    }
                                }
                            } catch (e) {
                                console.log('Failed to get Arkham attribution:', e);
                            }
                        }

                        foundAddresses.add(data.address);
                        addresses.push({
                            address: data.address,
                            type: data.address.startsWith('1') ? 'P2PKH' :
                                  data.address.startsWith('3') ? 'P2SH' :
                                  data.address.startsWith('bc1') ? 'Bech32' : 'Unknown',
                            balance: data.final_balance / 100000000,
                            txCount: data.n_tx,
                            entity: entity,
                            name: name,
                            source: 'Blockchain.info'
                        });
                    }
                }
            } catch (e) {
                console.log('Address lookup failed:', e);
            }
        }

        // Strategy 3: Try Mempool.space API (free, no auth required)
        if (typeof pattern === 'string' && pattern.length >= 26) {
            try {
                // Mempool.space API for complete addresses
                const mempoolUrl = `https://mempool.space/api/address/${pattern}`;
                const mempoolResponse = await fetch(mempoolUrl, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json'
                    }
                }).catch(err => {
                    console.log('Mempool.space API failed:', err);
                    return null;
                });

                if (mempoolResponse && mempoolResponse.ok) {
                    const mempoolData = await mempoolResponse.json();
                    if (mempoolData && mempoolData.address && !foundAddresses.has(mempoolData.address)) {
                        foundAddresses.add(mempoolData.address);
                        addresses.push({
                            address: mempoolData.address,
                            type: mempoolData.address.startsWith('1') ? 'P2PKH' :
                                  mempoolData.address.startsWith('3') ? 'P2SH' :
                                  mempoolData.address.startsWith('bc1') ? 'Bech32' : 'Unknown',
                            balance: (mempoolData.chain_stats.funded_txo_sum - mempoolData.chain_stats.spent_txo_sum) / 100000000,
                            txCount: mempoolData.chain_stats.tx_count,
                            source: 'Mempool.space'
                        });
                    }
                }
            } catch (e) {
                console.log('Mempool.space search failed:', e);
            }
        }

        // Strategy 4: Only use blockchain.info for COMPLETE addresses
        // The addressfirstseen endpoint doesn't support partial addresses
        if (typeof pattern === 'string' && pattern.length >= 26) { // Bitcoin addresses are at least 26 chars
            try {
                // Only check if this looks like a complete address
                const searchUrl = `https://blockchain.info/q/addressfirstseen/${pattern}`;
                const response = await fetch(searchUrl, {
                    method: 'GET',
                    headers: {
                        'Accept': 'text/plain'
                    }
                }).catch(err => {
                    // Expected to fail for partial addresses
                    return null;
                });

                if (response && response.ok) {
                    const timestamp = await response.text();
                    // If we got a valid timestamp, the address exists
                    if (timestamp && timestamp !== '0' && !foundAddresses.has(pattern)) {
                        foundAddresses.add(pattern);
                        // Now get full details
                        try {
                            const detailUrl = `https://blockchain.info/rawaddr/${pattern}?limit=1`;
                            const detailResponse = await fetch(detailUrl);
                            if (detailResponse.ok) {
                                const detailData = await detailResponse.json();
                                addresses.push({
                                    address: detailData.address,
                                    type: detailData.address.startsWith('1') ? 'P2PKH' :
                                          detailData.address.startsWith('3') ? 'P2SH' :
                                          detailData.address.startsWith('bc1') ? 'Bech32' : 'Unknown',
                                    balance: detailData.final_balance / 100000000,
                                    txCount: detailData.n_tx,
                                    firstSeen: new Date(timestamp * 1000).toISOString(),
                                    source: 'Blockchain.info'
                                });
                            }
                        } catch (e) {
                            // Still add basic info if detail fetch fails
                            addresses.push({
                                address: pattern,
                                type: pattern.startsWith('1') ? 'P2PKH' :
                                      pattern.startsWith('3') ? 'P2SH' :
                                      pattern.startsWith('bc1') ? 'Bech32' : 'Unknown',
                                firstSeen: new Date(timestamp * 1000).toISOString(),
                                source: 'Blockchain.info (partial)'
                            });
                        }
                    }
                }
            } catch (e) {
                console.log('Blockchain q search failed:', e);
            }
        }

        // Strategy 5: BlockCypher API (if available)
        const blockCypherKey = localStorage.getItem('bats_blockcypher_api_key');
        if (blockCypherKey && pattern.length >= 4 && addresses.length < 10) {
            try {
                // BlockCypher doesn't have direct partial search, but we can try exact match
                const bcUrl = `https://api.blockcypher.com/v1/btc/main/addrs/${pattern}?token=${blockCypherKey}`;

                const response = await fetch(bcUrl, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json'
                    }
                }).catch(err => {
                    console.log('BlockCypher search failed:', err);
                    return null;
                });

                if (response && response.ok) {
                    const data = await response.json();
                    if (data && data.address && !foundAddresses.has(data.address)) {
                        foundAddresses.add(data.address);
                        addresses.push({
                            address: data.address,
                            type: data.address.startsWith('1') ? 'P2PKH' :
                                  data.address.startsWith('3') ? 'P2SH' :
                                  data.address.startsWith('bc1') ? 'Bech32' : 'Unknown',
                            balance: data.balance / 100000000,
                            txCount: data.n_tx,
                            source: 'BlockCypher'
                        });
                    }
                }
            } catch (e) {
                console.log('BlockCypher API failed:', e);
            }
        }

        // Strategy 6: For very short patterns, try known exchange/service addresses
        if (pattern.length >= 3 && pattern.length < 26 && addresses.length < 5) {
            // Check against known Bitcoin addresses database
            const knownAddresses = [
                // Major exchanges
                { address: '1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa', label: 'Genesis Block', entity: 'Satoshi Nakamoto' },
                { address: '12cgpFdJViXbwHbhrA3TuW1EGnL25Zqc3P', label: 'Binance Cold Wallet', entity: 'Binance' },
                { address: '34xp4vRoCGJym3xR7yCVPFHoCNxv4Twseo', label: 'Binance Cold Wallet', entity: 'Binance' },
                { address: '3M219KR5vEneNb47ewrPfWyb5jQ2DjxRP6', label: 'Binance Hot Wallet', entity: 'Binance' },
                { address: '1FeexV6bAHb8ybZjqQMjJrcCrHGW9sb6uF', label: 'Coinbase Cold Storage', entity: 'Coinbase' },
                { address: '3Cbq7aT1tY8kMxWLbitaG7yT6bPbKChq64', label: 'Coinbase Cold Storage', entity: 'Coinbase' },
                { address: '3Nxwenay9Z8Lc9JBiywExpnEFiLp6Afp8v', label: 'Bitstamp Cold Wallet', entity: 'Bitstamp' },
                { address: '1Kr6QSydW9bFQG1mXiPNNu6WpJGmUa9i1g', label: 'Bitfinex Cold Wallet', entity: 'Bitfinex' },
                { address: '3D2oetdNuZUqQHPJmcMDDHYoqkyNVsFk9r', label: 'Bitfinex Cold Wallet 2', entity: 'Bitfinex' },
                { address: '16rCmCmbuWDhPjWTrpQGaU3EPdZF7MTdUk', label: 'Bittrex Cold Wallet', entity: 'Bittrex' },
                { address: 'bc1qgdjqv0av3q56jvd82tkdjpy7gdp9ut8tlqmgrpmv24sq90ecnvqqjwvw97', label: 'Binance Cold Wallet', entity: 'Binance' },
                { address: 'bc1q28py4w5l8nt0prqsl4v20e50vh3edqhxgr5ydf7', label: 'Kraken Cold Wallet', entity: 'Kraken' }
            ];

            for (const known of knownAddresses) {
                const matchesPattern =
                    (searchType === 'prefix' && known.address.startsWith(pattern)) ||
                    (searchType === 'suffix' && known.address.endsWith(pattern)) ||
                    (searchType === 'contains' && known.address.includes(pattern));

                if (matchesPattern && !foundAddresses.has(known.address)) {
                    foundAddresses.add(known.address);
                    // Try to get current balance from blockchain.info
                    try {
                        const balanceUrl = `https://blockchain.info/q/addressbalance/${known.address}`;
                        const balanceResponse = await fetch(balanceUrl).catch(() => null);
                        let balance = 0;
                        if (balanceResponse && balanceResponse.ok) {
                            const satoshis = await balanceResponse.text();
                            balance = parseInt(satoshis) / 100000000;
                        }

                        addresses.push({
                            address: known.address,
                            type: known.address.startsWith('1') ? 'P2PKH' :
                                  known.address.startsWith('3') ? 'P2SH' :
                                  known.address.startsWith('bc1') ? 'Bech32' : 'Unknown',
                            balance: balance,
                            label: known.label,
                            entity: known.entity,
                            source: 'Known Address Database'
                        });
                    } catch (e) {
                        // Add without balance if fetch fails
                        addresses.push({
                            address: known.address,
                            type: known.address.startsWith('1') ? 'P2PKH' :
                                  known.address.startsWith('3') ? 'P2SH' :
                                  known.address.startsWith('bc1') ? 'Bech32' : 'Unknown',
                            label: known.label,
                            entity: known.entity,
                            source: 'Known Address Database'
                        });
                    }
                }
            }
        }

        // Note: For complete Bitcoin address search, consider using:
        // - BTCPay Server API
        // - Blockstream Esplora API
        // - Local Bitcoin Core with txindex enabled

    } catch (error) {
        console.error('Bitcoin address search error:', error);
    }

    // Log search summary for debugging
    if (addresses.length > 0) {
        console.log(`Bitcoin address search found ${addresses.length} results for pattern: ${pattern}`);
    } else {
        console.log(`No Bitcoin addresses found for pattern: ${pattern}`);
    }

    return addresses;
}

// Helper function to generate possible Bitcoin addresses based on partial pattern
function generateBitcoinAddressPatterns(prefix) {
    const patterns = [];

    // Only generate a few common patterns to check
    // This is limited to avoid too many API calls
    if (prefix.startsWith('1') || prefix.startsWith('3') || prefix.startsWith('bc1')) {
        // For demonstration, just return the prefix itself to check
        // In production, you'd use a more sophisticated pattern generator
        patterns.push(prefix);
    }

    return patterns;
}

async function searchEVMAddresses(chain, searchType, pattern) {
    console.log('searchEVMAddresses called with:', { chain, searchType, pattern });
    const addresses = [];
    const apiKey = localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8';

    try {
        // Strategy 1: If it's a complete address, try Arkham first for best attribution
        if (pattern.match(/^0x[a-fA-F0-9]{40}$/i)) {
            console.log('Complete address detected, trying Arkham first...');
            try {
                const arkhamKey = window.apiKeys?.arkham || 'd377a526-c9ea-4cb6-a647-775559583ff6';

                // Try multiple Arkham endpoints (with tags for enhanced data)
                const arkhamEndpoints = [
                    `/intelligence/address_with_extra_enrichment/${pattern}/all?tags=true`,
                    `/intelligence/address/${pattern}/all`,
                    `/intelligence/address/${pattern}`
                ];

                for (const endpoint of arkhamEndpoints) {
                    try {
                        const arkhamResponse = await fetch(`/.netlify/functions/arkham3?endpoint=${encodeURIComponent(endpoint)}`, {
                            headers: {
                                'X-Arkham-API-Key': arkhamKey
                            }
                        });

                        if (arkhamResponse.ok) {
                            const arkhamData = await arkhamResponse.json();
                            console.log('Arkham response for', endpoint, ':', arkhamData);

                            if (arkhamData && (arkhamData.arkhamEntity || arkhamData.entity || arkhamData.name || arkhamData.label)) {
                                // Found attribution via Arkham
                                const addressEntry = {
                                    address: pattern,
                                    type: 'EOA',
                                    entity: arkhamData.arkhamEntity?.name || arkhamData.entity || arkhamData.name || arkhamData.label || 'Unknown',
                                    name: arkhamData.arkhamEntity?.name || arkhamData.name || '',
                                    source: 'Arkham Intelligence',
                                    isExchange: arkhamData.arkhamEntity?.type === 'exchange' || arkhamData.type === 'exchange',
                                    hasAttribution: true,
                                    detectionConfidence: 95
                                };
                                console.log('Adding Arkham-attributed address:', addressEntry);
                                addresses.push(addressEntry);
                                break; // Found good attribution, stop trying other endpoints
                            }
                        }
                    } catch (e) {
                        console.log('Arkham endpoint failed:', endpoint, e);
                    }
                }
            } catch (arkhamError) {
                console.log('Arkham search failed:', arkhamError);
            }
        }

        // Strategy 2: Use Etherscan API (V2 endpoints if available)
        let apiUrl = '';
        if (chain === 'ethereum') {
            apiUrl = 'https://api.etherscan.io/api';
        } else if (chain === 'bsc') {
            apiUrl = 'https://api.bscscan.com/api';
        } else if (chain === 'polygon') {
            apiUrl = 'https://api.polygonscan.com/api';
        }

        // For exact address match or if pattern is long enough, check directly via Etherscan
        // Even if we already got it from Arkham, still check Etherscan for balance info
        if (pattern.length >= 40 && pattern.match(/^0x[a-fA-F0-9]{40}$/i)) {
            console.log('Checking full address via Etherscan:', pattern);
            // Check if we already have this address from Arkham
            const existingAddress = addresses.find(a => a.address.toLowerCase() === pattern.toLowerCase());
            if (existingAddress) {
                console.log('Address already found via Arkham, skipping Etherscan check');
            } else {
                // Potentially a full address, check it directly
            try {
                // First try V2 API for address metadata/tags
                let entity = 'Unknown';
                let hasTag = false;

                try {
                    const chainId = chain === 'ethereum' ? 1 : chain === 'bsc' ? 56 : 137;
                    const v2Url = `https://api.etherscan.io/v2/api?chainid=${chainId}&module=nametag&action=getaddresstag&address=${pattern}&apikey=${apiKey}`;
                    console.log('Trying Etherscan V2 nametag API:', v2Url);

                    const v2Response = await fetch(v2Url);
                    if (v2Response.ok) {
                        const v2Data = await v2Response.json();
                        console.log('Etherscan V2 response:', v2Data);

                        if (v2Data.status === '1' && v2Data.result && v2Data.result.length > 0) {
                            const tag = v2Data.result[0];
                            entity = tag.name || tag.nameTag || 'Unknown';
                            hasTag = true;
                            console.log('Found V2 nametag:', entity);
                        }
                    }
                } catch (v2Error) {
                    console.log('V2 API failed, falling back to V1:', v2Error);
                }

                // Now get balance and contract info using V1 API (still supported)
                const checkUrl = `${apiUrl}?module=account&action=balance&address=${pattern}&tag=latest&apikey=${apiKey}`;
                console.log('Fetching balance from V1 API:', checkUrl);
                const response = await fetch(checkUrl);
                if (response.ok) {
                    const data = await response.json();
                    console.log('Etherscan V1 balance response:', data);
                    try {
                        console.log('Response status:', data.status, 'Type:', typeof data.status);
                        // Even if status is '0', it's still a valid Ethereum address format
                        // Status '0' might mean no transactions or V1 deprecation warning
                        if (pattern.match(/^0x[a-fA-F0-9]{40}$/i)) {
                        console.log('Valid Ethereum address format, processing...');
                        // Valid address (even with zero balance)
                        // Try to get contract name if it's a contract
                        let contractName = '';

                        if (!hasTag) {
                            try {
                                const contractUrl = `${apiUrl}?module=contract&action=getsourcecode&address=${pattern}&apikey=${apiKey}`;
                                const contractResponse = await fetch(contractUrl);
                                if (contractResponse.ok) {
                                    const contractData = await contractResponse.json();
                                    if (contractData.status === '1' && contractData.result[0]) {
                                        contractName = contractData.result[0].ContractName || '';
                                        // Common contract names to entity mapping
                                        if (contractName.toLowerCase().includes('tether')) entity = 'Tether (USDT)';
                                        else if (contractName.toLowerCase().includes('usdc')) entity = 'Circle (USDC)';
                                        else if (contractName.toLowerCase().includes('uniswap')) entity = 'Uniswap';
                                        else if (contractName.toLowerCase().includes('compound')) entity = 'Compound';
                                        else if (contractName.toLowerCase().includes('aave')) entity = 'Aave';
                                        else if (contractName === '') entity = 'EOA (Wallet)';
                                        else entity = contractName;
                                    }
                                }
                            } catch (e) {
                                console.log('Could not fetch contract info:', e);
                            }
                        }

                        // Get attribution from our working attribution function
                        let attribution = null;
                        try {
                            attribution = await getWalletAttribution(pattern);
                            console.log('Attribution found:', attribution);
                        } catch (attrError) {
                            console.log('Could not get attribution:', attrError);
                        }

                        const addressEntry = {
                            address: pattern,
                            type: contractName ? 'Contract' : 'EOA',
                            entity: attribution?.name || attribution?.label || entity,
                            name: contractName || attribution?.name || '',
                            balance: parseFloat(data.result || '0') / 1e18,
                            source: hasTag ? 'Etherscan V2' : 'Etherscan + Arkham',
                            isToken: contractName && (contractName.toLowerCase().includes('token') ||
                                                     contractName.toLowerCase().includes('usdt') ||
                                                     contractName.toLowerCase().includes('usdc') ||
                                                     contractName.toLowerCase().includes('dai')),
                            isExchange: attribution?.isExchange || false,
                            isPersonalLabel: attribution?.isPersonalLabel || false,
                            detectionConfidence: attribution?.detectionConfidence || 0,
                            hasActivity: parseFloat(data.result || '0') > 0
                        };
                        console.log('Adding address to results:', addressEntry);
                        addresses.push(addressEntry);
                        console.log('Addresses array now has', addresses.length, 'entries');
                    } else {
                        console.log('Not a valid Ethereum address format:', pattern);
                    }
                    } catch (innerError) {
                        console.error('Error processing Etherscan response:', innerError);
                    }
                } else {
                    console.log('Response not ok:', response.status, response.statusText);
                }
            } catch (e) {
                console.log('Direct address check failed:', e);
            }
            }
        }

        // For shorter patterns, search recent blocks
        try {
            const blockResponse = await fetch(`${apiUrl}?module=proxy&action=eth_blockNumber&apikey=${apiKey}`);
            if (blockResponse.ok) {
                const blockData = await blockResponse.json();
                const currentBlock = parseInt(blockData.result, 16);

                // Check last few blocks for addresses matching pattern
                for (let i = 0; i < 3; i++) {
                    const blockNum = '0x' + (currentBlock - i).toString(16);
                    const txResponse = await fetch(`${apiUrl}?module=proxy&action=eth_getBlockByNumber&tag=${blockNum}&boolean=true&apikey=${apiKey}`);

                    if (txResponse.ok) {
                        const txData = await txResponse.json();
                        if (txData.result && txData.result.transactions) {
                            for (const tx of txData.result.transactions) {
                                // Check from address
                                if (matchesPattern(tx.from, searchType, pattern)) {
                                    addresses.push({
                                        address: tx.from,
                                        type: 'EOA',
                                        lastTx: tx.hash,
                                        source: 'Recent Block'
                                    });
                                }
                                // Check to address
                                if (tx.to && matchesPattern(tx.to, searchType, pattern)) {
                                    addresses.push({
                                        address: tx.to,
                                        type: tx.input === '0x' ? 'EOA' : 'Contract',
                                        lastTx: tx.hash,
                                        source: 'Recent Block'
                                    });
                                }
                            }
                        }
                    }
                }
            }
        } catch (e) {
            console.log('Block search failed:', e);
        }

        // Strategy 2: Search known token holders for patterns
        if (addresses.length < 10) {
            try {
                // Get USDT holders as they're common
                const tokenAddress = chain === 'ethereum' ? '0xdac17f958d2ee523a2206206c33637e02a75a60e' :
                                   chain === 'bsc' ? '0x55d398326f99059ff775485246999027b3197955' :
                                   '0xc2132d05d31c914a87c6611c10748aeb04b58e8f'; // Polygon

                const holdersUrl = `${apiUrl}?module=token&action=tokenholderlist&contractaddress=${tokenAddress}&page=1&offset=100&apikey=${apiKey}`;
                const holdersResponse = await fetch(holdersUrl);

                if (holdersResponse.ok) {
                    const holdersData = await holdersResponse.json();
                    if (holdersData.status === '1' && holdersData.result) {
                        for (const holder of holdersData.result) {
                            if (matchesPattern(holder.TokenHolderAddress, searchType, pattern)) {
                                addresses.push({
                                    address: holder.TokenHolderAddress,
                                    balance: parseFloat(holder.TokenHolderQuantity) / 1e6 + ' USDT',
                                    type: 'Token Holder',
                                    source: 'Token Holders'
                                });
                            }
                        }
                    }
                }
            } catch (e) {
                console.log('Token holder search failed:', e);
            }
        }

        // Strategy 3: Generate and validate potential addresses
        if (addresses.length === 0 && searchType === 'prefix') {
            const potentials = [];
            for (let i = 0; i < 5; i++) {
                const addr = pattern.toLowerCase() + generateRandomHex(42 - pattern.length);
                potentials.push(addr);
            }

            // Check if these addresses exist
            for (const addr of potentials) {
                try {
                    const balanceUrl = `${apiUrl}?module=account&action=balance&address=${addr}&tag=latest&apikey=${apiKey}`;
                    const response = await fetch(balanceUrl);
                    if (response.ok) {
                        const data = await response.json();
                        if (data.status === '1' && data.result !== '0') {
                            addresses.push({
                                address: addr,
                                balance: (parseFloat(data.result) / 1e18).toFixed(4) + ' ETH',
                                type: 'Validated',
                                source: 'Balance Check'
                            });
                        }
                    }
                } catch (e) {
                    // Address has no balance, skip
                }
            }
        }

    } catch (error) {
        console.error('EVM address search error:', error);
        console.log('Error occurred but continuing with addresses found so far:', addresses.length, 'addresses');
    }

    // Remove duplicates
    const uniqueAddresses = [];
    const seen = new Set();
    for (const addr of addresses) {
        if (!seen.has(addr.address.toLowerCase())) {
            seen.add(addr.address.toLowerCase());
            uniqueAddresses.push(addr);
        }
    }

    console.log('searchEVMAddresses returning', uniqueAddresses.length, 'unique addresses:', uniqueAddresses);
    return uniqueAddresses;
}

// Helper function to check if address matches pattern
function matchesPattern(address, searchType, pattern) {
    if (!address) return false;

    const addr = address.toLowerCase();
    const pat = typeof pattern === 'string' ? pattern.toLowerCase() : pattern;

    if (searchType === 'prefix') {
        return addr.startsWith(pat);
    } else if (searchType === 'suffix') {
        return addr.endsWith(pat);
    } else if (searchType === 'contains') {
        return addr.includes(pat);
    } else if (searchType === 'both') {
        return addr.startsWith(pat.prefix.toLowerCase()) && addr.endsWith(pat.suffix.toLowerCase());
    }

    return false;
}

async function searchTronAddresses(searchType, pattern) {
    const addresses = [];

    // Tron addresses start with T and are base58 encoded
    // This is a simplified demo

    if (searchType === 'prefix' && pattern.startsWith('T')) {
        for (let i = 0; i < 3; i++) {
            addresses.push({
                address: pattern + generateRandomBase58(34 - pattern.length),
                type: 'Account',
                firstSeen: '2024-02-01',
                lastSeen: '2024-12-01'
            });
        }
    }

    return addresses;
}

async function searchSolanaAddresses(searchType, pattern) {
    const addresses = [];

    // Known Solana vanity addresses and popular accounts
    const knownSolanaAddresses = [
        // System Programs
        { address: '11111111111111111111111111111111', name: 'System Program', type: 'System', entity: 'Solana' },
        { address: 'So11111111111111111111111111111111111111112', name: 'Wrapped SOL', type: 'Token', entity: 'Solana' },

        // Major SPL Tokens
        { address: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', name: 'USDC', type: 'SPL Token', entity: 'Circle' },
        { address: 'Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB', name: 'USDT', type: 'SPL Token', entity: 'Tether' },
        { address: 'DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263', name: 'BONK', type: 'Meme Token', entity: 'BONK DAO' },
        { address: 'EKpQGSJtjMFqKZ9KQanSqYXRcF8fBopzLHYxdM65zcjm', name: 'dogwifhat (WIF)', type: 'Meme Token', entity: 'Community' },
        { address: 'JUPyiwrYJFskUPiHa8hkeR8VUtAeFoSYbKedZNsDvCN', name: 'Jupiter (JUP)', type: 'DeFi Token', entity: 'Jupiter' },
        { address: '4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R', name: 'Raydium (RAY)', type: 'DEX Token', entity: 'Raydium' },

        // Vanity Addresses (examples)
        { address: '7777777777777777777777777777777777777777Eno', name: 'Lucky 7s', type: 'Vanity', entity: 'Unknown' },

        // Major Exchanges
        { address: '5tzFkiKscXHK5ZXCGbXZxdw7gTjjD1mBwuoFbhUvuAi9', name: 'Binance Hot Wallet', type: 'Exchange', entity: 'Binance' },
        { address: 'H8sMJSCQxfKiFTCfDR3DUMLPwcRbM61LGFJ8N4dK3WjS', name: 'Coinbase', type: 'Exchange', entity: 'Coinbase' },

        // DeFi Protocols
        { address: '9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin', name: 'Serum DEX', type: 'DEX', entity: 'Serum' },
        { address: 'DjVE6JNiYqPL2QXyCUUh8rNjHrbz9hXHNYt99MQ59qw1', name: 'Orca', type: 'DEX', entity: 'Orca' }
    ];

    try {
        let searchStr = '';
        if (searchType === 'both' && pattern.prefix && pattern.suffix) {
            // Search for addresses that start with prefix and end with suffix
            searchStr = pattern.prefix.toLowerCase();
            const suffixLower = pattern.suffix.toLowerCase();

            for (const addr of knownSolanaAddresses) {
                if (addr.address.toLowerCase().startsWith(searchStr) &&
                    addr.address.toLowerCase().endsWith(suffixLower)) {
                    addresses.push({
                        address: addr.address,
                        type: addr.type,
                        entity: addr.entity || 'Unknown',
                        name: addr.name,
                        firstSeen: '2020-03-01',
                        lastSeen: new Date().toISOString().split('T')[0]
                    });
                }
            }
        } else if (searchType === 'prefix') {
            searchStr = pattern.toLowerCase();
            for (const addr of knownSolanaAddresses) {
                if (addr.address.toLowerCase().startsWith(searchStr) ||
                    addr.name.toLowerCase().includes(searchStr)) {
                    addresses.push({
                        address: addr.address,
                        type: addr.type,
                        entity: addr.entity || 'Unknown',
                        name: addr.name,
                        firstSeen: '2020-03-01',
                        lastSeen: new Date().toISOString().split('T')[0]
                    });
                }
            }
        } else if (searchType === 'suffix') {
            searchStr = pattern.toLowerCase();
            for (const addr of knownSolanaAddresses) {
                if (addr.address.toLowerCase().endsWith(searchStr)) {
                    addresses.push({
                        address: addr.address,
                        type: addr.type,
                        entity: addr.entity || 'Unknown',
                        name: addr.name,
                        firstSeen: '2020-03-01',
                        lastSeen: new Date().toISOString().split('T')[0]
                    });
                }
            }
        } else if (searchType === 'contains') {
            searchStr = pattern.toLowerCase();
            for (const addr of knownSolanaAddresses) {
                if (addr.address.toLowerCase().includes(searchStr) ||
                    addr.name.toLowerCase().includes(searchStr)) {
                    addresses.push({
                        address: addr.address,
                        type: addr.type,
                        entity: addr.entity || 'Unknown',
                        name: addr.name,
                        firstSeen: '2020-03-01',
                        lastSeen: new Date().toISOString().split('T')[0]
                    });
                }
            }
        }

        // If pattern is a complete valid Solana address (32-44 chars), validate it
        if (typeof pattern === 'string' && pattern.length >= 32 && pattern.length <= 44) {
            try {
                // Check if it's a valid base58 address
                const base58Regex = /^[1-9A-HJ-NP-Za-km-z]{32,44}$/;
                if (base58Regex.test(pattern)) {
                    // Try to get account info from Solana RPC
                    const rpcUrl = localStorage.getItem('bats_solana_rpc_endpoint') || 'https://api.mainnet-beta.solana.com';
                    const response = await fetch(rpcUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            jsonrpc: '2.0',
                            id: 1,
                            method: 'getAccountInfo',
                            params: [pattern, { encoding: 'jsonParsed' }]
                        })
                    });

                    if (response.ok) {
                        const data = await response.json();
                        if (data.result && data.result.value) {
                            // Address exists on-chain
                            addresses.push({
                                address: pattern,
                                type: 'Account',
                                entity: 'Unknown',
                                name: 'Valid Solana Account',
                                firstSeen: 'On-chain',
                                lastSeen: new Date().toISOString().split('T')[0]
                            });
                        }
                    }
                }
            } catch (e) {
                console.log('Error validating Solana address:', e);
            }
        }

    } catch (error) {
        console.error('Solana address search error:', error);
    }

    return addresses;
}

async function checkAddressHasActivity(address, chain) {
    try {
        if (chain === 'bitcoin') {
            const response = await fetch(`https://blockchain.info/rawaddr/${address}?limit=1`);
            if (response.ok) {
                const data = await response.json();
                return data.n_tx > 0;
            }
        } else if (chain === 'ethereum' || chain === 'bsc' || chain === 'polygon') {
            const apiKey = localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8';
            let apiUrl = '';

            if (chain === 'ethereum') {
                apiUrl = `https://api.etherscan.io/api?module=account&action=txlist&address=${address}&page=1&offset=1&apikey=${apiKey}`;
            } else if (chain === 'bsc') {
                apiUrl = `https://api.bscscan.com/api?module=account&action=txlist&address=${address}&page=1&offset=1&apikey=${apiKey}`;
            } else if (chain === 'polygon') {
                apiUrl = `https://api.polygonscan.com/api?module=account&action=txlist&address=${address}&page=1&offset=1&apikey=${apiKey}`;
            }

            const response = await fetch(apiUrl);
            if (response.ok) {
                const data = await response.json();
                return data.status === '1' && data.result.length > 0;
            }
        }
    } catch (error) {
        console.error('Activity check error:', error);
    }

    return false; // Default to no activity if check fails
}

// Removed getDemoAddresses function - no demo data in production

async function displayAddressFinderResults(addresses, chain) {
    const resultsDiv = document.getElementById('addressFinderResults');
    const gridDiv = document.getElementById('addressResultsGrid');
    const countSpan = document.getElementById('resultCount');

    // Check attribution for each address
    for (let addr of addresses) {
        if (!addr.attribution && addr.entity && addr.entity !== 'Unknown') {
            const indicators = checkExchangeIndicators(addr.entity);
            addr.attribution = {
                confidence: indicators.confidence,
                isLikely: indicators.isLikely,
                type: indicators.suggestedType,
                matches: indicators.matches
            };
        }

        // Also try to get attribution if we don't have entity info
        if (!addr.entity || addr.entity === 'Unknown') {
            try {
                let attribution = null;
                if (chain === 'bitcoin') {
                    attribution = await getBitcoinWalletAttribution(addr.address);
                } else if (chain === 'solana') {
                    // Explicitly use Solana attribution for Solana chain
                    attribution = await getSolanaWalletAttribution(addr.address);
                } else {
                    // For other chains, use general attribution (which also detects Solana)
                    attribution = await getWalletAttribution(addr.address);
                }

                if (attribution) {
                    addr.entity = attribution.name || attribution.label || 'Unknown';
                    addr.entityType = attribution.type;
                    addr.isExchange = attribution.isExchange;
                    addr.isPersonalLabel = attribution.isPersonalLabel;

                    const indicators = checkExchangeIndicators(addr.entity);
                    addr.attribution = {
                        confidence: indicators.confidence || attribution.detectionConfidence || 0,
                        isLikely: indicators.isLikely || attribution.isExchange,
                        type: indicators.suggestedType || attribution.type,
                        matches: indicators.matches || attribution.detectionMatches || []
                    };
                }
            } catch (e) {
                console.log('Attribution lookup failed for', addr.address, e);
            }
        }
    }

    gridDiv.innerHTML = '';
    countSpan.textContent = `Found ${addresses.length} address${addresses.length !== 1 ? 'es' : ''}`;

    if (addresses.length === 0) {
        gridDiv.innerHTML = `
            <div style="text-align: center; padding: 40px; background: #f8f9fa; border-radius: 8px;">
                <div style="font-size: 48px; margin-bottom: 20px;">🔍</div>
                <h4 style="color: #666; margin-bottom: 15px;">No Matching Addresses Found</h4>
                <p style="color: #999; margin-bottom: 20px;">Try the following:</p>
                <ul style="text-align: left; display: inline-block; color: #777;">
                    <li>Provide at least 8-10 characters for partial searches</li>
                    <li>For Bitcoin, use at least 26 characters</li>
                    <li>Consider using complete addresses for best results</li>
                    <li>Configure Arkham Intelligence API key in settings for advanced search</li>
                    <li>Check your pattern for typos</li>
                    <li>Try a shorter prefix (minimum 3-4 characters)</li>
                    <li>Disable "Show only active addresses" filter</li>
                    <li>Try a different blockchain network</li>
                </ul>
                <p style="color: #999; margin-top: 20px; font-size: 12px;">
                    Note: Free APIs have limited search capabilities. For comprehensive searches,
                    consider using specialized blockchain indexing services.
                </p>
            </div>
        `;
    } else {
        addresses.forEach(addr => {
            const card = document.createElement('div');
            card.style.cssText = `
                background: white;
                border: 1px solid ${addr.hasActivity ? '#27ae60' : '#ddd'};
                border-radius: 8px;
                padding: 15px;
                display: grid;
                grid-template-columns: 1fr auto;
                gap: 15px;
                align-items: center;
                transition: all 0.2s;
                cursor: pointer;
            `;

            card.onmouseover = () => card.style.boxShadow = '0 4px 12px rgba(0,0,0,0.1)';
            card.onmouseout = () => card.style.boxShadow = 'none';

            const explorerUrls = {
                bitcoin: `https://www.blockchain.com/btc/address/${addr.address}`,
                ethereum: `https://etherscan.io/address/${addr.address}`,
                bsc: `https://bscscan.com/address/${addr.address}`,
                polygon: `https://polygonscan.com/address/${addr.address}`,
                tron: `https://tronscan.org/#/address/${addr.address}`
            };

            // Determine attribution display
            let attributionBadge = '';
            let entityColor = '#c0392b';
            let borderStyle = '';

            if (addr.attribution && addr.attribution.confidence > 0) {
                if (addr.attribution.confidence >= 85) {
                    attributionBadge = `<span style="background: #9c27b0; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px; font-weight: bold; margin-left: 8px;">🏦 EXCHANGE ${addr.attribution.confidence}%</span>`;
                    entityColor = '#9c27b0';
                    borderStyle = 'border-left: 4px solid #9c27b0;';
                } else if (addr.attribution.confidence >= 70) {
                    attributionBadge = `<span style="background: #e67e22; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px; margin-left: 8px;">⚠️ Likely Exchange ${addr.attribution.confidence}%</span>`;
                    entityColor = '#e67e22';
                    borderStyle = 'border-left: 4px solid #e67e22;';
                } else if (addr.attribution.confidence >= 50) {
                    attributionBadge = `<span style="background: #f39c12; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px; margin-left: 8px;">❓ Possible Service</span>`;
                    entityColor = '#f39c12';
                }
            } else if (addr.isExchange) {
                attributionBadge = `<span style="background: #9c27b0; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px; font-weight: bold; margin-left: 8px;">🏦 VERIFIED EXCHANGE</span>`;
                entityColor = '#9c27b0';
                borderStyle = 'border-left: 4px solid #9c27b0;';
            } else if (addr.isPersonalLabel) {
                attributionBadge = `<span style="background: #3498db; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px; margin-left: 8px;">🏷️ Personal Label</span>`;
                entityColor = '#3498db';
            }

            // Update card style if high confidence exchange
            if (borderStyle) {
                card.style.cssText += borderStyle;
            }

            card.innerHTML = `
                <div>
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                        <span style="font-family: 'Courier New', monospace; font-size: 13px; color: #2c3e50; word-break: break-all;">
                            ${highlightMatch(addr.address)}
                        </span>
                        <button onclick="navigator.clipboard.writeText('${addr.address}'); event.stopPropagation();"
                                style="padding: 2px 8px; background: #95a5a6; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">
                            Copy
                        </button>
                        ${attributionBadge}
                    </div>
                    <div style="display: flex; gap: 20px; font-size: 12px; color: #666; flex-wrap: wrap;">
                        <span>Type: <strong>${addr.type || 'Unknown'}</strong></span>
                        ${addr.name && addr.type === 'Contract' ? `<span style="color: #9b59b6; font-weight: bold;">📜 Contract: <strong style="color: #8e44ad;">${addr.name}</strong></span>` : ''}
                        ${addr.entity && addr.entity !== 'Unknown' ? `<span style="color: #e74c3c; font-weight: bold;">🏢 Entity: <strong style="color: ${entityColor};">${addr.entity}</strong></span>` : ''}
                        ${addr.isToken ? `<span style="color: #27ae60; font-weight: bold;">🪙 Token</span>` : ''}
                        ${addr.name && addr.type !== 'Contract' && !addr.entity ? `<span>Label: <strong>${addr.name}</strong></span>` : ''}
                        <span>Balance: <strong>${addr.balance || 'Unknown'}</strong></span>
                        <span>Txs: <strong>${addr.txCount || 'Unknown'}</strong></span>
                    </div>
                    ${addr.attribution && addr.attribution.matches && addr.attribution.matches.length > 0 ? `
                        <div style="margin-top: 8px; padding: 6px; background: #f8f9fa; border-radius: 4px; font-size: 11px; color: #666;">
                            <strong>Detection:</strong> ${addr.attribution.matches.map(m => `${m.type === 'CEX' ? '🏦' : m.type === 'DEX/Bridge' ? '🌉' : '🔍'} ${m.name}`).join(', ')}
                        </div>
                    ` : ''}
                </div>
                <div style="display: flex; gap: 10px;">
                    <button onclick="window.open('${explorerUrls[chain]}', '_blank'); event.stopPropagation();"
                            style="padding: 6px 12px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                        Explorer
                    </button>
                    <button onclick="addToInvestigation('${addr.address}', '${chain}'); event.stopPropagation();"
                            style="padding: 6px 12px; background: #27ae60; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                        Add to Case
                    </button>
                </div>
            `;

            gridDiv.appendChild(card);
        });
    }

    resultsDiv.style.display = 'block';
}

function highlightMatch(address) {
    const searchType = document.getElementById('addressFinderType').value;

    if (searchType === 'prefix') {
        const pattern = document.getElementById('addressPrefix').value;
        return `<strong style="color: #9b59b6;">${address.substring(0, pattern.length)}</strong>${address.substring(pattern.length)}`;
    } else if (searchType === 'suffix') {
        const pattern = document.getElementById('addressPrefix').value;
        return address.substring(0, address.length - pattern.length) + `<strong style="color: #9b59b6;">${address.substring(address.length - pattern.length)}</strong>`;
    } else if (searchType === 'both') {
        const prefix = document.getElementById('addressPrefixDouble').value;
        const suffix = document.getElementById('addressSuffix').value;
        return `<strong style="color: #9b59b6;">${address.substring(0, prefix.length)}</strong>${address.substring(prefix.length, address.length - suffix.length)}<strong style="color: #9b59b6;">${address.substring(address.length - suffix.length)}</strong>`;
    }

    return address;
}

function addToInvestigation(address, chain) {
    // Add the address to the current investigation
    alert(`Address ${address} would be added to your investigation.\n\nThis feature will integrate with the main B.A.T.S. investigation workflow.`);
    // In production, this would add the address to the victims or traces
}

function searchEntityAddresses(entityName) {
    // Close current modal and search for all addresses belonging to this entity
    console.log('Searching for addresses belonging to entity:', entityName);

    // You could enhance this to:
    // 1. Search Arkham for all addresses with this entity
    // 2. Filter by chain
    // 3. Show results in the same modal

    alert(`This would search for all addresses belonging to:\n${entityName}\n\nThis feature can help identify all wallets controlled by the same entity.`);
}

function showAddressFinderError(message) {
    const errorDiv = document.getElementById('addressFinderError');
    errorDiv.textContent = message;
    errorDiv.style.display = 'block';
}

// Helper functions for generating random characters
function generateRandomChars(length) {
    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz123456789';
    let result = '';
    for (let i = 0; i < length; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return result;
}

function generateRandomHex(length) {
    const chars = '0123456789abcdef';
    let result = '';
    for (let i = 0; i < length; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return result;
}

function generateRandomBase58(length) {
    const chars = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
    let result = '';
    for (let i = 0; i < length; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return result;
}

// Attribution API Integration (Arkham & Etherscan)
let currentAttributionData = null;
let pendingAttributionForEntry = null;

// Check Etherscan for attribution/labels
async function checkEtherscanAttribution(address) {
    // Only check Ethereum addresses
    if (!address || !address.startsWith('0x') || address.length !== 42) {
        return null;
    }
    
    try {
        const apiKey = localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8';
        const corsEnabled = localStorage.getItem('bats_cors_proxy_enabled') === 'true';
        const corsProxyUrl = localStorage.getItem('bats_cors_proxy_url') || 'https://cors-anywhere.herokuapp.com/';
        
        // Use Etherscan's address info endpoint
        let url = `https://api.etherscan.io/v2/api?chainid=1&module=account&action=addressinfo&address=${address}&apikey=${apiKey}`;
        if (corsEnabled) {
            url = corsProxyUrl + url;
        }
        
        const response = await fetch(url);
        if (!response.ok) return null;
        
        const data = await response.json();
        
        if (data.status === '1' && data.result) {
            const result = data.result;
            
            // Check if there's a public name tag or label
            if (result.publicTag || result.publicName || (result.labels && result.labels.length > 0)) {
                const attribution = {
                    chain: 'ethereum',
                    source: 'Etherscan',
                    entity: {
                        name: result.publicName || result.publicTag || (result.labels && result.labels[0]) || 'Unknown',
                        type: result.contractCreator ? 'Contract' : 'Address',
                        service: result.publicTag || null,
                        description: result.publicNote || null,
                        website: result.website || null
                    },
                    address: address
                };
                
                return [attribution];
            }
        }
        
        return null;
    } catch (error) {
        console.error('Error checking Etherscan attribution:', error);
        return null;
    }
}

// Combined attribution check (Arkham + Etherscan)
async function checkAllAttributions(address) {
    if (!address || address.trim() === '') return null;
    
    const attributions = [];
    
    // Check both sources in parallel
    const [arkhamData, etherscanData] = await Promise.all([
        checkArkhamAttribution(address),
        checkEtherscanAttribution(address)
    ]);
    
    if (arkhamData) {
        attributions.push(...arkhamData);
    }
    
    if (etherscanData) {
        attributions.push(...etherscanData);
    }
    
    return attributions.length > 0 ? attributions : null;
}

async function checkArkhamAttribution(address) {
    // Use embedded API key or user override
    const apiKey = window.apiKeys?.arkham || 'd377a526-c9ea-4cb6-a647-775559583ff6';
    const autoCheck = localStorage.getItem('bats_arkham_auto_check') !== 'false';
    
    if (!autoCheck) {
        return null;
    }
    
    // Validate it's a valid address format (basic check)
    if (!address || address.length < 26) {
        return null;
    }
    
    try {
        // Check if we need CORS proxy
        const corsEnabled = localStorage.getItem('bats_cors_proxy_enabled') === 'true';
        const corsProxyUrl = localStorage.getItem('bats_cors_proxy_url') || 'https://cors-anywhere.herokuapp.com/';
        
        let url = `https://api.arkhamintelligence.com/intelligence/address/${address}/all`;
        if (corsEnabled) {
            url = corsProxyUrl + url;
        }
        
        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'API-Key': apiKey,
                'Accept': 'application/json'
            }
        });
        
        if (!response.ok) {
            if (response.status === 401) {
                console.error('Arkham API: Invalid API key');
            } else if (response.status === 429) {
                console.error('Arkham API: Rate limit exceeded');
            }
            return null;
        }
        
        const data = await response.json();
        
        // Check if there's attribution data
        if (data && Object.keys(data).length > 0) {
            // Process the response to find entities
            const attributions = [];
            
            for (const [chain, addressData] of Object.entries(data)) {
                if (addressData && addressData.arkhamEntity) {
                    attributions.push({
                        chain: chain,
                        source: 'Arkham',
                        entity: addressData.arkhamEntity,
                        address: address
                    });
                }
            }
            
            if (attributions.length > 0) {
                return attributions;
            }
        }
        
        return null;
    } catch (error) {
        console.error('Error checking Arkham attribution:', error);
        return null;
    }
}

function showAttributionModal(attributions, hopNumber, entryId) {
    if (!attributions || attributions.length === 0) return;
    
    // Store for later use
    currentAttributionData = attributions;
    pendingAttributionForEntry = { hopNumber, entryId };
    
    // Build the content
    let content = '<div style="background: #e6f3ff; border: 2px solid #0066cc; border-radius: 8px; padding: 15px; margin-bottom: 20px;">';
    content += '<h4 style="color: #0066cc; margin-bottom: 10px;">Attribution Information Found!</h4>';
    
    attributions.forEach(attr => {
        const entity = attr.entity;
        const sourceColor = attr.source === 'Etherscan' ? '#627eea' : '#0066cc';
        const sourceEmoji = attr.source === 'Etherscan' ? '🔷' : '🔍';
        
        content += `
            <div style="margin: 15px 0; padding: 15px; background: white; border-radius: 6px; border: 1px solid ${sourceColor}20;">
                <div style="display: flex; align-items: start; gap: 15px;">
                    <div style="flex: 1;">
                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                            <h5 style="color: #2c3e50; margin: 0; font-size: 18px;">
                                ${entity.name || 'Unknown Entity'}
                            </h5>
                            <span style="background: ${sourceColor}; color: white; padding: 2px 8px; border-radius: 4px; font-size: 11px; font-weight: bold;">
                                ${sourceEmoji} ${attr.source || 'Arkham'}
                            </span>
                        </div>
                        ${entity.type ? `<div style="color: #666; margin-bottom: 5px;"><strong>Type:</strong> ${entity.type}</div>` : ''}
                        ${entity.service ? `<div style="color: #666; margin-bottom: 5px;"><strong>Service:</strong> ${entity.service}</div>` : ''}
                        <div style="color: #666; margin-bottom: 5px;"><strong>Chain:</strong> ${attr.chain}</div>
                        <div style="color: #666; margin-bottom: 5px; font-family: monospace; font-size: 12px;">
                            <strong>Address:</strong> ${attr.address}
                        </div>
                        ${entity.description ? `<div style="color: #666; margin-top: 10px; font-style: italic;">${entity.description}</div>` : ''}
                    </div>
                </div>
                ${entity.website || entity.twitter ? `
                    <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #e8f0fe;">
                        ${entity.website ? `<a href="${entity.website}" target="_blank" style="color: #3498db; margin-right: 15px;">🌐 Website</a>` : ''}
                        ${entity.twitter ? `<a href="https://twitter.com/${entity.twitter}" target="_blank" style="color: #3498db;">🐦 Twitter</a>` : ''}
                    </div>
                ` : ''}
            </div>
        `;
    });
    
    content += '</div>';
    content += '<p style="color: #666; font-size: 14px;">Would you like to apply this attribution information to the wallet entry?</p>';
    
    document.getElementById('attributionContent').innerHTML = content;
    showModal('attributionModal');
}

function applyAttribution() {
    if (!currentAttributionData || !pendingAttributionForEntry) return;
    
    const { hopNumber, entryId } = pendingAttributionForEntry;
    
    // Combine all attribution sources into notes
    let attributionNotes = [];
    currentAttributionData.forEach(attr => {
        const entity = attr.entity;
        const source = attr.source || 'Arkham';
        attributionNotes.push(`[${source}] Entity: ${entity.name}${entity.type ? ` (${entity.type})` : ''}${entity.service ? ` - ${entity.service}` : ''}`);
    });
    
    const attributionNote = attributionNotes.join('\n');
    
    // Find the entry and add notes about the attribution
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    if (hop) {
        const entry = hop.entries.find(e => e.id === entryId);
        if (entry) {
            if (entry.notes) {
                entry.notes = attributionNote + '\n' + entry.notes;
            } else {
                entry.notes = attributionNote;
            }
            
            // Update the notes field if it exists
            const notesField = document.querySelector(`textarea[onchange*="updateHopEntry(${hopNumber}, ${entryId}, 'notes'"]`);
            if (notesField) {
                notesField.value = entry.notes;
            }
            
            saveToStorage();
        }
    }
    
    hideModal('attributionModal');
    currentAttributionData = null;
    pendingAttributionForEntry = null;
}

// Wallet Address Autocomplete Functions
let autocompleteTimeout = null;
let currentAutocompleteRequest = null;

function detectBlockchainFromAddress(address) {
    if (!address || address.length < 3) return null;
    
    // Check each blockchain's address pattern
    for (const [chain, config] of Object.entries(blockchainAPIs)) {
        // First check prefixes for quick detection
        if (config.addressPrefixes) {
            for (const prefix of config.addressPrefixes) {
                if (address.startsWith(prefix)) {
                    // For longer prefixes like 'bc1', check if we have enough characters
                    if (prefix.length > 1 && address.length < 10) continue;
                    return chain;
                }
            }
        }
    }
    return null;
}

async function handleWalletAutocomplete(input, hopNumber, entryId) {
    const value = input.value.trim();
    const dropdown = document.getElementById(`autocomplete_${hopNumber}_${entryId}`);
    
    // Clear any pending timeout
    if (autocompleteTimeout) {
        clearTimeout(autocompleteTimeout);
    }
    
    // Hide dropdown if input is too short
    if (value.length < 9) {
        dropdown.style.display = 'none';
        return;
    }
    
    // First check if it matches any existing wallet in UWI
    const existingMatches = (investigation.universalWalletIndex || [])
        .filter(wallet => wallet.address.toLowerCase().startsWith(value.toLowerCase()))
        .slice(0, 5); // Limit to 5 matches
    
    if (existingMatches.length > 0) {
        // Show existing matches immediately
        showAutocompleteResults(dropdown, existingMatches.map(wallet => ({
            address: wallet.address,
            type: 'existing',
            walletInfo: wallet
        })), hopNumber, entryId);
        return;
    }
    
    // Detect blockchain type
    const detectedChain = detectBlockchainFromAddress(value);
    if (!detectedChain) {
        dropdown.style.display = 'none';
        return;
    }
    
    // Show loading state
    dropdown.innerHTML = '<div class="wallet-autocomplete-loading">Searching blockchain...</div>';
    dropdown.style.display = 'block';
    
    // Debounce API calls
    autocompleteTimeout = setTimeout(async () => {
        try {
            const suggestions = await fetchAddressSuggestions(value, detectedChain);
            if (suggestions && suggestions.length > 0) {
                showAutocompleteResults(dropdown, suggestions, hopNumber, entryId);
            } else {
                dropdown.innerHTML = `<div class="wallet-autocomplete-loading">No addresses found starting with "${value}"</div>`;
                setTimeout(() => { dropdown.style.display = 'none'; }, 2000);
            }
        } catch (error) {
            console.error('Autocomplete error:', error);
            dropdown.style.display = 'none';
        }
    }, 300); // 300ms debounce
}

async function fetchAddressSuggestions(partialAddress, blockchain) {
    const config = blockchainAPIs[blockchain];
    if (!config) return [];
    
    try {
        // For now, we'll validate the address format
        // In a real implementation, you'd query blockchain explorers for similar addresses
        // Most blockchains don't offer address autocomplete APIs, so we'll provide format validation
        
        const suggestions = [];
        
        // Check if the partial address could be valid when completed
        if (blockchain === 'bitcoin') {
            // Bitcoin addresses are 26-34 chars for P2PKH/P2SH, 42-62 for Bech32
            if (partialAddress.startsWith('1') || partialAddress.startsWith('3')) {
                // Legacy/SegWit addresses
                if (partialAddress.length >= 26) {
                    suggestions.push({
                        address: partialAddress,
                        type: 'valid',
                        blockchain: 'Bitcoin',
                        note: 'Valid Bitcoin address format'
                    });
                } else {
                    suggestions.push({
                        address: partialAddress + '...',
                        type: 'partial',
                        blockchain: 'Bitcoin',
                        note: `Need ${26 - partialAddress.length} more characters (min 26)`
                    });
                }
            } else if (partialAddress.startsWith('bc1')) {
                // Bech32 addresses
                if (partialAddress.length >= 42) {
                    suggestions.push({
                        address: partialAddress,
                        type: 'valid',
                        blockchain: 'Bitcoin',
                        note: 'Valid Bitcoin Bech32 address format'
                    });
                } else {
                    suggestions.push({
                        address: partialAddress + '...',
                        type: 'partial',
                        blockchain: 'Bitcoin',
                        note: `Need ${42 - partialAddress.length} more characters (min 42)`
                    });
                }
            }
        } else if (blockchain === 'ethereum') {
            // Ethereum addresses are exactly 42 chars (including 0x)
            if (partialAddress.length === 42) {
                suggestions.push({
                    address: partialAddress,
                    type: 'valid',
                    blockchain: 'Ethereum',
                    note: 'Valid Ethereum address format'
                });
            } else if (partialAddress.length < 42) {
                suggestions.push({
                    address: partialAddress + '...',
                    type: 'partial',
                    blockchain: 'Ethereum',
                    note: `Need ${42 - partialAddress.length} more characters (exactly 42)`
                });
            }
        } else if (blockchain === 'tron') {
            // Tron addresses are exactly 34 chars
            if (partialAddress.length === 34) {
                suggestions.push({
                    address: partialAddress,
                    type: 'valid',
                    blockchain: 'Tron',
                    note: 'Valid Tron address format'
                });
            } else if (partialAddress.length < 34) {
                suggestions.push({
                    address: partialAddress + '...',
                    type: 'partial',
                    blockchain: 'Tron',
                    note: `Need ${34 - partialAddress.length} more characters (exactly 34)`
                });
            }
        } else if (blockchain === 'solana') {
            // Solana addresses are 32-44 chars
            if (partialAddress.length >= 32 && partialAddress.length <= 44) {
                suggestions.push({
                    address: partialAddress,
                    type: 'valid',
                    blockchain: 'Solana',
                    note: 'Valid Solana address format'
                });
            } else if (partialAddress.length < 32) {
                suggestions.push({
                    address: partialAddress + '...',
                    type: 'partial',
                    blockchain: 'Solana',
                    note: `Need ${32 - partialAddress.length} more characters (min 32)`
                });
            }
        }
        
        return suggestions;
    } catch (error) {
        console.error('Error fetching address suggestions:', error);
        return [];
    }
}

function showAutocompleteResults(dropdown, results, hopNumber, entryId) {
    dropdown.innerHTML = '';
    dropdown.style.display = 'block';
    
    results.forEach((result, index) => {
        const item = document.createElement('div');
        item.className = 'wallet-autocomplete-item';
        
        if (result.type === 'existing') {
            // Existing wallet from UWI
            item.innerHTML = `
                <div>${result.address}</div>
                <div class="wallet-autocomplete-blockchain">
                    ${result.walletInfo.permanentId} - ${walletTypes[result.walletInfo.permanentType] || result.walletInfo.permanentType}
                </div>
            `;
            item.onclick = () => selectAutocompleteAddress(result.address, hopNumber, entryId);
        } else {
            // Blockchain validation result
            const statusColor = result.type === 'valid' ? '#27ae60' : '#e67e22';
            item.innerHTML = `
                <div style="color: ${statusColor};">${result.address}</div>
                <div class="wallet-autocomplete-blockchain">${result.blockchain} - ${result.note}</div>
            `;
            if (result.type === 'valid') {
                item.onclick = () => selectAutocompleteAddress(result.address, hopNumber, entryId);
            }
        }
        
        dropdown.appendChild(item);
    });
}

function selectAutocompleteAddress(address, hopNumber, entryId) {
    const input = document.getElementById(`toWallet_${hopNumber}_${entryId}`);
    const dropdown = document.getElementById(`autocomplete_${hopNumber}_${entryId}`);
    
    input.value = address;
    dropdown.style.display = 'none';
    
    // Trigger the change event
    updateHopEntry(hopNumber, entryId, 'toWallet', address);
}

// Close autocomplete when clicking outside
document.addEventListener('click', function(event) {
    if (!event.target.matches('input[id^="toWallet_"]')) {
        document.querySelectorAll('.wallet-autocomplete-dropdown').forEach(dropdown => {
            dropdown.style.display = 'none';
        });
    }
});

// Bulk Transaction Modal Functions
function openBulkTransactionModal(victimId) {
    currentBulkVictimId = victimId;
    document.getElementById('bulkTransactionHashes').value = '';
    document.getElementById('bulkProcessingStatus').style.display = 'none';
    document.getElementById('bulkProcessingResults').style.display = 'none';
    document.getElementById('bulkProcessBtn').disabled = false;
    showModal('bulkTransactionModal');
}

function closeBulkTransactionModal() {
    hideModal('bulkTransactionModal');
    currentBulkVictimId = null;
    // Re-render to show the new transactions with correct V-T notation
    renderVictims();
}

async function processBulkTransactions() {
    const hashesText = document.getElementById('bulkTransactionHashes').value.trim();
    if (!hashesText) {
        alert('Please paste transaction hashes first');
        return;
    }
    
    // Parse hashes (one per line)
    const hashes = hashesText.split('\n')
        .map(h => h.trim())
        .filter(h => h.length > 0);
    
    if (hashes.length === 0) {
        alert('No valid transaction hashes found');
        return;
    }
    
    // Disable button and show progress
    document.getElementById('bulkProcessBtn').disabled = true;
    document.getElementById('bulkProcessingStatus').style.display = 'block';
    document.getElementById('bulkProcessingResults').style.display = 'none';
    
    const victim = investigation.victims.find(v => v.id === currentBulkVictimId);
    const results = [];
    const tempTransactions = [];
    
    // Process each hash
    for (let i = 0; i < hashes.length; i++) {
        const hash = hashes[i];
        const progress = ((i + 1) / hashes.length) * 100;
        
        // Update progress
        document.getElementById('bulkProgressFill').style.width = progress + '%';
        document.getElementById('bulkProgressText').textContent = `Processing ${i + 1} of ${hashes.length}...`;
        
        try {
            // Detect blockchain
            const detectedChain = detectBlockchainFromHash(hash);
            if (!detectedChain) {
                results.push({ hash, status: 'error', message: 'Unknown blockchain format' });
                continue;
            }

            console.log(`Processing hash ${i + 1}/${hashes.length}: ${hash} on ${detectedChain}`);

            // Use fetchTransactionData with proper parsing
            const txData = await fetchTransactionData(hash, detectedChain);

            console.log(`Transaction data received for ${hash}:`, txData);

            if (txData) {
                // Handle multiple transfers (token transactions)
                if (txData.multipleTransfers && txData.transfers && txData.transfers.length > 0) {
                    console.log(`Transaction ${hash} has ${txData.transfers.length} transfers`);

                    // For bulk upload, if only one transfer, auto-select it
                    // If multiple, take the first one and note it needs review
                    if (txData.transfers.length === 1) {
                        const transfer = txData.transfers[0];
                        const transaction = {
                            id: 0, // Will be reassigned after sorting
                            txHash: hash,
                            amount: transfer.amount.toString(),
                            currency: transfer.currency || 'Unknown',
                            customCurrency: '',
                            receivingWallet: transfer.to,
                            datetime: txData.time ? new Date(txData.time).toISOString().slice(0, 16) : new Date().toISOString().slice(0, 16),
                            timezone: 'UTC',
                            notes: `From: ${transfer.from}`
                        };

                        tempTransactions.push(transaction);
                        results.push({
                            hash,
                            status: 'success',
                            message: `${transfer.amount} ${transfer.currency} to ${transfer.to.substring(0, 20)}...`,
                            timestamp: txData.time
                        });
                    } else {
                        // Multiple transfers - store for batch selection later
                        results.push({
                            hash,
                            status: 'pending',
                            message: `${txData.transfers.length} transfers - requires selection`,
                            timestamp: txData.time,
                            transfers: txData.transfers,
                            from: txData.from
                        });
                    }
                } else {
                    // Single transfer or ETH transaction
                    const transaction = {
                        id: 0, // Will be reassigned after sorting
                        txHash: hash,
                        amount: (txData.amount || 0).toString(),
                        currency: txData.currency || 'ETH',
                        customCurrency: '',
                        receivingWallet: txData.to || '',
                        datetime: txData.time ? new Date(txData.time).toISOString().slice(0, 16) : new Date().toISOString().slice(0, 16),
                        timezone: 'UTC',
                        notes: txData.from ? `From: ${txData.from}` : ''
                    };

                    tempTransactions.push(transaction);
                    results.push({
                        hash,
                        status: 'success',
                        message: `${txData.amount || 0} ${txData.currency || 'ETH'} to ${(txData.to || '').substring(0, 20)}...`,
                        timestamp: txData.time
                    });
                }
            } else {
                results.push({ hash, status: 'error', message: 'Failed to parse transaction data' });
            }
            
        } catch (error) {
            results.push({ hash, status: 'error', message: error.message });
        }
        
        // Small delay to avoid rate limiting
        await new Promise(resolve => setTimeout(resolve, 500));
    }
    
    // Check if we have any pending multi-transfer transactions
    const pendingMultiTransfers = results.filter(r => r.status === 'pending');

    if (pendingMultiTransfers.length > 0) {
        // Show bulk transfer selection modal
        document.getElementById('bulkProgressText').textContent = 'Select transfers for multi-output transactions...';

        const selectedTransfers = await showBulkTransferSelectionModal(pendingMultiTransfers);

        // Process selected transfers
        selectedTransfers.forEach(selection => {
            const transaction = {
                id: 0,
                txHash: selection.hash,
                amount: selection.transfer.amount.toString(),
                currency: selection.transfer.currency || 'Unknown',
                customCurrency: '',
                receivingWallet: selection.transfer.to,
                datetime: selection.timestamp ? new Date(selection.timestamp).toISOString().slice(0, 16) : new Date().toISOString().slice(0, 16),
                timezone: 'UTC',
                notes: `From: ${selection.transfer.from}`
            };
            tempTransactions.push(transaction);

            // Update result status
            const resultIndex = results.findIndex(r => r.hash === selection.hash);
            if (resultIndex !== -1) {
                results[resultIndex].status = 'success';
                results[resultIndex].message = `${selection.transfer.amount} ${selection.transfer.currency} to ${selection.transfer.to.substring(0, 20)}...`;
            }
        });
    }

    // Add all successful transactions to the victim
    tempTransactions.forEach(tx => {
        victim.transactions.push(tx);
    });

    // Show results
    document.getElementById('bulkProgressText').textContent = 'Complete! Sorting transactions chronologically...';
    showBulkResults(results);
    
    // Save and re-render (which will sort chronologically)
    saveToStorage();
    
    // Give user time to see results before closing
    setTimeout(() => {
        alert(` Processed ${hashes.length} transaction hashes!\n\n${results.filter(r => r.status === 'success').length} successful\n${results.filter(r => r.status === 'error').length} failed\n\nTransactions have been sorted chronologically and V-T notation has been updated.`);
        closeBulkTransactionModal();
    }, 2000);
}

function showBulkResults(results) {
    const resultsList = document.getElementById('bulkResultsList');
    resultsList.innerHTML = results.map(result => {
        const icon = result.status === 'success' ? '✅' :
                     result.status === 'warning' ? '⚠️' :
                     result.status === 'pending' ? '⏳' : '❌';
        const color = result.status === 'success' ? '#27ae60' :
                      result.status === 'warning' ? '#ff9800' :
                      result.status === 'pending' ? '#2196f3' : '#dc3545';
        return `
            <div style="padding: 8px; border-bottom: 1px solid #e0e0e0;">
                <span style="color: ${color};">${icon}</span>
                <span style="font-family: monospace; font-size: 12px;">${result.hash.substring(0, 20)}...</span>
                <span style="color: #666; margin-left: 10px;">${result.message}</span>
            </div>
        `;
    }).join('');

    document.getElementById('bulkProcessingResults').style.display = 'block';
}

// New function to handle bulk transfer selection
async function showBulkTransferSelectionModal(pendingTransfers) {
    return new Promise(resolve => {
        const selectedTransfers = [];
        let currentIndex = 0;

        // Create modal HTML if it doesn't exist
        let modal = document.getElementById('bulkTransferSelectionModal');
        if (!modal) {
            modal = document.createElement('div');
            modal.id = 'bulkTransferSelectionModal';
            modal.className = 'modal';
            modal.style.cssText = 'display: none; position: fixed; z-index: 10000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5);';
            modal.innerHTML = `
                <div class="modal-content" style="background: white; margin: 5% auto; padding: 20px; width: 90%; max-width: 800px; max-height: 80vh; overflow-y: auto; border-radius: 8px;">
                    <h2>Select Transfers for Multi-Output Transactions</h2>
                    <p id="bulkTransferProgress" style="color: #666; margin: 10px 0;"></p>
                    <div id="bulkTransfersList" style="margin: 20px 0;"></div>
                    <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;">
                        <button id="bulkTransferSkip" class="btn btn-secondary" style="padding: 10px 20px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">Skip This Transaction</button>
                        <button id="bulkTransferNext" class="btn btn-primary" style="padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">Confirm Selection</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        function showNextTransaction() {
            if (currentIndex >= pendingTransfers.length) {
                // All done
                modal.style.display = 'none';
                resolve(selectedTransfers);
                return;
            }

            const tx = pendingTransfers[currentIndex];
            document.getElementById('bulkTransferProgress').textContent =
                `Transaction ${currentIndex + 1} of ${pendingTransfers.length} - ${tx.hash.substring(0, 20)}...`;

            const transfersList = document.getElementById('bulkTransfersList');
            transfersList.innerHTML = '<h3>Select transfers to include:</h3>';

            // Add "Select All" checkbox
            const selectAllDiv = document.createElement('div');
            selectAllDiv.style.cssText = 'margin: 10px 0; padding: 10px; background: #f5f5f5; border-radius: 4px;';
            selectAllDiv.innerHTML = `
                <label style="font-weight: bold; cursor: pointer;">
                    <input type="checkbox" id="bulkSelectAll" checked> Select All
                </label>
            `;
            transfersList.appendChild(selectAllDiv);

            // Add transfer options
            tx.transfers.forEach((transfer, index) => {
                const div = document.createElement('div');
                div.style.cssText = 'padding: 10px; margin: 10px 0; border: 1px solid #ddd; border-radius: 4px;';
                div.innerHTML = `
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" value="${index}" style="margin-right: 10px;" checked>
                        <div style="flex: 1;">
                            <div><strong>${transfer.amount} ${transfer.currency}</strong></div>
                            <div style="font-size: 12px; color: #666;">To: ${transfer.to}</div>
                            <div style="font-size: 12px; color: #666;">From: ${transfer.from}</div>
                        </div>
                    </label>
                `;
                transfersList.appendChild(div);
            });

            document.getElementById('bulkSelectAll').onchange = function(e) {
                const checkboxes = transfersList.querySelectorAll('input[type="checkbox"]:not(#bulkSelectAll)');
                checkboxes.forEach(cb => cb.checked = e.target.checked);
            };
        }

        document.getElementById('bulkTransferNext').onclick = function() {
            const tx = pendingTransfers[currentIndex];
            const checkboxes = document.getElementById('bulkTransfersList').querySelectorAll('input[type="checkbox"]:not(#bulkSelectAll):checked');

            checkboxes.forEach(cb => {
                const index = parseInt(cb.value);
                selectedTransfers.push({
                    hash: tx.hash,
                    transfer: tx.transfers[index],
                    timestamp: tx.timestamp
                });
            });

            currentIndex++;
            showNextTransaction();
        };

        document.getElementById('bulkTransferSkip').onclick = function() {
            currentIndex++;
            showNextTransaction();
        };

        // Show modal and start with first transaction
        modal.style.display = 'block';
        showNextTransaction();
    });
}

async function fetchTransactionData(hash, blockchain) {
    const config = blockchainAPIs[blockchain];
    // Disable CORS proxy to avoid CSP issues - APIs should handle CORS natively
    const corsEnabled = false;
    const corsProxyUrl = '';

    // Try primary and fallback URLs
    const urlsToTry = [config.apiUrl, ...(config.fallbackUrls || [])];

    for (let apiUrl of urlsToTry) {
        try {
            // Add a small delay to prevent extension interference
            await new Promise(resolve => setTimeout(resolve, 100));
            let data;
            let url;
            let tokenData = null; // Define tokenData at this scope
            
            if (blockchain === 'bitcoin') {
                url = apiUrl + hash;
                if (config.apiKey) url += `?api_key=${config.apiKey}`;
                if (corsEnabled) url = corsProxyUrl + url;

                const response = await fetch(url).catch(err => {
                    console.warn(`Bitcoin fetch failed for ${url}:`, err);
                    return null;
                });
                if (!response || !response.ok) continue;
                data = await response.json();
                
            } else if (['ethereum', 'base', 'arbitrum', 'optimism', 'polygon', 'bsc'].includes(blockchain)) {
                // Handle all EVM chains
                const apiKey = localStorage.getItem('bats_etherscan_api_key') || config.apiKey || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8';

                // First get the basic transaction
                url = `${apiUrl}${hash}&apikey=${apiKey}`;
                if (corsEnabled) url = corsProxyUrl + url;

                const response = await fetch(url).catch(err => {
                    console.warn(`${blockchain} fetch failed for ${url}:`, err);
                    return null;
                });
                if (!response || !response.ok) continue;
                data = await response.json();
                if (!data.result || data.result === null) continue;

                // Also check for token transfers
                tokenData = null; // Use the outer scope tokenData, don't redeclare
                try {
                    const tokenUrl = corsEnabled ?
                        corsProxyUrl + `${config.tokenApiUrl}${hash}&apikey=${apiKey}` :
                        `${config.tokenApiUrl}${hash}&apikey=${apiKey}`;

                    const tokenResponse = await fetch(tokenUrl).catch(err => {
                        console.warn(`Token fetch failed:`, err);
                        return null;
                    });
                    if (tokenResponse && tokenResponse.ok) {
                        tokenData = await tokenResponse.json();
                        console.log('Receipt/Token data received:', tokenData);

                        // Check if Etherscan returned an error
                        if (tokenData && tokenData.status === '0' && tokenData.message === 'NOTOK') {
                            console.error('Etherscan API error:', tokenData.result);
                            throw new Error(tokenData.result);
                        }
                    }
                } catch (err) {
                    console.log('No token transfers found');
                }

            } else if (blockchain === 'tron') {
                url = apiUrl + hash;
                const headers = config.apiKey ? { 'TRON-PRO-API-KEY': config.apiKey } : {};
                if (corsEnabled) url = corsProxyUrl + url;
                
                const response = await fetch(url, { headers });
                if (!response.ok) continue;
                data = await response.json();
                
            } else if (blockchain === 'solana') {
                url = apiUrl;
                if (corsEnabled) url = corsProxyUrl + url;
                
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        jsonrpc: '2.0',
                        id: 1,
                        method: 'getTransaction',
                        params: [hash, { encoding: 'json', maxSupportedTransactionVersion: 0 }]
                    })
                });
                if (!response.ok) continue;
                data = await response.json();
                if (data.error) continue;
            }
            
            // Parse and return the data (pass tokenData for all EVM chains)
            const evmChains = ['ethereum', 'base', 'arbitrum', 'optimism', 'polygon', 'bsc'];
            const txData = evmChains.includes(blockchain) ?
                config.parseResponse(data, tokenData, null, config) :
                config.parseResponse(data);
            if (txData) {
                txData.blockchain = config.name;
                return txData;
            }
            
        } catch (error) {
            console.error(`Failed with ${apiUrl}:`, error);
            // Continue to next URL
        }
    }
    
    return null;
}

// Individual blockchain lookup functions for hop transactions
async function lookupEthereumTransaction(txHash, chainName = null) {
    // If no chain specified, detect it or default to ethereum
    if (!chainName) {
        chainName = detectBlockchainFromHash(txHash) || 'ethereum';
    }
    // Use global blockchainAPIs
    const config = window.blockchainAPIs[chainName] || window.blockchainAPIs.ethereum;
    if (!config) {
        throw new Error(`Configuration not found for chain: ${chainName}`);
    }
    // Disable CORS proxy to avoid CSP issues - APIs should handle CORS natively
    const corsEnabled = false;
    const corsProxyUrl = '';
    const apiKey = config.apiKey || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8';
    
    // Build array of URLs to try (primary + fallbacks)
    const urlsToTry = [config.apiUrl, ...(config.fallbackUrls || [])];
    
    for (let apiUrl of urlsToTry) {
        try {
            // First get the basic transaction
            let url = `${apiUrl}${txHash}&apikey=${apiKey}`;
            if (corsEnabled) url = corsProxyUrl + url;

            // Use shorter timeout for each attempt
            const response = await fetchWithTimeout(url,
                apiUrl.includes('alchemy') ? {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        jsonrpc: '2.0',
                        method: 'eth_getTransactionByHash',
                        params: [txHash],
                        id: 1
                    })
                } : {},
                8000, 1);

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }

            const data = await response.json();

            // Check if we got valid data
            if (!data || (!data.result && !data.hash && !data.txhash)) {
                throw new Error('Invalid response format');
            }
            
            // Also check for token transfers
            let tokenData = null;
            try {
                const tokenUrl = corsEnabled ? 
                    corsProxyUrl + `${config.tokenApiUrl}${txHash}&apikey=${apiKey}` :
                    `${config.tokenApiUrl}${txHash}&apikey=${apiKey}`;
                
                const tokenResponse = await fetchWithTimeout(tokenUrl);
                tokenData = await tokenResponse.json();
            } catch (err) {
                console.log('No token transfers found');
            }
            
            // Get block timestamp
            let blockTimestamp = null;
            if (data.result && data.result.blockNumber) {
                try {
                    const blockUrl = corsEnabled ?
                        corsProxyUrl + `${config.blockApiUrl}${data.result.blockNumber}&boolean=true&apikey=${apiKey}` :
                        `${config.blockApiUrl}${data.result.blockNumber}&boolean=true&apikey=${apiKey}`;
                    
                    const blockResponse = await fetch(blockUrl);
                    if (blockResponse.ok) {
                        const blockData = await blockResponse.json();
                        if (blockData && blockData.result && blockData.result.timestamp) {
                            blockTimestamp = parseInt(blockData.result.timestamp, 16) * 1000;
                            console.log('Got block timestamp:', new Date(blockTimestamp).toISOString());
                        }
                    }
                } catch (err) {
                    console.log('Failed to fetch block timestamp:', err);
                }
            }
            
            // Parse the response with blockTimestamp
            const txData = config.parseResponse(data, tokenData, blockTimestamp, config);
            if (txData) {
                txData.blockchain = config.name;
                txData.rawHash = txHash;

                // Check if destination is an exchange/VASP
                if (txData.to) {
                    // Pass the chainId for proper multi-chain attribution
                    const chainId = config.chainId || 1;
                    const attribution = await getWalletAttribution(txData.to, chainId);
                    if (attribution) {
                        txData.toWalletAttribution = attribution;
                        // Only mark as terminal if it's an exchange, not a personal label
                        if (attribution.isExchange && !attribution.isPersonalLabel) {
                            txData.isTerminalWallet = true;
                            console.log(`🟣 Terminal wallet detected on chain ${chainId}: ${attribution.name}`);
                        } else if (attribution.isPersonalLabel) {
                            txData.isTerminalWallet = false;
                            console.log(`🏷️ Personal label detected on chain ${chainId}: ${attribution.name}`);
                        }
                    }
                }

                return txData;
            }
        } catch (error) {
            console.error(`Failed with ${apiUrl}:`, error);
        }
    }

    throw new Error('Failed to fetch Ethereum transaction');
}


async function lookupBitcoinTransaction(txHash) {
    const config = window.blockchainAPIs.bitcoin;
    // Disable CORS proxy to avoid CSP issues - APIs should handle CORS natively
    const corsEnabled = false;
    const corsProxyUrl = '';
    
    const urlsToTry = [config.apiUrl, ...(config.fallbackUrls || [])];
    
    for (let apiUrl of urlsToTry) {
        try {
            let url = apiUrl + txHash;
            if (config.apiKey) {
                url += `?api_key=${config.apiKey}`;
            }
            if (corsEnabled) url = corsProxyUrl + url;
            
            const response = await fetch(url);
            if (!response.ok) continue;
            const data = await response.json();
            
            const txData = config.parseResponse(data);
            if (txData) {
                txData.blockchain = config.name;
                txData.rawHash = txHash;
                return txData;
            }
        } catch (error) {
            console.error(`Failed with ${apiUrl}:`, error);
        }
    }
    
    throw new Error('Failed to fetch Bitcoin transaction');
}

// ====================================================================
// LIBR (Lowest Intermediate Balance Rule) - Balance Tracking Functions
// CONDITIONAL: These functions only execute when investigation.tracingMethod === 'LIBR'
// ====================================================================

async function fetchCompleteTransactionHistory(address, blockchain, currency) {
    console.log('📊 [LIBR] Fetching complete transaction history for ' + address + ' on ' + blockchain);

    const config = window.blockchainAPIs[blockchain];
    if (!config) {
        throw new Error('No API configuration for blockchain: ' + blockchain);
    }

    const apiKey = config.apiKey || localStorage.getItem('bats_' + blockchain + '_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8';
    const allTxs = [];
    let page = 1;
    let hasMore = true;

    // For Ethereum/EVM chains
    if (config.addressApiUrl) {
        while (hasMore && page <= 10) { // Limit to 10 pages (100k txs max)
            try {
                const url = config.addressApiUrl + address + '&startblock=0&endblock=99999999&page=' + page + '&offset=10000&sort=asc&apikey=' + apiKey;

                console.log('Fetching page ' + page + '...');
                const response = await fetch(url);

                if (!response.ok) {
                    throw new Error('API request failed: ' + response.status + ' ' + response.statusText);
                }

                const data = await response.json();

                if (data.status === '1' && data.result && Array.isArray(data.result)) {
                    allTxs.push(...data.result);
                    hasMore = data.result.length === 10000;
                    page++;

                    // Rate limiting: wait 200ms between requests
                    if (hasMore) await new Promise(resolve => setTimeout(resolve, 200));
                } else {
                    console.log('No more results or API error: ' + (data.message || 'unknown'));
                    hasMore = false;
                }
            } catch (err) {
                console.error('Failed to fetch page ' + page + ':', err);
                hasMore = false;
            }
        }
    }
    // For Bitcoin
    else if (blockchain === 'bitcoin') {
        try {
            const url = 'https://blockchain.info/rawaddr/' + address + '?limit=10000';
            console.log('Fetching Bitcoin transaction history...');
            const response = await fetch(url);

            if (!response.ok) {
                throw new Error('Bitcoin API request failed: ' + response.status + ' ' + response.statusText);
            }

            const data = await response.json();

            if (data.txs) {
                allTxs.push(...data.txs.map(tx => ({
                    timeStamp: tx.time,
                    hash: tx.hash,
                    from: tx.inputs[0]?.prev_out?.addr || '',
                    to: '', // Bitcoin has multiple outputs
                    value: '0', // Will calculate from outputs
                    isError: '0',
                    rawTx: tx
                })));
            }
        } catch (err) {
            console.error('Failed to fetch Bitcoin transaction history:', err);
            throw new Error('Failed to fetch Bitcoin transaction history: ' + err.message);
        }
    }

    console.log('✅ [LIBR] Fetched ' + allTxs.length + ' transactions for ' + address);

    // Cache the results in investigation object
    if (!investigation.librWalletAnalysis) investigation.librWalletAnalysis = {};
    const walletKey = blockchain + '_' + address.toLowerCase();
    if (!investigation.librWalletAnalysis[walletKey]) {
        investigation.librWalletAnalysis[walletKey] = {};
    }
    investigation.librWalletAnalysis[walletKey].transactionHistory = allTxs;
    investigation.librWalletAnalysis[walletKey].lastFetched = new Date().toISOString();

    saveToStorage();

    return allTxs;
}

function calculateRunningBalance(address, transactions, blockchain, startingBalance = 0) {
    console.log('📊 [LIBR] Calculating running balance for ' + address + ' (' + transactions.length + ' transactions)');

    let balance = startingBalance;
    const balanceHistory = [];
    const lowerAddress = address.toLowerCase();

    // Sort transactions chronologically
    const sortedTxs = [...transactions].sort((a, b) => {
        const timeA = parseInt(a.timeStamp) || 0;
        const timeB = parseInt(b.timeStamp) || 0;
        return timeA - timeB;
    });

    for (const tx of sortedTxs) {
        let amount = 0;
        let type = 'unknown';

        if (blockchain === 'bitcoin') {
            // Bitcoin UTXO calculation
            if (!tx.rawTx) {
                console.warn('Bitcoin transaction ' + tx.hash + ' missing rawTx data, skipping balance calculation');
                continue;
            }

            // Calculate net amount for this address
            let outputsToAddress = 0;
            let inputsFromAddress = 0;

            // Check outputs going TO this address (including change)
            for (const output of tx.rawTx.out || []) {
                if (output && output.addr === address && output.value != null) {
                    outputsToAddress += output.value / 100000000; // Satoshis to BTC
                }
            }

            // Check inputs coming FROM this address
            for (const input of tx.rawTx.inputs || []) {
                if (input && input.prev_out && input.prev_out.addr === address && input.prev_out.value != null) {
                    inputsFromAddress += input.prev_out.value / 100000000;
                }
            }

            // Calculate net amount (positive = received more, negative = sent more)
            amount = outputsToAddress - inputsFromAddress;

            // Determine type based on NET direction, not loop order
            if (amount > 0.00000001) {
                type = 'inbound'; // Net inflow (received more than sent)
            } else if (amount < -0.00000001) {
                type = 'outbound'; // Net outflow (sent more than received, including change back)

                // Log when change is detected (outbound with return to same address)
                if (outputsToAddress > 0 && inputsFromAddress > 0) {
                    console.log('🔄 [LIBR] Change detected in TX ' + tx.hash.substring(0, 10) + '... | ' +
                               'Inputs: ' + inputsFromAddress.toFixed(8) + ' | ' +
                               'Outputs (change): ' + outputsToAddress.toFixed(8) + ' | ' +
                               'Net outflow: ' + Math.abs(amount).toFixed(8));
                }
            } else {
                type = 'self-transfer'; // Net zero (consolidation or exact return)
            }

            balance += amount;
        } else {
            // Ethereum/EVM calculation
            const isInbound = tx.to?.toLowerCase() === lowerAddress;
            const isOutbound = tx.from?.toLowerCase() === lowerAddress;

            if (isInbound) {
                amount = parseFloat(tx.value) / 1e18; // Wei to ETH
                type = 'inbound';
                balance += amount;
            } else if (isOutbound) {
                amount = parseFloat(tx.value) / 1e18;
                type = 'outbound';
                balance -= amount;

                // Also subtract gas fee
                if (tx.gasUsed && tx.gasPrice) {
                    const gasFee = (parseInt(tx.gasUsed) * parseInt(tx.gasPrice)) / 1e18;
                    balance -= gasFee;
                }
            }
        }

        balanceHistory.push({
            timestamp: parseInt(tx.timeStamp) * 1000, // Convert to milliseconds
            txHash: tx.hash,
            type: type,
            amount: Math.abs(amount),
            balance: Math.max(0, balance), // Don't allow negative balances
            blockNumber: tx.blockNumber,
            isError: tx.isError === '1'
        });
    }

    console.log('✅ [LIBR] Calculated ' + balanceHistory.length + ' balance snapshots');
    return balanceHistory;
}

function findLIBRTransactionPoint(balanceHistory, criminalProceedsAmount, criminalProceedsTimestamp) {
    console.log('📊 [LIBR] Finding transaction points using iterative LIBR methodology: ' + criminalProceedsAmount + ' at ' + new Date(criminalProceedsTimestamp).toISOString());

    // Only look at transactions AFTER criminal proceeds were deposited
    const relevantHistory = balanceHistory.filter(h => h.timestamp >= criminalProceedsTimestamp);

    if (relevantHistory.length === 0) {
        return {
            analysis: 'No transactions found after criminal proceeds deposit',
            transactionsToFollow: [],
            firstTransactionToFollow: null,
            lowestIntermediateBalance: null,
            balanceDroppedBelowProceeds: false,
            proceedsRemainInWallet: true,
            remainingProceedsInWallet: criminalProceedsAmount,
            currentBalance: 0,
            transactionsAnalyzed: 0,
            totalTransactionsToTrace: 0
        };
    }

    let trackedAmount = criminalProceedsAmount;  // Amount we're still tracking
    let lowestBalance = Infinity;
    const transactionsToFollow = [];  // Array of all transactions we need to follow

    for (const entry of relevantHistory) {
        // Track lowest balance
        if (entry.balance < lowestBalance) {
            lowestBalance = entry.balance;
        }

        // Find outbound transactions where balance drops below our tracked amount
        if (entry.type === 'outbound' && entry.balance < trackedAmount) {
            // Calculate how much of the tracked funds went into this transaction
            const balanceBefore = entry.balance + entry.amount;  // Balance before this outbound
            const tracedInThisTx = Math.min(
                entry.amount,  // The transaction amount
                trackedAmount - entry.balance  // How much below threshold it dropped
            );

            transactionsToFollow.push({
                txHash: entry.txHash,
                timestamp: entry.timestamp,
                amount: entry.amount,
                tracedAmount: tracedInThisTx,  // Amount of criminal proceeds in this TX
                balanceAfter: entry.balance,
                balanceBefore: balanceBefore,
                blockNumber: entry.blockNumber
            });

            // Reduce tracked amount to the new balance after this transaction
            trackedAmount = entry.balance;

            console.log('📍 [LIBR] Found drop: TX ' + entry.txHash.substring(0, 10) + '... traced ' + tracedInThisTx.toFixed(6) + ', remaining in wallet: ' + trackedAmount.toFixed(6));

            // If tracked amount reaches zero or near-zero, we've traced everything
            if (trackedAmount < 0.000001) {
                console.log('✅ [LIBR] All proceeds traced through transactions');
                break;
            }
        }
    }

    const currentBalance = relevantHistory[relevantHistory.length - 1]?.balance || 0;
    const balanceDropped = transactionsToFollow.length > 0;

    const result = {
        analysis: !balanceDropped ?
            'Balance never dropped below criminal proceeds - funds remain in wallet' :
            transactionsToFollow.length + ' transaction(s) contain traced proceeds',
        transactionsToFollow: transactionsToFollow,  // Array of ALL transactions to follow
        firstTransactionToFollow: transactionsToFollow[0] || null,  // Keep for backwards compat
        lowestIntermediateBalance: lowestBalance,
        balanceDroppedBelowProceeds: balanceDropped,
        proceedsRemainInWallet: !balanceDropped || trackedAmount > 0.000001,
        remainingProceedsInWallet: trackedAmount,  // How much still remains in wallet
        currentBalance: currentBalance,
        transactionsAnalyzed: relevantHistory.length,
        totalTransactionsToTrace: transactionsToFollow.length
    };

    console.log('✅ [LIBR] Analysis complete:', result.analysis);
    console.log('   Transactions to follow: ' + result.totalTransactionsToTrace);
    console.log('   Remaining in wallet: ' + result.remainingProceedsInWallet.toFixed(6));
    return result;
}

// End of LIBR Balance Tracking Functions
// ====================================================================

// ====================================================================
// LIBR UI Functions
// CONDITIONAL: These functions only execute when investigation.tracingMethod === 'LIBR'
// ====================================================================

async function showLIBRBalanceTracker(walletAddress, criminalProceedsAmount, criminalProceedsDate, currency, blockchain) {
    console.log('📊 [LIBR] Opening Balance Tracker for ' + walletAddress);

    const modal = document.createElement('div');
    modal.className = 'modal-overlay';
    modal.id = 'librBalanceModal';
    modal.style.zIndex = '10000';

    modal.innerHTML = '<div class="modal-content" style="max-width: 1000px; max-height: 90vh; overflow-y: auto;">' +
        '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">' +
        '<h2>⚖️ LIBR Balance Analysis</h2>' +
        '<button onclick="closeLIBRBalanceModal()" class="btn-close" style="font-size: 24px; border: none; background: none; cursor: pointer;">✕</button>' +
        '</div>' +
        '<div style="background: #fff3cd; border: 2px solid #ffc107; padding: 15px; border-radius: 8px; margin-bottom: 20px;">' +
        '<h4 style="margin-top: 0;">Wallet Address</h4>' +
        '<p style="font-family: monospace; word-break: break-all; margin-bottom: 15px;">' + walletAddress + '</p>' +
        '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">' +
        '<div><strong>Criminal Proceeds Deposited:</strong><br>' + criminalProceedsAmount.toLocaleString() + ' ' + currency + '</div>' +
        '<div><strong>Deposit Date:</strong><br>' + new Date(criminalProceedsDate).toLocaleString() + '</div>' +
        '</div>' +
        '<p style="margin: 15px 0 0 0; padding: 10px; background: #fff; border-radius: 4px;">' +
        '<strong>📜 LIBR Rule:</strong> Only follow outbound transactions when wallet balance drops below ' + criminalProceedsAmount.toLocaleString() + ' ' + currency +
        '</p></div>' +
        '<div id="librLoadingIndicator" style="text-align: center; padding: 40px;">' +
        '<div style="font-size: 48px;">⏳</div>' +
        '<p>Fetching transaction history from ' + blockchain + ' blockchain...</p>' +
        '<p style="color: #666; font-size: 14px;">This may take a moment for wallets with many transactions</p>' +
        '</div>' +
        '<div id="librAnalysisResults" style="display: none;"></div>' +
        '<div id="librDecisionButtons" style="display: none; margin-top: 20px;">' +
        '<div style="background: #e8f5e9; border: 2px solid #4caf50; border-radius: 8px; padding: 15px; margin-bottom: 15px;">' +
        '<h4 style="margin: 0 0 10px 0; color: #2e7d32;">📋 Investigator Decision Required</h4>' +
        '<p style="margin: 0; font-size: 13px; color: #666;">Review the calculations above. The system has identified which transactions contain criminal proceeds. What action do you want to take?</p>' +
        '</div>' +
        '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">' +
        '<button onclick="acceptLIBRCalculation()" class="btn btn-primary" style="padding: 12px; font-size: 14px;">' +
        '✅ Accept & Create Trace<br><span style="font-size: 11px; opacity: 0.9;">Creates hop entries with calculated allocations</span>' +
        '</button>' +
        '<button onclick="writeOffLIBRAmount()" class="btn" style="padding: 12px; font-size: 14px; background: #ff9800; color: white; border: none;">' +
        '❌ Write Off<br><span style="font-size: 11px; opacity: 0.9;">Reduce ART, not worth tracing</span>' +
        '</button>' +
        '<button onclick="deferLIBRDecision()" class="btn btn-secondary" style="padding: 12px; font-size: 14px;">' +
        '📝 Defer Decision<br><span style="font-size: 11px; opacity: 0.9;">Review later, keep monitoring</span>' +
        '</button>' +
        '<button onclick="adjustLIBRAllocations()" class="btn btn-secondary" style="padding: 12px; font-size: 14px;">' +
        '🔧 Adjust Allocations<br><span style="font-size: 11px; opacity: 0.9;">Manual override (advanced)</span>' +
        '</button>' +
        '</div></div>' +
        '<div style="display: flex; gap: 10px; justify-content: space-between; margin-top: 20px;">' +
        '<button id="librVerificationButton" onclick="openLIBRVerificationFromModal()" class="btn btn-secondary" style="display: none;">' +
        '📋 View Verification Details</button>' +
        '<div style="display: flex; gap: 10px;">' +
        '<button onclick="closeLIBRBalanceModal()" class="btn btn-secondary">Close</button>' +
        '</div></div></div>';

    document.body.appendChild(modal);

    // Perform analysis
    try {
        await performLIBRAnalysis(walletAddress, criminalProceedsAmount, criminalProceedsDate, currency, blockchain);
    } catch (err) {
        document.getElementById('librLoadingIndicator').innerHTML =
            '<div style="color: #d32f2f;">' +
            '<div style="font-size: 48px;">⚠️</div>' +
            '<p>Failed to fetch transaction history</p>' +
            '<p style="color: #666; font-size: 14px;">' + err.message + '</p>' +
            '<button onclick="closeLIBRBalanceModal()" class="btn btn-secondary" style="margin-top: 20px;">Close</button>' +
            '</div>';
    }
}

async function performLIBRAnalysis(walletAddress, criminalProceedsAmount, criminalProceedsDate, currency, blockchain) {
    console.log('📊 [LIBR] Performing analysis for ' + walletAddress);

    // Fetch transaction history
    const txHistory = await fetchCompleteTransactionHistory(walletAddress, blockchain, currency);

    // Calculate running balance
    const balanceHistory = calculateRunningBalance(walletAddress, txHistory, blockchain);

    // Find LIBR transaction point
    const librAnalysis = findLIBRTransactionPoint(
        balanceHistory,
        criminalProceedsAmount,
        new Date(criminalProceedsDate).getTime()
    );

    // For Bitcoin: Run change detection on identified outbound transactions
    if (blockchain === 'bitcoin' && librAnalysis.transactionsToFollow && librAnalysis.transactionsToFollow.length > 0) {
        console.log('🔍 [LIBR] Running change detection on ' + librAnalysis.transactionsToFollow.length + ' Bitcoin transactions...');

        for (const tx of librAnalysis.transactionsToFollow) {
            // Find the full transaction data with rawTx
            const fullTx = txHistory.find(t => t.hash === tx.txHash);

            if (fullTx && fullTx.rawTx) {
                const changeAnalysis = detectChangeOutputs(fullTx, walletAddress);
                tx.changeDetection = changeAnalysis;

                if (changeAnalysis.hasChange) {
                    const changeOutputs = changeAnalysis.outputs.filter(o => o.isLikelyChange);
                    console.log('⚠️ [LIBR] TX ' + tx.txHash.substring(0, 10) + '... has ' + changeOutputs.length + ' potential change output(s)');
                    changeOutputs.forEach(output => {
                        console.log('   Output ' + output.index + ': ' + output.amount.toFixed(8) + ' BTC to ' + output.address.substring(0, 20) + '...');
                        console.log('   Change score: ' + output.changeScore + ' | Reasons: ' + output.changeReasons.join(', '));
                    });
                }
            }
        }
    }

    // Get red wallet deposits for PIFO allocation display
    let redWalletDeposits = [];
    if (window.librRedWallets) {
        const redWallet = window.librRedWallets.find(w =>
            w.address.toLowerCase() === walletAddress.toLowerCase() &&
            w.blockchain === blockchain &&
            w.currency === currency
        );
        if (redWallet) {
            redWalletDeposits = redWallet.deposits;
        }
    }

    // Store analysis in investigation object
    const walletKey = blockchain + '_' + walletAddress.toLowerCase();
    if (!investigation.librWalletAnalysis) investigation.librWalletAnalysis = {};
    if (!investigation.librWalletAnalysis[walletKey]) {
        investigation.librWalletAnalysis[walletKey] = {};
    }

    investigation.librWalletAnalysis[walletKey] = {
        ...investigation.librWalletAnalysis[walletKey],
        address: walletAddress,
        blockchain: blockchain,
        currency: currency,
        criminalProceedsAmount: criminalProceedsAmount,
        criminalProceedsDate: criminalProceedsDate,
        balanceHistory: balanceHistory,
        librAnalysis: librAnalysis,
        redWalletDeposits: redWalletDeposits,
        lastAnalyzed: new Date().toISOString()
    };

    saveToStorage();

    // Display results
    displayLIBRAnalysisResults(librAnalysis, balanceHistory, criminalProceedsAmount, criminalProceedsDate, currency, walletAddress, blockchain, redWalletDeposits);
}

function displayLIBRAnalysisResults(librAnalysis, balanceHistory, criminalProceedsAmount, criminalProceedsDate, currency, walletAddress, blockchain, redWalletDeposits) {
    console.log('📊 [LIBR] Displaying results:', {
        balanceHistoryLength: balanceHistory?.length || 0,
        criminalProceedsDate,
        librAnalysis,
        redWalletDepositsCount: redWalletDeposits?.length || 0
    });

    const loadingDiv = document.getElementById('librLoadingIndicator');
    const resultsDiv = document.getElementById('librAnalysisResults');

    if (loadingDiv) loadingDiv.style.display = 'none';
    if (resultsDiv) resultsDiv.style.display = 'block';

    const statusColor = librAnalysis.balanceDroppedBelowProceeds ? '#4caf50' : '#ff9800';
    const statusIcon = librAnalysis.balanceDroppedBelowProceeds ? '✅' : '⚠️';
    const statusText = librAnalysis.balanceDroppedBelowProceeds ?
        'Balance Dropped Below Proceeds' :
        'Proceeds Remain in Wallet';

    const criminalProceedsTimestamp = new Date(criminalProceedsDate).getTime();
    console.log('🔍 [LIBR] Filtering history. Criminal proceeds timestamp:', new Date(criminalProceedsTimestamp).toISOString());

    const filteredHistory = balanceHistory.filter(h => h.timestamp >= criminalProceedsTimestamp);

    console.log(`📊 [LIBR] Filtered history: ${filteredHistory.length} transactions (from ${balanceHistory.length} total)`);

    // Create a map of transactions to follow for quick lookup
    const txHashesToFollow = new Set((librAnalysis.transactionsToFollow || []).map(t => t.txHash));
    const txDataMap = {};
    (librAnalysis.transactionsToFollow || []).forEach(t => {
        txDataMap[t.txHash] = t;
    });

    const tableRows = filteredHistory.map((h, index) => {
        const isTracedTx = txHashesToFollow.has(h.txHash);
        const txData = txDataMap[h.txHash];
        const isFirstDrop = librAnalysis.firstTransactionToFollow?.txHash === h.txHash;

        return '<tr style="background: ' + (isTracedTx ? '#e3f2fd' : 'white') + ';">' +
            '<td style="padding: 8px; border-bottom: 1px solid #eee; font-size: 12px;">' + new Date(h.timestamp).toLocaleString() + '</td>' +
            '<td style="padding: 8px; border-bottom: 1px solid #eee;">' +
            '<span style="padding: 2px 8px; border-radius: 4px; background: ' + (h.type === 'inbound' ? '#4caf5022' : '#f4433622') + '; color: ' + (h.type === 'inbound' ? '#4caf50' : '#f44336') + ';">' +
            (h.type === 'inbound' ? '📥 In' : '📤 Out') +
            '</span></td>' +
            '<td style="padding: 8px; border-bottom: 1px solid #eee; text-align: right; font-family: monospace;">' +
            h.amount.toFixed(6) +
            (isTracedTx && txData ? '<br><span style="color: #2196f3; font-size: 10px;">⚖️ ' + txData.tracedAmount.toFixed(6) + ' traced</span>' : '') +
            '</td>' +
            '<td style="padding: 8px; border-bottom: 1px solid #eee; text-align: right; font-family: monospace; font-weight: bold; color: ' + (isTracedTx ? '#2196f3' : '#666') + ';">' +
            h.balance.toFixed(6) + '</td>' +
            '<td style="padding: 8px; border-bottom: 1px solid #eee; text-align: center;">' +
            (isFirstDrop ? '🎯 <strong>1st TRACE</strong>' : isTracedTx ? '✅ <strong>TRACE</strong>' : '⏭️ Skip') +
            '</td></tr>';
    }).join('');

    console.log(`📊 [LIBR] Generated ${filteredHistory.length} table rows. HTML length: ${tableRows.length} characters`);

    // Find which hop this wallet belongs to (if any)
    let targetHopNumber = null;
    if (investigation.hops && walletAddress) {
        for (let i = 0; i < investigation.hops.length; i++) {
            const hop = investigation.hops[i];
            if (hop.entries) {
                const hasMonitoredEntry = hop.entries.some(e =>
                    e.type === 'libr_wallet_status' &&
                    e.walletAddress &&
                    e.walletAddress.toLowerCase() === walletAddress.toLowerCase()
                );
                if (hasMonitoredEntry) {
                    targetHopNumber = i + 1;
                    break;
                }
            }
        }
    }

    // Build transactions to follow HTML with PIFO allocations
    let transactionsToFollowHTML = '';
    if (librAnalysis.balanceDroppedBelowProceeds && librAnalysis.transactionsToFollow && librAnalysis.transactionsToFollow.length > 0) {
        transactionsToFollowHTML = '<div style="background: #e3f2fd; border-left: 4px solid #2196f3; padding: 15px; margin-bottom: 20px;">' +
            '<h4 style="margin-top: 0;">⚖️ LIBR Calculation Results</h4>' +
            '<p style="margin-bottom: 5px;"><strong>The balance dropped below the monitored amount.</strong></p>' +
            '<p style="margin-bottom: 15px; color: #666; font-size: 13px;">The system has calculated which transactions contain criminal proceeds using PIFO (Proceeds In, First Out) allocation.</p>';

        // Track cumulative allocation across all transactions
        let remainingDeposits = redWalletDeposits ? [...redWalletDeposits] : [];
        let cumulativeConsumed = {};

        librAnalysis.transactionsToFollow.forEach((tx, index) => {
            // Calculate PIFO allocation for this transaction
            const allocation = calculatePIFOAllocation(tx.tracedAmount, remainingDeposits);

            // Build allocation display
            let allocationHTML = '';
            allocation.allocation.forEach(alloc => {
                // Track cumulative consumption
                if (!cumulativeConsumed[alloc.threadId]) {
                    cumulativeConsumed[alloc.threadId] = 0;
                }
                cumulativeConsumed[alloc.threadId] += alloc.allocatedAmount;

                const statusIcon = alloc.isFullyConsumed ? '✅' : '⚖️';
                const statusText = alloc.isFullyConsumed ? 'Fully consumed' : alloc.percentage.toFixed(1) + '% consumed';

                allocationHTML += '<div style="margin: 5px 0; padding: 8px; background: #f5f5f5; border-radius: 4px; border-left: 3px solid ' + (alloc.isFullyConsumed ? '#4caf50' : '#ff9800') + ';">' +
                    '<div style="display: flex; justify-content: space-between; align-items: center;">' +
                    '<span style="font-weight: bold; color: #333;">' + statusIcon + ' ' + alloc.threadId + '</span>' +
                    '<span style="color: #666; font-size: 12px;">' + statusText + '</span>' +
                    '</div>' +
                    '<div style="font-size: 12px; color: #666; margin-top: 3px;">' +
                    alloc.allocatedAmount.toFixed(6) + ' ' + currency + ' of ' + alloc.depositAmount.toFixed(6) + ' ' + currency +
                    (alloc.remainingInThread > 0.000001 ? ' <span style="color: #ff9800;">(' + alloc.remainingInThread.toFixed(6) + ' remains)</span>' : '') +
                    '</div>' +
                    '</div>';

                // Update remaining deposits for next transaction
                const depositIndex = remainingDeposits.findIndex(d => d.threadId === alloc.threadId);
                if (depositIndex !== -1) {
                    if (alloc.isFullyConsumed) {
                        remainingDeposits.splice(depositIndex, 1); // Remove fully consumed
                    } else {
                        remainingDeposits[depositIndex] = {
                            ...remainingDeposits[depositIndex],
                            amount: alloc.remainingInThread
                        };
                    }
                }
            });

            // Prepare data for action buttons
            const txData = {
                txHash: tx.txHash,
                timestamp: tx.timestamp,
                amount: tx.amount,
                tracedAmount: tx.tracedAmount,
                balanceAfter: tx.balanceAfter,
                balanceBefore: tx.balanceBefore,
                blockNumber: tx.blockNumber,
                walletAddress: walletAddress,
                blockchain: blockchain,
                currency: currency,
                allocation: allocation.allocation,
                remainingInWallet: librAnalysis.remainingProceedsInWallet
            };

            const txDataJson = JSON.stringify(txData).replace(/"/g, '&quot;');

            // Build change detection warning if applicable
            let changeWarningHTML = '';
            if (tx.changeDetection && tx.changeDetection.hasChange) {
                const changeOutputs = tx.changeDetection.outputs.filter(o => o.isLikelyChange);
                if (changeOutputs.length > 0) {
                    changeWarningHTML = '<div style="background: #fff3e0; border: 2px solid #ff9800; padding: 12px; border-radius: 4px; margin-bottom: 12px;">' +
                        '<div style="display: flex; align-items: center; margin-bottom: 8px;">' +
                        '<strong style="color: #e65100; font-size: 14px;">⚠️ CHANGE ADDRESS DETECTED</strong>' +
                        '</div>' +
                        '<p style="margin: 0 0 10px 0; font-size: 13px; color: #666;">' +
                        'This transaction has ' + changeOutputs.length + ' output(s) that may be change addresses. ' +
                        'The balance calculation may be incorrect if change went to a different address in the same wallet.' +
                        '</p>';

                    changeOutputs.forEach(output => {
                        const scoreColor = output.changeScore >= 80 ? '#d32f2f' : output.changeScore >= 50 ? '#f57c00' : '#ff9800';
                        changeWarningHTML += '<div style="background: white; padding: 8px; border-radius: 4px; margin: 8px 0; border-left: 3px solid ' + scoreColor + ';">' +
                            '<div style="font-size: 12px; margin-bottom: 4px;">' +
                            '<strong>Output #' + (output.index + 1) + ':</strong> ' + output.amount.toFixed(8) + ' ' + currency +
                            ' <span style="background: ' + scoreColor + '22; color: ' + scoreColor + '; padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 8px;">' +
                            'Score: ' + output.changeScore + '</span>' +
                            '</div>' +
                            '<div style="font-family: monospace; font-size: 11px; color: #666; margin-bottom: 4px;">' +
                            output.address.substring(0, 35) + '...' +
                            '</div>' +
                            '<div style="font-size: 11px; color: #666;">' +
                            '🔍 ' + output.changeReasons.join(' • ') +
                            '</div>' +
                            '</div>';
                    });

                    changeWarningHTML += '<div style="margin-top: 10px; padding: 8px; background: #e3f2fd; border-radius: 4px; font-size: 12px;">' +
                        '<strong>💡 Recommendation:</strong> Review transaction outputs before accepting. ' +
                        'If this is change to a different wallet address, consider deferring this decision and manually clustering the addresses.' +
                        '</div></div>';
                }
            }

            transactionsToFollowHTML += '<div style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 15px; border: ' + (index === 0 ? '3px solid #2196f3' : '2px solid #ddd') + ';">' +
                '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">' +
                '<strong style="color: #2196f3; font-size: 16px;">' + (index === 0 ? '🎯 Transaction #1 (Start Here)' : '📍 Transaction #' + (index + 1)) + '</strong>' +
                '<span style="background: #4caf50; color: white; padding: 4px 12px; border-radius: 12px; font-size: 12px; font-weight: bold;">⚖️ ' + tx.tracedAmount.toFixed(6) + ' ' + currency + '</span>' +
                '</div>' +
                '<div style="font-family: monospace; font-size: 12px; color: #666; margin-bottom: 12px; padding: 10px; background: #fafafa; border-radius: 4px;">' +
                '<strong>TX Hash:</strong> ' + tx.txHash.substring(0, 20) + '...' + tx.txHash.substring(tx.txHash.length - 10) + '<br>' +
                '<strong>Date:</strong> ' + new Date(tx.timestamp).toLocaleString() + '<br>' +
                '<strong>TX Amount:</strong> ' + tx.amount.toFixed(6) + ' ' + currency + ' | ' +
                '<strong>Balance After:</strong> ' + tx.balanceAfter.toFixed(6) + ' ' + currency +
                '</div>' +
                changeWarningHTML +
                '<div style="background: #fff3cd; padding: 10px; border-radius: 4px; border-left: 3px solid #ffc107; margin-bottom: 12px;">' +
                '<strong style="color: #f57c00;">📊 PIFO Allocation (Calculated):</strong>' +
                allocationHTML +
                '</div>' +
                '</div>';
        });

        // Show remaining amount if any
        if (librAnalysis.remainingProceedsInWallet && librAnalysis.remainingProceedsInWallet > 0.000001) {
            transactionsToFollowHTML += '<div style="background: #fff3cd; padding: 10px; border-radius: 4px; margin-top: 10px; border-left: 3px solid #ffc107;">' +
                '<strong>💰 Remaining in Wallet:</strong> ' + librAnalysis.remainingProceedsInWallet.toFixed(6) + ' ' + currency + '<br>' +
                '<span style="font-size: 12px; color: #666;">These proceeds remain in the wallet and should not be traced unless the balance drops further.</span>' +
                '</div>';
        }

        transactionsToFollowHTML += '</div>';
    } else if (!librAnalysis.balanceDroppedBelowProceeds) {
        transactionsToFollowHTML = '<div style="background: #fff3cd; border-left: 4px solid #ffc107; padding: 15px; margin-bottom: 20px;">' +
            '<h4 style="margin-top: 0;">💰 Proceeds Remain in Wallet</h4>' +
            '<p>The wallet balance has never dropped below ' + criminalProceedsAmount.toLocaleString() + ' ' + currency + '.</p>' +
            '<p style="margin-bottom: 0;">Per LIBR methodology, the criminal proceeds remain in this wallet and should not be traced further at this time.</p>' +
            '</div>';
    }

    resultsDiv.innerHTML = '<div style="background: ' + statusColor + '22; border: 2px solid ' + statusColor + '; padding: 15px; border-radius: 8px; margin-bottom: 20px;">' +
        '<h3 style="margin-top: 0; color: ' + statusColor + ';">' + statusIcon + ' ' + statusText + '</h3>' +
        '<div style="display: grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap: 15px;">' +
        '<div><strong>Transactions to Trace:</strong><br><span style="font-size: 24px; color: #2196f3;">' + (librAnalysis.totalTransactionsToTrace || 0) + '</span></div>' +
        '<div><strong>Lowest Balance:</strong><br>' + (librAnalysis.lowestIntermediateBalance?.toFixed(6) || 'N/A') + ' ' + currency + '</div>' +
        '<div><strong>Current Balance:</strong><br>' + (librAnalysis.currentBalance?.toFixed(6) || 'N/A') + ' ' + currency + '</div>' +
        '<div><strong>Remaining Proceeds:</strong><br>' + ((librAnalysis.remainingProceedsInWallet || 0).toFixed(6)) + ' ' + currency + '</div>' +
        '</div></div>' +
        transactionsToFollowHTML +
        '<div style="max-height: 400px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px;">' +
        '<table style="width: 100%; border-collapse: collapse;">' +
        '<thead style="position: sticky; top: 0; background: #f5f5f5; z-index: 1;"><tr>' +
        '<th style="padding: 10px; text-align: left; border-bottom: 2px solid #ddd;">Date</th>' +
        '<th style="padding: 10px; text-align: left; border-bottom: 2px solid #ddd;">Type</th>' +
        '<th style="padding: 10px; text-align: right; border-bottom: 2px solid #ddd;">Amount</th>' +
        '<th style="padding: 10px; text-align: right; border-bottom: 2px solid #ddd;">Balance After</th>' +
        '<th style="padding: 10px; text-align: center; border-bottom: 2px solid #ddd;">LIBR Status</th>' +
        '</tr></thead><tbody>' + tableRows + '</tbody></table></div>';

    // Show decision buttons if balance dropped
    const decisionButtons = document.getElementById('librDecisionButtons');
    if (librAnalysis.balanceDroppedBelowProceeds && decisionButtons) {
        decisionButtons.style.display = 'block';
    }

    // Always show verification button (optional transparency feature)
    const verificationButton = document.getElementById('librVerificationButton');
    if (verificationButton) {
        verificationButton.style.display = 'inline-block';
    }

    // Store analysis data globally for decision functions and verification modal
    window.librCurrentAnalysis = {
        walletAddress: walletAddress,
        balanceHistory: balanceHistory,
        librAnalysis: librAnalysis,
        criminalProceedsAmount: criminalProceedsAmount,
        criminalProceedsDate: criminalProceedsDate,
        currency: currency,
        blockchain: blockchain,
        redWalletDeposits: redWalletDeposits || []
    };

    // Also maintain librVerificationData for backward compatibility
    window.librVerificationData = window.librCurrentAnalysis;
}

function closeLIBRBalanceModal() {
    const modal = document.getElementById('librBalanceModal');
    if (modal) modal.remove();
}

// LIBR Decision Functions - Investigator Actions

// Accept calculation and create trace entries
window.acceptLIBRCalculation = function() {
    const analysis = window.librCurrentAnalysis;
    if (!analysis || !analysis.librAnalysis.transactionsToFollow) {
        alert('No analysis data available.');
        return;
    }

    const totalTraced = analysis.librAnalysis.transactionsToFollow.reduce((sum, tx) => sum + tx.tracedAmount, 0);

    const confirmed = window.confirm(
        'Accept LIBR Calculation?\n\n' +
        'This will create hop entries for ' + analysis.librAnalysis.totalTransactionsToTrace + ' transaction(s) ' +
        'with the calculated PIFO allocations.\n\n' +
        'Total traced: ' + totalTraced.toFixed(6) + ' ' + analysis.currency + '\n\n' +
        'Continue?'
    );

    if (!confirmed) return;

    console.log('✅ [LIBR] Investigator accepted calculation - creating hop entries...');

    try {
        // Get or create hop 1
        let hop = investigation.hops.find(h => h.hopNumber === 1);
        if (!hop) {
            // Create hop 1
            hop = {
                hopNumber: 1,
                entries: [],
                artAtStartByCurrency: investigation.confirmedRootTotalsByCurrency || {},
                artAtStart: Object.values(investigation.confirmedRootTotalsByCurrency || {}).reduce((sum, amt) => sum + amt, 0),
                completed: false
            };
            investigation.hops.push(hop);
            console.log('Created Hop 1');
        }

        // Track remaining deposits for PIFO allocation across all transactions
        let remainingDeposits = [...analysis.redWalletDeposits];
        let entriesCreated = 0;

        // Create an entry for each traced transaction
        analysis.librAnalysis.transactionsToFollow.forEach((tx, txIndex) => {
            // Calculate PIFO allocation for this transaction
            const allocation = calculatePIFOAllocation(tx.tracedAmount, remainingDeposits);

            // Build notation from allocation
            let notationParts = [];
            allocation.allocation.forEach(alloc => {
                if (alloc.isFullyConsumed) {
                    notationParts.push(alloc.threadId);
                } else {
                    notationParts.push(alloc.threadId + ' partial: ' + alloc.allocatedAmount.toFixed(6));
                }
            });

            const notation = '(' + notationParts.join(') (') + ') H1';

            // Create hop entry
            const entry = {
                entryType: 'trace',
                type: 'trace',
                notation: notation,
                amount: tx.tracedAmount,
                currency: analysis.currency,
                hopNumber: 1,
                sourceThreadIds: allocation.allocation.map(a => a.threadId),
                pifoAllocation: allocation.allocation, // Store full allocation data
                fromWallet: analysis.walletAddress,
                fromWalletType: 'red',
                fromWalletId: '',
                toWallet: '', // To be filled when transaction is looked up
                toWalletType: '',
                toWalletId: '',
                txHash: tx.txHash,
                timestamp: new Date(tx.timestamp).toISOString(),
                timezone: 'UTC',
                chain: analysis.blockchain,
                notes: 'LIBR-identified transaction\n' +
                       'Balance dropped to ' + tx.balanceAfter.toFixed(6) + ' ' + analysis.currency + '\n' +
                       'PIFO Allocation:\n' +
                       allocation.allocation.map(a =>
                           '- ' + a.threadId + ': ' + a.allocatedAmount.toFixed(6) + ' ' + analysis.currency +
                           ' (' + a.percentage.toFixed(1) + '% of thread)'
                       ).join('\n')
            };

            hop.entries.push(entry);
            entriesCreated++;

            console.log('Created hop entry:', notation, 'Amount:', tx.tracedAmount, analysis.currency);

            // Update remaining deposits for next transaction
            allocation.allocation.forEach(alloc => {
                const depositIndex = remainingDeposits.findIndex(d => d.threadId === alloc.threadId);
                if (depositIndex !== -1) {
                    if (alloc.isFullyConsumed) {
                        remainingDeposits.splice(depositIndex, 1);
                    } else {
                        remainingDeposits[depositIndex] = {
                            ...remainingDeposits[depositIndex],
                            amount: alloc.remainingInThread
                        };
                    }
                }
            });
        });

        // Update victim transaction consumption tracking
        // Mark the victim threads as consumed based on allocations
        const finalAllocation = calculatePIFOAllocation(totalTraced, analysis.redWalletDeposits);
        finalAllocation.allocation.forEach(alloc => {
            const deposit = analysis.redWalletDeposits.find(d => d.threadId === alloc.threadId);
            if (deposit) {
                const victim = investigation.victims[deposit.victimIndex];
                const tx = victim.transactions[deposit.txIndex];

                if (!tx.consumption) {
                    tx.consumption = {
                        totalAmount: deposit.amount,
                        consumed: 0,
                        remaining: deposit.amount
                    };
                }

                tx.consumption.consumed += alloc.allocatedAmount;
                tx.consumption.remaining = deposit.amount - tx.consumption.consumed;

                if (alloc.isFullyConsumed) {
                    tx.fullyConsumed = true;
                }

                console.log('Updated ' + alloc.threadId + ' consumption:', tx.consumption);
            }
        });

        // Rebuild thread index to reflect consumption
        buildAvailableThreadsIndex();

        // Save and refresh
        saveToStorage();
        renderHops();

        alert(
            '✅ LIBR Calculation Accepted!\n\n' +
            'Created ' + entriesCreated + ' hop ' + (entriesCreated === 1 ? 'entry' : 'entries') + ' in Hop 1\n' +
            'Total traced: ' + totalTraced.toFixed(6) + ' ' + analysis.currency + '\n\n' +
            'Thread consumption updated:\n' +
            finalAllocation.allocation.map(a =>
                '- ' + a.threadId + ': ' + a.allocatedAmount.toFixed(6) + ' traced' +
                (a.isFullyConsumed ? ' (fully consumed)' : ' (' + a.remainingInThread.toFixed(6) + ' remains)')
            ).join('\n') +
            '\n\nYou can now look up the transaction details to complete each entry.'
        );

        closeLIBRBalanceModal();

    } catch (error) {
        console.error('Error creating hop entries:', error);
        alert('Error creating hop entries:\n\n' + error.message + '\n\nPlease check the console for details.');
    }
};

// Write off the traced amount (not worth pursuing)
window.writeOffLIBRAmount = function() {
    const analysis = window.librCurrentAnalysis;
    if (!analysis || !analysis.librAnalysis.transactionsToFollow) {
        alert('No analysis data available.');
        return;
    }

    const totalToWriteOff = analysis.librAnalysis.transactionsToFollow.reduce((sum, tx) => sum + tx.tracedAmount, 0);

    const reason = prompt(
        '❌ Write Off Confirmation\n\n' +
        'Amount to write off: ' + totalToWriteOff.toFixed(6) + ' ' + analysis.currency + '\n\n' +
        'This will reduce your ART (Adjusted Root Total) and you will NOT trace these transactions.\n\n' +
        'Please provide a reason for writing off this amount:\n' +
        '(e.g., "Gas fees - not economically viable", "Dust amount", etc.)'
    );

    if (!reason || reason.trim() === '') {
        return; // Cancelled or no reason provided
    }

    console.log('❌ [LIBR] Investigator chose to write off:', totalToWriteOff, analysis.currency);
    console.log('   Reason:', reason);

    // Reduce ART
    if (!investigation.confirmedRootTotalsByCurrency) {
        investigation.confirmedRootTotalsByCurrency = {};
    }

    const currentART = investigation.confirmedRootTotalsByCurrency[analysis.currency] || 0;
    const newART = currentART - totalToWriteOff;
    investigation.confirmedRootTotalsByCurrency[analysis.currency] = newART;

    // Record the write-off
    if (!investigation.writeOffs) {
        investigation.writeOffs = [];
    }

    investigation.writeOffs.push({
        timestamp: new Date().toISOString(),
        walletAddress: analysis.walletAddress,
        blockchain: analysis.blockchain,
        currency: analysis.currency,
        amount: totalToWriteOff,
        reason: reason,
        transactions: analysis.librAnalysis.transactionsToFollow.map(tx => tx.txHash)
    });

    saveToStorage();

    alert(
        '✅ Write-Off Recorded\n\n' +
        'Amount: ' + totalToWriteOff.toFixed(6) + ' ' + analysis.currency + '\n' +
        'Reason: ' + reason + '\n\n' +
        'ART reduced from ' + currentART.toFixed(6) + ' to ' + newART.toFixed(6) + '\n\n' +
        'The wallet will continue to be monitored at the new balance threshold.'
    );

    closeLIBRBalanceModal();
};

// Defer decision - record analysis but take no action
window.deferLIBRDecision = function() {
    const analysis = window.librCurrentAnalysis;
    if (!analysis) {
        alert('No analysis data available.');
        return;
    }

    const notes = prompt(
        '📝 Defer Decision\n\n' +
        'You are choosing to defer this decision and review it later.\n\n' +
        'Optional: Add notes about why you\'re deferring:\n' +
        '(e.g., "Need to investigate change addresses", "Awaiting additional evidence", etc.)'
    );

    if (notes === null) return; // Cancelled

    console.log('📝 [LIBR] Investigator deferred decision');
    console.log('   Notes:', notes || 'None provided');

    // Record the deferral
    if (!investigation.librDeferredDecisions) {
        investigation.librDeferredDecisions = [];
    }

    investigation.librDeferredDecisions.push({
        timestamp: new Date().toISOString(),
        walletAddress: analysis.walletAddress,
        blockchain: analysis.blockchain,
        currency: analysis.currency,
        analysis: analysis.librAnalysis,
        notes: notes || ''
    });

    saveToStorage();

    alert(
        '✅ Decision Deferred\n\n' +
        'This analysis has been saved for later review.\n\n' +
        'The wallet will continue to be monitored.'
    );

    closeLIBRBalanceModal();
};

// Adjust allocations manually (advanced feature)
window.adjustLIBRAllocations = function() {
    alert(
        '🔧 Adjust Allocations\n\n' +
        'This advanced feature allows you to manually override the PIFO allocation calculations.\n\n' +
        '⚠️ Use with caution: Manual adjustments may affect the legal defensibility of your trace.\n\n' +
        'This feature will be implemented in a future update.'
    );
};

// Show LIBR Verification Modal - Full transaction history for transparency
function showLIBRVerificationModal(walletAddress, balanceHistory, librAnalysis, criminalProceedsAmount, criminalProceedsDate, currency, blockchain) {
    console.log('📋 [LIBR] Opening verification modal for', walletAddress);

    // Get source thread deposit transactions (criminal proceeds entering wallet)
    const sourceTimestamp = new Date(criminalProceedsDate).getTime();
    const sourceTransactions = balanceHistory.filter(entry =>
        entry.type === 'inbound' &&
        Math.abs(entry.timestamp - sourceTimestamp) < 60000 && // Within 1 minute
        entry.amount >= criminalProceedsAmount * 0.99 // Within 1% of amount
    );

    // Get LIBR-identified outbound transactions
    const identifiedTxHashes = new Set(
        (librAnalysis.transactionsToFollow || []).map(tx => tx.txHash)
    );

    // Filter history - only show from source deposit onwards
    let displayHistory = balanceHistory.filter(entry => entry.timestamp >= sourceTimestamp);

    // Safety limit: If > 1000 transactions, truncate and warn
    const isTruncated = displayHistory.length > 1000;
    if (isTruncated) {
        displayHistory = displayHistory.slice(-1000); // Show last 1000
    }

    // Build modal HTML
    const modal = document.createElement('div');
    modal.className = 'modal-overlay';
    modal.id = 'librVerificationModal';
    modal.style.zIndex = '10001';

    let html = '<div class="modal-content" style="max-width: 1200px; max-height: 90vh; overflow-y: auto;">' +
        '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">' +
        '<h2>📋 LIBR Analysis Verification</h2>' +
        '<button onclick="closeLIBRVerificationModal()" class="btn-close" style="font-size: 24px; border: none; background: none; cursor: pointer;">✕</button>' +
        '</div>' +

        '<div style="background: #e3f2fd; border-left: 4px solid #2196f3; padding: 15px; margin-bottom: 20px; border-radius: 4px;">' +
        '<h4 style="margin-top: 0;">🔍 Transaction History Verification</h4>' +
        '<p style="margin: 5px 0;"><strong>Wallet:</strong> <code style="background: #fff; padding: 2px 6px; border-radius: 3px;">' + walletAddress + '</code></p>' +
        '<p style="margin: 5px 0;"><strong>Blockchain:</strong> ' + blockchain + ' | <strong>Currency:</strong> ' + currency + '</p>' +
        '<p style="margin: 5px 0;"><strong>Source Deposit:</strong> ' + criminalProceedsAmount.toLocaleString() + ' ' + currency + ' on ' + new Date(criminalProceedsDate).toLocaleString() + '</p>' +
        '<p style="margin: 10px 0 0 0; font-size: 13px; color: #666;">💡 This table shows all transactions after the criminal proceeds deposit. Use this to verify LIBR analysis against block explorer data.</p>' +
        '</div>';

    // Warning if truncated
    if (isTruncated) {
        html += '<div style="background: #fff3cd; border: 2px solid #ffc107; padding: 15px; margin-bottom: 20px; border-radius: 8px;">' +
            '<h4 style="margin-top: 0; color: #f57c00;">⚠️ Large Transaction History</h4>' +
            '<p style="margin: 5px 0;">This wallet has more than 1,000 transactions since the criminal proceeds deposit.</p>' +
            '<p style="margin: 5px 0;">Showing the <strong>most recent 1,000 transactions</strong> for verification.</p>' +
            '<p style="margin: 5px 0; font-weight: bold;">For complete records, please obtain full transaction history from a block explorer:</p>' +
            '<ul style="margin: 5px 0; padding-left: 20px;">' +
            '<li>Ethereum/EVM: <a href="https://etherscan.io/address/' + walletAddress + '" target="_blank">Etherscan</a></li>' +
            '<li>Bitcoin: <a href="https://www.blockchain.com/explorer/addresses/btc/' + walletAddress + '" target="_blank">Blockchain.com</a></li>' +
            '</ul>' +
            '</div>';
    }

    // Legend
    html += '<div style="display: flex; gap: 15px; margin-bottom: 15px; padding: 10px; background: #f5f5f5; border-radius: 4px; font-size: 13px;">' +
        '<div><span style="display: inline-block; width: 15px; height: 15px; background: #c8e6c9; border: 1px solid #4caf50; margin-right: 5px;"></span>Source Thread Deposit</div>' +
        '<div><span style="display: inline-block; width: 15px; height: 15px; background: #fff3cd; border: 1px solid #ffc107; margin-right: 5px;"></span>LIBR-Identified Outbound (New Thread)</div>' +
        '</div>';

    // Transaction table
    html += '<div style="overflow-x: auto;">' +
        '<table style="width: 100%; border-collapse: collapse; font-size: 13px;">' +
        '<thead style="position: sticky; top: 0; background: #f5f5f5; z-index: 1;">' +
        '<tr>' +
        '<th style="padding: 10px; text-align: left; border-bottom: 2px solid #ddd;">Date/Time</th>' +
        '<th style="padding: 10px; text-align: center; border-bottom: 2px solid #ddd;">Type</th>' +
        '<th style="padding: 10px; text-align: right; border-bottom: 2px solid #ddd;">Credit (In)</th>' +
        '<th style="padding: 10px; text-align: right; border-bottom: 2px solid #ddd;">Debit (Out)</th>' +
        '<th style="padding: 10px; text-align: right; border-bottom: 2px solid #ddd;">Running Balance</th>' +
        '<th style="padding: 10px; text-align: left; border-bottom: 2px solid #ddd;">Transaction Hash</th>' +
        '</tr>' +
        '</thead><tbody>';

    // Add transaction rows
    displayHistory.forEach(entry => {
        const isSourceDeposit = sourceTransactions.some(st => st.txHash === entry.txHash);
        const isLIBRIdentified = identifiedTxHashes.has(entry.txHash);

        let rowStyle = '';
        if (isSourceDeposit) {
            rowStyle = 'background: #c8e6c9; border-left: 4px solid #4caf50;';
        } else if (isLIBRIdentified) {
            rowStyle = 'background: #fff3cd; border-left: 4px solid #ffc107;';
        }

        const creditAmount = entry.type === 'inbound' ? entry.amount.toFixed(6) : '';
        const debitAmount = entry.type === 'outbound' ? entry.amount.toFixed(6) : '';

        // Block explorer link
        let explorerUrl = '#';
        if (blockchain === 'ethereum' || blockchain.toLowerCase().includes('evm')) {
            explorerUrl = 'https://etherscan.io/tx/' + entry.txHash;
        } else if (blockchain === 'bitcoin') {
            explorerUrl = 'https://www.blockchain.com/explorer/transactions/btc/' + entry.txHash;
        }

        const txHashShort = entry.txHash.substring(0, 10) + '...' + entry.txHash.substring(entry.txHash.length - 8);

        html += '<tr style="' + rowStyle + '">' +
            '<td style="padding: 8px; border-bottom: 1px solid #ddd;">' + new Date(entry.timestamp).toLocaleString() + '</td>' +
            '<td style="padding: 8px; border-bottom: 1px solid #ddd; text-align: center;">' +
            (entry.type === 'inbound' ? '📥 In' : '📤 Out') + '</td>' +
            '<td style="padding: 8px; border-bottom: 1px solid #ddd; text-align: right; color: #2e7d32;">' +
            (creditAmount ? creditAmount + ' ' + currency : '-') + '</td>' +
            '<td style="padding: 8px; border-bottom: 1px solid #ddd; text-align: right; color: #c62828;">' +
            (debitAmount ? debitAmount + ' ' + currency : '-') + '</td>' +
            '<td style="padding: 8px; border-bottom: 1px solid #ddd; text-align: right; font-weight: bold;">' +
            entry.balance.toFixed(6) + ' ' + currency + '</td>' +
            '<td style="padding: 8px; border-bottom: 1px solid #ddd; font-family: monospace; font-size: 11px;">' +
            '<a href="' + explorerUrl + '" target="_blank" style="color: #1976d2; text-decoration: none;">' +
            txHashShort + ' 🔗</a>' +
            '</td>' +
            '</tr>';
    });

    html += '</tbody></table></div>' +

        // Summary footer
        '<div style="margin-top: 20px; padding: 15px; background: #f5f5f5; border-radius: 4px;">' +
        '<h4 style="margin-top: 0;">📊 Verification Summary</h4>' +
        '<div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; font-size: 13px;">' +
        '<div><strong>Total Transactions Shown:</strong><br>' + displayHistory.length.toLocaleString() + '</div>' +
        '<div><strong>Source Deposits Found:</strong><br>' + sourceTransactions.length + '</div>' +
        '<div><strong>LIBR-Identified Outbound:</strong><br>' + identifiedTxHashes.size + '</div>' +
        '</div></div>' +

        '<div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">' +
        '<button onclick="closeLIBRVerificationModal()" class="btn btn-secondary">Close</button>' +
        '</div></div>';

    modal.innerHTML = html;
    document.body.appendChild(modal);
}

window.closeLIBRVerificationModal = function() {
    const modal = document.getElementById('librVerificationModal');
    if (modal) modal.remove();
};

// Helper to open verification modal from main LIBR modal
function openLIBRVerificationFromModal() {
    if (!window.librVerificationData) {
        alert('No verification data available. Please run LIBR analysis first.');
        return;
    }

    const data = window.librVerificationData;
    showLIBRVerificationModal(
        data.walletAddress,
        data.balanceHistory,
        data.librAnalysis,
        data.criminalProceedsAmount,
        data.criminalProceedsDate,
        data.currency,
        data.blockchain
    );
}

// Calculate PIFO allocation for traced amount across victim deposits
function calculatePIFOAllocation(tracedAmount, deposits) {
    const allocation = [];
    let remaining = tracedAmount;

    // Sort deposits chronologically (should already be sorted but ensure it)
    const sortedDeposits = [...deposits].sort((a, b) => new Date(a.date) - new Date(b.date));

    for (const deposit of sortedDeposits) {
        if (remaining <= 0.000001) break; // All allocated

        const allocated = Math.min(remaining, deposit.amount);
        const percentage = (allocated / deposit.amount) * 100;

        allocation.push({
            threadId: deposit.threadId,
            depositAmount: deposit.amount,
            allocatedAmount: allocated,
            percentage: percentage,
            isFullyConsumed: percentage >= 99.999, // Account for floating point
            remainingInThread: deposit.amount - allocated
        });

        remaining -= allocated;
    }

    return {
        allocation,
        totalAllocated: tracedAmount,
        unallocatedAmount: remaining > 0.000001 ? remaining : 0
    };
}

// Detect potential change outputs in Bitcoin transactions
function detectChangeOutputs(tx, sourceAddress) {
    if (!tx.rawTx || !tx.rawTx.out) {
        return { outputs: [], hasChange: false };
    }

    const outputs = tx.rawTx.out.map((output, index) => {
        const address = output.addr || '';
        const amount = (output.value || 0) / 100000000; // Satoshis to BTC

        let changeScore = 0;
        let changeReasons = [];

        // 1. Same address as sender (100% change)
        if (address && sourceAddress && address.toLowerCase() === sourceAddress.toLowerCase()) {
            changeScore = 100;
            changeReasons.push('Returns to sender address');
            return { index, address, amount, changeScore, changeReasons, isLikelyChange: true };
        }

        // 2. Round amount heuristic (payments are often round)
        const isRoundAmount = amount % 1 === 0 || amount % 0.1 === 0 || amount % 0.01 === 0;
        const amountStr = amount.toFixed(8);
        const decimalPart = amountStr.split('.')[1];
        const hasManySigFigs = decimalPart && decimalPart.replace(/0+$/, '').length > 4;

        if (hasManySigFigs) {
            changeScore += 30;
            changeReasons.push('Many decimal places (typical of change)');
        } else if (!isRoundAmount) {
            changeScore += 20;
            changeReasons.push('Non-round amount');
        }

        // 3. Output order heuristic (change often comes last in Bitcoin)
        if (tx.rawTx.out.length === 2 && index === 1) {
            changeScore += 15;
            changeReasons.push('Second of two outputs');
        }

        // 4. Address type matching (change often uses same script type)
        if (sourceAddress) {
            const sourcePrefix = sourceAddress.substring(0, 3);
            const destPrefix = address.substring(0, 3);

            const sameType = sourcePrefix === destPrefix ||
                            (sourceAddress.startsWith('bc1') && address.startsWith('bc1'));

            if (sameType) {
                changeScore += 10;
                changeReasons.push('Same address type as sender');
            }
        }

        // 5. Amount comparison (change is often smaller in 2-output transactions)
        if (tx.rawTx.out.length === 2) {
            const otherOutput = tx.rawTx.out[1 - index];
            const otherAmount = (otherOutput.value || 0) / 100000000;

            if (amount < otherAmount * 0.5) {
                changeScore += 10;
                changeReasons.push('Smaller than other output');
            }
        }

        // 6. Calculate total inputs
        let totalInputs = 0;
        if (tx.rawTx.inputs) {
            totalInputs = tx.rawTx.inputs.reduce((sum, input) => {
                return sum + ((input.prev_out?.value || 0) / 100000000);
            }, 0);
        }

        // 7. Perfect change calculation
        if (tx.rawTx.out.length === 2 && totalInputs > 0) {
            const otherOutput = tx.rawTx.out[1 - index];
            const otherAmount = (otherOutput.value || 0) / 100000000;
            const estimatedFee = 0.0001; // Very rough estimate
            const expectedChange = totalInputs - otherAmount - estimatedFee;

            if (expectedChange > 0) {
                const difference = Math.abs(expectedChange - amount);
                if (difference < expectedChange * 0.1) {
                    changeScore += 25;
                    changeReasons.push('Matches expected change calculation');
                }
            }
        }

        const isLikelyChange = changeScore >= 50; // Threshold for flagging

        return {
            index,
            address,
            amount,
            changeScore,
            changeReasons,
            isLikelyChange
        };
    });

    const hasChange = outputs.some(o => o.isLikelyChange);

    return { outputs, hasChange };
}

// Helper function to launch LIBR analyzer from wizard or other contexts
async function analyzeLIBRForWallet(walletAddress, proceedsAmount, proceedsDate, currency, blockchain) {
    // CONDITIONAL: Only execute if LIBR method is selected
    if (investigation.tracingMethod !== 'LIBR') {
        alert('LIBR Balance Tracker is only available when using LIBR methodology.\\n\\nYour current investigation uses PIFO method.');
        return;
    }

    await showLIBRBalanceTracker(walletAddress, proceedsAmount, proceedsDate, currency, blockchain);
}

// Helper function to launch LIBR analyzer from hop wizard
async function launchLIBRAnalyzerFromWizard() {
    // Get wizard data
    const wizardData = window.hopWizardData;
    if (!wizardData || !wizardData.selectedThreads || wizardData.selectedThreads.length === 0) {
        alert('Please select at least one thread first.');
        return;
    }

    // Get the first selected thread to determine wallet and amount
    const availableThreads = getAvailableSourcesForHop(wizardData.hopNumber, null);
    const selectedThread = availableThreads.find(t =>
        wizardData.selectedThreads.includes(t.threadId) ||
        wizardData.selectedInternalIds?.includes(t.internalId)
    );

    if (!selectedThread) {
        alert('Could not find thread information. Please try again.');
        return;
    }

    // Determine wallet address (the source wallet from the thread)
    const walletAddress = selectedThread.lastReceivingWallet || selectedThread.sourceWallet;
    if (!walletAddress) {
        alert('Could not determine wallet address for LIBR analysis.');
        return;
    }

    // Determine blockchain
    const blockchain = selectedThread.chainId || 'ethereum';

    // Determine currency and amount
    const currency = selectedThread.currency;
    const proceedsAmount = selectedThread.availableAmount;

    // Determine deposit date - get the actual victim transaction date
    let proceedsDate;
    if (selectedThread.victimIndex !== undefined && selectedThread.transactionIndex !== undefined) {
        // Get the actual victim transaction
        const victim = investigation.victims[selectedThread.victimIndex];
        if (victim && victim.transactions && victim.transactions[selectedThread.transactionIndex]) {
            proceedsDate = victim.transactions[selectedThread.transactionIndex].date;
            console.log('📅 [LIBR] Using victim transaction date:', proceedsDate);
        }
    }

    // Fallback to thread dates or current time
    if (!proceedsDate) {
        proceedsDate = selectedThread.threadEndDate || selectedThread.createdAt || new Date().toISOString();
        console.log('⚠️ [LIBR] Using fallback date (thread/current):', proceedsDate);
    }

    console.log(`🚀 Launching LIBR analyzer from wizard:`, {
        walletAddress,
        proceedsAmount,
        currency,
        blockchain,
        proceedsDate
    });

    await analyzeLIBRForWallet(walletAddress, proceedsAmount, proceedsDate, currency, blockchain);
}

// Group victim transactions by destination wallet (red wallets) for LIBR
function getRedWalletsForLIBR() {
    console.log('🔶 [LIBR] Grouping victim transactions by red wallet...');

    const redWallets = [];

    if (!investigation.victims || investigation.victims.length === 0) {
        return redWallets;
    }

    investigation.victims.forEach((victim, victimIndex) => {
        victim.transactions.forEach((tx, txIndex) => {
            const walletAddress = tx.destinationWallet;
            if (!walletAddress) return;

            // Find existing red wallet entry
            const existing = redWallets.find(w =>
                w.address.toLowerCase() === walletAddress.toLowerCase() &&
                w.blockchain === tx.blockchain &&
                w.currency === tx.currency
            );

            if (existing) {
                // Add to existing wallet's deposits
                existing.monitoredAmount += parseFloat(tx.amount || 0);
                existing.deposits.push({
                    threadId: `V${victimIndex + 1}-T${txIndex + 1}`,
                    victimIndex,
                    txIndex,
                    amount: parseFloat(tx.amount || 0),
                    date: tx.date,
                    txHash: tx.txHash
                });
                // Use earliest deposit date
                if (new Date(tx.date) < new Date(existing.earliestDeposit)) {
                    existing.earliestDeposit = tx.date;
                }
            } else {
                // New red wallet
                redWallets.push({
                    address: walletAddress,
                    blockchain: tx.blockchain,
                    currency: tx.currency,
                    monitoredAmount: parseFloat(tx.amount || 0),
                    earliestDeposit: tx.date,
                    deposits: [{
                        threadId: `V${victimIndex + 1}-T${txIndex + 1}`,
                        victimIndex,
                        txIndex,
                        amount: parseFloat(tx.amount || 0),
                        date: tx.date,
                        txHash: tx.txHash
                    }],
                    analyzed: false,
                    lastAnalyzed: null
                });
            }
        });
    });

    // Sort deposits within each wallet chronologically (PIFO order)
    redWallets.forEach(wallet => {
        wallet.deposits.sort((a, b) => new Date(a.date) - new Date(b.date));
    });

    console.log(`📊 [LIBR] Found ${redWallets.length} unique red wallet(s)`);
    return redWallets;
}

// Show Red Wallets Dashboard for LIBR methodology
function showRedWalletsDashboard() {
    console.log('🔶 [LIBR] Opening Red Wallets Dashboard...');

    const redWallets = getRedWalletsForLIBR();

    if (redWallets.length === 0) {
        alert('No red wallets found. Please ensure victim transactions have destination wallets specified.');
        return;
    }

    const modal = document.createElement('div');
    modal.className = 'modal-overlay';
    modal.id = 'redWalletsDashboard';
    modal.style.zIndex = '10000';

    let walletsHTML = '';
    redWallets.forEach((wallet, index) => {
        const depositsHTML = wallet.deposits.map(d =>
            `<div style="font-size: 12px; color: #666; margin: 2px 0;">
                • ${d.threadId}: ${d.amount.toLocaleString()} ${wallet.currency} (${new Date(d.date).toLocaleDateString()})
            </div>`
        ).join('');

        walletsHTML += `
            <div style="background: white; border: 2px solid #e0e0e0; border-radius: 8px; padding: 20px; margin-bottom: 15px;">
                <div style="display: flex; justify-content: between; align-items: flex-start; margin-bottom: 15px;">
                    <div style="flex: 1;">
                        <h3 style="margin: 0 0 10px 0; color: #c62828;">🔴 Red Wallet ${index + 1}</h3>
                        <div style="font-family: monospace; font-size: 13px; background: #f5f5f5; padding: 8px; border-radius: 4px; word-break: break-all; margin-bottom: 10px;">
                            ${wallet.address}
                        </div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">
                            <div><strong>Blockchain:</strong> ${wallet.blockchain}</div>
                            <div><strong>Currency:</strong> ${wallet.currency}</div>
                        </div>
                    </div>
                </div>

                <div style="background: #fff3cd; border-left: 4px solid #ffc107; padding: 12px; border-radius: 4px; margin-bottom: 15px;">
                    <div style="font-size: 18px; font-weight: bold; color: #f57c00; margin-bottom: 5px;">
                        ⚖️ Monitored Balance: ${wallet.monitoredAmount.toLocaleString()} ${wallet.currency}
                    </div>
                    <div style="font-size: 13px; color: #666;">
                        LIBR will trace when balance drops below this amount
                    </div>
                </div>

                <div style="margin-bottom: 15px;">
                    <strong>Victim Deposits (${wallet.deposits.length}):</strong>
                    ${depositsHTML}
                </div>

                <div style="display: flex; gap: 10px;">
                    <button onclick="analyzeLIBRRedWallet(${index})" class="btn btn-primary" style="flex: 1;">
                        📊 Analyze Wallet Balance
                    </button>
                </div>
            </div>
        `;
    });

    modal.innerHTML = `
        <div class="modal-content" style="max-width: 900px; max-height: 90vh; overflow-y: auto;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                <h2>🔴 Red Wallets - LIBR Monitoring</h2>
                <button onclick="closeRedWalletsDashboard()" class="btn-close" style="font-size: 24px; border: none; background: none; cursor: pointer;">✕</button>
            </div>

            <div style="background: #e3f2fd; border-left: 4px solid #2196f3; padding: 15px; margin-bottom: 20px; border-radius: 4px;">
                <h4 style="margin-top: 0;">📘 LIBR Methodology Workflow</h4>
                <p style="margin: 5px 0;">In LIBR, you monitor <strong>red wallets</strong> holding criminal proceeds, not individual threads.</p>
                <p style="margin: 5px 0;">Click <strong>"Analyze Wallet Balance"</strong> for each wallet below to determine if tracing is required.</p>
                <p style="margin: 5px 0; font-weight: bold;">The system will calculate when the balance drops below the monitored amount and show you which transactions contain the proceeds.</p>
            </div>

            ${walletsHTML}

            <div style="text-align: right; margin-top: 20px;">
                <button onclick="closeRedWalletsDashboard()" class="btn btn-secondary">Close</button>
            </div>
        </div>
    `;

    document.body.appendChild(modal);

    // Store red wallets data globally for analysis functions
    window.librRedWallets = redWallets;
}

window.closeRedWalletsDashboard = function() {
    const modal = document.getElementById('redWalletsDashboard');
    if (modal) modal.remove();
};

// Analyze a specific red wallet from the dashboard
window.analyzeLIBRRedWallet = async function(walletIndex) {
    const redWallets = window.librRedWallets;
    if (!redWallets || !redWallets[walletIndex]) {
        alert('Wallet data not found. Please try again.');
        return;
    }

    const wallet = redWallets[walletIndex];

    console.log(`📊 [LIBR] Analyzing red wallet ${walletIndex + 1}: ${wallet.address}`);

    await analyzeLIBRForWallet(
        wallet.address,
        wallet.monitoredAmount,
        wallet.earliestDeposit,
        wallet.currency,
        wallet.blockchain
    );

    // Mark as analyzed
    wallet.analyzed = true;
    wallet.lastAnalyzed = new Date().toISOString();
};

// Helper function to analyze all victim wallets for LIBR methodology
async function analyzeLIBRForVictimWallets() {
    console.log('🔶 [LIBR] Analyzing all victim wallets...');

    if (!investigation.victims || investigation.victims.length === 0) {
        alert('No victim transactions found. Please add victim transactions first.');
        return;
    }

    // Collect all unique victim wallet addresses with their transaction details
    const victimWallets = [];

    investigation.victims.forEach((victim, victimIndex) => {
        victim.transactions.forEach((tx, txIndex) => {
            // Get the destination wallet (where criminal proceeds were deposited)
            const walletAddress = tx.destinationWallet;
            if (!walletAddress) return;

            // Check if we already have this wallet
            const existing = victimWallets.find(w =>
                w.address.toLowerCase() === walletAddress.toLowerCase() &&
                w.blockchain === tx.blockchain &&
                w.currency === tx.currency
            );

            if (existing) {
                // Add to existing wallet's proceeds
                existing.proceedsAmount += parseFloat(tx.amount || 0);
                existing.transactions.push({
                    victimIndex,
                    txIndex,
                    amount: parseFloat(tx.amount || 0),
                    date: tx.date
                });
                // Use earliest date
                if (new Date(tx.date) < new Date(existing.proceedsDate)) {
                    existing.proceedsDate = tx.date;
                }
            } else {
                // New wallet
                victimWallets.push({
                    address: walletAddress,
                    blockchain: tx.blockchain,
                    currency: tx.currency,
                    proceedsAmount: parseFloat(tx.amount || 0),
                    proceedsDate: tx.date,
                    transactions: [{
                        victimIndex,
                        txIndex,
                        amount: parseFloat(tx.amount || 0),
                        date: tx.date
                    }]
                });
            }
        });
    });

    if (victimWallets.length === 0) {
        alert('No victim wallet addresses found. Please ensure victim transactions have destination wallets specified.');
        return;
    }

    console.log(`📊 [LIBR] Found ${victimWallets.length} unique victim wallet(s) to analyze`);

    // Analyze each wallet sequentially
    for (let i = 0; i < victimWallets.length; i++) {
        const wallet = victimWallets[i];

        console.log(`📊 [LIBR] Analyzing wallet ${i + 1}/${victimWallets.length}: ${wallet.address}`);

        try {
            await analyzeLIBRForWallet(
                wallet.address,
                wallet.proceedsAmount,
                wallet.proceedsDate,
                wallet.currency,
                wallet.blockchain
            );

            // Wait for user to close the modal before proceeding to next wallet
            // The modal is already shown by analyzeLIBRForWallet

            // If there are more wallets, we'll wait for them to close current modal
            if (i < victimWallets.length - 1) {
                await new Promise(resolve => {
                    // Wait for modal to be closed
                    const checkModal = setInterval(() => {
                        const modal = document.getElementById('librBalanceModal');
                        if (!modal) {
                            clearInterval(checkModal);
                            resolve();
                        }
                    }, 500);
                });
            }
        } catch (err) {
            console.error(`❌ [LIBR] Failed to analyze wallet ${wallet.address}:`, err);
            alert(`Failed to analyze wallet ${wallet.address}:\n\n${err.message}\n\nContinuing with next wallet...`);
        }
    }

    console.log('✅ [LIBR] Completed analysis of all victim wallets');
}

// ====================================================================
// LIBR Monitoring Dashboard Functions
// ====================================================================

// Get all monitored wallets across all hops
function getAllMonitoredWallets() {
    const monitored = [];

    if (!investigation.hops) return monitored;

    investigation.hops.forEach((hop, hopIndex) => {
        if (!hop.entries) return;

        hop.entries.forEach(entry => {
            if (entry.type === 'libr_wallet_status') {
                // Ensure thread structure exists (migrate old format if needed)
                ensureThreadStructure(entry);

                monitored.push({
                    ...entry,
                    hopNumber: hopIndex + 1,
                    hopNotation: hop.notation || 'H' + (hopIndex + 1)
                });
            }
        });
    });

    return monitored;
}

// Calculate days since last analysis
function daysSinceAnalysis(lastAnalyzedDate) {
    if (!lastAnalyzedDate) return Infinity;
    const now = new Date();
    const then = new Date(lastAnalyzedDate);
    const diffMs = now - then;
    const diffDays = Math.floor(diffMs / (1000 * 60 * 60 * 24));
    return diffDays;
}

// Get monitoring status (color, icon, text)
function getMonitoringStatus(lastAnalyzed) {
    const daysAgo = daysSinceAnalysis(lastAnalyzed);

    if (daysAgo === Infinity || daysAgo > 30) {
        return { icon: '🔴', text: daysAgo === Infinity ? 'Never' : daysAgo + ' days ago', color: '#f44336', needsReview: true };
    } else if (daysAgo >= 7) {
        return { icon: '⚠️', text: daysAgo + ' days ago', color: '#ff9800', needsReview: true };
    } else {
        return { icon: '✅', text: daysAgo + ' days ago', color: '#4caf50', needsReview: false };
    }
}

// Update monitored wallet after re-analysis
function updateMonitoredWallet(hopNumber, walletAddress, newData) {
    const hop = investigation.hops[hopNumber - 1];
    if (!hop) return;

    const monitoredEntry = hop.entries.find(e =>
        e.type === 'libr_wallet_status' &&
        e.walletAddress.toLowerCase() === walletAddress.toLowerCase()
    );

    if (monitoredEntry) {
        monitoredEntry.remainingProceeds = newData.remainingProceeds;
        monitoredEntry.lastAnalyzed = new Date().toISOString();
        monitoredEntry.lastBalance = newData.currentBalance;

        // If new transactions were traced, update the note
        if (newData.transactionsTraced > 0) {
            const today = new Date().toLocaleDateString();
            const updateNote = '[' + today + '] Traced ' + newData.totalTraced.toFixed(6) + ' via ' + newData.transactionsTraced + ' transaction(s)';
            monitoredEntry.notes = monitoredEntry.notes ? monitoredEntry.notes + '\n' + updateNote : updateNote;
        }

        saveToStorage();
        console.log('✅ Updated monitored wallet:', walletAddress);
    }
}

// Jump to specific hop from monitoring panel
function jumpToHopForMonitoredWallet(hopNumber) {
    // Switch to Hops tab
    switchTab('hops');

    // Small delay to ensure tab has switched
    setTimeout(() => {
        const hopElement = document.getElementById('hop-' + hopNumber);
        if (hopElement) {
            hopElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            hopElement.classList.add('highlight-flash');
            setTimeout(() => hopElement.classList.remove('highlight-flash'), 2000);
        }
    }, 100);
}

// Re-analyze a single monitored wallet
async function reanalyzeSingleMonitoredWallet(monitoredWallet) {
    console.log('🔄 Re-analyzing monitored wallet:', monitoredWallet.walletAddress);

    try {
        // Ensure thread structure and get current thread
        ensureThreadStructure(monitoredWallet);
        const currentThread = getCurrentMonitoredThread(monitoredWallet);

        if (!currentThread) {
            alert('No active thread to monitor in this wallet.\n\nAll threads may have been consumed.');
            return;
        }

        // Run LIBR analysis with the CURRENT thread's remaining amount as threshold
        // (LIBR + PIFO: only monitor oldest unconsumed thread)
        console.log('📊 Analyzing current thread:', currentThread.notation, '(' + currentThread.remainingAmount + ' ' + monitoredWallet.currency + ')');

        await showLIBRBalanceTracker(
            monitoredWallet.walletAddress,
            currentThread.remainingAmount,  // Use CURRENT thread amount, not total
            monitoredWallet.lastAnalyzed || new Date().toISOString(),
            monitoredWallet.currency,
            monitoredWallet.blockchain
        );

        // The LIBR modal will handle showing results and allowing user to add to hop

    } catch (err) {
        console.error('Failed to re-analyze wallet:', err);
        alert('Failed to re-analyze wallet: ' + err.message);
    }
}

// Show LIBR Monitoring Dashboard
function showLIBRMonitoringDashboard() {
    const monitoredWallets = getAllMonitoredWallets();

    if (monitoredWallets.length === 0) {
        alert('No LIBR monitored wallets found.\n\nMonitored wallets are created when you use LIBR methodology and mark funds as remaining in a wallet.');
        return;
    }

    // Count wallets needing review
    const needsReview = monitoredWallets.filter(w => getMonitoringStatus(w.lastAnalyzed).needsReview).length;

    // Calculate total monitored value by currency
    const totalsByCurrency = {};
    monitoredWallets.forEach(w => {
        if (!totalsByCurrency[w.currency]) {
            totalsByCurrency[w.currency] = 0;
        }
        totalsByCurrency[w.currency] += w.remainingProceeds || 0;
    });

    const totalsDisplay = Object.entries(totalsByCurrency)
        .map(([curr, amt]) => amt.toLocaleString() + ' ' + curr)
        .join(' + ');

    // Build dashboard HTML
    let html = '<div class="modal-overlay" id="librMonitoringModal" style="z-index: 10000;">' +
        '<div class="modal-content" style="max-width: 1200px; max-height: 90vh; overflow-y: auto;">' +
        '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">' +
        '<h2>👁️ LIBR Monitored Wallets</h2>' +
        '<button onclick="closeLIBRMonitoringDashboard()" class="btn-close" style="font-size: 24px; border: none; background: none; cursor: pointer;">✕</button>' +
        '</div>' +

        '<div style="background: #e3f2fd; border-left: 4px solid #2196f3; padding: 15px; margin-bottom: 20px; border-radius: 4px;">' +
        '<p style="margin: 0;">💡 <strong>These wallets contain criminal proceeds that remain untraced.</strong></p>' +
        '<p style="margin: 5px 0 0 0; font-size: 14px; color: #666;">Re-analyze them periodically to detect new outbound transactions.</p>' +
        '</div>' +

        '<div style="display: flex; gap: 10px; margin-bottom: 20px;">' +
        '<button onclick="reanalyzeAllMonitoredWallets()" class="btn btn-primary">🔄 Re-analyze All Wallets</button>' +
        '</div>' +

        '<hr style="margin: 20px 0; border: none; border-top: 2px solid #eee;">';

    // Add wallet cards
    monitoredWallets.forEach((wallet, index) => {
        const status = getMonitoringStatus(wallet.lastAnalyzed);
        const currentThread = getCurrentMonitoredThread(wallet);

        // Calculate totals
        const totalOriginal = wallet.totalOriginalProceeds || wallet.originalProceeds || 0;
        const totalRemaining = wallet.totalRemainingProceeds || wallet.remainingProceeds || 0;
        const totalConsumed = wallet.totalConsumed || (totalOriginal - totalRemaining);
        const tracedPercent = totalOriginal > 0 ? ((totalConsumed / totalOriginal) * 100).toFixed(0) : 0;

        html += '<div style="border: 1px solid #ddd; border-radius: 8px; padding: 15px; margin-bottom: 15px; background: white;">' +
            '<div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">' +
            '<div><strong style="font-size: 16px;">📍 Wallet #' + (index + 1) + ' - Hop ' + wallet.hopNumber + ' (' + wallet.hopNotation + ')</strong></div>' +
            '<span style="font-size: 24px;">' + status.icon + '</span>' +
            '</div>' +

            '<div style="font-family: monospace; font-size: 13px; background: #f5f5f5; padding: 8px; border-radius: 4px; margin-bottom: 10px; word-break: break-all;">' +
            '<strong>Address:</strong> ' + wallet.walletAddress +
            '</div>' +

            '<div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">' +
            '<div><strong>Blockchain:</strong> ' + (wallet.blockchain || 'ethereum') + '</div>' +
            '<div><strong>Currency:</strong> ' + wallet.currency + '</div>' +
            '</div>';

        // Thread queue display
        if (wallet.threads && wallet.threads.length > 0) {
            html += '<div style="background: #e3f2fd; border-left: 4px solid #2196f3; padding: 10px; border-radius: 4px; margin-bottom: 10px;">' +
                '<h4 style="margin: 0 0 10px 0; font-size: 14px;">🧵 Thread Queue (' + wallet.threads.length + ' thread' + (wallet.threads.length !== 1 ? 's' : '') + ')</h4>';

            // Show each thread
            wallet.threads.forEach((thread, threadIndex) => {
                const isCurrent = threadIndex === wallet.currentThreadIndex;
                const statusEmoji = thread.status === 'consumed' ? '✅' : (thread.status === 'monitoring' ? '👁️' : '⏳');
                const statusText = thread.status === 'consumed' ? 'Consumed' : (thread.status === 'monitoring' ? 'Monitoring' : 'Pending');
                const bgColor = isCurrent ? '#fff3cd' : '#f9f9f9';
                const borderColor = isCurrent ? '#ffc107' : '#ddd';

                html += '<div style="background: ' + bgColor + '; border: 1px solid ' + borderColor + '; padding: 8px; border-radius: 4px; margin-bottom: 5px; font-size: 12px;">' +
                    '<div style="display: flex; justify-content: space-between; align-items: center;">' +
                    '<div><strong>' + thread.notation + '</strong> ' + statusEmoji + ' <em style="color: #666;">' + statusText + '</em></div>' +
                    '<div><strong>' + thread.remainingAmount.toLocaleString() + ' / ' + thread.originalAmount.toLocaleString() + '</strong> ' + wallet.currency + '</div>' +
                    '</div>';

                if (isCurrent) {
                    html += '<div style="margin-top: 5px; font-size: 11px; color: #f57c00;"><strong>← Currently monitoring this thread (PIFO: oldest first)</strong></div>';
                }

                html += '</div>';
            });

            html += '</div>';
        }

        // Total values display
        html += '<div style="background: #fff3cd; padding: 10px; border-radius: 4px; margin-bottom: 10px;">' +
            '<div style="font-size: 18px; font-weight: bold; color: #f57c00;">💰 Total Remaining: ' + totalRemaining.toLocaleString() + ' ' + wallet.currency + '</div>' +
            '<div style="font-size: 12px; color: #666; margin-top: 5px;">Last Analyzed: ' + status.text + '</div>' +
            '</div>' +

            '<div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px; font-size: 13px; margin-bottom: 10px;">' +
            '<div><strong>Total Original:</strong><br>' + totalOriginal.toLocaleString() + ' ' + wallet.currency + '</div>' +
            '<div><strong>Total Consumed:</strong><br>' + totalConsumed.toLocaleString() + ' ' + wallet.currency + '</div>' +
            '<div><strong>Progress:</strong><br>' + tracedPercent + '%</div>' +
            '</div>';

        // Current thread info
        if (currentThread) {
            html += '<div style="background: #e8f5e9; border: 1px solid #4caf50; padding: 8px; border-radius: 4px; margin-bottom: 10px; font-size: 12px;">' +
                '👁️ <strong>Analyzing:</strong> Thread ' + currentThread.notation + ' (' + currentThread.remainingAmount.toLocaleString() + ' ' + wallet.currency + ' of ' + currentThread.originalAmount.toLocaleString() + ' remaining)' +
                '</div>';
        } else {
            html += '<div style="background: #f5f5f5; border: 1px solid #ccc; padding: 8px; border-radius: 4px; margin-bottom: 10px; font-size: 12px; color: #666;">' +
                '✅ <strong>All threads consumed</strong>' +
                '</div>';
        }

        html += '<div style="display: flex; gap: 10px;">' +
            '<button onclick="reanalyzeSingleMonitoredWallet(' + JSON.stringify(wallet).replace(/"/g, '&quot;') + ')" class="btn btn-primary">🔄 Re-analyze Now</button>' +
            '<button onclick="jumpToHopForMonitoredWallet(' + wallet.hopNumber + ')" class="btn btn-secondary">📊 View Hop ' + wallet.hopNumber + '</button>' +
            '</div>' +
            '</div>';
    });

    // Summary footer
    html += '<hr style="margin: 20px 0; border: none; border-top: 2px solid #eee;">' +
        '<div style="background: #f5f5f5; padding: 15px; border-radius: 8px;">' +
        '<h4 style="margin-top: 0;">📊 Summary</h4>' +
        '<div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 10px;">' +
        '<div><strong>Total Monitored Wallets:</strong><br>' + monitoredWallets.length + '</div>' +
        '<div><strong>Total Value:</strong><br>' + totalsDisplay + '</div>' +
        '<div><strong>Needing Review:</strong><br>' + needsReview + (needsReview > 0 ? ' ⚠️' : ' ✅') + '</div>' +
        '</div></div>' +

        '<div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">' +
        '<button onclick="closeLIBRMonitoringDashboard()" class="btn btn-secondary">Close</button>' +
        '</div></div></div>';

    document.body.insertAdjacentHTML('beforeend', html);
}

function closeLIBRMonitoringDashboard() {
    const modal = document.getElementById('librMonitoringModal');
    if (modal) modal.remove();
}

// Batch re-analyze all monitored wallets
async function reanalyzeAllMonitoredWallets() {
    const monitoredWallets = getAllMonitoredWallets();

    if (monitoredWallets.length === 0) {
        alert('No monitored wallets to analyze.');
        return;
    }

    // Show progress modal
    const progressHtml = '<div class="modal-overlay" id="librBatchProgressModal" style="z-index: 10001;">' +
        '<div class="modal-content" style="max-width: 600px;">' +
        '<h3>🔄 Re-analyzing Monitored Wallets</h3>' +
        '<p id="batchProgressText">Starting analysis...</p>' +
        '<div style="background: #f5f5f5; border-radius: 4px; height: 30px; overflow: hidden; margin: 10px 0;">' +
        '<div id="batchProgressBar" style="background: #2196f3; height: 100%; width: 0%; transition: width 0.3s;"></div>' +
        '</div>' +
        '<p id="batchProgressDetail" style="font-size: 12px; color: #666;">Analyzed 0 of ' + monitoredWallets.length + ' wallets</p>' +
        '</div></div>';

    document.body.insertAdjacentHTML('beforeend', progressHtml);

    const results = [];

    for (let i = 0; i < monitoredWallets.length; i++) {
        const wallet = monitoredWallets[i];

        // Update progress
        document.getElementById('batchProgressText').textContent = 'Analyzing ' + wallet.walletAddress.substring(0, 10) + '...';
        document.getElementById('batchProgressDetail').textContent = 'Analyzed ' + i + ' of ' + monitoredWallets.length + ' wallets';
        document.getElementById('batchProgressBar').style.width = ((i / monitoredWallets.length) * 100) + '%';

        try {
            // Ensure thread structure and get current thread
            ensureThreadStructure(wallet);
            const currentThread = getCurrentMonitoredThread(wallet);

            // Skip if no active thread
            if (!currentThread) {
                results.push({
                    wallet: wallet.walletAddress,
                    status: 'skipped',
                    message: 'All threads consumed'
                });
                continue;
            }

            // Perform LIBR analysis on current thread
            const txHistory = await fetchCompleteTransactionHistory(
                wallet.walletAddress,
                wallet.blockchain || 'ethereum',
                wallet.currency
            );

            const balanceHistory = calculateRunningBalance(
                wallet.walletAddress,
                txHistory,
                wallet.blockchain || 'ethereum'
            );

            const librAnalysis = findLIBRTransactionPoint(
                balanceHistory,
                currentThread.remainingAmount,  // Use current thread amount, not total
                new Date(wallet.lastAnalyzed || new Date()).getTime()
            );

            results.push({
                wallet: wallet,
                success: true,
                hasNewActivity: librAnalysis.transactionsToFollow && librAnalysis.transactionsToFollow.length > 0,
                newTransactions: librAnalysis.transactionsToFollow || [],
                analysis: librAnalysis
            });

        } catch (err) {
            console.error('Failed to analyze wallet:', wallet.walletAddress, err);
            results.push({
                wallet: wallet,
                success: false,
                error: err.message
            });
        }
    }

    // Update to 100%
    document.getElementById('batchProgressBar').style.width = '100%';
    document.getElementById('batchProgressText').textContent = 'Analysis complete!';
    document.getElementById('batchProgressDetail').textContent = 'Analyzed ' + monitoredWallets.length + ' of ' + monitoredWallets.length + ' wallets';

    // Wait a moment then show results
    setTimeout(() => {
        const progressModal = document.getElementById('librBatchProgressModal');
        if (progressModal) progressModal.remove();
        showBatchResultsSummary(results);
    }, 1000);
}

// Show batch analysis results summary
function showBatchResultsSummary(results) {
    const walletsWithActivity = results.filter(r => r.success && r.hasNewActivity);
    const walletsStable = results.filter(r => r.success && !r.hasNewActivity);
    const walletsFailed = results.filter(r => !r.success);

    let html = '<div class="modal-overlay" id="librBatchResultsModal" style="z-index: 10000;">' +
        '<div class="modal-content" style="max-width: 900px; max-height: 90vh; overflow-y: auto;">' +
        '<div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">' +
        '<h2>🔄 Batch Re-Analysis Complete</h2>' +
        '<button onclick="closeBatchResults()" class="btn-close" style="font-size: 24px; border: none; background: none; cursor: pointer;">✕</button>' +
        '</div>' +

        '<div style="background: #e3f2fd; padding: 15px; border-radius: 8px; margin-bottom: 20px;">' +
        '<div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; text-align: center;">' +
        '<div><div style="font-size: 32px; font-weight: bold; color: #f57c00;">' + walletsWithActivity.length + '</div><div style="font-size: 14px; color: #666;">New Activity 🔔</div></div>' +
        '<div><div style="font-size: 32px; font-weight: bold; color: #4caf50;">' + walletsStable.length + '</div><div style="font-size: 14px; color: #666;">Stable ✅</div></div>' +
        '<div><div style="font-size: 32px; font-weight: bold; color: #f44336;">' + walletsFailed.length + '</div><div style="font-size: 14px; color: #666;">Failed ❌</div></div>' +
        '</div></div>' +

        '<div style="margin-bottom: 10px;"><strong>Analysis Time:</strong> ' + new Date().toLocaleString() + '</div>' +
        '<hr style="margin: 20px 0; border: none; border-top: 2px solid #eee;">';

    // Show wallets with new activity first
    if (walletsWithActivity.length > 0) {
        html += '<h3 style="color: #f57c00;">🔔 Wallets with New Activity (' + walletsWithActivity.length + ')</h3>';

        walletsWithActivity.forEach(result => {
            const wallet = result.wallet;
            const newTxCount = result.newTransactions.length;
            const totalTraced = result.newTransactions.reduce((sum, tx) => sum + tx.tracedAmount, 0);

            html += '<div style="border: 2px solid #ff9800; border-radius: 8px; padding: 15px; margin-bottom: 15px; background: #fff3cd;">' +
                '<div style="display: flex; justify-content: space-between; align-items: start; margin-bottom: 10px;">' +
                '<div><strong style="font-size: 16px;">📍 Hop ' + wallet.hopNumber + ' (' + wallet.hopNotation + ')</strong></div>' +
                '<div style="background: #f57c00; color: white; padding: 4px 12px; border-radius: 12px; font-size: 12px; font-weight: bold;">NEW ACTIVITY</div>' +
                '</div>' +

                '<div style="font-family: monospace; font-size: 12px; background: white; padding: 8px; border-radius: 4px; margin-bottom: 10px; word-break: break-all;">' +
                wallet.walletAddress +
                '</div>' +

                '<div style="background: white; padding: 10px; border-radius: 4px; margin-bottom: 10px;">' +
                '<div><strong>' + newTxCount + ' new outbound transaction(s) found</strong></div>' +
                '<div style="font-size: 14px; color: #666; margin-top: 5px;">Total traced: ' + totalTraced.toFixed(6) + ' ' + wallet.currency + '</div>' +
                '<div style="font-size: 14px; color: #666;">Remaining: ' + result.analysis.remainingProceedsInWallet.toFixed(6) + ' ' + wallet.currency + '</div>' +
                '</div>' +

                '<div style="display: flex; gap: 10px;">' +
                '<button onclick="reanalyzeSingleMonitoredWallet(' + JSON.stringify(wallet).replace(/"/g, '&quot;') + '); closeBatchResults();" class="btn btn-primary">📊 View Details</button>' +
                '<button onclick="jumpToHopForMonitoredWallet(' + wallet.hopNumber + '); closeBatchResults();" class="btn btn-secondary">➕ Add to Hop ' + wallet.hopNumber + '</button>' +
                '</div>' +
                '</div>';
        });
    }

    // Show stable wallets
    if (walletsStable.length > 0) {
        html += '<h3 style="color: #4caf50;">✅ Stable Wallets (' + walletsStable.length + ')</h3>';

        walletsStable.forEach(result => {
            const wallet = result.wallet;

            html += '<div style="border: 1px solid #ddd; border-radius: 8px; padding: 10px; margin-bottom: 10px; background: white;">' +
                '<div style="display: flex; justify-content: space-between; align-items: center;">' +
                '<div><strong>Hop ' + wallet.hopNumber + ' (' + wallet.hopNotation + ')</strong> - ' + wallet.walletAddress.substring(0, 20) + '...</div>' +
                '<div style="color: #4caf50; font-size: 12px;">No new activity</div>' +
                '</div>' +
                '<div style="font-size: 12px; color: #666; margin-top: 5px;">Balance: ' + wallet.remainingProceeds.toLocaleString() + ' ' + wallet.currency + ' (unchanged)</div>' +
                '</div>';
        });
    }

    // Show failed wallets
    if (walletsFailed.length > 0) {
        html += '<h3 style="color: #f44336;">❌ Failed Analysis (' + walletsFailed.length + ')</h3>';

        walletsFailed.forEach(result => {
            const wallet = result.wallet;

            html += '<div style="border: 1px solid #f44336; border-radius: 8px; padding: 10px; margin-bottom: 10px; background: #ffebee;">' +
                '<div><strong>Hop ' + wallet.hopNumber + ' (' + wallet.hopNotation + ')</strong> - ' + wallet.walletAddress.substring(0, 20) + '...</div>' +
                '<div style="font-size: 12px; color: #d32f2f; margin-top: 5px;">Error: ' + result.error + '</div>' +
                '</div>';
        });
    }

    html += '<hr style="margin: 20px 0; border: none; border-top: 2px solid #eee;">' +
        '<div style="display: flex; gap: 10px; justify-content: flex-end; margin-top: 20px;">' +
        '<button onclick="closeBatchResults()" class="btn btn-primary">Close</button>' +
        '</div></div></div>';

    document.body.insertAdjacentHTML('beforeend', html);
}

function closeBatchResults() {
    const modal = document.getElementById('librBatchResultsModal');
    if (modal) modal.remove();
}

// End of LIBR Monitoring Dashboard Functions
// ====================================================================

// ====================================================================
// LIBR Transaction Action Functions
// ====================================================================

// Follow a LIBR transaction by adding it to the appropriate hop
function followLIBRTransaction(txData) {
    console.log('✅ Following LIBR transaction:', txData.txHash);

    if (!txData.hopNumber) {
        alert('Cannot determine which hop this transaction belongs to.\n\nPlease add it manually through the hop wizard.');
        return;
    }

    const hop = investigation.hops[txData.hopNumber - 1];
    if (!hop) {
        alert('Hop ' + txData.hopNumber + ' not found.');
        return;
    }

    // Add outbound entry to the hop
    const newEntry = {
        type: 'outbound',
        txHash: txData.txHash,
        timestamp: txData.timestamp,
        datetime: new Date(txData.timestamp).toLocaleString(),
        fromWallet: txData.walletAddress,
        toWallet: '', // Will be filled by user or blockchain lookup
        amount: txData.tracedAmount, // Use traced amount, not full TX amount
        currency: txData.currency,
        blockchain: txData.blockchain,
        notes: 'LIBR: Traced ' + txData.tracedAmount.toFixed(6) + ' ' + txData.currency + ' from monitored wallet.\nBalance dropped to ' + txData.balanceAfter.toFixed(6) + ' ' + txData.currency,
        isError: '0',
        methodId: '',
        gasPrice: '',
        gasUsed: '',
        blockNumber: txData.blockNumber || ''
    };

    // Add entry to hop
    if (!hop.entries) hop.entries = [];
    hop.entries.push(newEntry);

    // Update monitored wallet entry
    const monitoredEntry = hop.entries.find(e =>
        e.type === 'libr_wallet_status' &&
        e.walletAddress &&
        e.walletAddress.toLowerCase() === txData.walletAddress.toLowerCase()
    );

    if (monitoredEntry) {
        // Ensure thread structure exists (migrate if needed)
        ensureThreadStructure(monitoredEntry);

        // Reduce current thread amount
        reduceCurrentThreadAmount(monitoredEntry, txData.tracedAmount);

        // Update last analyzed timestamp
        monitoredEntry.lastAnalyzed = new Date().toISOString();

        // Add trace note
        const today = new Date().toLocaleDateString();
        const currentThread = getCurrentMonitoredThread(monitoredEntry);
        const threadNotation = currentThread ? currentThread.notation : 'UNKNOWN';
        const updateNote = '[' + today + '] Traced ' + txData.tracedAmount.toFixed(6) + ' ' + txData.currency + ' from thread ' + threadNotation + ' via ' + txData.txHash;
        monitoredEntry.notes = monitoredEntry.notes ? monitoredEntry.notes + '\n' + updateNote : updateNote;
    } else {
        // Create monitored entry with thread structure if it doesn't exist
        const remainingEntry = {
            type: 'libr_wallet_status',
            walletAddress: txData.walletAddress,
            blockchain: txData.blockchain,
            currency: txData.currency,
            threads: [{
                notation: txData.threadNotation || 'UNKNOWN',
                depositTimestamp: txData.depositTimestamp || Date.now(),
                originalAmount: txData.tracedAmount + txData.remainingInWallet,
                remainingAmount: txData.remainingInWallet,
                status: 'monitoring',
                depositTxHash: txData.depositTxHash || ''
            }],
            currentThreadIndex: 0,
            totalOriginalProceeds: txData.tracedAmount + txData.remainingInWallet,
            totalRemainingProceeds: txData.remainingInWallet,
            totalConsumed: txData.tracedAmount,
            // Legacy fields for backwards compatibility
            remainingProceeds: txData.remainingInWallet,
            originalProceeds: txData.tracedAmount + txData.remainingInWallet,
            lastAnalyzed: new Date().toISOString(),
            notes: 'LIBR monitored wallet. Traced ' + txData.tracedAmount.toFixed(6) + ' ' + txData.currency + ', ' + txData.remainingInWallet.toFixed(6) + ' remains.'
        };
        hop.entries.push(remainingEntry);
    }

    // Save and refresh
    saveToStorage();
    renderHops();

    // Close LIBR modal
    closeLIBRBalanceModal();

    // Show success notification
    showNotification('✅ Transaction added to Hop ' + txData.hopNumber + '\n' + txData.tracedAmount.toFixed(6) + ' ' + txData.currency + ' traced', 'success');

    // Jump to the hop
    setTimeout(() => {
        jumpToHopForMonitoredWallet(txData.hopNumber);
    }, 500);
}

// Mark transaction as monitored only (don't trace yet)
function markAsMonitoredOnly(txData) {
    console.log('👁️ Marking transaction as monitored only:', txData.txHash);

    if (!txData.hopNumber) {
        alert('Cannot determine which hop this transaction belongs to.');
        return;
    }

    const hop = investigation.hops[txData.hopNumber - 1];
    if (!hop) {
        alert('Hop ' + txData.hopNumber + ' not found.');
        return;
    }

    // Update monitored wallet entry with note about untraced transaction
    const monitoredEntry = hop.entries.find(e =>
        e.type === 'libr_wallet_status' &&
        e.walletAddress &&
        e.walletAddress.toLowerCase() === txData.walletAddress.toLowerCase()
    );

    if (monitoredEntry) {
        const today = new Date().toLocaleDateString();
        const note = '[' + today + '] Identified but not traced: ' + txData.tracedAmount.toFixed(6) + ' ' + txData.currency + ' in TX ' + txData.txHash.substring(0, 10) + '...';
        monitoredEntry.notes = monitoredEntry.notes ? monitoredEntry.notes + '\n' + note : note;

        saveToStorage();
        renderHops();
        closeLIBRBalanceModal();

        showNotification('Transaction marked as monitored but not traced.\nYou can trace it later if needed.', 'info');
    }
}

// ====================================================================
// LIBR Multi-Thread Management Functions
// ====================================================================

// Ensure monitored entry has thread structure (migrate from old format if needed)
function ensureThreadStructure(monitoredEntry) {
    // If already has threads array, return as-is
    if (monitoredEntry.threads && Array.isArray(monitoredEntry.threads)) {
        return monitoredEntry;
    }

    // Migrate old single-thread format to new multi-thread format
    console.log('🔄 Migrating monitored entry to multi-thread structure');

    // Create threads array with single thread from old data
    monitoredEntry.threads = [{
        notation: 'LEGACY',  // Will be updated when we know the actual thread notation
        depositTimestamp: monitoredEntry.depositTimestamp || Date.now(),
        originalAmount: monitoredEntry.originalProceeds || 0,
        remainingAmount: monitoredEntry.remainingProceeds || 0,
        status: (monitoredEntry.remainingProceeds > 0.000001) ? 'monitoring' : 'consumed',
        depositTxHash: monitoredEntry.depositTxHash || ''
    }];

    // Set current thread index
    monitoredEntry.currentThreadIndex = 0;

    // Set aggregate totals
    monitoredEntry.totalOriginalProceeds = monitoredEntry.originalProceeds || 0;
    monitoredEntry.totalRemainingProceeds = monitoredEntry.remainingProceeds || 0;
    monitoredEntry.totalConsumed = (monitoredEntry.originalProceeds || 0) - (monitoredEntry.remainingProceeds || 0);

    return monitoredEntry;
}

// Add a new thread to monitored wallet (PIFO - chronologically ordered)
function addThreadToMonitoredWallet(monitoredEntry, threadData) {
    console.log('➕ Adding thread to monitored wallet:', threadData.notation);

    // Ensure thread structure exists
    ensureThreadStructure(monitoredEntry);

    // Create new thread object
    const newThread = {
        notation: threadData.notation || 'UNKNOWN',
        depositTimestamp: threadData.depositTimestamp || Date.now(),
        originalAmount: threadData.amount || 0,
        remainingAmount: threadData.amount || 0,
        status: 'pending',  // New threads start as pending (will be monitored when current thread consumed)
        depositTxHash: threadData.txHash || ''
    };

    // Insert thread in chronological order (oldest first - PIFO)
    let insertIndex = monitoredEntry.threads.length;
    for (let i = 0; i < monitoredEntry.threads.length; i++) {
        if (newThread.depositTimestamp < monitoredEntry.threads[i].depositTimestamp) {
            insertIndex = i;
            break;
        }
    }

    monitoredEntry.threads.splice(insertIndex, 0, newThread);

    // Update totals
    updateMonitoredWalletTotals(monitoredEntry);

    // Update current thread index if we inserted before it
    if (insertIndex <= monitoredEntry.currentThreadIndex) {
        monitoredEntry.currentThreadIndex++;
    }

    // If this is the only thread or current thread is consumed, set this as current
    if (monitoredEntry.threads.length === 1 ||
        monitoredEntry.threads[monitoredEntry.currentThreadIndex].status === 'consumed') {
        monitoredEntry.currentThreadIndex = insertIndex;
        monitoredEntry.threads[insertIndex].status = 'monitoring';
    }

    console.log('✅ Thread added. Queue now has ' + monitoredEntry.threads.length + ' threads');

    return monitoredEntry;
}

// Update aggregate totals for monitored wallet
function updateMonitoredWalletTotals(monitoredEntry) {
    if (!monitoredEntry.threads || monitoredEntry.threads.length === 0) {
        monitoredEntry.totalOriginalProceeds = 0;
        monitoredEntry.totalRemainingProceeds = 0;
        monitoredEntry.totalConsumed = 0;
        return monitoredEntry;
    }

    let totalOriginal = 0;
    let totalRemaining = 0;

    monitoredEntry.threads.forEach(thread => {
        totalOriginal += thread.originalAmount;
        totalRemaining += thread.remainingAmount;
    });

    monitoredEntry.totalOriginalProceeds = totalOriginal;
    monitoredEntry.totalRemainingProceeds = totalRemaining;
    monitoredEntry.totalConsumed = totalOriginal - totalRemaining;

    // Also update legacy fields for backwards compatibility
    monitoredEntry.originalProceeds = totalOriginal;
    monitoredEntry.remainingProceeds = totalRemaining;

    return monitoredEntry;
}

// Get current thread being monitored
function getCurrentMonitoredThread(monitoredEntry) {
    ensureThreadStructure(monitoredEntry);

    if (!monitoredEntry.threads || monitoredEntry.threads.length === 0) {
        return null;
    }

    const currentIndex = monitoredEntry.currentThreadIndex || 0;
    if (currentIndex >= monitoredEntry.threads.length) {
        return null;
    }

    return monitoredEntry.threads[currentIndex];
}

// Check if current thread is consumed and advance to next if needed
function checkAndAdvanceToNextThread(monitoredEntry) {
    ensureThreadStructure(monitoredEntry);

    if (!monitoredEntry.threads || monitoredEntry.threads.length === 0) {
        return false;  // No threads
    }

    const currentThread = monitoredEntry.threads[monitoredEntry.currentThreadIndex];

    // Check if current thread is consumed (remaining amount is negligible)
    if (currentThread.remainingAmount < 0.000001) {
        currentThread.status = 'consumed';
        console.log('✅ Thread ' + currentThread.notation + ' fully consumed');

        // Find next pending thread in chronological order
        let nextThreadIndex = -1;
        for (let i = 0; i < monitoredEntry.threads.length; i++) {
            if (monitoredEntry.threads[i].status === 'pending') {
                nextThreadIndex = i;
                break;
            }
        }

        // Advance to next thread if found
        if (nextThreadIndex !== -1) {
            console.log('🔄 Advancing to next thread: ' + monitoredEntry.threads[nextThreadIndex].notation);
            monitoredEntry.currentThreadIndex = nextThreadIndex;
            monitoredEntry.threads[nextThreadIndex].status = 'monitoring';

            // Add note about advancement
            const today = new Date().toLocaleDateString();
            const advanceNote = '[' + today + '] Advanced to thread ' + monitoredEntry.threads[nextThreadIndex].notation + ' (' + monitoredEntry.threads[nextThreadIndex].remainingAmount.toFixed(6) + ' ' + monitoredEntry.currency + ') after ' + currentThread.notation + ' fully consumed';
            monitoredEntry.notes = monitoredEntry.notes ? monitoredEntry.notes + '\n' + advanceNote : advanceNote;

            return true;  // Advanced
        } else {
            console.log('✅ All threads consumed in this wallet');
            return false;  // No more threads
        }
    }

    return false;  // Current thread not yet consumed
}

// Reduce current thread amount after tracing
function reduceCurrentThreadAmount(monitoredEntry, amountTraced) {
    const currentThread = getCurrentMonitoredThread(monitoredEntry);

    if (!currentThread) {
        console.warn('⚠️ No current thread to reduce');
        return monitoredEntry;
    }

    // Reduce the current thread's remaining amount
    currentThread.remainingAmount = Math.max(0, currentThread.remainingAmount - amountTraced);

    console.log('📉 Reduced thread ' + currentThread.notation + ' by ' + amountTraced.toFixed(6) +
                ', remaining: ' + currentThread.remainingAmount.toFixed(6));

    // Update totals
    updateMonitoredWalletTotals(monitoredEntry);

    // Check if thread consumed and advance if needed
    checkAndAdvanceToNextThread(monitoredEntry);

    return monitoredEntry;
}

// End of LIBR Multi-Thread Management Functions
// ====================================================================

// End of LIBR Transaction Action Functions
// ====================================================================

// End of LIBR UI Functions
// ====================================================================

async function lookupTronTransaction(txHash) {
    const config = window.blockchainAPIs.tron;
    // Disable CORS proxy to avoid CSP issues - APIs should handle CORS natively
    const corsEnabled = false;
    const corsProxyUrl = '';
    
    const urlsToTry = [config.apiUrl, ...(config.fallbackUrls || [])];
    
    for (let apiUrl of urlsToTry) {
        try {
            let url = apiUrl + txHash;
            const headers = config.apiKey ? { 'TRON-PRO-API-KEY': config.apiKey } : {};
            
            if (corsEnabled) url = corsProxyUrl + url;
            
            const response = await fetch(url, { headers });
            if (!response.ok) continue;
            const data = await response.json();
            
            const txData = config.parseResponse(data);
            if (txData) {
                txData.blockchain = config.name;
                txData.rawHash = txHash;
                return txData;
            }
        } catch (error) {
            console.error(`Failed with ${apiUrl}:`, error);
        }
    }
    
    throw new Error('Failed to fetch Tron transaction');
}

async function lookupSolanaTransaction(txHash) {
    const config = window.blockchainAPIs.solana;

    // Check if we're on a deployed site (Netlify) or local development
    const isNetlifyDeployed = window.location.hostname.includes('batstool.com') ||
                             window.location.hostname.includes('netlify.app');

    // Try using our Netlify proxy first if on deployed site
    if (isNetlifyDeployed) {
        try {
            console.log('Attempting Solana lookup via Netlify proxy...');
            const response = await fetch('/.netlify/functions/solana-proxy', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    jsonrpc: '2.0',
                    id: 1,
                    method: 'getTransaction',
                    params: [txHash, {
                        encoding: 'jsonParsed',
                        commitment: 'confirmed',
                        maxSupportedTransactionVersion: 0
                    }]
                })
            });

            if (response.ok) {
                const data = await response.json();
                if (!data.error && data.result) {
                    const txData = config.parseResponse(data);
                    if (txData) {
                        txData.blockchain = config.name;
                        txData.rawHash = txHash;
                        console.log('Successfully fetched Solana tx via proxy');
                        return txData;
                    }
                } else if (data.error) {
                    console.log('Solana RPC error:', data.error);
                    throw new Error(data.error.message || 'Transaction not found');
                }
            } else {
                console.log('Proxy response not ok:', response.status);
            }
        } catch (error) {
            console.log('Netlify proxy failed:', error);
            // Don't fallback to direct calls - they'll fail with CORS
            throw new Error(`Solana lookup failed: ${error.message}. Please check the transaction hash.`);
        }
    }

    // For local development, try direct API (will likely fail with CORS but worth trying)
    console.warn('Local development mode - Solana API calls may fail due to CORS');
    const urlsToTry = [config.apiUrl, ...(config.fallbackUrls || [])];

    for (let apiUrl of urlsToTry) {
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    jsonrpc: '2.0',
                    id: 1,
                    method: 'getTransaction',
                    params: [txHash, {
                        encoding: 'jsonParsed',
                        commitment: 'confirmed',
                        maxSupportedTransactionVersion: 0
                    }]
                })
            });

            if (!response.ok) continue;
            const data = await response.json();
            if (data.error) {
                console.log(`Solana RPC error from ${apiUrl}:`, data.error);
                continue;
            }

            const txData = config.parseResponse(data);
            if (txData) {
                txData.blockchain = config.name;
                txData.rawHash = txHash;
                return txData;
            }
        } catch (error) {
            console.error(`Failed with ${apiUrl}:`, error);
        }
    }

    throw new Error('Failed to fetch Solana transaction');
}

// Victim Transaction Lookup Function
async function lookupHopTransaction(hopNumber, entryId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop?.entries.find(e => e.id === entryId);
    if (!hop || !entry) return;
    
    const txHash = document.getElementById(`txHash_${hopNumber}_${entryId}`)?.value?.trim();
    if (!txHash) {
        alert('Please enter a transaction hash');
        return;
    }
    
    const detectedChain = detectBlockchainFromHash(txHash);
    if (!detectedChain) {
        alert('Cannot determine blockchain from hash format');
        return;
    }
    
    // Show loading indicator
    const button = event.target;
    const originalText = button.textContent;
    button.textContent = '⏳ Looking up...';
    button.disabled = true;
    
    try {
        let txData = null;
        
        switch(detectedChain) {
            case 'ethereum':
                txData = await lookupEthereumTransaction(txHash);
                break;
            case 'bitcoin':
                txData = await lookupBitcoinTransaction(txHash);
                break;
            case 'tron':
                txData = await lookupTronTransaction(txHash);
                break;
            case 'solana':
                txData = await lookupSolanaTransaction(txHash);
                break;
            default:
                throw new Error('Unsupported blockchain');
        }
        
        if (txData) {
            // Handle multiple transfers case (batch transactions)
            if (txData.multipleTransfers) {
                // Show transfer selection modal
                showTransferSelectionForHop(hopNumber, entryId, txData.transfers);
                return;
            }
            
            // Auto-populate hop entry fields
            updateHopEntry(hopNumber, entryId, 'fromWallet', txData.from);
            updateHopEntry(hopNumber, entryId, 'toWallet', txData.to);
            updateHopEntry(hopNumber, entryId, 'amount', txData.amount); // Use 'amount' not 'value'
            updateHopEntry(hopNumber, entryId, 'currency', txData.currency);
            updateHopEntry(hopNumber, entryId, 'timestamp', formatDatetimeLocal(txData.time));
            
            // Update UI fields directly
            const amountField = document.getElementById(`amount_${hopNumber}_${entryId}`);
            if (amountField) amountField.value = txData.amount; // Use 'amount' not 'value'
            
            const currencySelect = document.querySelector(`[onchange*="updateHopEntry(${hopNumber}, ${entryId}, 'currency'"]`);
            if (currencySelect) {
                currencySelect.value = txData.currency;
                // Trigger currency change to update step
                updateHopEntry(hopNumber, entryId, 'currency', txData.currency);
            }
            
            const timestampField = document.getElementById(`timestamp_${hopNumber}_${entryId}`);
            if (timestampField) timestampField.value = formatDatetimeLocal(txData.time);
            
            const toWalletField = document.getElementById(`toWallet_${hopNumber}_${entryId}`);
            if (toWalletField) toWalletField.value = txData.to;
            
            // Update from wallet field if it exists
            const fromWalletField = document.querySelector(`input[onchange*="updateHopEntry(${hopNumber}, ${entryId}, 'fromWallet'"]`);
            if (fromWalletField) fromWalletField.value = txData.from;
            
            let alertMessage = ` Transaction data loaded:\n\nFrom: ${txData.from}\nTo: ${txData.to}\nAmount: ${txData.amount} ${txData.currency}\nTime: ${new Date(txData.time).toLocaleString()}`;
            
            // Add warning if timestamp is not from blockchain
            if (txData.hasRealTimestamp === false) {
                alertMessage += '\n\n⚠️ WARNING: Could not retrieve actual transaction timestamp from blockchain. Please manually verify and update the date/time field!';
            }
            
            alert(alertMessage);
        }
    } catch (error) {
        console.error('Lookup error:', error);
        alert(`ERROR:  Failed to lookup transaction: ${error.message}`);
    } finally {
        button.textContent = originalText;
        button.disabled = false;
    }
}

async function lookupRippleTransaction(txHash) {
    try {
        // Use XRPL public API
        const url = `https://api.xrpscan.com/api/v1/tx/${txHash}`;

        const response = await fetch(url);
        if (!response.ok) {
            // Try alternative API
            const altUrl = `https://data.ripple.com/v2/transactions/${txHash}`;
            const altResponse = await fetch(altUrl);

            if (!altResponse.ok) {
                throw new Error('Transaction not found on Ripple network');
            }

            const altData = await altResponse.json();
            if (altData.transaction) {
                const tx = altData.transaction;
                return {
                    hash: txHash,
                    blockchain: 'Ripple',
                    from: tx.Account || '',
                    to: tx.Destination || '',
                    amount: tx.Amount ? (parseInt(tx.Amount) / 1000000) : 0, // Convert drops to XRP
                    currency: 'XRP',
                    time: tx.date ? new Date(tx.date).getTime() : Date.now(),
                    fee: tx.Fee ? (parseInt(tx.Fee) / 1000000) : 0,
                    rawData: altData
                };
            }
        }

        const data = await response.json();

        // Parse XRPScan API response
        if (data) {
            // Extract payment details
            let amount = 0;
            let currency = 'XRP';
            let toAddress = '';

            if (data.Amount) {
                if (typeof data.Amount === 'string') {
                    amount = parseInt(data.Amount) / 1000000; // Convert drops to XRP
                } else if (data.Amount.value) {
                    amount = parseFloat(data.Amount.value);
                    currency = data.Amount.currency || 'XRP';
                }
            }

            // Get destination address
            toAddress = data.Destination || data.Account || '';

            return {
                hash: txHash,
                blockchain: 'Ripple',
                from: data.Account || '',
                to: toAddress,
                amount: amount,
                currency: currency,
                time: data.date ? new Date(data.date * 1000).getTime() : Date.now(),
                fee: data.Fee ? (parseInt(data.Fee) / 1000000) : 0,
                rawData: data
            };
        }

        throw new Error('Unable to parse Ripple transaction');
    } catch (error) {
        console.error('Ripple lookup error:', error);
        throw error;
    }
}

function showTransferSelectionForHop(hopNumber, entryId, transfers) {
    const modalHTML = `
        <div id="hopTransferModal" class="modal" style="display: block;">
            <div class="modal-content" style="max-width: 700px;">
                <div class="modal-header">
                    <h2>🔀 Multiple Transfers Detected</h2>
                    <p>This transaction contains ${transfers.length} transfers. Select the one to use:</p>
                </div>
                
                <div style="max-height: 400px; overflow-y: auto; margin: 20px 0;">
                    ${transfers.map((transfer, index) => `
                        <div style="background: white; border: 2px solid #e8f0fe; border-radius: 8px; padding: 15px; margin-bottom: 10px; cursor: pointer; transition: all 0.2s;"
                             onmouseover="this.style.borderColor='#3498db'; this.style.transform='translateY(-2px)'"
                             onmouseout="this.style.borderColor='#e8f0fe'; this.style.transform='translateY(0)'"
                             onclick="selectHopTransfer(${hopNumber}, ${entryId}, ${index})">
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                                <div>
                                    <strong>From:</strong><br>
                                    <span style="font-family: monospace; font-size: 12px;">${transfer.from}</span>
                                </div>
                                <div>
                                    <strong>To:</strong><br>
                                    <span style="font-family: monospace; font-size: 12px;">${transfer.to}</span>
                                </div>
                            </div>
                            <div style="margin-top: 10px; font-size: 18px; font-weight: bold; color: #2c3e50;">
                                ${transfer.amount} ${transfer.currency}
                            </div>
                        </div>
                    `).join('')}
                </div>
                
                <div style="text-align: center; margin-top: 20px;">
                    <button class="btn btn-secondary" onclick="closeHopTransferModal()">
                        Cancel
                    </button>
                </div>
            </div>
        </div>
    `;
    
    // Store transfers data for selection
    window.hopTransferData = transfers;
    
    // Create centered modal
    createCenteredModal('hopTransferModal', modalHTML);
}

function selectHopTransfer(hopNumber, entryId, transferIndex) {
    const transfer = window.hopTransferData[transferIndex];
    if (!transfer) return;
    
    // Populate the hop entry with selected transfer
    updateHopEntry(hopNumber, entryId, 'fromWallet', transfer.from);
    updateHopEntry(hopNumber, entryId, 'toWallet', transfer.to);
    updateHopEntry(hopNumber, entryId, 'amount', transfer.amount);
    updateHopEntry(hopNumber, entryId, 'currency', transfer.currency);
    
    // Update UI fields
    const amountField = document.getElementById(`amount_${hopNumber}_${entryId}`);
    if (amountField) amountField.value = transfer.amount;
    
    const toWalletField = document.getElementById(`toWallet_${hopNumber}_${entryId}`);
    if (toWalletField) toWalletField.value = transfer.to;
    
    alert(` Transfer selected:\n\nFrom: ${transfer.from}\nTo: ${transfer.to}\nAmount: ${transfer.amount} ${transfer.currency}`);
    
    closeHopTransferModal();
}

function closeHopTransferModal() {
    const modal = document.getElementById('hopTransferModal');
    if (modal) modal.remove();
    window.hopTransferData = null;
}

async function lookupVictimTransaction(victimId, transactionId) {
    const txHashInputElement = document.getElementById(`txHash_victim_${victimId}_${transactionId}`);
    const txHash = txHashInputElement.value.trim();

    if (!txHash) {
        alert('Please paste a transaction hash first');
        return;
    }

    // Check if user selected a specific chain
    const chainSelector = document.getElementById(`chain_victim_${victimId}_${transactionId}`);
    let detectedChain = chainSelector && chainSelector.value ? chainSelector.value : detectBlockchainFromHash(txHash);

    if (!detectedChain) {
        alert('Unable to detect blockchain. Please select a chain from the dropdown.');
        return;
    }
    
    // Show loading state - find the button that was clicked
    const lookupBtn = document.querySelector(`button[onclick*="lookupVictimTransaction(${victimId}, ${transactionId})"]`);
    const originalText = lookupBtn.textContent;
    lookupBtn.textContent = '⏳ Loading...';
    lookupBtn.disabled = true;
    
    try {
        const config = blockchainAPIs[detectedChain];
        const corsEnabled = localStorage.getItem('bats_cors_proxy_enabled') === 'true';
        const corsProxyUrl = localStorage.getItem('bats_cors_proxy_url') || 'https://cors-anywhere.herokuapp.com/';
        
        // Build array of URLs to try (primary + fallbacks)
        const urlsToTry = [config.apiUrl, ...(config.fallbackUrls || [])];
        let lastError = null;
        let txData = null;
        
        for (let apiUrl of urlsToTry) {
            try {
                let data;
                let url;
                let tokenData = null; // Define tokenData at this scope
                let blockTimestamp = null; // Define blockTimestamp at this scope
                let blockData = null; // Define blockData at this scope
                
                if (detectedChain === 'bitcoin') {
                    url = apiUrl + txHash;
                    if (config.apiKey) {
                        url += `?api_key=${config.apiKey}`;
                    }
                    if (corsEnabled) url = corsProxyUrl + url;
                    
                    const response = await fetch(url);
                    if (!response.ok) throw new Error('Transaction not found');
                    data = await response.json();
                    
                } else if (['ethereum', 'base', 'arbitrum', 'optimism', 'polygon', 'bsc',
                           'avalanche', 'hyperevm', 'linea', 'scroll', 'mantle', 'blast',
                           'zksync', 'gnosis', 'celo', 'moonbeam', 'moonriver', 'fraxtal',
                           'taiko', 'arbitrumnova', 'bittorrent', 'opbnb'].includes(detectedChain)) {
                    const apiKey = localStorage.getItem('bats_etherscan_api_key') || config.apiKey || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8';
                    
                    // First get the basic transaction
                    url = `${apiUrl}${txHash}&apikey=${apiKey}`;
                    if (corsEnabled) url = corsProxyUrl + url;
                    
                    const response = await fetch(url);
                    if (!response.ok) throw new Error('API request failed');
                    data = await response.json();
                    if (!data.result || data.result === null) throw new Error('Transaction not found');
                    
                    // Get block data for timestamp - but don't let it block token transfers
                    if (data.result && data.result.blockNumber) {
                        try {
                            const blockUrl = corsEnabled ?
                                corsProxyUrl + `${config.blockApiUrl}${data.result.blockNumber}&boolean=true&apikey=${apiKey}` :
                                `${config.blockApiUrl}${data.result.blockNumber}&boolean=true&apikey=${apiKey}`;
                            
                            const blockResponse = await fetch(blockUrl);
                            if (blockResponse.ok) {
                                const blockData = await blockResponse.json();
                                if (blockData && blockData.result && blockData.result.timestamp) {
                                    blockTimestamp = parseInt(blockData.result.timestamp, 16) * 1000;
                                    console.log('Got block timestamp:', new Date(blockTimestamp).toISOString());
                                }
                            }
                        } catch (err) {
                            console.log('Failed to fetch block timestamp, will proceed without it:', err);
                        }
                    }
                    
                    // Small delay to avoid rate limit
                    if (blockTimestamp) {
                        await new Promise(resolve => setTimeout(resolve, 300));
                    }
                    
                    // Also check for token transfers
                    try {
                        const tokenUrl = corsEnabled ? 
                            corsProxyUrl + `${config.tokenApiUrl}${txHash}&apikey=${apiKey}` :
                            `${config.tokenApiUrl}${txHash}&apikey=${apiKey}`;
                        
                        const tokenResponse = await fetch(tokenUrl);
                        if (tokenResponse.ok) {
                            tokenData = await tokenResponse.json();
                            console.log('Receipt/Token data received:', tokenData);
                            
                            // Check if Etherscan returned an error
                            if (tokenData && tokenData.status === '0' && tokenData.message === 'NOTOK') {
                                console.error('Etherscan API error:', tokenData.result);
                                throw new Error(tokenData.result);
                            }
                        }
                    } catch (err) {
                        console.log('No token transfers found');
                    }
                    
                } else if (detectedChain === 'tron') {
                    url = apiUrl + txHash;
                    if (config.apiKey) {
                        const headers = { 'TRON-PRO-API-KEY': config.apiKey };
                        if (corsEnabled) url = corsProxyUrl + url;
                        
                        const response = await fetch(url, { headers });
                        if (!response.ok) throw new Error('Transaction not found');
                        data = await response.json();
                    } else {
                        if (corsEnabled) url = corsProxyUrl + url;
                        const response = await fetch(url);
                        if (!response.ok) throw new Error('Transaction not found');
                        data = await response.json();
                    }
                    
                } else if (detectedChain === 'solana') {
                    url = apiUrl;
                    if (corsEnabled) url = corsProxyUrl + url;

                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            jsonrpc: '2.0',
                            id: 1,
                            method: 'getTransaction',
                            params: [txHash, { encoding: 'json', maxSupportedTransactionVersion: 0 }]
                        })
                    });
                    if (!response.ok) throw new Error('RPC request failed');
                    data = await response.json();
                    if (data.error) throw new Error(data.error.message);

                } else if (detectedChain === 'sui') {
                    url = apiUrl;
                    if (corsEnabled) url = corsProxyUrl + url;

                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            jsonrpc: '2.0',
                            id: 1,
                            method: 'sui_getTransactionBlock',
                            params: [
                                txHash,
                                {
                                    showInput: true,
                                    showEffects: true,
                                    showEvents: true,
                                    showObjectChanges: true,
                                    showBalanceChanges: true
                                }
                            ]
                        })
                    });
                    if (!response.ok) throw new Error('RPC request failed');
                    data = await response.json();
                    if (data.error) throw new Error(data.error.message);
                }

                // Parse the response (pass tokenData and blockTimestamp for EVM chains)
                const isEVMChain = ['ethereum', 'base', 'arbitrum', 'optimism', 'polygon', 'bsc',
                               'avalanche', 'hyperevm', 'linea', 'scroll', 'mantle', 'blast',
                               'zksync', 'gnosis', 'celo', 'moonbeam', 'moonriver', 'fraxtal',
                               'taiko', 'arbitrumnova', 'bittorrent', 'opbnb', 'unichain',
                               'sonic', 'abstract', 'memecore', 'sophon', 'berachain'].includes(detectedChain);
                txData = isEVMChain ?
                    config.parseResponse(data, tokenData, blockTimestamp, config) :
                    config.parseResponse(data);
                
                console.log('Parsed transaction data:', txData);

                if (!txData) {
                    const nativeCurrency = config.nativeCurrency || 'native currency';
                    throw new Error(`No transfers found in this ${config.name} transaction (0 ${nativeCurrency} transfer with no token transfers)`);
                }
                
                // Check if multiple transfers were detected
                if (txData.multipleTransfers) {
                    console.log('Multiple transfers detected, showing selection modal with', txData.transfers.length, 'transfers');
                    // Store the callback with proper context
                    // Add chain to each transfer
                    const transfersWithChain = txData.transfers.map(t => ({...t, chain: detectedChain}));

                    window.pendingTransferContext = {
                        victimId: victimId,
                        transactionId: transactionId,
                        txHash: txHash,
                        transfers: transfersWithChain,
                        timestamp: txData.time,
                        hasRealTimestamp: txData.hasRealTimestamp
                    };
                    pendingTransferCallback = (selectedTransfer) => {
                        // Apply the selected transfer with timestamp
                        applyTransferToVictim(victimId, transactionId, selectedTransfer, txHash, txData.time, txData.hasRealTimestamp);
                    };
                    showTransferSelectionModal(txData.transfers);
                    lookupBtn.textContent = originalText;
                    lookupBtn.disabled = false;
                    return; // Exit early - will continue after selection
                }
                
                // Success! Break out of the loop
                break;
                
            } catch (error) {
                console.error(`Failed with ${apiUrl}:`, error);
                lastError = error;
                // Continue to next URL
            }
        }
        
        if (!txData) {
            throw lastError || new Error('Failed to fetch transaction');
        }
        
        // Apply the data to the victim transaction
        const victim = investigation.victims.find(v => v.id === victimId);
        const transaction = victim.transactions.find(t => t.id === transactionId);
        
        // Update amount
        document.getElementById(`amount_victim_${victimId}_${transactionId}`).value = txData.amount;
        transaction.amount = txData.amount.toString();
        
        // Update currency
        const currencySelect = document.getElementById(`currency_victim_${victimId}_${transactionId}`);
        if (currencySelect) {
            // Check if the currency exists in the dropdown
            const optionExists = Array.from(currencySelect.options).some(opt => opt.value === txData.currency);
            if (!optionExists && txData.currency !== 'CUSTOM') {
                // Add new currency option if it doesn't exist
                const newOption = document.createElement('option');
                newOption.value = txData.currency;
                newOption.textContent = txData.currency;
                currencySelect.appendChild(newOption);
            }

            currencySelect.value = txData.currency;
            transaction.currency = txData.currency;
        }
        
        // Update receiving wallet (the "to" address is the RED wallet)
        document.getElementById(`receivingWallet_victim_${victimId}_${transactionId}`).value = txData.to;
        transaction.receivingWallet = txData.to;

        // Store the detected chain
        const chainSelector = document.getElementById(`chain_victim_${victimId}_${transactionId}`);
        if (chainSelector && detectedChain) {
            chainSelector.value = detectedChain;
            transaction.chain = detectedChain;
            console.log(`Stored chain '${detectedChain}' for V${victimId}-T${transactionId}`);
        }
        
        // Update datetime with validation
        if (txData.time && !isNaN(txData.time)) {
            const date = new Date(txData.time);
            if (!isNaN(date.getTime())) {
                const dateTimeLocal = date.toISOString().slice(0, 16);
                document.getElementById(`datetime_victim_${victimId}_${transactionId}`).value = dateTimeLocal;
                transaction.datetime = dateTimeLocal;
            } else {
                console.warn('Invalid date from transaction time:', txData.time);
                // Leave datetime empty for manual entry
            }
        } else {
            console.warn('No valid timestamp in transaction data');
            // Leave datetime empty for manual entry
        }
        
        // Set timezone to UTC
        document.getElementById(`timezone_victim_${victimId}_${transactionId}`).value = 'UTC';
        transaction.timezone = 'UTC';
        
        // Add note about the transaction
        const notesInput = document.querySelector(`input[onchange*="updateTransaction(${victimId}, ${transactionId}, 'notes'"]`);
        if (notesInput) {
            notesInput.value = `From: ${txData.from} | ${config.name} transaction`;
            transaction.notes = notesInput.value;
        }
        
        // Save and re-render
        saveToStorage();
        renderVictims();
        
        const timeString = txData.time && !isNaN(txData.time) ? 
            `\nTime: ${new Date(txData.time).toLocaleString()} UTC` : 
            '\nTime: Not available (please enter manually)';
        
        let alertMessage = `✅ Transaction data retrieved successfully!\n\nAmount: ${txData.amount} ${txData.currency}\nFrom: ${txData.from}\nTo (RED Wallet): ${txData.to}${timeString}`;
        
        if (txData.hasRealTimestamp === false) {
            alertMessage += '\n\n⚠️ WARNING: Could not retrieve actual transaction timestamp. Current time was used. Please manually update the date/time field!';
        }
        
        alert(alertMessage);
        
    } catch (error) {
        console.error('Lookup error:', error);
        const errorMsg = error.message || 'Failed to fetch transaction';

        // Check if user entered an address instead of a transaction hash
        if (txHash.startsWith('0x') && txHash.length === 42) {
            alert(`❌ Invalid Input: Wallet Address Detected\n\n` +
                  `You entered a wallet address, not a transaction hash.\n\n` +
                  `What you entered: ${txHash}\n` +
                  `This is a wallet address (42 characters)\n\n` +
                  `What's needed: A transaction hash (66 characters)\n` +
                  `Example: 0x1234...abcd (64 hex characters after 0x)\n\n` +
                  `Please paste the transaction hash, not the wallet address.`);
        }
        // Check if this looks like an EVM transaction hash that failed
        else if (txHash.startsWith('0x') && txHash.length === 66) {
            // This is likely an EVM transaction hash
            const selectedChain = chainSelector && chainSelector.value ? chainSelector.value : null;

            if (!selectedChain || selectedChain === 'ethereum') {
                // User didn't manually select a chain or it defaulted to Ethereum
                alert(`❌ Transaction not found on Ethereum\n\n` +
                      `The transaction hash appears to be from an EVM-compatible blockchain.\n\n` +
                      `⚠️ IMPORTANT: All EVM chains use the same transaction format (0x followed by 64 characters), ` +
                      `so automatic chain detection cannot determine which specific EVM network to search.\n\n` +
                      `The system searched Ethereum by default. If your transaction is on a different EVM chain ` +
                      `(BSC, Polygon, Arbitrum, Base, etc.), please:\n\n` +
                      `1. Select the correct chain from the dropdown menu\n` +
                      `2. Try the lookup again\n\n` +
                      `Common EVM chains: Ethereum, BSC, Polygon, Arbitrum, Optimism, Base, Avalanche`);
            } else {
                // User selected a specific chain but it still failed
                alert(`❌ Transaction not found on ${selectedChain}\n\n` +
                      `The transaction was not found on the selected chain.\n\n` +
                      `Please verify:\n` +
                      `1. The transaction hash is correct\n` +
                      `2. You've selected the right EVM chain\n` +
                      `3. The transaction has been confirmed on-chain\n\n` +
                      `If unsure, check the source where you obtained this transaction hash ` +
                      `to confirm which blockchain network it's on.`);
            }
        } else if (errorMsg.includes('CORS') || errorMsg.includes('Failed to fetch')) {
            alert(`ERROR:  ${errorMsg}\n\nThe app will retry automatically with different methods.`);
        } else {
            alert(`ERROR:  Failed to fetch transaction: ${errorMsg}`);
        }
    } finally {
        lookupBtn.textContent = originalText;
        lookupBtn.disabled = false;
    }
}
        // Transfer Selection Modal Functions
        function showTransferSelectionModal(transfers) {
            const modal = document.getElementById('transferSelectionModal');
            const transfersList = document.getElementById('transfersList');
            
            // Store transfers globally for filtering
            window.allTransfers = transfers;
            window.filteredTransfers = transfers;
            
            // Populate asset filter dropdown
            const assetFilter = document.getElementById('transferAssetFilter');
            assetFilter.innerHTML = '<option value="">All Assets</option>';
            
            // Get unique assets
            const uniqueAssets = [...new Set(transfers.map(t => t.currency))].sort();
            uniqueAssets.forEach(asset => {
                const option = document.createElement('option');
                option.value = asset;
                option.textContent = asset;
                assetFilter.appendChild(option);
            });
            
            // Clear filters
            document.getElementById('transferAmountFilter').value = '';
            document.getElementById('transferAddressFilter').value = '';
            assetFilter.value = '';
            
            // Render transfers
            renderTransferCards(transfers);
            
            // Update filter info
            updateFilterInfo(transfers.length, transfers.length);
            
            // Show the modal
            modal.classList.add('show');
        }
        
        function renderTransferCards(transfers) {
            const transfersList = document.getElementById('transfersList');
            transfersList.innerHTML = '';
            
            if (transfers.length === 0) {
                transfersList.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;">No transfers match your filters</div>';
                return;
            }
            
            transfers.forEach((transfer, index) => {
                // Find the original index for correct selection
                const originalIndex = window.allTransfers.indexOf(transfer);
                
                const transferCard = document.createElement('div');
                transferCard.className = 'transfer-card';
                transferCard.style.cssText = `
                    background: white;
                    border: 2px solid #e8f0fe;
                    border-radius: 8px;
                    padding: 20px;
                    margin-bottom: 15px;
                    cursor: pointer;
                    transition: all 0.3s ease;
                `;
                
                transferCard.onmouseover = () => {
                    transferCard.style.borderColor = '#3498db';
                    transferCard.style.backgroundColor = '#f0f8ff';
                };
                
                transferCard.onmouseout = () => {
                    transferCard.style.borderColor = '#e8f0fe';
                    transferCard.style.backgroundColor = 'white';
                };
                
                transferCard.innerHTML = `
                    <div style="display: grid; grid-template-columns: 1fr auto; gap: 15px; align-items: start;">
                        <div>
                            <h4 style="margin: 0 0 10px 0; color: #2c3e50;">
                                Transfer ${originalIndex + 1}: <span style="color: #3498db; font-weight: 600;">${formatNumber(transfer.amount)}</span> <span style="color: #27ae60; font-weight: 600;">${transfer.currency}</span>
                            </h4>
                            <div style="font-size: 14px; color: #555;">
                                <div style="margin-bottom: 5px;">
                                    <strong>From:</strong> <span style="font-family: monospace;">${transfer.from}</span>
                                </div>
                                <div style="margin-bottom: 5px;">
                                    <strong>To:</strong> <span style="font-family: monospace;">${transfer.to}</span>
                                </div>
                                <div>
                                    <strong>Token Contract:</strong> <span style="font-family: monospace;">${transfer.contractAddress}</span>
                                </div>
                            </div>
                        </div>
                        <button class="btn btn-confirm" onclick="selectTransfer(${originalIndex})" style="margin-top: 0;">
                            Select This Transfer
                        </button>
                    </div>
                `;
                
                transfersList.appendChild(transferCard);
            });
        }
        
        function filterTransfers() {
            const assetFilter = document.getElementById('transferAssetFilter').value;
            const amountFilter = document.getElementById('transferAmountFilter').value.trim();
            const addressFilter = document.getElementById('transferAddressFilter').value.trim().toLowerCase();
            
            window.filteredTransfers = window.allTransfers.filter(transfer => {
                // Asset filter
                if (assetFilter && transfer.currency !== assetFilter) {
                    return false;
                }
                
                // Amount filter
                if (amountFilter) {
                    const filterAmount = parseFloat(amountFilter);
                    if (!isNaN(filterAmount)) {
                        // Allow for slight variations due to decimal precision
                        if (Math.abs(transfer.amount - filterAmount) > 0.000001) {
                            return false;
                        }
                    }
                }
                
                // Address filter (check both from and to)
                if (addressFilter) {
                    const fromMatch = transfer.from.toLowerCase().includes(addressFilter);
                    const toMatch = transfer.to.toLowerCase().includes(addressFilter);
                    if (!fromMatch && !toMatch) {
                        return false;
                    }
                }
                
                return true;
            });
            
            // Re-render filtered transfers
            renderTransferCards(window.filteredTransfers);
            
            // Update filter info
            updateFilterInfo(window.filteredTransfers.length, window.allTransfers.length);
        }
        
        function clearTransferFilters() {
            document.getElementById('transferAssetFilter').value = '';
            document.getElementById('transferAmountFilter').value = '';
            document.getElementById('transferAddressFilter').value = '';
            window.filteredTransfers = window.allTransfers;
            renderTransferCards(window.allTransfers);
            updateFilterInfo(window.allTransfers.length, window.allTransfers.length);
        }
        
        function updateFilterInfo(shown, total) {
            const infoDiv = document.getElementById('filterResultsInfo');
            if (shown === total) {
                infoDiv.textContent = `Showing all ${total} transfers`;
            } else {
                infoDiv.textContent = `Showing ${shown} of ${total} transfers`;
            }
        }
        
        function closeTransferSelectionModal() {
            const modal = document.getElementById('transferSelectionModal');
            modal.classList.remove('show');
            
            // Clear pending data
            pendingTransfers = null;
            pendingTransferCallback = null;
        }
        
        function selectTransfer(index) {
            if (!window.allTransfers || !pendingTransferCallback) {
                console.error('No pending transfer data');
                return;
            }
            
            const selectedTransfer = window.allTransfers[index];
            
            // Store the callback before closing modal (which clears it)
            const callback = pendingTransferCallback;
            
            // Close the modal
            closeTransferSelectionModal();
            
            // Execute the callback with the selected transfer
            callback(selectedTransfer);
        }
        
        function applyTransferToVictim(victimId, transactionId, transfer, txHash, timestamp, hasRealTimestamp) {
            console.log('Applying transfer to victim:', { victimId, transactionId, transfer, txHash });
            
            // Ensure transfer data is valid
            if (!transfer || !transfer.amount || !transfer.to) {
                console.error('Invalid transfer data:', transfer);
                alert('Error: Invalid transfer data received');
                return;
            }
            
            const victim = investigation.victims.find(v => v.id === victimId);
            if (!victim) {
                console.error('Victim not found:', victimId);
                alert('Error: Victim not found');
                return;
            }
            
            const transaction = victim.transactions.find(t => t.id === transactionId);
            if (!transaction) {
                console.error('Transaction not found:', transactionId);
                alert('Error: Transaction not found');
                return;
            }
            
            // Update transaction hash first
            const txHashField = document.getElementById(`txHash_victim_${victimId}_${transactionId}`);
            if (txHashField && txHash) {
                txHashField.value = txHash;
                transaction.txHash = txHash;
            }
            
            // Update amount
            const amountInput = document.getElementById(`amount_victim_${victimId}_${transactionId}`);
            if (amountInput) {
                amountInput.value = transfer.amount;
                transaction.amount = transfer.amount.toString();
            } else {
                console.error('Amount input not found:', `amount_victim_${victimId}_${transactionId}`);
            }
            
            // Update currency
            const currencySelect = document.getElementById(`currency_victim_${victimId}_${transactionId}`);
            if (!currencySelect) {
                console.error('Currency select not found:', `currency_victim_${victimId}_${transactionId}`);
            } else {
                // If the currency doesn't exist in the select, add it
                const optionExists = Array.from(currencySelect.options).some(opt => opt.value === transfer.currency);
                if (!optionExists && transfer.currency !== 'CUSTOM') {
                    const newOption = document.createElement('option');
                    newOption.value = transfer.currency;
                    newOption.textContent = transfer.currency;
                    currencySelect.appendChild(newOption);
                }
                
                currencySelect.value = transfer.currency;
                transaction.currency = transfer.currency;
            }
            
            // Update receiving wallet (the "to" address is the RED wallet)
            const receivingWalletInput = document.getElementById(`receivingWallet_victim_${victimId}_${transactionId}`);
            if (receivingWalletInput) {
                receivingWalletInput.value = transfer.to;
                transaction.receivingWallet = transfer.to;
            } else {
                console.error('Receiving wallet input not found');
            }

            // Store the detected chain if available
            if (transfer.chain) {
                const chainSelector = document.getElementById(`chain_victim_${victimId}_${transactionId}`);
                if (chainSelector) {
                    chainSelector.value = transfer.chain;
                    transaction.chain = transfer.chain;
                    console.log(`Stored chain '${transfer.chain}' for V${victimId}-T${transactionId} from transfer`);
                }
            }
            
            // Update datetime with transaction timestamp if available
            if (timestamp && !isNaN(timestamp)) {
                const date = new Date(timestamp);
                if (!isNaN(date.getTime())) {
                    const dateTimeLocal = date.toISOString().slice(0, 16);
                    const datetimeInput = document.getElementById(`datetime_victim_${victimId}_${transactionId}`);
                    if (datetimeInput) {
                        datetimeInput.value = dateTimeLocal;
                        transaction.datetime = dateTimeLocal;
                        console.log(`Set transaction datetime to: ${dateTimeLocal}`);
                    }
                    
                    // Show warning if this is not a real timestamp
                    if (!hasRealTimestamp) {
                        setTimeout(() => {
                            alert('⚠️ Transaction timestamp could not be retrieved from the blockchain.\n\nCurrent time has been used as a placeholder.\n\nPlease manually update the date/time field with the correct transaction time.');
                        }, 100);
                    }
                } else {
                    console.warn('Invalid timestamp provided:', timestamp);
                }
            } else {
                console.warn('No timestamp provided for transfer');
                setTimeout(() => {
                    alert('⚠️ No timestamp available for this transaction.\n\nPlease manually enter the date/time.');
                }, 100);
            }
            
            // Set timezone to UTC
            const timezoneSelect = document.getElementById(`timezone_victim_${victimId}_${transactionId}`);
            if (timezoneSelect) {
                timezoneSelect.value = 'UTC';
                transaction.timezone = 'UTC';
            }
            
            // Add note about the transaction
            const notesInput = document.querySelector(`input[onchange*="updateTransaction(${victimId}, ${transactionId}, 'notes'"]`);
            if (notesInput) {
                // Create appropriate note based on currency type
                if (transfer.currency === 'BTC') {
                    notesInput.value = `From: ${transfer.from} | Bitcoin transfer${transfer.outputIndex !== undefined ? ` | Output #${transfer.outputIndex}` : ''}`;
                } else if (transfer.contractAddress) {
                    notesInput.value = `From: ${transfer.from} | ${transfer.currency} token transfer | Contract: ${transfer.contractAddress}`;
                } else {
                    notesInput.value = `From: ${transfer.from} | ${transfer.currency} transfer`;
                }
                transaction.notes = notesInput.value;
            }
            
            // Store the transaction hash
            transaction.txHash = txHash;
            
            // Also update the transaction hash input field
            const txHashElem = document.getElementById(`txHash_victim_${victimId}_${transactionId}`);
            if (txHashElem) {
                txHashElem.value = txHash;
            }
            
            // Save to storage
            saveToStorage();
            
            // Update the workflow steps to reflect progress
            updateWorkflowSteps();
            
            // Show success message
            let alertMessage = `✅ Transaction data retrieved successfully!

Amount: ${formatNumber(transfer.amount)} ${transfer.currency}
From: ${transfer.from}
To (RED Wallet): ${transfer.to}`;
            
            if (!hasRealTimestamp) {
                alertMessage += '\n\n⚠️ WARNING: Could not retrieve actual transaction timestamp. Current time was used. Please manually update the date/time field!';
            }
            
            alert(alertMessage);

            // Log for debugging
            console.log('Transfer applied successfully:', {
                victimId,
                transactionId,
                amount: transfer.amount,
                currency: transfer.currency,
                to: transfer.to
            });

            // Update UI to reflect the changes
            saveToStorage();
            renderVictims();
            updateValidationStatus();
            updateWorkflowSteps();
            updateGenerateRootSection();
        }
        
        // Entity Detection Functions
        async function detectWalletEntity(address, blockchain) {
            const config = blockchainAPIs[blockchain];
            if (!config) return null;
            
            const corsEnabled = localStorage.getItem('bats_cors_proxy_enabled') === 'true';
            const corsProxyUrl = localStorage.getItem('bats_cors_proxy_url') || 'https://cors-anywhere.herokuapp.com/';
            
            try {
                if (blockchain === 'bitcoin' && config.entityApiUrl) {
                    // WalletExplorer API for Bitcoin
                    let url = config.entityApiUrl + address;
                    if (corsEnabled) url = corsProxyUrl + url;
                    
                    const response = await fetch(url);
                    if (response.ok) {
                        const data = await response.json();
                        if (data && data.label && data.label !== 'Unknown') {
                            return {
                                entity: data.label,
                                category: data.category || 'Exchange/Service',
                                confidence: 'high',
                                source: 'WalletExplorer'
                            };
                        }
                    }
                } else if (blockchain === 'ethereum' && config.labelApiUrl) {
                    // Etherscan labels API
                    const apiKey = localStorage.getItem('bats_etherscan_api_key') || config.apiKey || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8';
                    let url = `${config.labelApiUrl}${address}&apikey=${apiKey}`;
                    if (corsEnabled) url = corsProxyUrl + url;
                    
                    const response = await fetch(url);
                    if (response.ok) {
                        const data = await response.json();
                        if (data.status === '1' && data.result) {
                            // Check for name tag (exchange/service label)
                            if (data.result.length > 0) {
                                const labelInfo = data.result[0];
                                if (labelInfo.nameTag && labelInfo.nameTag !== '') {
                                    return {
                                        entity: labelInfo.nameTag,
                                        category: 'Exchange/Service',
                                        confidence: 'high',
                                        source: 'Etherscan'
                                    };
                                }
                            }
                        }
                    }
                }
                
                // Check against known exchange patterns
                const knownPatterns = checkKnownExchangePatterns(address, blockchain);
                if (knownPatterns) {
                    return knownPatterns;
                }
                
            } catch (error) {
                console.error('Entity detection error:', error);
            }
            
            return null;
        }
        
        function checkKnownExchangePatterns(address, blockchain) {
            // Common exchange address patterns and known addresses
            const knownExchanges = {
                bitcoin: {
                    // Binance cold wallets often start with bc1q
                    patterns: [
                        { prefix: '3BMEX', entity: 'BitMEX', category: 'Exchange' },
                        { prefix: '3JZq4atUahhuA9rLhX', entity: 'Bitfinex', category: 'Exchange' },
                        { prefix: '1NDyJtNTjmwk5xPNhjgAMu4HDHigtobu1s', entity: 'Binance', category: 'Exchange' }
                    ],
                    addresses: {
                        '1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa': { entity: 'Genesis Block', category: 'Historical' },
                        '12cgpFdJViXbwHbhrA3TuW1EGnL25Zqc3P': { entity: 'Binance Cold Wallet', category: 'Exchange' }
                    }
                },
                ethereum: {
                    addresses: {
                        '0x3f5ce5fbfe3e9af3971dd833d26ba9b5c936f0be': { entity: 'Binance', category: 'Exchange' },
                        '0xd551234ae421e3bcba99a0da6d736074f22192ff': { entity: 'Binance 2', category: 'Exchange' },
                        '0x564286362092d8e7936f0549571a803b203aaced': { entity: 'Binance 3', category: 'Exchange' },
                        '0x28c6c06298d514db089934071355e5743bf21d60': { entity: 'Binance 14', category: 'Exchange' },
                        '0x21a31ee1afc51d94c2efccaa2092ad1028285549': { entity: 'Binance 15', category: 'Exchange' },
                        '0xdfd5293d8e347dfe59e90efd55b2956a1343963d': { entity: 'Binance 16', category: 'Exchange' },
                        '0x56eddb7aa87536c09ccc2793473599fd21a8b17f': { entity: 'Binance 17', category: 'Exchange' },
                        '0x9696f59e4d72e237be84ffd425dcad154bf96976': { entity: 'Binance 18', category: 'Exchange' },
                        '0x4e9ce36e442e55ecd9025b9a6e0d88485d628a67': { entity: 'Binance US', category: 'Exchange' },
                        '0xbe0eb53f46cd790cd13851d5eff43d12404d33e8': { entity: 'Binance 7', category: 'Exchange' },
                        '0x876eabf441b2ee5b5b0554fd502a8e0600950cfa': { entity: 'Bitfinex', category: 'Exchange' },
                        '0xc6bed363b30df7f35b601a5547fe56cd31ec63da': { entity: 'Bitfinex 2', category: 'Exchange' },
                        '0x29728d0efd284d85187362faa2d4d76c2cfc2612': { entity: 'Bitfinex 3', category: 'Exchange' },
                        '0xe92d1a43df510f82c66382592a047d288f85226f': { entity: 'Bitfinex 4', category: 'Exchange' },
                        '0x8103683202aa8da10536036edef04cdd865c225e': { entity: 'Bitfinex 5', category: 'Exchange' },
                        '0xab7c74abc0c4d48d1bdad5dcb26153fc8780f83e': { entity: 'Bitfinex MultiSig', category: 'Exchange' },
                        '0x6262998ced04146fa42253a5c0af90ca02dfd2a3': { entity: 'Crypto.com', category: 'Exchange' },
                        '0x46340b20830761efd32832a74d7169b29feb9758': { entity: 'Crypto.com 2', category: 'Exchange' },
                        '0x71660c4005ba85c37ccec55d0c4493e66fe775d3': { entity: 'Coinbase 1', category: 'Exchange' },
                        '0x503828976d22510aad0201ac7ec88293211d23da': { entity: 'Coinbase 2', category: 'Exchange' },
                        '0xddfabcdc4d8ffc6d5beaf154f18b778f892a0740': { entity: 'Coinbase 3', category: 'Exchange' },
                        '0x3cd751e6b0078be393132286c442345e5dc49699': { entity: 'Coinbase 4', category: 'Exchange' },
                        '0xb5d85cbf7cb3ee0d56b3bb207d5fc4b82f43f511': { entity: 'Coinbase 5', category: 'Exchange' },
                        '0xeb2629a2734e272bcc07bda959863f316f4bd4cf': { entity: 'Coinbase 6', category: 'Exchange' },
                        '0xa090e606e30bd747d4e6245a1517ebe430f0057e': { entity: 'Coinbase Miscellaneous', category: 'Exchange' },
                        '0x6cc5f688a315f3dc28a7781717a9a798a59fda7b': { entity: 'OKEx', category: 'Exchange' },
                        '0x236f9f97e0e62388479bf9e5ba4889e46b0273c3': { entity: 'OKEx 2', category: 'Exchange' },
                        '0xa7efae728d2936e78bda97dc267687568dd593f3': { entity: 'OKEx 3', category: 'Exchange' },
                        '0x2c8fbb630289363ac80705a1a61273f76fd5a161': { entity: 'Poloniex', category: 'Exchange' },
                        '0x32be343b94f860124dc4fee278fdcbd38c102d88': { entity: 'Poloniex', category: 'Exchange' },
                        '0x209c4784ab1e8183cf58ca33cb740efbf3fc18ef': { entity: 'Poloniex 2', category: 'Exchange' },
                        '0xb794f5ea0ba39494ce839613fffba74279579268': { entity: 'Poloniex 3', category: 'Exchange' },
                        '0x0a869d79a7052c7f1b55a8ebabbea3420f0d1e13': { entity: 'KuCoin', category: 'Exchange' },
                        '0x2b5634c42055806a59e9107ed44d43c426e58258': { entity: 'KuCoin 2', category: 'Exchange' },
                        '0x689c56aef474df92d44a1b70850f808488f9769c': { entity: 'KuCoin 3', category: 'Exchange' },
                        '0xa1d8d972560c2f8144af871db508f0b0b10a3fbf': { entity: 'KuCoin 4', category: 'Exchange' },
                        '0x4ad64983349c49defe8d7a4686202d24b25d0ce8': { entity: 'KuCoin 5', category: 'Exchange' },
                        '0x1692e170361cefd1eb7240ec13d048fd9af6d667': { entity: 'KuCoin 6', category: 'Exchange' },
                        '0xd6216fc19db775df9774a6e33526131da7d19a2c': { entity: 'KuCoin 7', category: 'Exchange' },
                        '0xe59cd29be3be4461d79c0881d238cbe87d64595a': { entity: 'Kraken', category: 'Exchange' },
                        '0x43984d578803891dfa9706bdeee6078d80cfc79e': { entity: 'Kraken 2', category: 'Exchange' },
                        '0x66c57bf505a85a74609d2c83e94aabb26d691e41': { entity: 'Kraken 3', category: 'Exchange' },
                        '0xda9dfa130df4de4673b89022ee50ff26f6ea73cf': { entity: 'Kraken 4', category: 'Exchange' },
                        '0xa83b11093c858c86321fbc4c20fe82cdbd58e09e': { entity: 'Kraken 5', category: 'Exchange' },
                        '0x0a98fb70939162725ae66e626fe4b52cff62c2e5': { entity: 'Gate.io', category: 'Exchange' },
                        '0xf56e08ee4e8ac390c28bba0431c22e6c1cb54529': { entity: 'Gate.io 2', category: 'Exchange' },
                        '0x7793cd85c11a924478d358d49b05b37e91b5810f': { entity: 'Gate.io 3', category: 'Exchange' },
                        '0x1c4b70a3968436b9a0a9cf5205c787eb81bb558c': { entity: 'Gate.io 4', category: 'Exchange' },
                        '0xd793281182a0e3e023116004778f45c29fc14f19': { entity: 'Gate.io 5', category: 'Exchange' },
                        '0x9f5ca0012b9b72e8f3db57092a6f26bf4f13dc69': { entity: 'Gate.io 6', category: 'Exchange' },
                        '0xc882b111a75c0c657fc507c04fbfcd2cc984f071': { entity: 'Gate.io 7', category: 'Exchange' }
                    }
                }
            };
            
            const lowerAddress = address.toLowerCase();
            
            // Check exact matches
            if (knownExchanges[blockchain] && knownExchanges[blockchain].addresses) {
                const match = knownExchanges[blockchain].addresses[lowerAddress];
                if (match) {
                    return {
                        entity: match.entity,
                        category: match.category,
                        confidence: 'high',
                        source: 'Known Address Database'
                    };
                }
            }
            
            // Check patterns
            if (knownExchanges[blockchain] && knownExchanges[blockchain].patterns) {
                for (const pattern of knownExchanges[blockchain].patterns) {
                    if (address.startsWith(pattern.prefix)) {
                        return {
                            entity: pattern.entity,
                            category: pattern.category,
                            confidence: 'medium',
                            source: 'Address Pattern Match'
                        };
                    }
                }
            }
            
            return null;
        }
        
        // Update wallet classification based on entity
        function updateWalletClassificationFromEntity(entityData, walletType) {
            if (!entityData) return walletType;
            
            // If it's an exchange, mark as purple
            if (entityData.category === 'Exchange' || entityData.category === 'Exchange/Service') {
                return 'purple';
            }
            
            // Keep original classification if no exchange detected
            return walletType;
        }
        
        // Check wallet entity when address is entered
        async function checkWalletEntity(address, hopNumber, entryId) {
            if (!address || address.trim() === '') return;
            
            // Detect blockchain from address
            let detectedBlockchain = null;
            for (const [blockchain, config] of Object.entries(blockchainAPIs)) {
                if (config.addressPattern && config.addressPattern.test(address)) {
                    detectedBlockchain = blockchain;
                    break;
                }
            }
            
            if (!detectedBlockchain) return;
            
            // Show loading state
            const entityInfoDiv = document.getElementById(`entityInfo_${hopNumber}_${entryId}`);
            if (entityInfoDiv) {
                entityInfoDiv.style.display = 'block';
                entityInfoDiv.innerHTML = '<div style="text-align: center;">🔍 Checking wallet entity...</div>';
            }
            
            try {
                const entityData = await detectWalletEntity(address, detectedBlockchain);
                
                if (entityData) {
                    // Display entity information
                    if (entityInfoDiv) {
                        entityInfoDiv.innerHTML = `
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <strong>🏢 Entity Detected:</strong> ${entityData.entity}<br>
                                    <small>Category: ${entityData.category} | Confidence: ${entityData.confidence} | Source: ${entityData.source}</small>
                                </div>
                                <div>
                                    ${entityData.category === 'Exchange' || entityData.category === 'Exchange/Service' ? 
                                        '<span style="background: #9b59b6; color: white; padding: 4px 12px; border-radius: 4px; font-weight: bold;">PURPLE</span>' : 
                                        ''}
                                </div>
                            </div>
                        `;
                        
                        // Auto-update wallet type if it's an exchange
                        if (entityData.category === 'Exchange' || entityData.category === 'Exchange/Service') {
                            const walletTypeSelect = document.querySelector(`select[onchange*="updateHopEntryWalletType(${hopNumber}, ${entryId}"]`);
                            if (walletTypeSelect && walletTypeSelect.value !== 'purple') {
                                walletTypeSelect.value = 'purple';
                                updateHopEntryWalletType(hopNumber, entryId, 'purple');
                                
                                // Add note about auto-classification
                                entityInfoDiv.innerHTML += `
                                    <div style="margin-top: 10px; padding: 8px; background: rgba(255,255,255,0.5); border-radius: 4px; font-size: 12px;">
                                        ✅ Wallet automatically classified as PURPLE (Exchange)
                                    </div>
                                `;
                                
                                // Show terminal wallet notification
                                showTerminalWalletNotification(entityData, address, hopNumber, entryId);
                            }
                        }
                    }
                } else {
                    // No entity found
                    if (entityInfoDiv) {
                        entityInfoDiv.style.display = 'none';
                    }
                }
            } catch (error) {
                console.error('Entity detection error:', error);
                if (entityInfoDiv) {
                    entityInfoDiv.style.display = 'none';
                }
            }
        }
        
        // File system save functionality
        async function saveAndCaptureFilePath() {
            try {
                // Check if File System Access API is available
                if ('showSaveFilePicker' in window) {
                    const options = {
                        types: [{
                            description: 'BATS Investigation Files',
                            accept: { 'application/json': ['.bats'] }
                        }],
                        suggestedName: `BATS_${investigation.caseId || 'Investigation'}_${new Date().toISOString().split('T')[0]}.bats`
                    };
                    
                    // Show save file picker
                    fileHandle = await window.showSaveFilePicker(options);
                    
                    // Create the file content
                    const fileData = JSON.stringify(investigation, null, 2);
                    
                    // Write the file
                    const writable = await fileHandle.createWritable();
                    await writable.write(fileData);
                    await writable.close();
                    
                    // Capture file path info
                    savedFilePath = fileHandle.name;
                    isFileSystemAvailable = true;
                    
                    // Update UI
                    document.getElementById('saveRequiredMessage').style.display = 'none';
                    document.getElementById('generateRootBtn').style.display = 'block';
                    
                    alert(` Investigation saved successfully!\n\nFile: ${savedFilePath}\nLocation: ${fileHandle.name}\n\nAutomatic saving is now enabled!\nYour investigation will be automatically saved to this location after each hop.`);
                    
                } else {
                    // Fallback to regular download
                    const fileData = JSON.stringify(investigation, null, 2);
                    const filename = `BATS_${investigation.caseId || 'Investigation'}_${new Date().toISOString().split('T')[0]}.bats`;
                    
                    const blob = new Blob([fileData], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    // Mark as saved (but without autosave capability)
                    savedFilePath = filename;
                    isFileSystemAvailable = false;
                    
                    // Update UI
                    document.getElementById('saveRequiredMessage').style.display = 'none';
                    document.getElementById('generateRootBtn').style.display = 'block';
                    
                    let helpText = `✅ Investigation saved to Downloads folder!\n\nFile: ${filename}\n\n⚠️ Browser Limitation: `;
                    
                    if (window.location.protocol === 'file:') {
                        helpText += `You're running this tool from a local file (file://), which limits some features.\n\nFor full functionality including custom save locations:\n• Host on a local server (e.g., python -m http.server)\n• Use a tool like Live Server in VS Code\n• Upload to a web server with HTTPS\n• Or continue with manual saves to Downloads folder`;
                    } else {
                        helpText += `Your browser doesn't support the File System API.\n\nFor custom save locations, use:\n• Chrome 86+ or Edge 86+ (Chromium-based)\n• Opera 72+\n• Make sure you're on HTTPS`;
                    }
                    
                    alert(helpText);
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    // User cancelled the save dialog
                    return;
                }
                console.error('Save error:', error);
                alert('ERROR:  Error saving file: ' + error.message);
            }
        }
        
        // Autosave function for hops
        async function autosaveInvestigation() {
            if (!isFileSystemAvailable || !fileHandle) {
                console.log('Autosave not available - no file handle');
                return;
            }
            
            try {
                const fileData = JSON.stringify(investigation, null, 2);
                const writable = await fileHandle.createWritable();
                await writable.write(fileData);
                await writable.close();
                
                // Show subtle save indicator
                showAutosaveIndicator();
                
            } catch (error) {
                console.error('Autosave error:', error);
                // Don't alert on every autosave failure, just log it
            }
        }
        
        function showAutosaveIndicator() {
            // Create or update autosave indicator
            let indicator = document.getElementById('autosaveIndicator');
            if (!indicator) {
                indicator = document.createElement('div');
                indicator.id = 'autosaveIndicator';
                indicator.style.cssText = `
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    background: #27ae60;
                    color: white;
                    padding: 10px 20px;
                    border-radius: 20px;
                    font-size: 14px;
                    z-index: 1000;
                    opacity: 0;
                    transition: opacity 0.3s ease;
                    pointer-events: none;
                `;
                document.body.appendChild(indicator);
            }
            
            indicator.textContent = '✓ Autosaved';
            indicator.style.opacity = '1';
            
            setTimeout(() => {
                indicator.style.opacity = '0';
            }, 2000);
        }

        // Helper function for proper decimal rounding to avoid floating point errors
        function roundAmount(amount, decimals = 8) {
            // Round to 8 decimal places by default - important for high value crypto
            // where even small decimals can represent significant value
            const factor = Math.pow(10, decimals);
            return Math.round((amount + Number.EPSILON) * factor) / factor;
        }

        // Comprehensive list of known exchange and service indicators
        function getExchangeIndicators() {
            return {
                exchanges: [
                    // Major CEXs
                    'binance', 'coinbase', 'kraken', 'crypto.com', 'kucoin', 'okx', 'okex',
                    'huobi', 'bitfinex', 'bitstamp', 'gemini', 'ftx', 'gate.io', 'mexc',
                    'bybit', 'bitget', 'bitmart', 'probit', 'lbank', 'xt.com', 'bingx',
                    'poloniex', 'upbit', 'bithumb', 'coinone', 'korbit', 'bitflyer',
                    'liquid', 'bitbank', 'zaif', 'btcbox', 'hotbit', 'ascendex', 'bitmax',
                    'phemex', 'deribit', 'bitmex', 'bittrex', 'hitbtc', 'whitebit',
                    'coinsbit', 'p2pb2b', 'latoken', 'vindax', 'digifinex', 'bigone',
                    'indodax', 'wazirx', 'coindcx', 'zebpay', 'btc-alpha', 'cex.io',
                    'exmo', 'yobit', 'cryptopia', 'mercatox', 'bleutrade', 'c-cex',
                    'nova exchange', 'trade satoshi', 'stocks.exchange', 'crex24',
                    'stex', 'finexbox', 'graviex', 'coineal', 'biki', 'mxc', 'bhex',
                    'hoo', 'bibox', 'bit-z', 'coinbene', 'zbg', 'coinw', 'bw.com',
                    'oceanex', 'vcc', 'coinex', 'catex', 'bitforex', 'fcoin', 'coinall',
                    'b2bx', 'rightbtc', 'cobinhood', 'kuna', 'tidex', 'blokmy',
                    'tokenomy', 'bitso', 'volabit', 'bitflip', 'kriptomat', 'paymium',
                    'therocktrading', 'bit2me', 'bitvavo', 'bl3p', 'btcdirect', 'litebit',
                    'anycoin', 'coinmama', 'coinhouse', 'paybis', 'bitpanda', 'bitbay',
                    'zonda', 'coinfinity', 'coinfinity', 'bitcoin.de', 'bitkub', 'satang',
                    'zipmex', 'tokocrypto', 'pintu', 'rekeningku', 'triv', 'uphold',
                    'voyager', 'blockfi', 'celsius', 'nexo', 'crypto.com app', 'swissborg',
                    'youhodler', 'blockchain.com', 'exodus', 'atomic wallet', 'trust wallet',
                    'abra', 'edge', 'breadwallet', 'bitcoin.com', 'paxful', 'localbitcoins',
                    'bisq', 'hodlhodl', 'agoradesk', 'robosats', 'peachbitcoin'
                ],
                dexBridges: [
                    // DEXs and Bridges
                    'uniswap', 'sushiswap', 'pancakeswap', '1inch', 'curve', 'balancer',
                    'quickswap', 'spookyswap', 'spiritswap', 'traderjoe', 'raydium',
                    'orca', 'serum', 'osmosis', 'thorchain', 'anyswap', 'multichain',
                    'synapse', 'stargate', 'hop protocol', 'across', 'celer', 'connext',
                    'nomad', 'wormhole', 'portal', 'allbridge', 'chainport', 'poly network',
                    'ren', 'badger', 'thorswap', 'maya protocol', 'chainflip', 'squid',
                    'axelar', 'layerzero', 'debridge', 'li.fi', 'socket', 'bungee',
                    'rango', 'xy finance', 'o3swap', 'rubic', 'paraswap', 'matcha',
                    'cowswap', 'kyberswap', '0x', 'airswap', 'tokenlon', 'dodo',
                    'bancor', 'kyber', 'loopring', 'idex', 'ddex', 'radar relay',
                    'paradex', 'etherdelta', 'forkdelta', 'token store', 'oasis',
                    'deversifi', 'nash', 'dydx', 'perpetual protocol', 'gmx', 'gains',
                    'kwenta', 'polynomial', 'lyra', 'hegic', 'opyn', 'ribbon',
                    'friktion', 'katana', 'zeta', 'drift', 'mango', 'jupiter', 'gluex',
                    'gluexrouter', 'meteora', 'lifinity', 'phoenixdex', 'fluxbeam'
                ],
                keywords: [
                    // General keywords
                    'deposit', 'withdrawal', 'hot wallet', 'cold wallet', 'cold storage',
                    'exchange', 'cex', 'dex', 'swap', 'bridge', 'cross-chain',
                    'liquidity pool', 'lp', 'amm', 'automated market maker',
                    'treasury', 'reserve', 'custodial', 'custody', 'escrow',
                    'otc', 'over the counter', 'desk', 'market maker', 'mm'
                ],
                services: [
                    // Other services
                    'tornado cash', 'tornado', 'mixer', 'tumbler', 'coinjoin',
                    'wasabi', 'samourai', 'blender', 'bitcoinfog', 'helix',
                    'chipmixer', 'bitcoin laundry', 'bitmix', 'cryptomixer',
                    'coinomize', 'anonymix', 'privcoin', 'bitcoin blender'
                ]
            };
        }

        // Check if a label suggests it might be an exchange/service
        function checkExchangeIndicators(labelName) {
            if (!labelName) return { isLikely: false, confidence: 0, matches: [] };

            const indicators = getExchangeIndicators();
            const labelLower = labelName.toLowerCase();
            const matches = [];
            let confidence = 0;

            // Check exact exchange matches
            for (const exchange of indicators.exchanges) {
                if (labelLower.includes(exchange)) {
                    matches.push({ type: 'CEX', name: exchange, confidence: 90 });
                    confidence = Math.max(confidence, 90);
                }
            }

            // Check DEX/Bridge matches
            for (const dex of indicators.dexBridges) {
                if (labelLower.includes(dex)) {
                    matches.push({ type: 'DEX/Bridge', name: dex, confidence: 85 });
                    confidence = Math.max(confidence, 85);
                }
            }

            // Check keyword matches
            for (const keyword of indicators.keywords) {
                if (labelLower.includes(keyword)) {
                    matches.push({ type: 'Keyword', name: keyword, confidence: 70 });
                    confidence = Math.max(confidence, 70);
                }
            }

            // Check mixer/tumbler services
            for (const service of indicators.services) {
                if (labelLower.includes(service)) {
                    matches.push({ type: 'Mixer', name: service, confidence: 95 });
                    confidence = Math.max(confidence, 95);
                }
            }

            return {
                isLikely: confidence >= 70,
                confidence: confidence,
                matches: matches,
                suggestedType: matches.length > 0 ? matches[0].type : null
            };
        }

        // General notification function
        function showNotification(message, type = 'info', duration = 3000) {
            let notification = document.getElementById('notification');
            if (!notification) {
                notification = document.createElement('div');
                notification.id = 'notification';
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    padding: 15px 25px;
                    border-radius: 8px;
                    font-size: 14px;
                    z-index: 10001;
                    opacity: 0;
                    transition: opacity 0.3s ease;
                    pointer-events: auto;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                    max-width: 400px;
                    word-wrap: break-word;
                `;
                document.body.appendChild(notification);
            }

            // Set color based on type
            const colors = {
                success: '#27ae60',
                error: '#e74c3c',
                warning: '#f39c12',
                info: '#3498db'
            };

            notification.style.background = colors[type] || colors.info;
            notification.style.color = 'white';
            notification.innerHTML = message; // Use innerHTML to support HTML content
            notification.style.opacity = '1';

            // Clear any existing timeout
            if (notification.hideTimeout) {
                clearTimeout(notification.hideTimeout);
            }

            notification.hideTimeout = setTimeout(() => {
                notification.style.opacity = '0';
            }, duration);
        }
        
        // Show terminal wallet notification
        function showTerminalWalletNotification(entityData, address, hopNumber, entryId) {
            // Create overlay
            const overlay = document.createElement('div');
            overlay.className = 'terminal-notification-overlay';
            overlay.onclick = () => closeTerminalNotification();
            
            // Create notification
            const notification = document.createElement('div');
            notification.className = 'terminal-notification';
            notification.innerHTML = `
                <div style="background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%); color: white; padding: 25px; border-radius: 12px 12px 0 0;">
                    <h2 style="margin: 0; font-size: 24px; display: flex; align-items: center; gap: 10px;">
                        VASP: Exchange Detected - Terminal Wallet
                    </h2>
                </div>
                
                <div style="padding: 30px;">
                    <div style="background: #f3e6ff; border: 2px solid #9b59b6; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
                        <h3 style="color: #9b59b6; margin: 0 0 10px 0;">${entityData.entity}</h3>
                        <p style="margin: 0; color: #555; font-size: 14px;">
                            <strong>Address:</strong> <code style="background: #fff; padding: 2px 6px; border-radius: 3px;">${address.substring(0, 20)}...${address.substring(address.length - 10)}</code><br>
                            <strong>Confidence:</strong> ${entityData.confidence.toUpperCase()}<br>
                            <strong>Source:</strong> ${entityData.source}
                        </p>
                    </div>
                    
                    <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
                        <h4 style="color: #856404; margin: 0 0 10px 0;">⚠️ Important: Terminal Wallet Considerations</h4>
                        <ul style="margin: 0; padding-left: 20px; color: #666;">
                            <li>This appears to be an <strong>exchange deposit address</strong></li>
                            <li>Funds sent here are typically <strong>commingled</strong> with other users' funds</li>
                            <li>You may need to <strong>serve legal process</strong> to the exchange for further tracing</li>
                            <li>Consider this a <strong>potential endpoint</strong> for this trace thread</li>
                        </ul>
                    </div>
                    
                    <div style="display: flex; gap: 15px; justify-content: center;">
                        <button class="btn btn-confirm" onclick="markAsTerminal(${hopNumber}, ${entryId})" style="background: #9b59b6; padding: 12px 30px; font-size: 16px;">
                            ✓ Mark as Terminal & Continue
                        </button>
                        <button class="btn btn-secondary" onclick="closeTerminalNotification()" style="padding: 12px 30px; font-size: 16px;">
                            Continue Tracing
                        </button>
                    </div>
                    
                    <p style="text-align: center; margin-top: 20px; color: #666; font-size: 12px;">
                        Tip: You can always change the classification later if needed
                    </p>
                </div>
            `;
            
            // Add to page
            document.body.appendChild(overlay);
            document.body.appendChild(notification);
        }
        
        function closeTerminalNotification() {
            const overlay = document.querySelector('.terminal-notification-overlay');
            const notification = document.querySelector('.terminal-notification');
            if (overlay) overlay.remove();
            if (notification) notification.remove();
        }
        
        function markAsTerminal(hopNumber, entryId) {
            // The wallet is already marked as purple, just close the notification
            closeTerminalNotification();
            
            // Optionally add a note about terminal status
            const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
            if (hop) {
                const entry = hop.entries.find(e => e.id === entryId);
                if (entry) {
                    const currentNotes = entry.notes || '';
                    const terminalNote = 'TERMINAL: Exchange deposit - may require legal process for further tracing';
                    if (!currentNotes.includes('TERMINAL')) {
                        entry.notes = currentNotes ? `${currentNotes} | ${terminalNote}` : terminalNote;
                        saveToStorage();
                        renderHops();
                    }
                }
            }
        }
        
        // Welcome Screen and Onboarding Functions
        function checkOnboardingState() {
            const hasBasicInfo = investigation.caseId || investigation.investigator || investigation.caseType;
            const hasVictims = investigation.victims && investigation.victims.length > 0;
            const allTabs = document.querySelectorAll('.tab-content');
            const navTabs = document.querySelectorAll('.nav-tab');

            // Update tab states based on progress
            if (hasBasicInfo || hasVictims) {
                updateTabStates();
            } else {
                // Disable tabs except victims when no data
                navTabs.forEach((tab, index) => {
                    // Skip home button (index 0) and victims tab
                    if (index > 1) {
                        tab.style.opacity = '0.5';
                        tab.style.cursor = 'not-allowed';
                        tab.onclick = (e) => {
                            e.preventDefault();
                            alert('Please complete the victim transactions first before accessing this section.');
                        };
                    }
                });
            }
        }
        
        function updateTabStates() {
            const navTabs = document.querySelectorAll('.nav-tab');
            const hasVictims = investigation.victims && investigation.victims.length > 0;
            const hasRootTotal = investigation.rootTotalConfirmed;
            const hasHops = investigation.hops && investigation.hops.length > 0;
            
            navTabs.forEach((tab, index) => {
                const tabText = tab.textContent;
                
                // Always enable victims tab
                if (tabText.includes('Victims')) {
                    tab.style.opacity = '1';
                    tab.style.cursor = 'pointer';
                    tab.onclick = () => switchTab('victims');
                }
                // Enable traces tab only after root total confirmed
                else if (tabText.includes('Trace')) {
                    if (hasRootTotal) {
                        tab.style.opacity = '1';
                        tab.style.cursor = 'pointer';
                        tab.onclick = () => switchTab('traces');
                    } else {
                        tab.style.opacity = '0.5';
                        tab.style.cursor = 'not-allowed';
                        tab.onclick = (e) => {
                            e.preventDefault();
                            alert('Please confirm your root total before starting trace documentation.');
                        };
                    }
                }
                // Enable wallet indexes after some traces
                else if (tabText.includes('Wallet')) {
                    if (hasHops) {
                        tab.style.opacity = '1';
                        tab.style.cursor = 'pointer';
                        tab.onclick = () => switchTab('walletindexes');
                    } else {
                        tab.style.opacity = '0.5';
                        tab.style.cursor = 'not-allowed';
                        tab.onclick = (e) => {
                            e.preventDefault();
                            alert('Start documenting traces to build wallet indexes.');
                        };
                    }
                }
                // Enable summary after traces
                else if (tabText.includes('Summary')) {
                    if (hasHops) {
                        tab.style.opacity = '1';
                        tab.style.cursor = 'pointer';
                        tab.onclick = () => switchTab('summary');
                    } else {
                        tab.style.opacity = '0.5';
                        tab.style.cursor = 'not-allowed';
                        tab.onclick = (e) => {
                            e.preventDefault();
                            alert('Complete some trace documentation before accessing the summary.');
                        };
                    }
                }
            });
        }
        
        // Flow Diagram Functions
        function generateFlowDiagram() {
            // Check if the enhanced flow diagram function exists
            if (typeof generateHopCentricDAG === 'function') {
                // Use the new enhanced DAG visualization
                generateHopCentricDAG(investigation);
                return;
            }

            // Fallback to simple visualization if enhanced version not loaded
            const svg = document.getElementById('flowDiagramSVG');
            svg.innerHTML = ''; // Clear existing content

            if (!investigation.hops || investigation.hops.length === 0) {
                svg.innerHTML = '<text x="50%" y="50%" text-anchor="middle" fill="#999">No trace data available</text>';
                return;
            }

            // Configuration
            const walletColumnWidth = 200;
            const hopLaneWidth = 250;
            const nodeRadius = 20;
            const verticalSpacing = 80;
            const topMargin = 60;
            const bottomMargin = 100;
            const leftMargin = 20;

            // Calculate dimensions
            const numHops = investigation.hops.length;
            const totalWidth = leftMargin + walletColumnWidth + (numHops * hopLaneWidth) + 50;

            // Calculate total height needed
            let yPosition = topMargin + 40; // Start position after titles
            const walletPositions = new Map();

            // Map all wallet positions
            investigation.victims.forEach((victim, idx) => {
                const walletId = `V${victim.id}`;
                walletPositions.set(walletId, yPosition);
                yPosition += verticalSpacing;
            });

            // Add spacing between victims and other wallets
            yPosition += 30;

            // Map all unique wallets from hops
            const processedWallets = new Set();
            investigation.hops.forEach(hop => {
                hop.entries.filter(e => !e.isWriteoff).forEach(entry => {
                    const walletKey = `${entry.toWallet}-${entry.toWalletType}`;
                    if (!processedWallets.has(walletKey)) {
                        processedWallets.add(walletKey);
                        walletPositions.set(walletKey, yPosition);
                        yPosition += verticalSpacing;
                    }
                });
            });

            const totalHeight = yPosition + bottomMargin;
            
            // Set SVG dimensions
            svg.setAttribute('width', totalWidth);
            svg.setAttribute('height', totalHeight);
            svg.setAttribute('viewBox', `0 0 ${totalWidth} ${totalHeight}`);
            
            // Draw hop lanes (colored backgrounds)
            for (let i = 0; i < numHops; i++) {
                const laneX = leftMargin + walletColumnWidth + (i * hopLaneWidth);
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', laneX);
                rect.setAttribute('y', 0);
                rect.setAttribute('width', hopLaneWidth);
                rect.setAttribute('height', totalHeight);
                rect.setAttribute('class', `flow-hop-lane flow-hop-lane-${(i % 5) + 1}`);
                svg.appendChild(rect);
                
                // Hop title
                const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                title.setAttribute('x', laneX + hopLaneWidth / 2);
                title.setAttribute('y', 30);
                title.setAttribute('text-anchor', 'middle');
                title.setAttribute('class', 'flow-hop-title');
                title.textContent = `HOP ${i + 1}`;
                svg.appendChild(title);
            }
            
            // Draw all wallets on the left side
            const walletData = [];
            
            // Draw victim wallets (RED)
            investigation.victims.forEach(victim => {
                const walletId = `V${victim.id}`;
                const y = walletPositions.get(walletId);
                const totalAmount = victim.transactions.reduce((sum, t) => sum + parseFloat(t.amount || 0), 0);
                
                // Red circle
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', leftMargin + walletColumnWidth / 2);
                circle.setAttribute('cy', y);
                circle.setAttribute('r', nodeRadius);
                circle.setAttribute('class', 'flow-wallet-node');
                circle.setAttribute('fill', '#e74c3c');
                circle.onclick = () => showWalletDetails({
                    address: victim.transactions[0]?.receivingWallet || 'Unknown',
                    type: 'victim',
                    notation: `V-${victim.id}`
                });
                svg.appendChild(circle);
                
                // Wallet number inside circle
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', leftMargin + walletColumnWidth / 2);
                label.setAttribute('y', y + 5);
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('class', 'flow-wallet-label');
                label.textContent = victim.id;
                svg.appendChild(label);
                
                // Wallet address to the right of circle
                const addressText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                addressText.setAttribute('x', leftMargin + walletColumnWidth / 2 + nodeRadius + 10);
                addressText.setAttribute('y', y + 5);
                addressText.setAttribute('text-anchor', 'start');
                addressText.setAttribute('font-size', '11px');
                addressText.setAttribute('fill', '#666');
                const address = victim.transactions[0]?.receivingWallet || 'Unknown';
                addressText.textContent = address.length > 20 ? address.substring(0, 8) + '...' + address.slice(-6) : address;
                svg.appendChild(addressText);
                
                walletData.push({
                    id: walletId,
                    x: leftMargin + walletColumnWidth / 2,
                    y: y,
                    amount: totalAmount,
                    type: 'victim'
                });
            });
            
            // Draw hop wallets
            const walletsByAddress = new Map();
            investigation.hops.forEach(hop => {
                hop.entries.filter(e => !e.isWriteoff).forEach(entry => {
                    const walletKey = `${entry.toWallet}-${entry.toWalletType}`;
                    if (!walletsByAddress.has(walletKey)) {
                        const y = walletPositions.get(walletKey);
                        
                        // Wallet circle
                        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        circle.setAttribute('cx', leftMargin + walletColumnWidth / 2);
                        circle.setAttribute('cy', y);
                        circle.setAttribute('r', nodeRadius);
                        circle.setAttribute('class', 'flow-wallet-node');
                        circle.setAttribute('fill', getWalletColor(entry.toWalletType));
                        circle.onclick = () => showWalletDetails({
                            address: entry.toWallet,
                            type: entry.toWalletType,
                            notation: entry.notation
                        });
                        svg.appendChild(circle);
                        
                        // Wallet notation inside circle
                        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        label.setAttribute('x', leftMargin + walletColumnWidth / 2);
                        label.setAttribute('y', y + 5);
                        label.setAttribute('text-anchor', 'middle');
                        label.setAttribute('class', 'flow-wallet-label');
                        // Extract number from notation (e.g., "V1-T1-H1" -> "1")
                        const hopNum = entry.notation ? entry.notation.split('-H')[1] : '';
                        label.textContent = hopNum || '';
                        svg.appendChild(label);
                        
                        // Wallet entity name if known
                        if (entry.entityName) {
                            const entityText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            entityText.setAttribute('x', leftMargin + walletColumnWidth / 2 + nodeRadius + 10);
                            entityText.setAttribute('y', y + 5);
                            entityText.setAttribute('text-anchor', 'start');
                            entityText.setAttribute('font-size', '11px');
                            entityText.setAttribute('fill', '#666');
                            entityText.setAttribute('font-weight', 'bold');
                            entityText.textContent = entry.entityName;
                            svg.appendChild(entityText);
                        }
                        
                        walletsByAddress.set(walletKey, {
                            x: leftMargin + walletColumnWidth / 2,
                            y: y,
                            type: entry.toWalletType,
                            notation: entry.notation
                        });
                    }
                });
            });
            
            // Draw connections and amounts
            const hopSums = [];
            
            investigation.hops.forEach((hop, hopIndex) => {
                const laneX = leftMargin + walletColumnWidth + (hopIndex * hopLaneWidth);
                const laneCenterX = laneX + hopLaneWidth / 2;
                
                hop.entries.forEach(entry => {
                    if (entry.isWriteoff) {
                        // Track writeoffs separately for display
                        if (!hopSums[hopIndex]) hopSums[hopIndex] = { total: 0, writeoffs: 0 };
                        hopSums[hopIndex].writeoffs += parseFloat(entry.amount || 0);
                        return;
                    }
                    
                    // Initialize hop sum if needed
                    if (!hopSums[hopIndex]) hopSums[hopIndex] = { total: 0, writeoffs: 0 };
                    
                    // Find source wallet position
                    let sourceY;
                    if (entry.sourceThread) {
                        // Check if it's from a victim
                        const victimMatch = entry.sourceThread.match(/V-(\d+)/);
                        if (victimMatch) {
                            sourceY = walletPositions.get(`V${victimMatch[1]}`);
                        } else {
                            // Find the source hop entry
                            for (let i = hopIndex - 1; i >= 0; i--) {
                                const sourceHop = investigation.hops[i];
                                const sourceEntry = sourceHop.entries.find(e => e.notation === entry.sourceThread);
                                if (sourceEntry) {
                                    const sourceKey = `${sourceEntry.toWallet}-${sourceEntry.toWalletType}`;
                                    sourceY = walletPositions.get(sourceKey);
                                    break;
                                }
                            }
                        }
                    }
                    
                    // Find destination wallet position
                    const destKey = `${entry.toWallet}-${entry.toWalletType}`;
                    const destY = walletPositions.get(destKey);
                    
                    if (sourceY && destY) {
                        // Draw straight line
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', leftMargin + walletColumnWidth / 2 + nodeRadius);
                        line.setAttribute('y1', sourceY);
                        line.setAttribute('x2', laneCenterX);
                        line.setAttribute('y2', destY);
                        line.setAttribute('class', 'flow-connection-line');
                        svg.appendChild(line);
                        
                        // Add amount text on the line
                        const amountText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        amountText.setAttribute('x', laneCenterX - 10);
                        amountText.setAttribute('y', destY - 5);
                        amountText.setAttribute('text-anchor', 'end');
                        amountText.setAttribute('class', 'flow-thread-amount');
                        amountText.textContent = formatCurrency(parseFloat(entry.amount || 0));
                        svg.appendChild(amountText);
                    }
                    
                    // Add to hop sum
                    hopSums[hopIndex].total += parseFloat(entry.amount || 0);
                });
                
                // Draw sum at bottom of hop lane
                const sumData = hopSums[hopIndex] || { total: 0, writeoffs: 0 };
                const sumText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                sumText.setAttribute('x', laneCenterX);
                sumText.setAttribute('y', totalHeight - 30);
                sumText.setAttribute('text-anchor', 'middle');
                sumText.setAttribute('class', 'flow-sum-text');
                sumText.textContent = formatCurrency(sumData.total);
                svg.appendChild(sumText);
                
                // Show writeoffs if any
                if (sumData.writeoffs > 0) {
                    const writeoffText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    writeoffText.setAttribute('x', laneCenterX);
                    writeoffText.setAttribute('y', totalHeight - 10);
                    writeoffText.setAttribute('text-anchor', 'middle');
                    writeoffText.setAttribute('font-size', '12px');
                    writeoffText.setAttribute('fill', '#666');
                    writeoffText.textContent = `(${formatCurrency(sumData.writeoffs)}) WO`;
                    svg.appendChild(writeoffText);
                }
                
                // Add "SUM:" label
                const sumLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                sumLabel.setAttribute('x', laneCenterX);
                sumLabel.setAttribute('y', totalHeight - 50);
                sumLabel.setAttribute('text-anchor', 'middle');
                sumLabel.setAttribute('font-size', '14px');
                sumLabel.setAttribute('fill', '#666');
                sumLabel.textContent = 'SUM:';
                svg.appendChild(sumLabel);
            });
        }
        
        // DUPLICATE FUNCTION REMOVED - Using the global version at line 9714
        /*function getWalletColor(type) {
            const colors = {
                'victim': '#e74c3c',
                'red': '#e74c3c',
                'purple': '#9b59b6',
                'blue': '#3498db',
                'green': '#27ae60',
                'unknown': '#95a5a6'
            };
            return colors[type] || colors.unknown;
        }*/
        
        
        function showWalletDetails(walletData) {
            alert(`Wallet: ${walletData.address || 'Unknown'}\nType: ${walletData.type}\nNotation: ${walletData.notation || 'N/A'}`);
        }
        
        // Generate BATS Training Example Visualization
        function generateBATSTrainingExample() {
            const svg = document.getElementById('flowDiagramSVG');
            svg.innerHTML = ''; // Clear existing content
            
            // Configuration
            const walletColumnWidth = 250;
            const hopLaneWidth = 300;
            const nodeRadius = 25;
            const verticalSpacing = 100;
            const topMargin = 80;
            const bottomMargin = 120;
            const leftMargin = 20;
            
            // Example data structure
            const exampleData = {
                victims: [
                    { id: 1, wallet: '0xVictim1...ABC', amount: 50000, label: 'Exchange Hack Victim' },
                    { id: 2, wallet: '0xVictim2...DEF', amount: 75000, label: 'DeFi Protocol Hack' },
                    { id: 3, wallet: '0xVictim3...GHI', amount: 25000, label: 'Phishing Victim' }
                ],
                hops: [
                    {
                        number: 1,
                        entries: [
                            { from: 'V1', to: '0xHub1...123', amount: 50000, type: 'purple', label: 'Hub Wallet', notation: 'V1-T1-H1' },
                            { from: 'V2', to: '0xHub1...123', amount: 75000, type: 'purple', label: 'Hub Wallet', notation: 'V2-T1-H1' },
                            { from: 'V3', to: '0xCold1...456', amount: 25000, type: 'gray', label: 'Cold Storage', notation: 'V3-T1-H1' }
                        ]
                    },
                    {
                        number: 2,
                        entries: [
                            { from: 'V1-T1-H1', to: '0xExchange1...789', amount: 45000, type: 'blue', label: 'Binance', notation: 'V1-T1-H2', entity: true },
                            { from: 'V1-T1-H1', to: '0xMixer...ABC', amount: 5000, type: 'red', label: 'Mixer', notation: 'V1-T1-H2', writeoff: true },
                            { from: 'V2-T1-H1', to: '0xExchange2...DEF', amount: 70000, type: 'blue', label: 'Coinbase', notation: 'V2-T1-H2', entity: true },
                            { from: 'V2-T1-H1', to: '0xUnknown...123', amount: 5000, type: 'red', label: 'Unknown', notation: 'V2-T1-H2', writeoff: true }
                        ]
                    },
                    {
                        number: 3,
                        entries: [
                            { from: 'V1-T1-H2', to: '0xExchange3...GHI', amount: 40000, type: 'blue', label: 'Kraken', notation: 'V1-T1-H3', entity: true },
                            { from: 'V1-T1-H2', to: '0xCold2...JKL', amount: 5000, type: 'gray', label: 'Cold Storage', notation: 'V1-T1-H3' },
                            { from: 'V2-T1-H2', to: '0xExchange3...GHI', amount: 70000, type: 'blue', label: 'Kraken', notation: 'V2-T1-H3', entity: true }
                        ]
                    }
                ]
            };
            
            // Calculate dimensions
            const numHops = exampleData.hops.length;
            const totalWidth = leftMargin + walletColumnWidth + (numHops * hopLaneWidth) + 50;
            const totalHeight = topMargin + (8 * verticalSpacing) + bottomMargin;
            
            // Set SVG dimensions
            svg.setAttribute('width', totalWidth);
            svg.setAttribute('height', totalHeight);
            svg.setAttribute('viewBox', `0 0 ${totalWidth} ${totalHeight}`);
            
            // Add title
            const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            title.setAttribute('x', totalWidth / 2);
            title.setAttribute('y', 30);
            title.setAttribute('text-anchor', 'middle');
            title.setAttribute('font-size', '24px');
            title.setAttribute('font-weight', 'bold');
            title.setAttribute('fill', '#2c3e50');
            title.textContent = 'BATS Training Example - Multiple Principles';
            svg.appendChild(title);
            
            // Draw hop lanes
            for (let i = 0; i < numHops; i++) {
                const laneX = leftMargin + walletColumnWidth + (i * hopLaneWidth);
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', laneX);
                rect.setAttribute('y', 50);
                rect.setAttribute('width', hopLaneWidth);
                rect.setAttribute('height', totalHeight - 70);
                rect.setAttribute('class', `flow-hop-lane flow-hop-lane-${(i % 5) + 1}`);
                svg.appendChild(rect);
                
                // Hop title
                const hopTitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                hopTitle.setAttribute('x', laneX + hopLaneWidth / 2);
                hopTitle.setAttribute('y', 75);
                hopTitle.setAttribute('text-anchor', 'middle');
                hopTitle.setAttribute('class', 'flow-hop-title');
                hopTitle.textContent = `HOP ${i + 1}`;
                svg.appendChild(hopTitle);
            }
            
            // Draw victim wallets
            let yPosition = topMargin + 50;
            exampleData.victims.forEach((victim, idx) => {
                // Red circle
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', leftMargin + 40);
                circle.setAttribute('cy', yPosition);
                circle.setAttribute('r', nodeRadius);
                circle.setAttribute('class', 'flow-wallet-node');
                circle.setAttribute('fill', '#e74c3c');
                svg.appendChild(circle);
                
                // Victim number
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', leftMargin + 40);
                label.setAttribute('y', yPosition + 5);
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('fill', 'white');
                label.setAttribute('font-weight', 'bold');
                label.textContent = victim.id;
                svg.appendChild(label);
                
                // Description
                const desc = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                desc.setAttribute('x', leftMargin + 75);
                desc.setAttribute('y', yPosition + 5);
                desc.setAttribute('font-size', '12px');
                desc.setAttribute('fill', '#666');
                desc.textContent = victim.label;
                svg.appendChild(desc);
                
                yPosition += verticalSpacing;
            });
            
            // Add legend
            const legendY = yPosition + 20;
            const legendItems = [
                { color: '#e74c3c', label: 'RED - Victim/High Risk' },
                { color: '#9b59b6', label: 'PURPLE - Hub Wallet' },
                { color: '#3498db', label: 'BLUE - Exchange/Service' },
                { color: '#95a5a6', label: 'GRAY - Cold Storage' }
            ];
            
            legendItems.forEach((item, idx) => {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', leftMargin + 40);
                circle.setAttribute('cy', legendY + (idx * 30));
                circle.setAttribute('r', 10);
                circle.setAttribute('fill', item.color);
                svg.appendChild(circle);
                
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', leftMargin + 60);
                text.setAttribute('y', legendY + (idx * 30) + 5);
                text.setAttribute('font-size', '12px');
                text.setAttribute('fill', '#2c3e50');
                text.textContent = item.label;
                svg.appendChild(text);
            });
            
            // Draw hop wallets and connections
            const walletPositions = new Map();
            let currentY = topMargin + 50;
            
            // Position all wallets
            exampleData.hops.forEach((hop, hopIdx) => {
                const uniqueWallets = new Map();
                hop.entries.forEach(entry => {
                    if (!entry.writeoff && !uniqueWallets.has(entry.to)) {
                        uniqueWallets.set(entry.to, { type: entry.type, label: entry.label, entity: entry.entity });
                    }
                });
                
                uniqueWallets.forEach((wallet, address) => {
                    if (!walletPositions.has(address)) {
                        walletPositions.set(address, { y: currentY, ...wallet });
                        currentY += verticalSpacing * 0.8;
                    }
                });
            });
            
            // Draw wallet nodes
            walletPositions.forEach((wallet, address) => {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', leftMargin + walletColumnWidth - 50);
                circle.setAttribute('cy', wallet.y);
                circle.setAttribute('r', nodeRadius);
                circle.setAttribute('class', 'flow-wallet-node');
                circle.setAttribute('fill', getWalletColor(wallet.type));
                svg.appendChild(circle);
                
                // Wallet type icon/number
                const icon = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                icon.setAttribute('x', leftMargin + walletColumnWidth - 50);
                icon.setAttribute('y', wallet.y + 5);
                icon.setAttribute('text-anchor', 'middle');
                icon.setAttribute('fill', 'white');
                icon.setAttribute('font-weight', 'bold');
                icon.textContent = wallet.entity ? 'E' : wallet.type === 'gray' ? 'C' : 'H';
                svg.appendChild(icon);
                
                // Wallet label
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', leftMargin + walletColumnWidth - 15);
                label.setAttribute('y', wallet.y + 5);
                label.setAttribute('font-size', '12px');
                label.setAttribute('fill', '#2c3e50');
                label.setAttribute('font-weight', wallet.entity ? 'bold' : 'normal');
                label.textContent = wallet.label;
                svg.appendChild(label);
            });
            
            // Draw connections and amounts
            exampleData.hops.forEach((hop, hopIdx) => {
                const laneX = leftMargin + walletColumnWidth + (hopIdx * hopLaneWidth);
                const laneCenterX = laneX + hopLaneWidth / 2;
                let hopTotal = 0;
                let hopWriteoffs = 0;
                
                hop.entries.forEach(entry => {
                    let sourceY;
                    
                    // Find source position
                    if (entry.from.startsWith('V')) {
                        const victimId = parseInt(entry.from.substring(1));
                        sourceY = topMargin + 50 + ((victimId - 1) * verticalSpacing);
                    } else {
                        // Find from previous hop
                        for (let i = hopIdx - 1; i >= 0; i--) {
                            const prevHop = exampleData.hops[i];
                            const prevEntry = prevHop.entries.find(e => e.notation === entry.from);
                            if (prevEntry) {
                                sourceY = walletPositions.get(prevEntry.to)?.y;
                                break;
                            }
                        }
                    }
                    
                    if (entry.writeoff) {
                        hopWriteoffs += entry.amount;
                        
                        // Draw writeoff notation
                        const writeoffText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        writeoffText.setAttribute('x', laneCenterX);
                        writeoffText.setAttribute('y', sourceY);
                        writeoffText.setAttribute('text-anchor', 'middle');
                        writeoffText.setAttribute('font-size', '12px');
                        writeoffText.setAttribute('fill', '#e74c3c');
                        writeoffText.setAttribute('font-weight', 'bold');
                        writeoffText.textContent = `Write-off: ${formatCurrency(entry.amount)} (${entry.label})`;
                        svg.appendChild(writeoffText);
                    } else {
                        hopTotal += entry.amount;
                        const destY = walletPositions.get(entry.to)?.y;
                        
                        if (sourceY && destY) {
                            // Draw line
                            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                            line.setAttribute('x1', entry.from.startsWith('V') ? leftMargin + 65 : leftMargin + walletColumnWidth - 25);
                            line.setAttribute('y1', sourceY);
                            line.setAttribute('x2', laneCenterX);
                            line.setAttribute('y2', destY);
                            line.setAttribute('class', 'flow-connection-line');
                            svg.appendChild(line);
                            
                            // Amount on line
                            const amountText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            amountText.setAttribute('x', laneCenterX - 10);
                            amountText.setAttribute('y', destY - 5);
                            amountText.setAttribute('text-anchor', 'end');
                            amountText.setAttribute('class', 'flow-thread-amount');
                            amountText.textContent = formatCurrency(entry.amount);
                            svg.appendChild(amountText);
                        }
                    }
                });
                
                // Draw hop totals
                const sumY = totalHeight - 60;
                const sumText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                sumText.setAttribute('x', laneCenterX);
                sumText.setAttribute('y', sumY);
                sumText.setAttribute('text-anchor', 'middle');
                sumText.setAttribute('class', 'flow-sum-text');
                sumText.textContent = formatCurrency(hopTotal);
                svg.appendChild(sumText);
                
                if (hopWriteoffs > 0) {
                    const writeoffSumText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    writeoffSumText.setAttribute('x', laneCenterX);
                    writeoffSumText.setAttribute('y', sumY + 20);
                    writeoffSumText.setAttribute('text-anchor', 'middle');
                    writeoffSumText.setAttribute('font-size', '12px');
                    writeoffSumText.setAttribute('fill', '#e74c3c');
                    writeoffSumText.textContent = `WO: (${formatCurrency(hopWriteoffs)})`;
                    svg.appendChild(writeoffSumText);
                }
                
                // Sum label
                const sumLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                sumLabel.setAttribute('x', laneCenterX);
                sumLabel.setAttribute('y', sumY - 20);
                sumLabel.setAttribute('text-anchor', 'middle');
                sumLabel.setAttribute('font-size', '14px');
                sumLabel.setAttribute('fill', '#666');
                sumLabel.textContent = 'SUM:';
                svg.appendChild(sumLabel);
            });
            
            // Add explanatory notes
            const notesY = totalHeight - 30;
            const notes = [
                'Hub Wallets (Purple): Consolidate funds from multiple sources',
                'Cold Storage (Gray): Long-term storage, harder to trace',
                'Exchanges (Blue): Known entities, potential recovery points',
                'Write-offs (Red): Lost/untraceable funds, reduce ART'
            ];
            
            notes.forEach((note, idx) => {
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', leftMargin);
                text.setAttribute('y', notesY + (idx * 15));
                text.setAttribute('font-size', '11px');
                text.setAttribute('fill', '#666');
                text.textContent = `• ${note}`;
                svg.appendChild(text);
            });
        }
        
        function exportFlowDiagram(format) {
            const svg = document.getElementById('flowDiagramSVG');
            
            if (format === 'svg') {
                const svgData = new XMLSerializer().serializeToString(svg);
                const blob = new Blob([svgData], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `BATS_Flow_${investigation.caseId || 'Diagram'}.svg`;
                a.click();
                URL.revokeObjectURL(url);
            } else if (format === 'png') {
                // Convert SVG to PNG
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                const svgData = new XMLSerializer().serializeToString(svg);
                const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
                const url = URL.createObjectURL(svgBlob);
                
                img.onload = function() {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                    
                    canvas.toBlob(function(blob) {
                        const a = document.createElement('a');
                        a.href = URL.createObjectURL(blob);
                        a.download = `BATS_Flow_${investigation.caseId || 'Diagram'}.png`;
                        a.click();
                    });
                    
                    URL.revokeObjectURL(url);
                };
                
                img.src = url;
            }
        }
        
        function printFlowDiagram() {
            window.print();
        }
        
        // Function to show landing page
        function showLandingPage() {
            // Hide entire app container
            const appContainer = document.querySelector('.container');
            if (appContainer) {
                appContainer.style.display = 'none';
            }

            // Show landing page container
            const landingContainer = document.getElementById('landingPageContainer');
            if (landingContainer) {
                landingContainer.style.display = 'block';
            }

            // Keep modals accessible
            const pkModal = document.getElementById('pkConverterModal');
            if (pkModal) {
                pkModal.style.position = 'fixed';
                pkModal.style.zIndex = '10001';
            }
            const addressModal = document.getElementById('addressFinderModal');
            if (addressModal) {
                addressModal.style.position = 'fixed';
                addressModal.style.zIndex = '10001';
            }
        }

        function showAppUI() {
            // Hide landing page container
            const landingContainer = document.getElementById('landingPageContainer');
            if (landingContainer) {
                landingContainer.style.display = 'none';
            }

            // Show app container
            const appContainer = document.querySelector('.container');
            if (appContainer) {
                appContainer.style.display = 'block';
            }

            // Show investigation tracker
            const tracker = document.querySelector('.investigation-step-tracker');
            if (tracker) tracker.style.display = 'block';

            // Show nav tabs
            const navTabs = document.getElementById('mainNavTabs');
            if (navTabs) navTabs.style.display = 'flex';

            // Show case details sidebar
            const sidebar = document.querySelector('.case-details-sidebar');
            if (sidebar) sidebar.style.display = 'block';

            // Show action bar
            const actionBar = document.querySelector('div[style*="Undo"]');
            if (actionBar && actionBar.parentElement) {
                actionBar.parentElement.style.display = 'flex';
            }
        }

        // Legacy function to show welcome screen
        function showWelcomeScreen() {
            showLandingPage();
        }
        
        // Quick start from welcome screen
        function quickStartInvestigation() {
            const caseId = document.getElementById('welcomeCaseId').value.trim();
            const investigator = document.getElementById('welcomeInvestigator').value.trim();
            const caseType = document.getElementById('welcomeCaseType').value;
            
            if (!caseId || !investigator || !caseType) {
                // Highlight missing fields
                if (!caseId) document.getElementById('welcomeCaseId').style.borderColor = '#e74c3c';
                if (!investigator) document.getElementById('welcomeInvestigator').style.borderColor = '#e74c3c';
                if (!caseType) document.getElementById('welcomeCaseType').style.borderColor = '#e74c3c';
                
                alert('Please fill in all required fields');
                return;
            }
            
            // Get synopsis value
            const caseSynopsis = document.getElementById('welcomeCaseSynopsis').value.trim();
            
            // Save to investigation object
            investigation.caseId = caseId;
            investigation.investigator = investigator;
            investigation.caseType = caseType;
            investigation.caseSynopsis = caseSynopsis;
            investigation.setupComplete = true;
            
            // Update main form fields
            document.getElementById('caseId').value = caseId;
            document.getElementById('investigator').value = investigator;
            document.getElementById('caseType').value = caseType;
            document.getElementById('caseSynopsis').value = caseSynopsis;
            
            // Save to storage
            saveToStorage();
            
            // Hide welcome screen
            document.getElementById('landingPageContainer').style.display = 'none';
            
            // Switch to victims tab
            switchTab('victims');
            
            // Auto-collapse setup card
            setTimeout(() => {
                const setupContent = document.getElementById('setupContent');
                if (setupContent && setupContent.style.display !== 'none') {
                    toggleSetupCard();
                }
                
                // Focus on add victim button
                const addVictimBtn = document.querySelector('button[onclick="addVictim()"]');
                if (addVictimBtn) {
                    addVictimBtn.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    // Add pulsing animation
                    addVictimBtn.style.animation = 'pulse 2s infinite';
                    addVictimBtn.style.boxShadow = '0 0 20px rgba(255, 152, 0, 0.5)';
                }
            }, 300);
        }
        
        // Skip welcome screen
        function skipWelcome() {
            document.getElementById('landingPageContainer').style.display = 'none';
            switchTab('victims');
        }

        function startBATSDocumentation() {
            // Navigate to the app URL instead of trying to initialize here
            // This ensures a clean separation between landing page and app
            const currentUrl = new URL(window.location.href);
            currentUrl.searchParams.set('app', 'true');
            window.location.href = currentUrl.toString();
        }

        function returnToLanding() {
            if (confirm('Return to landing page? Your work is auto-saved.')) {
                // Navigate back to the landing page by removing the app parameter
                const currentUrl = new URL(window.location.href);
                currentUrl.searchParams.delete('app');
                window.location.href = currentUrl.toString();
            }
        }

        function showQuickStartGuide() {
            alert('B.A.T.S. Quick Start Guide\n\n' +
                  '1. V-T-H Notation:\n' +
                  '   V = Victim identifier (V1, V2, etc.)\n' +
                  '   T = Transaction number (T1, T2, etc.)\n' +
                  '   H = Hop level (H1, H2, etc.)\n\n' +
                  '2. ART System:\n' +
                  '   Track Available Running Total at each hop\n' +
                  '   Document amounts traced vs. remaining\n\n' +
                  '3. Documentation Requirements:\n' +
                  '   - Screenshot all transactions\n' +
                  '   - Note timestamps and fees\n' +
                  '   - Document wallet attributions\n' +
                  '   - Maintain chain of custody\n\n' +
                  'For full training, open the B.A.T.S. Training page from the utility tools.');
        }
        
        function startInvestigation() {
            // Check if case details are filled
            const caseId = document.getElementById('caseId').value;
            const investigator = document.getElementById('investigator').value;
            const caseType = document.getElementById('caseType').value;
            
            if (!caseId || !investigator || !caseType) {
                alert('Please fill in the case details in the left sidebar first:\n- Case ID\n- Investigator Name\n- Case Type');
                
                // Highlight the fields
                if (!caseId) document.getElementById('caseId').style.borderColor = '#e74c3c';
                if (!investigator) document.getElementById('investigator').style.borderColor = '#e74c3c';
                if (!caseType) document.getElementById('caseType').style.borderColor = '#e74c3c';
                
                // Reset field highlighting after 3 seconds
                setTimeout(() => {
                    document.getElementById('caseId').style.borderColor = '';
                    document.getElementById('investigator').style.borderColor = '';
                    document.getElementById('caseType').style.borderColor = '';
                }, 3000);
                
                return;
            }
            
            // Hide welcome screen and show victims tab
            document.getElementById('landingPageContainer').style.display = 'none';
            switchTab('victims');
            
            // Focus on add victim button
            setTimeout(() => {
                const addVictimBtn = document.querySelector('button[onclick="addVictim()"]');
                if (addVictimBtn) {
                    addVictimBtn.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    addVictimBtn.style.animation = 'pulse 2s infinite';
                }
            }, 300);
        }

        // Save case details from Case Details tab
        function saveCaseDetails() {
            const caseId = document.getElementById('caseId').value.trim();
            const investigator = document.getElementById('investigator').value.trim();
            const caseType = document.getElementById('caseType').value;
            const caseSynopsis = document.getElementById('caseSynopsis').value.trim();

            // Validate required fields
            if (!caseId || !investigator || !caseType) {
                alert('Please fill in all required fields (Case ID, Investigator, and Case Type)');
                return;
            }

            // Update investigation object
            investigation.caseId = caseId;
            investigation.investigator = investigator;
            investigation.caseType = caseType;
            investigation.caseSynopsis = caseSynopsis;

            // Mark as complete if all required fields are filled
            if (caseId && investigator && caseType) {
                investigation.setupComplete = true;
            }

            // Save to storage
            saveToStorage();

            // Show success message with next step
            alert('✅ Case details saved successfully!\n\nClick "Next: Add Victims" to continue your investigation.');

            // Update stats
            updateCaseStats();

            // Show the next step button
            showNextStepButton();
        }
        
        // Check if setup is complete
        function isSetupComplete() {
            // First check the saved state
            if (investigation.setupComplete) {
                return true;
            }
            
            // Otherwise check current form values
            const caseId = document.getElementById('caseId').value;
            const investigator = document.getElementById('investigator').value;
            const caseType = document.getElementById('caseType').value;
            const caseSynopsis = document.getElementById('caseSynopsis').value;
            
            return caseId && investigator && caseType && caseSynopsis;
        }
        
        // Update case statistics
        function updateCaseStats() {
            const statsContainer = document.getElementById('caseStats');
            if (!statsContainer) return;
            
            const totalVictims = investigation.victims.length;
            const totalTransactions = investigation.victims.reduce((sum, v) => sum + v.transactions.length, 0);
            const totalHops = investigation.hops.length;
            const totalWallets = investigation.universalWalletIndex.length;
            
            // Calculate total traced amounts
            let totalTracedAmounts = {};
            investigation.victims.forEach(victim => {
                victim.transactions.forEach(tx => {
                    const currency = tx.customCurrency || tx.currency;
                    totalTracedAmounts[currency] = (totalTracedAmounts[currency] || 0) + parseFloat(tx.amount || 0);
                });
            });
            
            // Format amounts
            const amountsHtml = Object.entries(totalTracedAmounts)
                .map(([currency, amount]) => `<div>${formatCurrencyAmount(amount, currency)}</div>`)
                .join('');
            
            statsContainer.innerHTML = `
                <div style="background: #f8f9fa; border: 2px solid #3498db; padding: 20px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 2rem; font-weight: bold; color: #2c3e50;">${totalVictims}</div>
                    <div style="color: #7f8c8d;">Victims</div>
                </div>
                <div style="background: #f8f9fa; border: 2px solid #3498db; padding: 20px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 2rem; font-weight: bold; color: #2c3e50;">${totalTransactions}</div>
                    <div style="color: #7f8c8d;">Transactions</div>
                </div>
                <div style="background: #f8f9fa; border: 2px solid #3498db; padding: 20px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 2rem; font-weight: bold; color: #2c3e50;">${totalHops}</div>
                    <div style="color: #7f8c8d;">Hops Traced</div>
                </div>
                <div style="background: #f8f9fa; border: 2px solid #3498db; padding: 20px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 2rem; font-weight: bold; color: #2c3e50;">${totalWallets}</div>
                    <div style="color: #7f8c8d;">Wallets Tracked</div>
                </div>
                <div style="background: #e8f4f8; border: 2px solid #3498db; padding: 20px; border-radius: 8px; text-align: center; grid-column: span 2;">
                    <div style="font-size: 1.2rem; font-weight: bold; color: #2c3e50;">Total Traced:</div>
                    <div style="color: #3498db;">${amountsHtml || 'No amounts traced yet'}</div>
                </div>
            `;
        }
        
        // Helper function to toggle setup card (kept for compatibility)
        function toggleSetupCard() {
            // No longer needed since setup card is in its own tab
        }
        
        // Helper function to update setup card (kept for compatibility)
        function updateSetupCard() {
            // No longer needed since setup card is in its own tab
        }
        
        // Helper function to validate and proceed (kept for compatibility)
        function validateAndProceedSetup() {
            // This functionality is now handled by saveCaseDetails()
            saveCaseDetails();
            switchTab('victims');
            
            // Show success message
            setTimeout(() => {
                alert(' Investigation setup complete!\n\nNow add victim transactions to begin your investigation.');
            }, 100);
        }
        
        // Function to show next step button after saving case details
        function showNextStepButton() {
            const nextStepContainer = document.getElementById('nextStepContainer');
            if (nextStepContainer) {
                nextStepContainer.style.display = 'block';
                // Add pulsing animation to draw attention
                const nextButton = nextStepContainer.querySelector('button');
                if (nextButton) {
                    nextButton.style.animation = 'pulse 2s infinite';
                }
            }
        }

        // Make functions globally accessible
        window.validateAndProceedSetup = validateAndProceedSetup;
        window.saveCaseDetails = saveCaseDetails;
        window.updateCaseStats = updateCaseStats;
        window.showNextStepButton = showNextStepButton;
        window.lookupWizardTransaction = lookupWizardTransaction;
        window.selectWizardTransfer = selectWizardTransfer;

        // Define removeTransaction function if it doesn't exist
        function removeTransaction(victimId, transactionId) {
            const victim = investigation.victims.find(v => v.id === victimId);
            if (!victim) return;

            // Filter out the transaction
            victim.transactions = victim.transactions.filter(t => t.id !== transactionId);

            // Save and re-render
            saveToStorage();
            renderVictims();
            updateValidationStatus();
            updateWorkflowSteps();
        }

        // Expose victim-related functions globally so onclick handlers work
        window.addVictim = addVictim;
        window.completeVictim = completeVictim;
        window.reopenVictim = reopenVictim;
        window.removeVictim = removeVictim;
        window.addTransaction = addTransaction;
        window.updateTransaction = updateTransaction;
        window.removeTransaction = removeTransaction;
        window.fixVictimTransactionOrder = fixVictimTransactionOrder;
        window.openBulkTransactionModal = openBulkTransactionModal;
        window.updateTransactionCurrency = updateTransactionCurrency;

        // Expose wizard and PIFO functions
        window.applyPIFOAllocation = applyPIFOAllocation;
        window.applyPIFOToWizard = applyPIFOToWizard;
        window.lookupSwapTransaction = lookupSwapTransaction;
        window.toggleSwapThread = toggleSwapThread;
        window.updateSwapThreadAmount = updateSwapThreadAmount;
        window.setMaxSwapAmount = setMaxSwapAmount;
        window.setSwapType = setSwapType;
        window.swapWizardNext = swapWizardNext;
        window.swapWizardBack = swapWizardBack;
        window.closeSwapWizard = closeSwapWizard;
        window.showSwapWizardStep = showSwapWizardStep;
        window.createSwapEntry = createSwapEntry;
        window.setAllocationMode = setAllocationMode;
        window.applyMatchingAllocation = applyMatchingAllocation;
        window.updateWizardAllocation = updateWizardAllocation;
        window.setWizardMaxAllocation = setWizardMaxAllocation;

        // Expose hop management functions
        window.closeHopAndProceed = closeHopAndProceed;
        window.completeHopAndProceed = completeHopAndProceed;
        window.checkForUnaccountedThreads = checkForUnaccountedThreads;
        window.proceedToNextHop = proceedToNextHop;
        window.showThreadReviewModal = showThreadReviewModal;
        window.showNotification = showNotification;
        window.logBridgeOutput = logBridgeOutput;
        window.confirmBridgeOutput = confirmBridgeOutput;
        window.lookupBridgeDestTransaction = lookupBridgeDestTransaction;
        window.showBridgeTransferSelection = showBridgeTransferSelection;
        window.showBridgeTransferSelectionModal = showBridgeTransferSelectionModal;
        window.selectBridgeTransfer = selectBridgeTransfer;
        window.selectBridgeTransferFromModal = selectBridgeTransferFromModal;
        window.filterBridgeTransfers = filterBridgeTransfers;
        window.filterBridgeTransfersModal = filterBridgeTransfersModal;
        window.clearBridgeFilters = clearBridgeFilters;
        window.clearBridgeTransferFilters = clearBridgeTransferFilters;
        window.renderBridgeTransferCards = renderBridgeTransferCards;
        window.renderBridgeTransferModalCards = renderBridgeTransferModalCards;
        window.removeHopEntry = removeHopEntry;
        window.addNewHop = addNewHop;
        window.overrideAttribution = overrideAttribution;
        window.toggleOverrideFields = toggleOverrideFields;
        window.cancelAttributionOverride = cancelAttributionOverride;
        window.applyAttributionOverride = applyAttributionOverride;

        // Add event listeners to setup fields
        document.addEventListener('DOMContentLoaded', function() {
            // Load existing values if they exist
            if (investigation.caseId) document.getElementById('caseId').value = investigation.caseId;
            if (investigation.investigator) document.getElementById('investigator').value = investigation.investigator;
            if (investigation.caseType) document.getElementById('caseType').value = investigation.caseType;

            // If case details are already complete, show the next step button
            if (investigation.setupComplete) {
                setTimeout(() => {
                    showNextStepButton();
                }, 500);
            }
            if (investigation.caseSynopsis) document.getElementById('caseSynopsis').value = investigation.caseSynopsis;
            
            // Update card appearance on load
            updateSetupCard();
        });

        // ============================================
        // BATS FLOW DIAGRAM VISUALIZATION
        // ============================================

        // Initialize the BATS hop-centric flow diagram
        function initializeGraphVisualization() {
            try {
                console.log('🎨 Initializing BATS Flow Diagram...');

                // Ensure container exists
                const container = document.getElementById('visualizationContainer');
                if (!container) {
                    console.error('Visualization container not found');
                    showErrorMessage('Visualization container not found. Please refresh the page.');
                    return;
                }

                // Check if investigation has data
                if (!investigation || !investigation.hops || investigation.hops.length === 0) {
                    container.innerHTML = `
                        <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; color: #999;">
                            <h3>No investigation data to visualize yet</h3>
                            <p>Complete at least one hop to see the flow diagram.</p>
                            <button onclick="switchTab('hops')" class="btn" style="margin-top: 20px;">Return to Investigation</button>
                        </div>
                    `;
                    return;
                }

                // Check if generateHopCentricDAG is available
                if (typeof generateHopCentricDAG !== 'function') {
                    console.error('generateHopCentricDAG not loaded');
                    showErrorMessage('Flow diagram engine not loaded. Please refresh the page.');
                    return;
                }

                // Clear container and setup with SVG for proper BATS visualization
                container.innerHTML = `
                    <div style="position: absolute; top: 10px; right: 10px; z-index: 1000;">
                        <button onclick="switchTab('hops'); saveInvestigation();" class="btn" style="background: rgba(52, 152, 219, 0.9); padding: 10px 20px; border: none; color: white; cursor: pointer; border-radius: 4px;">
                            ← Back to Investigation
                        </button>
                    </div>
                    <div style="width: 100%; height: 100%; overflow: auto; background: white; padding: 20px;">
                        <svg id="bats-flow-diagram" width="2400" height="2000" style="display: block;"></svg>
                    </div>
                `;

                // Generate the proper BATS hop-centric DAG visualization
                const svg = document.getElementById('bats-flow-diagram');
                generateHopCentricDAG(svg, investigation);

                console.log('✅ BATS Flow Diagram rendered successfully');

            } catch (error) {
                console.error('Error initializing visualization:', error);
                showErrorMessage('Failed to initialize visualization: ' + error.message);
            }
        }

        // Export SVG visualization (flow-diagram-enhanced.js renders as SVG)
        function exportFlowDiagram() {
            const svg = document.getElementById('bats-flow-diagram');
            if (!svg) {
                alert('No visualization to export. Please generate the flow diagram first.');
                return;
            }

            try {
                // Get the SVG as a string
                const svgData = new XMLSerializer().serializeToString(svg);
                const blob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
                const url = URL.createObjectURL(blob);

                const a = document.createElement('a');
                a.href = url;
                a.download = `bats-flow-diagram-${investigation.caseId || 'investigation'}-${Date.now()}.svg`;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                if (typeof showNotification === 'function') {
                    showNotification('Flow diagram exported successfully!', 'success');
                }
            } catch (error) {
                console.error('Export error:', error);
                alert('Failed to export flow diagram: ' + error.message);
            }
        }

        // Show error message in visualization container
        function showErrorMessage(message) {
            const container = document.getElementById('visualizationContainer');
            if (container) {
                container.innerHTML = `
                    <div style="position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); text-align: center; padding: 40px; background: rgba(255, 0, 0, 0.1); border: 2px solid #ff4444; border-radius: 10px; max-width: 600px;">
                        <h2 style="color: #ff4444; margin-bottom: 20px;">⚠️ Visualization Error</h2>
                        <p style="color: #fff; margin-bottom: 20px;">${message}</p>
                        <div style="display: flex; gap: 15px; justify-content: center;">
                            <button onclick="switchTab('hops'); saveInvestigation();" class="btn" style="background: #27ae60;">
                                ← Back to Investigation
                            </button>
                            <button onclick="location.reload();" class="btn" style="background: #3498db;">
                                🔄 Refresh Page
                            </button>
                        </div>
                        <p style="color: #aaa; margin-top: 20px; font-size: 14px;">
                            Your investigation data is safe and has been auto-saved.
                        </p>
                    </div>
                `;
            }
        }

        // End of visualization functions

        // Expose visualization functions globally
        window.initializeGraphVisualization = initializeGraphVisualization;
        window.exportFlowDiagram = exportFlowDiagram;
    </script>
</body>
</html>
