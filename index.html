<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
    <meta http-equiv="Pragma" content="no-cache">
    <meta http-equiv="Expires" content="0">
    <meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob:; connect-src 'self' https://api.etherscan.io https://api.bscscan.com https://api.polygonscan.com https://api.blockcypher.com https://blockchain.info https://api.blockchair.com https://*.infura.io https://mempool.space https://api.mainnet-beta.solana.com https://rpc.ankr.com https://solana-mainnet.g.alchemy.com https://api.arkhamintelligence.com https://api.trongrid.io https://tronscan.org https://api.blockchain.info https://walletexplorer.com https://www.walletexplorer.com https://*.solscan.io https://pro-api.solscan.io https://public-api.solscan.io https://api.solscan.io; img-src 'self' data: https:; font-src 'self' data:;">
    <title>B.A.T.S. - Block Audit Tracing Standard v4.1</title>

    <script>
        // Mobile detection and redirect
        (function() {
            // Check if user has explicitly chosen to view desktop version
            const forceDesktop = localStorage.getItem('bats_force_desktop') === 'true';
            
            if (!forceDesktop) {
                // Detect mobile devices
                const isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent) ||
                               (window.matchMedia && window.matchMedia("(max-width: 768px)").matches);
                
                // Check if we're not already on mobile.html to avoid redirect loop
                const currentPage = window.location.pathname.split('/').pop();
                
                if (isMobile && currentPage !== 'mobile.html') {
                    // Show a brief notice before redirecting
                    if (confirm('📱 Mobile device detected!\n\nWould you like to view the mobile-optimized version of B.A.T.S.?\n\n(You can always switch to desktop version from the mobile site)')) {
                        window.location.href = 'mobile.html';
                    } else {
                        // User chose to stay on desktop version
                        localStorage.setItem('bats_force_desktop', 'true');
                    }
                }
            }
        })();
    </script>

    <!-- Inline minimal crypto functions to avoid CSP issues -->
    <script>
    // Minimal crypto implementations for PK Converter and Address Finder
    // Using Web Crypto API for hashing (no external dependencies needed)
    window.cryptoJSBlocked = true; // Always use Web Crypto API to avoid CSP issues
    </script>

    <!-- Include the enhanced flow diagram visualization -->
    <script src="flow-diagram-enhanced.js"></script>

    <!--
    DEPLOYMENT INSTRUCTIONS:
    For full functionality (custom save locations, autosave), serve this file over HTTPS:
    
    Option 1 - Local Development Server:
    - Python: python -m http.server 8000 (then visit http://localhost:8000)
    - Node.js: npx http-server
    - VS Code: Use Live Server extension
    
    Option 2 - Web Hosting:
    - Upload to any HTTPS-enabled web server
    - GitHub Pages (free): https://pages.github.com
    - Netlify Drop (free): https://app.netlify.com/drop
    
    Option 3 - Direct File Access:
    - Open index.html directly in browser
    - Limited functionality: saves only to Downloads folder
    -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #e8ecf1 0%, #f5f7fa 100%);
            min-height: 100vh;
            color: #2c3e50;
            overflow-x: hidden;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .case-details-card {
            background: white;
            border-radius: 8px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
            border: 1px solid #e8f0fe;
        }

        .case-details-card .form-group {
            margin-bottom: 0;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 30px;
            border-radius: 8px;
            text-align: center;
            margin-bottom: 30px;
            box-shadow: 0 4px 15px rgba(44, 62, 80, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 30px;
        }

        .header-logo {
            width: 168px;
            height: auto;
            flex-shrink: 0;
        }

        .header-content {
            flex: 1;
            text-align: center;
        }

        .header h1 {
            font-size: 2.8rem;
            font-weight: 700;
            margin-bottom: 10px;
            letter-spacing: 2px;
        }

        .header .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            font-weight: 300;
        }

        .workflow-steps {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
            border: 1px solid #e8f0fe;
        }

        .steps-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .step-item {
            text-align: center;
            padding: 15px;
            border-radius: 8px;
            background: #f8f9fa;
            border: 2px solid #e8f0fe;
            transition: all 0.3s ease;
        }

        .step-item.active {
            background: #e8f4f8;
            border-color: #3498db;
        }

        .step-item.completed {
            background: #f0f0f0;
            border-color: #95a5a6;
        }

        .step-number {
            background: #95a5a6;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 10px;
            font-weight: bold;
        }

        .step-item.active .step-number {
            background: #3498db;
        }

        .step-item.completed .step-number {
            background: #2c3e50;
        }

        .main-content {
            display: block;
            width: 100%;
        }

        .sidebar {
            background: white;
            border-radius: 8px;
            padding: 25px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
            height: fit-content;
            border: 1px solid #e8f0fe;
        }

        .main-panel {
            background: linear-gradient(135deg, #ffffff 0%, #fafbfc 100%);
            border-radius: 12px;
            padding: 30px;
            box-shadow: 0 8px 32px rgba(52, 152, 219, 0.25), 0 2px 8px rgba(0, 0, 0, 0.05);
            min-height: 600px;
            border: 2px solid rgba(52, 152, 219, 0.3);
            width: 100%;
            position: relative;
            transition: all 0.3s ease;
        }

        .main-panel::before {
            content: '';
            position: absolute;
            top: -4px;
            left: -4px;
            right: -4px;
            bottom: -4px;
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            border-radius: 14px;
            opacity: 0.08;
            z-index: -1;
        }

        .main-panel:hover {
            box-shadow: 0 10px 40px rgba(52, 152, 219, 0.3), 0 4px 12px rgba(0, 0, 0, 0.08);
        }

        .section-title {
            font-size: 1.4rem;
            font-weight: 600;
            margin-bottom: 20px;
            color: white;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #34495e;
            font-size: 14px;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #95a5a6;
            border-radius: 6px;
            font-size: 14px;
            transition: all 0.3s ease;
            background: white;
            box-shadow: inset 0 1px 3px rgba(0, 0, 0, 0.08);
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #3498db;
            background: white;
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1), inset 0 1px 3px rgba(0, 0, 0, 0.08);
        }

        .datetime-timezone {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .datetime-timezone input {
            flex: 1;
        }

        .datetime-timezone select {
            width: 100px;
            flex-shrink: 0;
        }

        .btn {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            margin-right: 10px;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #95a5a6 0%, #7f8c8d 100%);
        }
        
        .btn-add-transaction {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            font-weight: 600;
            padding: 10px 20px;
            margin-right: 10px;
        }
        
        .btn-add-transaction:hover {
            background: linear-gradient(135deg, #2980b9 0%, #21618c 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
        }

        .btn-danger {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }

        .btn-success {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
        }

        .btn-confirm {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            font-size: 16px;
            padding: 15px 30px;
        }

        .btn-large {
            font-size: 18px;
            padding: 20px 40px;
            margin: 30px 0;
            font-weight: 700;
        }

        .generate-root-section {
            background: #f8f9fa;
            border: 2px solid #3498db;
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            margin-top: 30px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.05);
        }

        .generate-root-section h3 {
            color: #2c3e50;
            font-size: 1.5rem;
            margin-bottom: 15px;
        }

        .generate-root-section p {
            color: #2c3e50;
            margin-bottom: 25px;
            font-size: 16px;
            line-height: 1.6;
        }

        .trace-entry {
            background: white;
            border: 2px solid #95a5a6;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            transition: all 0.3s ease;
            box-shadow: 0 2px 10px rgba(0,0,0,0.2);
        }

        .trace-entry:hover {
            border-color: #3498db;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.1);
        }

        .trace-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .trace-notation {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #2c3e50;
            font-size: 1.2rem;
        }

        .validation-panel {
            background: #e8f4f8;
            color: #2c3e50;
            border: 2px solid #3498db;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: center;
            font-weight: 500;
        }

        .validation-error {
            background: #fef2f2;
            border: 2px solid #dc3545;
            color: #dc3545;
        }

        .validation-warning {
            background: #fff8e1;
            border: 2px solid #f39c12;
            color: #856404;
        }

        .nav-tabs {
            display: flex;
            margin-bottom: 25px;
            border-bottom: 2px solid #e8f0fe;
        }

        .nav-tab {
            padding: 15px 25px;
            border: none;
            background: #f8f9fa;
            cursor: pointer;
            font-weight: 500;
            color: #7f8c8d;
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
            font-size: 14px;
            position: relative;
            margin-right: 5px;
            border-radius: 8px 8px 0 0;
        }

        .nav-tab.active {
            color: #ffffff;
            background: #1a5490;
            border-bottom-color: #1a5490;
            font-weight: 600;
            box-shadow: 0 2px 8px rgba(26, 84, 144, 0.4);
        }

        .nav-tab:hover:not(.active) {
            color: #2c3e50;
            background: #e8f0fe;
        }
        
        /* Additional styling for better active tab visibility */
        .nav-tab.active::after {
            content: '';
            position: absolute;
            bottom: -2px;
            left: 0;
            right: 0;
            height: 4px;
            background: #1a5490;
            border-radius: 2px 2px 0 0;
        }

        .tab-content {
            display: none;
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            padding: 25px;
            border-radius: 0 0 12px 12px;
            min-height: 500px;
        }

        .tab-content.active {
            display: block !important;
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        /* Dashboard Styles */
        .dashboard-stat {
            background: white;
            border-radius: 6px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: transform 0.2s;
        }

        .dashboard-stat:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .stat-label {
            font-size: 14px;
            color: #7f8c8d;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .stat-value {
            font-size: 28px;
            font-weight: bold;
            color: #2c3e50;
        }

        .progress-bar-container {
            margin-bottom: 15px;
        }

        .progress-bar-label {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            margin-bottom: 5px;
        }

        .progress-bar-bg {
            background: #e0e0e0;
            border-radius: 10px;
            height: 20px;
            overflow: hidden;
        }

        .progress-bar-fill {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            height: 100%;
            border-radius: 10px;
            transition: width 0.3s ease;
        }

        .search-highlight {
            background-color: #fff3cd !important;
            border: 2px solid #ffc107 !important;
            animation: highlight-pulse 1s ease-in-out;
        }

        @keyframes highlight-pulse {
            0% { opacity: 0.7; }
            50% { opacity: 1; }
            100% { opacity: 0.7; }
        }

        .analysis-tab-content {
            padding: 20px;
            min-height: 300px;
        }

        .summary-card {
            background: #fdfdfd;
            border-radius: 8px;
            padding: 25px;
            text-align: center;
            border: 2px solid #e8f0fe;
            transition: transform 0.3s ease;
        }

        .summary-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .summary-card h3 {
            color: #3498db;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }

        .summary-card .value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #2c3e50;
        }

        .export-section {
            background: #fdfdfd;
            border-radius: 8px;
            padding: 25px;
            margin-top: 30px;
            border: 2px solid #e8f0fe;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 10000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            align-items: center;
            justify-content: center;
        }
        
        .modal.show {
            display: flex;
        }

        .modal-content {
            background-color: white;
            padding: 30px;
            border-radius: 12px;
            width: 90%;
            max-width: 700px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            max-height: 85vh;
            overflow-y: auto;
            position: relative;
        }
        
        /* Wallet Address Autocomplete Styles */
        .wallet-autocomplete-container {
            position: relative;
        }
        
        .wallet-autocomplete-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 4px 4px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }
        
        .wallet-autocomplete-item {
            padding: 10px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            font-family: monospace;
            font-size: 13px;
        }
        
        .wallet-autocomplete-item:hover {
            background-color: #f8f9fa;
        }
        
        .wallet-autocomplete-item.selected {
            background-color: #e3f2fd;
        }
        
        .wallet-autocomplete-blockchain {
            font-size: 11px;
            color: #666;
            margin-top: 4px;
            font-family: sans-serif;
        }
        
        .wallet-autocomplete-loading {
            padding: 15px;
            text-align: center;
            color: #666;
            font-size: 13px;
        }

        .modal-header {
            text-align: center;
            margin-bottom: 25px;
        }

        .modal-header h2 {
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .root-total-display {
            background: #f8f9fa;
            border: 2px solid #3498db;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            margin: 20px 0;
        }

        .root-total-amount {
            font-size: 2.5rem;
            font-weight: bold;
            color: #2c3e50;
            margin: 10px 0;
        }

        .root-explanation {
            background: #f8f9fa;
            border-left: 4px solid #3498db;
            padding: 20px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }

        .root-explanation h4 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .root-explanation ul {
            color: #34495e;
            line-height: 1.8;
            padding-left: 20px;
        }

        .root-explanation li {
            margin-bottom: 8px;
        }

        .art-display {
            background: #e8f4f8;
            border: 2px solid #3498db;
            border-radius: 6px;
            padding: 10px 15px;
            margin: 10px 0;
            text-align: center;
            font-weight: bold;
            color: #2c3e50;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            cursor: pointer;
            margin-right: 10px;
        }

        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }

        .no-traces-message {
            text-align: center;
            padding: 40px;
            color: #7f8c8d;
            background: #f8f9fa;
            border-radius: 8px;
            border: 2px dashed #bdc3c7;
        }

        .custom-currency-input {
            display: none;
        }

        .wallet-display {
            background: #f8f9fa;
            border: 2px solid #e8f0fe;
            border-radius: 6px;
            padding: 10px 15px;
            margin: 10px 0;
            font-weight: bold;
            color: #2c3e50;
        }

        .wallet-display.red { background: #fef2f2; border-color: #dc3545; color: #dc3545; }
        .wallet-display.pink { background: #fef2f8; border-color: #d63384; color: #d63384; }
        .wallet-display.yellow { background: #fff8e1; border-color: #ffc107; color: #856404; }
        .wallet-display.orange { background: #fff3e0; border-color: #fd7e14; color: #fd7e14; }
        .wallet-display.black { background: #f5f5f5; border-color: #2c3e50; color: #2c3e50; }
        .wallet-display.brown { background: #f5f5f5; border-color: #795548; color: #795548; }
        .wallet-display.blue { background: #e8f4f8; border-color: #3498db; color: #3498db; }
        .wallet-display.purple { background: #f3e5f5; border-color: #6f42c1; color: #6f42c1; }
        .wallet-display.gray { background: #f5f5f5; border-color: #95a5a6; color: #7f8c8d; }
        .wallet-display.green { background: #e8f8f5; border-color: #198754; color: #198754; }
        
        /* Pulse animation for call-to-action buttons */
        @keyframes pulse {
            0% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(255, 152, 0, 0.7);
            }
            50% {
                transform: scale(1.05);
                box-shadow: 0 0 20px 10px rgba(255, 152, 0, 0);
            }
            100% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(255, 152, 0, 0);
            }
        }

        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
            }

            .steps-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        @media (max-width: 768px) {
            .steps-grid {
                grid-template-columns: 1fr;
            }

            .datetime-timezone {
                flex-direction: column;
                gap: 5px;
            }

            .datetime-timezone select {
                width: 100%;
            }
        }
        /* =================================
   PART 4: CSS ADDITIONS - Add to your existing <style> section
   ================================= */

/* Enhanced UI Styles for Thread Tracking */
.enhanced-notation {
    background: linear-gradient(135deg, #f8f9fa 0%, #e8f4f8 100%);
    border: 2px solid #3498db;
    border-radius: 8px;
    padding: 15px;
    margin: 10px 0;
    font-family: 'Courier New', monospace;
    min-height: 80px;
}

.source-chain-display {
    background: #e8f4f8;
    border: 1px solid #3498db;
    border-radius: 4px;
    padding: 10px;
    margin: 8px 0;
    font-size: 12px;
}

.thread-tracker {
    background: #fff3cd;
    border: 2px solid #ffc107;
    border-radius: 6px;
    padding: 12px;
    margin: 10px 0;
}

.assignment-preview {
    background: #f8f9fa;
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 8px;
    margin-top: 5px;
    font-size: 12px;
}

.assignment-preview.valid {
    background: #d4edda;
    border-color: #27ae60;
    color: #155724;
}

.assignment-preview.invalid {
    background: #f8d7da;
    border-color: #dc3545;
    color: #721c24;
}

.convergence-indicator {
    background: #f39c12;
    color: white;
    padding: 2px 8px;
    border-radius: 4px;
    font-size: 11px;
    font-weight: bold;
    display: inline-block;
    margin-left: 8px;
}

/* Part 4 Integration Styles */
.part4-notification {
    background: linear-gradient(135deg, #d1ecf1 0%, #b8daff 100%);
    border: 2px solid #3498db;
    border-radius: 8px;
    padding: 20px;
    margin-bottom: 20px;
    color: #0c5460;
}

.enhanced-validation-panel {
    background: linear-gradient(135deg, #f8f9fa 0%, #e8f4f8 100%);
    border: 2px solid #3498db;
    border-radius: 8px;
    padding: 20px;
    margin: 20px 0;
}

.thread-analysis {
    background: #f8f9fa;
    border: 1px solid #ddd;
    border-radius: 6px;
    padding: 15px;
    margin: 10px 0;
    font-size: 14px;
}

.source-chain-report {
    background: white;
    border: 1px solid #ddd;
    border-radius: 6px;
    padding: 15px;
    margin: 10px 0;
    font-family: 'Courier New', monospace;
    font-size: 12px;
}

/* Collapsible hop and entry animations */
.hop-container {
    transition: all 0.3s ease;
}

.hop-header {
    transition: background-color 0.3s ease;
}

.hop-header:hover {
    filter: brightness(1.1);
}

.entry-collapsed {
    transition: all 0.3s ease;
}

@keyframes pulse {
    0% {
        box-shadow: 0 0 0 0 rgba(39, 174, 96, 0.7);
        transform: scale(1);
    }
    50% {
        box-shadow: 0 0 20px 10px rgba(39, 174, 96, 0);
        transform: scale(1.05);
    }
    100% {
        box-shadow: 0 0 0 0 rgba(39, 174, 96, 0);
        transform: scale(1);
    }
}

/* Terminal Wallet Notification Styles */
.terminal-notification {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: white;
    border-radius: 12px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.3);
    z-index: 10000;
    max-width: 500px;
    animation: slideIn 0.3s ease;
}

@keyframes slideIn {
    from {
        opacity: 0;
        transform: translate(-50%, -45%);
    }
    to {
        opacity: 1;
        transform: translate(-50%, -50%);
    }
}

.terminal-notification-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.5);
    z-index: 9999;
    animation: fadeIn 0.3s ease;
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

/* Modal Styles */
.modal {
    display: none;
    position: fixed;
    z-index: 10000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.5);
    align-items: center;
    justify-content: center;
}

.modal.show {
    display: flex;
}

.modal-content {
    background-color: white;
    margin: auto;
    padding: 0;
    border-radius: 8px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    position: relative;
    animation: modalSlideIn 0.3s ease;
    max-height: 90vh;
    overflow-y: auto;
}

@keyframes modalSlideIn {
    from {
        transform: translateY(-50px);
        opacity: 0;
    }
    to {
        transform: translateY(0);
        opacity: 1;
    }
}

/* Flow Diagram Styles */
.flow-wallet-node {
    cursor: pointer;
    transition: all 0.2s ease;
    stroke: #333;
    stroke-width: 2;
}

.flow-wallet-node:hover {
    filter: brightness(1.1);
    transform: scale(1.05);
}

.flow-connection-line {
    fill: none;
    stroke-width: 1;
    stroke: #333;
}

.flow-thread-amount {
    font-size: 14px;
    font-weight: 600;
    font-family: 'Courier New', monospace;
    fill: #2c3e50;
    background: white;
    padding: 2px;
}

.flow-hop-lane {
    opacity: 0.3;
}

.flow-hop-lane-1 {
    fill: #FFB6C1;
}

.flow-hop-lane-2 {
    fill: #87CEEB;
}

.flow-hop-lane-3 {
    fill: #98FB98;
}

.flow-hop-lane-4 {
    fill: #DDA0DD;
}

.flow-hop-lane-5 {
    fill: #F0E68C;
}

.flow-hop-title {
    font-size: 18px;
    font-weight: bold;
    fill: #2c3e50;
}

.flow-sum-text {
    font-size: 16px;
    font-weight: bold;
    font-family: 'Courier New', monospace;
    fill: #2c3e50;
}

.flow-wallet-label {
    font-size: 12px;
    font-weight: bold;
    fill: white;
}

@media print {
    #flowDiagramControls {
        display: none !important;
    }
    
    #flowDiagramContainer {
        border: none !important;
        box-shadow: none !important;
    }
}
   </style>
</head>
<body>
    <!-- Landing Page (completely separate from app) -->
    <div id="landingPageContainer" style="display: none; position: fixed; top: 0; left: 0; right: 0; bottom: 0; z-index: 10000; background: linear-gradient(135deg, #1a1a2e 0%, #0f0f1e 100%); overflow-y: auto;">
<div id="landingContent" >
                    <!-- Professional Dark Header -->
                    <div style="background: linear-gradient(135deg, #2c3e50 0%, #1a252f 100%); padding: 40px 0; border-bottom: 2px solid #34495e; box-shadow: 0 2px 10px rgba(0,0,0,0.3);">
                        <div style="max-width: 1200px; margin: 0 auto; padding: 0 20px; text-align: center;">
                            <h1 style="color: #ecf0f1; font-size: 3rem; margin-bottom: 10px; font-weight: 700; letter-spacing: 3px; text-shadow: 2px 2px 4px rgba(0,0,0,0.3);">
                                B.A.T.S.
                            </h1>
                            <p style="font-size: 1.1rem; color: #bdc3c7; font-weight: 300; letter-spacing: 1px;">
                                Block Audit Tracing Standard
                            </p>
                        </div>
                    </div>

                    <div style="max-width: 900px; margin: 0 auto; padding: 50px 20px;">

                        <!-- Brief Info Section -->
                        <div style="text-align: center; margin-bottom: 50px;">
                            <h2 style="color: #ecf0f1; margin-bottom: 20px; font-size: 1.8rem; font-weight: 300;">Documentation Standard for Blockchain Investigations</h2>
                            <p style="color: #95a5a6; line-height: 1.8; font-size: 1.1rem; max-width: 700px; margin: 0 auto 30px;">
                                B.A.T.S. provides a systematic methodology for documenting cryptocurrency fund movements.
                                Designed to work alongside your blockchain analysis tools to ensure legally compliant investigation records.
                            </p>
                            <div style="display: inline-block; background: rgba(241, 196, 15, 0.1); border: 1px solid #f39c12; border-radius: 6px; padding: 15px 25px; color: #f39c12; max-width: 800px; text-align: left;">
                                <strong>Note:</strong> This tool is not designed to be a stand alone tracing tool but serve as guardrails in applying the BATS method. It is best used to document tracing efforts conducted via opensource explorers or commercial forensic tools to develop BATS compliant consistent documentation and reporting.
                            </div>
                        </div>

                        <!-- Primary Action Card -->
                        <div style="background: linear-gradient(135deg, #34495e 0%, #2c3e50 100%); border-radius: 8px; padding: 40px; margin-bottom: 40px; box-shadow: 0 5px 20px rgba(0,0,0,0.4); text-align: center; cursor: pointer; transition: all 0.2s ease; border: 1px solid #4a5f7a;" onclick="startBATSDocumentation()" onmouseover="this.style.transform='translateY(-2px)'; this.style.boxShadow='0 8px 25px rgba(0,0,0,0.5)'" onmouseout="this.style.transform='translateY(0)'; this.style.boxShadow='0 5px 20px rgba(0,0,0,0.4)'">
                            <h2 style="color: #ecf0f1; font-size: 1.6rem; margin-bottom: 15px; font-weight: 400; letter-spacing: 1px;">
                                Enter B.A.T.S. Documentation Tool
                            </h2>
                            <p style="color: #95a5a6; font-size: 1rem; margin-bottom: 25px; line-height: 1.6;">
                                Begin documenting your investigation with the official B.A.T.S. methodology
                            </p>
                            <button style="background: linear-gradient(135deg, #3498db 0%, #2980b9 100%); color: white; border: none; padding: 12px 35px; border-radius: 4px; font-size: 1rem; font-weight: 500; cursor: pointer; transition: all 0.2s ease; box-shadow: 0 2px 10px rgba(52, 152, 219, 0.3);" onmouseover="event.stopPropagation(); this.style.boxShadow='0 4px 15px rgba(52, 152, 219, 0.5)'" onmouseout="event.stopPropagation(); this.style.boxShadow='0 2px 10px rgba(52, 152, 219, 0.3)'">
                                Start Documentation
                            </button>
                        </div>

                        <!-- Utility Tools - Smaller Cards -->
                        <div style="margin-bottom: 30px;">
                            <h3 style="color: #7f8c8d; font-size: 0.9rem; text-transform: uppercase; letter-spacing: 2px; margin-bottom: 25px; text-align: center; font-weight: 400;">Utility Tools</h3>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;">
                                <!-- PK Converter Card -->
                                <div style="background: #2c3e50; border-radius: 6px; padding: 25px; border: 1px solid #34495e; cursor: pointer; transition: all 0.2s ease; text-align: center;" onclick="openPKConverter()" onmouseover="this.style.borderColor='#3498db'; this.style.transform='translateY(-2px)'; this.style.boxShadow='0 5px 15px rgba(0,0,0,0.3)'" onmouseout="this.style.borderColor='#34495e'; this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                                    <div style="font-size: 2rem; margin-bottom: 15px; filter: grayscale(30%);">🔑</div>
                                    <h3 style="color: #ecf0f1; margin-bottom: 10px; font-weight: 400;">Public Key Converter</h3>
                                    <p style="color: #95a5a6; font-size: 0.9rem; line-height: 1.5;">
                                        Convert public keys to addresses across Bitcoin, Ethereum, and other blockchains
                                    </p>
                                    <div style="margin-top: 15px; color: #3498db; font-weight: 500; font-size: 0.95rem;">Open Tool →</div>
                                </div>

                                <!-- Address Finder Card -->
                                <div style="background: #2c3e50; border-radius: 6px; padding: 25px; border: 1px solid #34495e; cursor: pointer; transition: all 0.2s ease; text-align: center;" onclick="openAddressFinder()" onmouseover="this.style.borderColor='#3498db'; this.style.transform='translateY(-2px)'; this.style.boxShadow='0 5px 15px rgba(0,0,0,0.3)'" onmouseout="this.style.borderColor='#34495e'; this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                                    <div style="font-size: 2rem; margin-bottom: 15px; filter: grayscale(30%);">🔍</div>
                                    <h3 style="color: #ecf0f1; margin-bottom: 10px; font-weight: 400;">Address Finder</h3>
                                    <p style="color: #95a5a6; font-size: 0.9rem; line-height: 1.5;">
                                        Search for addresses using partial information like first and last characters
                                    </p>
                                    <div style="margin-top: 15px; color: #3498db; font-weight: 500; font-size: 0.95rem;">Open Tool →</div>
                                </div>

                                <!-- Training Card -->
                                <div style="background: #2c3e50; border-radius: 6px; padding: 25px; border: 1px solid #34495e; cursor: pointer; transition: all 0.2s ease; text-align: center;" onclick="window.open('training.html', '_blank')" onmouseover="this.style.borderColor='#3498db'; this.style.transform='translateY(-2px)'; this.style.boxShadow='0 5px 15px rgba(0,0,0,0.3)'" onmouseout="this.style.borderColor='#34495e'; this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                                    <div style="font-size: 2rem; margin-bottom: 15px; filter: grayscale(30%);">📚</div>
                                    <h3 style="color: #ecf0f1; margin-bottom: 10px; font-weight: 400;">B.A.T.S. Training</h3>
                                    <p style="color: #95a5a6; font-size: 0.9rem; line-height: 1.5;">
                                        Access official training materials and certification for the B.A.T.S. methodology
                                    </p>
                                    <div style="margin-top: 15px; color: #3498db; font-weight: 500; font-size: 0.95rem;">Learn More →</div>
                                </div>
                            </div>
                        </div>

                        <!-- What BATS Does/Doesn't Do -->
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 30px; margin-bottom: 40px;">
                            <div style="background: #f0f9ff; border-radius: 12px; padding: 30px;">
                                <h3 style="color: #2c3e50; margin-bottom: 20px; display: flex; align-items: center; gap: 10px;">
                                    <span style="font-size: 24px;">✅</span> What B.A.T.S. Does
                                </h3>
                                <ul style="color: #666; line-height: 1.8; list-style: none; padding: 0;">
                                    <li style="margin-bottom: 10px;">• Provides structured documentation framework</li>
                                    <li style="margin-bottom: 10px;">• Ensures consistent notation (V-T-H system)</li>
                                    <li style="margin-bottom: 10px;">• Maintains chain of custody records</li>
                                    <li style="margin-bottom: 10px;">• Creates court-admissible reports</li>
                                    <li style="margin-bottom: 10px;">• Validates traced amounts (ART system)</li>
                                    <li>• Standardizes multi-investigator collaboration</li>
                                </ul>
                            </div>

                            <div style="background: #fff3e6; border-radius: 12px; padding: 30px;">
                                <h3 style="color: #2c3e50; margin-bottom: 20px; display: flex; align-items: center; gap: 10px;">
                                    <span style="font-size: 24px;">❌</span> What B.A.T.S. Doesn't Do
                                </h3>
                                <ul style="color: #666; line-height: 1.8; list-style: none; padding: 0;">
                                    <li style="margin-bottom: 10px;">• Perform automatic blockchain analysis</li>
                                    <li style="margin-bottom: 10px;">• Replace commercial tracing tools</li>
                                    <li style="margin-bottom: 10px;">• Make attribution decisions</li>
                                    <li style="margin-bottom: 10px;">• Identify wallet clusters automatically</li>
                                    <li style="margin-bottom: 10px;">• Provide risk scoring</li>
                                    <li>• Replace investigator expertise</li>
                                </ul>
                            </div>
                        </div>

                        <!-- Footer Section -->
                        <div style="text-align: center; padding: 30px 20px; color: #7f8c8d; font-size: 0.9rem; border-top: 1px solid #34495e; margin-top: 50px;">
                            <p style="margin-bottom: 10px;">
                                B.A.T.S. is a documentation standard for blockchain investigations
                            </p>
                            <p>For training and certification, visit <a href="training.html" target="_blank" style="color: #3498db; text-decoration: none;">B.A.T.S. Training</a></p>
                        </div>
                    </div>
                </div>

                <!-- BATS Info Tab -->

    </div>

    <!-- Main App Container -->
    <div id="appContainer" style="display: none;">
        <!-- App content stays here -->
    </div>

    <script>
        // Define utility functions early so they're available for onclick handlers
        window.openPKConverter = function() {
            const modal = document.getElementById('pkConverterModal');
            if (modal) {
                // Force display the modal
                modal.style.display = 'flex';
                modal.style.position = 'fixed';
                modal.style.zIndex = '10001';
                modal.style.top = '0';
                modal.style.left = '0';
                modal.style.width = '100%';
                modal.style.height = '100%';
                modal.style.backgroundColor = 'rgba(0,0,0,0.5)';
                modal.style.alignItems = 'center';
                modal.style.justifyContent = 'center';
            } else {
                console.error('PK Converter modal not found - will be available after page loads');
            }
        };

        window.openAddressFinder = function() {
            const modal = document.getElementById('addressFinderModal');
            if (modal) {
                // Force display the modal
                modal.style.display = 'flex';
                modal.style.position = 'fixed';
                modal.style.zIndex = '10001';
                modal.style.top = '0';
                modal.style.left = '0';
                modal.style.width = '100%';
                modal.style.height = '100%';
                modal.style.backgroundColor = 'rgba(0,0,0,0.5)';
                modal.style.alignItems = 'center';
                modal.style.justifyContent = 'center';
            } else {
                console.error('Address Finder modal not found - will be available after page loads');
            }
        };
    </script>

    <!-- Start of app content that goes in appContainer -->
    <div class="container">
        <div class="header">
            <div style="background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1); margin-right: 30px;">
                <img src="data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAA1gAAAD/CAYAAADsbndjAAAAAXNSR0IArs4c6QAAAARnQU1BAACxjwv8YQUAAAAJcEhZcwAADsMAAA7DAcdvqGQAAJUOSURBVHhe7N11eFRHF8Dh370rUSBBgzsUt+DBHYpTnBarUEqFr8UdihRoKW0pFG9xLxR3CVqkuLsTICFEVu/3xyYLuQmx3YQkzPs8t0+ZM1mXe3ZmzkiKoigIgiAIgiAIgiAIDpPVDYIgCIIgCIIgCELiiARLEARBEARBEATBSUSCJQiCIAiCIAiC4CQiwRIEQRAEQRAEQXASkWAJgiAIgiAIgiA4iUiwBEEQBEEQBEEQnEQkWIIgCIIgCIIgCE4iEixBEARBEARBEAQnEQmWIAiCIAiCIAiCk4gESxAEQRAEQRAEwUlEgiUIgiAIgiAIguAkIsESBEEQBEEQBEFwEpFgCYIgCIIgCIIgOIlIsARBEARBEARBEJxEJFiCIAiCIAiCIAhOIhIsQRAEQRAEQRAEJxEJliAIgiAIgiAIgpOIBEsQBEEQBEEQBMFJRIIlCIIgCIIgCILgJCLBEpzu2bNn/Pzzz2zfvl0dEgRBEARBEIQ0TSRYgtOYTCZWrFhB7dq1+frrr2nevDk9evTg8uXL6q6CIAiCIAiCkCZJiqIo6kZBSKgjR44wevRotm7ditVqjRLLkiULX375JX379sXb2ztKTBAEQRAEQRDSEpFgCQ65e/cuEydOZP78+YSGhqrDURQrVowRI0bQrl07tFqtOiwIgiAIgiAIqZ5IsIREefnyJXPmzGHy5Mncv39fHX4jSZJo0KABo0aNomrVquqwIAiCIAiCIKRqIsESEsRisbBx40bGjBnD8ePH1eF4c3Nz46OPPmLgwIHky5dPHRYEQRAEQRCEVEkkWEK8nTx5knHjxvH3339jsVjU4UTJkSMH33zzDZ988gnp06dXhwVBEARBEAQhVREJlhCn+/fv8+OPPzJ79mxevHihDkelcYfc7SF3JzA8hstTIPA/da9oypYty/Dhw2nRooVYnyUIgiAIgiCkWiLBEt4oNDSUhQsX8sMPP3Dz5k11OLqsdaHYCMhWy/ZvCQh/BtfnwuXJYHii/osoNBoNzZo1Y8SIEVSoUEEdFgRBEARBEIQUTyRYQjSKorBt2zZGjx7NoUOH1OHo0r0HRQdA3s6gcYHXq7RLEbutvbgOlybCzT/BanitQ3Senp707t2bb7/9lpw5c6rDgiAIgiAIgpBiiQRLiOL8+fOMGTOGNWvWYDKZ1OGodF5Q+Cso1BfcskBsy7Iit7QOOAxnh8LjXaoO0eXKlYuBAwfSs2dP3N3d1WFBEARBEARBSHFEgiUAEBAQwM8//8xvv/3G8+fP1eGoJI1tjVWxweBV3DZiFd9XkQxYTHBnGVwYC8FX1D2iqVSpEiNHjqRx48bIcmSmJgiCIAiCIAgpj0iw3nEGg4GlS5cyfvx4rlyJO9khYyUoMQ586oEkR50OmBAaIDwQrvwE136Pc32WVquldevWDB8+nFKlSqnDgiAIgiAIgpAiiATrHbZnzx7GjBnD7t271aHo3PNCsSGQpwvoPBKfWL0ucn1W0CW4MA7urgZLmLpXFF5eXnz22Wd8/fXXZMuWTR0WBEEQBEEQhLdKJFjvoCtXrjB+/HiWLl2KwRB7wQl0GSB/L1sRC/dsCZsOGF+Rs/4e7oCL38PjPaoO0RUsWJBBgwbRpUsX3Nzc1GFBEARBEARBeCtEgvUOefbsGTNmzGD69Ok8eRL7lDxkHWRvBsVHg3dpW1KV1K8UDWA2wK2/4OJEeHlN3SOaGjVqMHLkSOrWrYskSeqwIAiCIAiCICQrkWC9A0wmE6tXr2bs2LGcP39eHY7OuwIUGwY5Wzi2ziqxNEDoA7j6q+0wxb65sV6vp0OHDgwdOpSiRYuqw4IgCIIgCIKQbESClcYdOnSIUaNGsX37duJ8qt1yQNHvIH9v0HvGXnY9qUWuz3p+Bi5OslUdVGK/QRkzZqRfv358+eWXZMyYUR0WBEEQBEEQhCQnEqw06ubNm0yaNImFCxcSFhZ74Qg0brakqkh/SJcvadZZJZYMKFZ4sBXODoHAU+oe0RQpUoThw4fToUMHdDqdOiwIgiAIgiAISUYkWGnMixcvmD17NlOnTuXBgwfqcFSSDNmbw3uDIEuVlJVYqWkAYwjcXGBbnxV2V90jCkmSqFevHiNHjsTPz08dFgRBEARBEIQkIRKsNMJsNrNhwwbGjh3LyZMn1eHo0hezFbDI1cpW0CK511klRuS0wZCHcGki3JgH5mB1ryjc3Nzo2rUrgwYNokCBAuqwIAiCIAiCIDiVSLDSgOPHjzNmzBj++ecfrNY4MiWXrBHrrHqBq/fbXWeVWFLE8fRfuDAaHm4Fq0ndK4ps2bLxzTff8Omnn+Ll5aUOC4IgCIIgCIJTiAQrFbt79y5Tp05l7ty5BAfHPpKDxhXyfgTvDYR0+VP2dMD4kgGrFe6thQvfQ2DcI3elS5dm2LBhtG7dGq1Wqw4LgiAIgiAIgkNEgpUKhYSEMH/+fCZPnszt27fVYRUZstaGEmMhSzVbUxyDXKmOBjAGw/U/4PJPEHZP3SMKWZZp3LgxI0eOpFKlSuqwIAiCIAiCICSaSLBSEavVypYtWxg1ahTHjh1Th6NLVxSKj4TcH4CsTXuJ1esi12cF34DLU+HGfLCEqntF4eHhQY8ePRgwYAC5c+dWhwVBEARBEAQhwUSClUqcPXuW0aNHs3btWiyWOBZOuWSBAp9CkW/ANWPqXGeVWJGJ1uNDr9ZnxSFHjhwMGDCA3r174+HhoQ4LgiAIgiAIQryJBCuFe/ToEdOmTeP3338nKChIHY5K4wa5PoD3hoBX0bSxziqxNIDZAPf+hvNj4MU5dY9ofH19GTFiBM2aNUOWZXVYEARBEARBEOIkEqwUKjw8nL/++otJkyZx7do1dTi6zDWg+CjwqWv7d1qeDpgQGiD8GVybCZd/BONTdY8oNBoNLVu2ZPjw4ZQtW1YdFgRBEARBEIRYiQQrhVEUhZ07dzJmzBj279+vDkeXrggUHQC5O4Le492aDhhfkdMGg67ChTFwdwVYDOpeUWTIkIGPP/6Y/v37kz17dnVYEARBEARBEGIkEqwU5MKFC0yYMIHly5djNBrV4ai06aDQF1D4K3DP9m5PB4wvOeIxerwXzo+AgAOgxD7Ulz9/fgYOHMhHH32Eq6urOiwIgiAIgiAIUYgEK4UIDQ2levXqnDp1Sh2KStJArrZQbDh4lxSJVWLIgMUEtxfDxQkQfFndI5rVq1fTpk0bdbMgCIIgCIIgRCFW8qcQVquV0NDYy4rj7Qt+m6DKEvAqaZsOKJKrhLMCkg4KdIfaB+C9waD3VveKwmCIfUqhIAiCIAiCICASrJRFkiR1k41bbij/O9TZD7kagqwRRSycwQJ4ZIFy46H2fsjTGWS9uhfE9twIgiAIgiAIwmtEgpXSaT2g+loo8hnoXOHybLixDCSLePYcIQOKAS7PgpurIWMJqLYY8nZT9xQEQRAEQRCEeBOn6Cmd7AL6zLapgIGX4MxgONoJ/NvCs1O2MuRicCX+5MiNiPfDviZw4jPbYxoSYIvrvNR/IQiCIAiCIAjxJhKsFE95tdDqyrRX+zjd/xv21ISTAyDsoUi04iJF7In18gYc+xj2NYQnu22xl1fgxmzxbhAEQRAEQRAcJqoIphAvX77E19eXS5cuRQ3ovaH+CfDMZxuxujAG7q8H5bUNrzzyw3tDbNPbdC5iLyw1DWAIhmuz4MoUCH/0Kia72NZevTcEvArBiW/h8tTX/xqApUuX0rFjR3WzkEjBwcHcv38/Wde2KYpCunTpyJIlC7du3cJqjXkho6IoeHp6kjNnTnVIEARBEAQhTiLBSiHiTLA88tlGYRQr3PsHzo+CwJNR+2auASXGQLbatn/HfP747pAjH68NEY+XqgR+5poRj1ct278l4KRIsJLDmjVr6NKlCy4uLupQkgkPD6dNmzZMmjSJqlWr8uLFC2Q5+rClwWDg/fffZ+XKleqQIAiCIAhCnKKfXQgplxVQZMjdAmrvhdJTwCXbq3jAftjfCI72gOBr7+60wcjpgM9O29aqHWoTNbnyyA8V5kCtbeBTy/a4vuvJaDIzGo2Eh4cTFBSUbIfBYCAkJASLxUJQUBDBwcHR+gQFBREeHk5ISIj6JguCIAiCIMSLSLBSIwugSwfF/gf1jkD+j21T3QCsRri5AHZVgXMTwRRsSzbeBZGJVfgTODkQ9vjB/XW2USwArScUGWB7zAr1sj1mYjrlWxE5NVCSpGQ71Nen/re6XRAEQRAEITFEgpVaKZH7OOWFin9AzR2QJWKqG4AhAM4Oht3V4fbatF/WXRORXF6bb0suL/8A5uCIoAw5Wto2FS43CVyyiE2aBUEQBEEQhCSRlk+53w1KxPS2bH5Qcxv4zgePgq/iQWfgUDs40BqenUx70wYjy64/3At7G8K/PSHk+qt4hjJQdTVUXwMZy4jEKoWIXPqpKEqcR3yo/yamA3hjYQtBEARBEARnEUUuUoh4FbmIzzOlAUKfwOUf4frvYAp6FdN6QoFPocj/wCN7xJqu1/84FZEiEqsX1+HC93B7MVgNr+Iu2Wz3s+Cn4JI+flMBNaLIRXLZsWMHgwYNQq/Xq0NRKIrCmTNnCAkJiXXaXsmSJUmXLl2sCZnRaKR+/fp89tlnlC5dmuDg4BgvU1EUmjZtysaNG9UhQRAEQRCEOIkEK4VwWoLFa8nHszNwfnTEOqTXMgz3fPDeYMj3Iehc45d8pCQawPACrs20JZIGddn1rlBsCKQvkLAkUiRYyUZRlDhHkyRJwmg0UqlSJc6cOfPGZEij0bB//36qVq2KxRL7i1mj0XDt2jXKlSsXa4L1/vvvs2HDBsLDwwkMDCQgIIDHjx/z9OlTnj17hslksv+toijodDry5MlD6dKl413e/eXLl5w/f57Lly8TGBgY422JiaIouLq6kidPHkqUKBHv6xMEQRAEIXmIBCuFcGqCFclepnwjnB8ZQ1l3Pyg+Gnzq2v4d+/nu2ydjSxTvbrDdn6DTUeNZakHxMZCtpu3fCb0/IsFKcUwmE76+vpw+fTrGBCQywfL396dy5crqcIzik2Dlzp2b0qVLc+vWLQICAuzVBeP6uMyaNSvNmjVj0KBBFClSRB0GICgoiJkzZ7Jw4UKuXr2KyWRSd4kXSZLInDkzjRs35rvvvqNUqVLqLoIgCIIgvAViDVZaZi/r3hzq7IPSU8HV51U84AAcaAxHPoIXKbisuxRZdv0U+LeBw22jJlceBcB3nm0Nmk9NUXZdcIgkSdy9e5eNGzdy9uxZHj58SFhYGIqiRKs4qD4eP37M/PnzqV27Njt27FBfNLdu3bInYBcuXLCPhCXmUBSFJ0+e8Ndff1G7dm2xb5cgCIIgpBAiwXoXWCLWXxXrD3WPQIFPXivrboJbf9oq750dD6YXKaese2RiFf4YTn4He2rA/fWvlV1PB0UHQt3DULAHSPrUN91RSLHUCY0Uw2iXWmS/Bw8e0LNnT65ff1VwxWAw0Lt3b/z9/RN0mW/y+mU8e/aMjz/+mMOHD6u7CYIgCIKQzESC9a5QIsu65wHfWVBrJ2Sp8ypuDIBzQ2FXdbi9xtb5bb46NNiKVlydCzsrw+UpYH5pi0ky5GgFdQ5A2YngGlF2XRCSiBJDRcLYSJLEnTt3+P333+1ta9eujXFU63Xq61EfbyJJEkFBQUyaNEkdEgRBEAQhmb3NU+gUwWQysWLFCubNm0doaKg6nPYoEdPnslaHmlug4kLwLPQq/uIsHPoA/FvB0xPJP23QXnZ9D+xtAMd7Q+jNV3GvslB1LVRfDd6l34my6zdv3mTq1KkcPXpUHRKSUGyJzZva1Xbt2mVfY7VhwwaISIZioigKbm5ulClThipVqlC5cmX7UalSJXx8fOK8Tn9/f+7evatuFgRBEAQhGb3TCdaRI0do1aoVnTp1olevXjRs2JBt27bFWd0sTbBgm1JX4EOoewjeGwI6r4igFR78A3trwYn/QdiDpE+0IqcDBl+Doz1hfyMI2P8q7poNSk+G2vsgdwvb2rI0/jS9fPmSX375hZo1a/Ltt99Sv359/ve//3H//n11V8GJFEXBw8ODevXqMXDgQObNm8fq1atZu3Yta9euZd26daxcuZLOnTvHmfA8f/6csLAwgCjTBdUURUGr1TJnzhyOHz/O/v37OXDggP04dOgQBw8epHTp0rFe5/Pnz0WCJQiCIAhv2TuZYN26dYsvvviCevXqsWnTJntC5e/vT/PmzenWrRvnz59X/1naZAFcMkOZ76H2fsjVDiStLWZ+CVd+hF1V4cossIQlzfosDbb9us5NhF3V4OZ8sBojYq6Q/2OocwiKfQu6dGl+OqDVauWff/6hbt26fPnll9y5cweA4OBgfvzxR6pVq8aMGTMICQlR/6ngJH5+fuzYsYOJEyfSo0cP2rRpQ6tWrWjVqhUtW7akXbt2/PbbbxQuXDjWhCeSoihxjpD7+PjQuHFjNBoNWq02yiHLMvnz56datWrqP4vCarViMLy2H5wgCIIgCMnunUqwgoOD+emnn6hevTq//fZbjCeoRqORJUuWUKNGDUaMGMGTJ0/UXdKeyPVZ3iWh6gqotha8K7yKh96CE5/Zpuw92PlqGp+jZGxXfHsN7K4JZweD4fGreJbaUGMbVPwD0uV/J6YD/vfff7Rv357WrVtz7NgxdRgifiDo27cv9evXZ/Pmze/GiGsy02ji/iXBzc0Nd3d3dXOiaTSaOK9Xq4348SMWb5qCKAiCIAhC8nDGaXKKZ7FYWL9+PbVr16Z///7cu3dP3SWaZ8+eMXbsWPz8/Fi4cCFGY8SISlpmBRQJcr0PtfdAmR+jlnV/6g8HmsCRD+HF1cRPG7SXXT8J/q3h8AeqsusFwXcB1NwK2Wq8E2XXHz58yMCBA6lVqxarV6/GbDaru0Rz+PBhWrZsSefOnTl79qw6LDggvqNS8ekXX2FhYezZs4fdu3ezc+fOaMe+ffu4ffu2+s8EQRAEQUhh0nyCderUKdq1a0ebNm04ceKEOhyny5cv0717dxo1asS+ffvU4bQpsqz7e99A3aNQ4DNVWfe/Isq6f5+wsu72suuPbBv67qkBDza8KruuSw/vDYZ6h6HgR+9E2fXw8HD++OMPqlWrxg8//EBQUJC6S6xMJhPLly+nRo0aDBky5N0YcU2DJEniyZMntGrVirp161K/fv1oR61atVi/fr0YoRIEQRCEFC7NJlgPHjzg22+/pWbNmqxbtw6LJeYzdY1Wh0/OgmTPXRi9i5s6bLdnzx4aNGhAr169uHbtmjqc9tjLuueGir9Drd2Qte6ruPEpnBsGO6vCrVVxl3W3l12fAzsrweWpYI6YoilpIGcbqOMPZcbb1oTF/HSlGYqisGPHDurXr8+nn37KjRs31F0SJDAwkAkTJlClShXmzZsn1uGkUSK5EgRBEISUL7ZT4lQpNDSU33//nWrVqjF16lSCg4PVXezyFCzF16OX8sPCU/yw4CTfTVxH4eKV1d3sjEYj8+bNo1q1aowfP57nz5+ru6Q9kYlWlqpQYwtU/BM8C7+KB5+HIx3gQEt4ejz6tMHI9VoPdsPe+nD8Ywh9bZqTVzlb2fVqK8Gr5DuxzurChQt8+OGHNG3aFH9/f3U4Gu98fhRvMZPsZToja3TqcBTXr1+3V8TcvXu3OiykcK9vHhzTIQiCIAhCypdmEiyr1crWrVupX78+n3/+OTdvvrZ3kkoG76x07jORsTP3U7VuW3R6V7Q6F8pWacjI33bR+7sZZPbJo/4zu8ePHzN06FBq1KjB8uXL7fvcpGlWQNJBgW5Q9yC8N+xVWXfFCg83wp5acOIbCLtvS7Q02NZqHekOBxpDwIFXl+fqA6WnQp19kLv5O1F2PSAggFGjRuHn58eiRYvifN24ZyxA8Ra/U77bFnJX+ZSSbf+iTOe1eOWpqu4azb59+2jSpAndu3fn0qVL6rCQQkWu60rM8frfC4IgCILw9qSJBOvcuXN07tyZ5s2bc+jQIXXYTqd3pW6L3oyesZc23Qfi4uqB0WhEUawoihWT0YhGo6dJuz6MmbGPZh2+xtU9nfpi7CKvt0WLFrFeb5piL+s+FuocgFztX5V1t4TAlWm2UuuXZ8L5H2B3Nbi1MGrZ9QKfQt3DUKy/ba1XGp8OaDAYWLhwIX5+fowePZpnz56pu0ShdUlH3urfULHXfnJV/gxZ64rFaEKxWslStBkVum/nvfd/wdXrzT8CoLreMWPG8PTpU3UXIQXRaDT4+PiQPXv2RB2Rf+viErFeUhAEQRCEt0JSUvHPnY8fP2b69OnMmDEjzul6pSs1oHW3wZSoUAdFsWKJo0qbrNGg1Wq4fPYofy/+gaN71qJEFmOIgYeHBx999BEDBgwgb9686nCcXr58ia+vb/TRBr031D8BHvlS3tQ5GVAUuL8Jzo+C5/+qe0SVpS6UGA1Z/Wz3JaXdHw224huXp6ojLF26lI4dO6qb47Rv3z5Gjx7N7t274xxZkGQtWYu3Ir/fQNLn8kWxWlGsMWSfkoxGqyHs+R1uH57G3ePzMYfF/voHKFasGEOHDuWDDz5Ar9erwymSyWTC19eX06dPxzhFTlEUNBoN/v7+VK785um9r7t27RrlypUjODj4jZfZtGlTNm7cqA5FER4eTuXKlWO9bfnz5+fUqVOkS5eOsmXLxto3V65c7N27lwwZMiS49P7rl5khQwZ0utinkgqCIAiCkHRS5QiWwWBg/vz5+Pn58f3338eaXGXNUYC+wxYyaPIGSvrWwWwyxZlcAVgtFowGI4WKV+KbMcv4dsIaChWvpO5mFxISwowZM+K19ivNsJd1bxZR1n0auOZQ9wLPQlBxIdTcDNn8Iv5O3SltuXbtGr169aJRo0bs2rUrzuQqfY6ylO20mtLtl5E+py9Wsynm5ArblEyLyYRL+pwUbTKVij13kbV4K5BifztfuHCBbt268f7778dr7ZeQvBRFIUOGDGTKlIksWbIk6MicObP9EMmVIAiCILxdsZ+RpUB79uyhUaNG9OzZkytXrqjDdukyZKLTZ+P5fvYh6rz/IZIkYzIaE3xmbzYZsSoKlWu3ZPjP2+jZfzoZs+RUd7O7f/9+vKoXpikWQOsB731lm/qXofSrWN6PoN5RKPDhO1F2PbKaX7Vq1Zg3bx7h4eHqLlG4ZsjJe01/okKP3WQp1gLFqmC1xL42K5JitWAxmUjnU5YyHVZQrvMa0ucor+4WhaIobN++nQYNGvDJJ584XL1QiB9JkuLcJPj+/ftMnDiRCxcucOXKFS5fvhzr8d9//7Fjxw6WLVvG9OnTGTp06LtR4VQQBEEQUrhUk2BdvXqVHj160KhRI/bu3asO22k0Oqo36MS4Wf606zGYdOkzYTQY4xxBiJWiYDQY0bt60KxDP8bNOkizDt/EWtb91KlTtG3blrZt23Ly5El1OO2JrDaYLje4v5aA+tQDN+80n1iZzWZWrlxp34/q8ePH6i5RaHRu5KnSl0ofHyJv9a/R6tNhNZsS/AMAgNViQlEkshRviW/PXbzXbBou6bKru0URFhbG7NmzqVq1KpMnT+bFixfqLoKTRH725MqVSx2yi5ziN2XKFMqVK0e5cuUoX758rIevry8NGjSgU6dOfPXVV0yYMIH79++rL1oQBEEQhGSW4hOs58+fM27cOKpWrcqCBQswGiOKJcSgSMmqDJ22hS9HLSJ77sIYwo1Y3zTNKhEUqxVDuJFMWXPR45sfGT1jLxVrtopxTQURlQ3//vtvatWqRf/+/d+Nkx+rLSF99W9rYnKGVOXo0aO0aNGCjh07cvbsWXU4CkmSyVK0Gb699vDe+7/ikj4XFpMp1vV98aNgNZnQ6DzJU+0rKn1ykNyV+qDRuas7RvHo0SMGDBhAjRo1WLNmDeZ4TJ8VEqdRo0bqpmgkScJgMBASEhLnEflcRX7+yLL8xs8iQRAEQRCST4pNsIxGI0uWLMHPz4/hw4cTEBCg7mKXNUd++gyZy4hfdlLKty4WsyVJTxQtFrNtfVaxivT/fgVfj11O7gIl1N3sgoOD+emnn6hWrRq//fYbISERG+wKqdqtW7f44osvqFOnDps3b46zMEE6n9KU6biSMp3WkCFXpYh1Vs59nSqKFavJhGuGvBRrMYMKPXaQuUgTdbdoTp8+zQcffEDr1q05evSoOiw4QefOnfH19Y1zNF2991VchyAIgiAIKUuKTLAOHjxI8+bN6datG+fPn1eH7TzSefF+x28YO/MA9Vr0RKPRJmqdVWKZTEZQoHq9Dxgz8wCd+0wgQ8Zs6m52kSfk9erVi9cJuZAyRSbM1atX57fffiM0NFTdJQoXTx8K1RuLb8/dZC3RBiQ5Yjpg0lGsZqxmE165q1K28xpKtfuLdD6l1N2isFqt/PPPP9SrV4+vvvqKO3fuqLu8Feo9nl4/Xo8nhLMuMz6XE/n/Xl5eLFiwgNKlS0frF1/q63j9MqxWa4IvTxAEQRAE50tRCdaNGzfo06cPDRo0YNu2bW9MQDQaHVXqtGPE9J10//pHMmTM5vg6q0RSFAWj0YibmydtPhrEqN/2UKdZD/R6V3VXuyNHjtCyZUs6d+7MmTNn1GEhBZJl21tl3bp11KlTh/79+3Pv3j11tyg0OndyVuhJxd77KVB3GFqXDLbEKhlfp1aLCSQt2ct1xbfXXgo3+B6XdD7qblG8fPmS6dOnU716daZPn87Lly/VXZKNJEm4uLggyzKurq7RDhcXF1xdXe3PT3xIkoSrqyt6vT7a5bm62t638S1jH9tt02q1uLi4RBllKlGiBNu3b2fIkCHkz58fjUYTLVmK7ZAkCTc3N7JkyULWrFnJlSsXBQsWpHTp0tSpU4dMmTJFuX2CIAiCICS/FLEPVlBQEH/88Qc//vgjDx8+VIejKFKyKq26DaKC3/tIkoTZlLQjAQml0WrRyDKnj+3i78U/cObYjljXgXl5edG3b1969uxJ8+bNo4/YpeR9sGIiAfubwMMttn9XXAAFPkodRS5i2Qdr6NChXL9+nRUrVsRZGVKSZDIVrEf+WsPxzl8Dxao4fSpgYkiSjKzVEPL4Ejf2T+LB6SVYzQZ1t2gqVqzIiBEjaNKkCRqNRh1OUoqicPnyZcLCwmKdDle4cGHc3WNfbxbJaDRy6dKlN/6Ao0SUS8+fP786FEVct01RFFxcXChSpEiMj1tgYCDnzp3j1q1bb7yMSLIskyFDBry8vMiSJQteXl5IkoRer0ev1+Pm5oZOp4v1MgRBEARBSB5vNcGyWCz8/fffjBkzhv/++08djiKLT16ad/6OOs0+ws3dE6MxcRXXkotOr8diNnN49ypWzh3NvVsX1V2iyJ8/P8+ePSMoKChqQCRYySeWBEuj0cSZWAF4ZC5KgdrDyFayPbJWn+RTARNDkrVIEjy7vpsb+8bz9NquON9LGo2GVq1aMWLECEqXfq0MvyAIgiAIghDFW0uwjh8/zqhRo9i0adMbf0kGcHX3pGGrz2ja4Wuy+OTEaDA7oeJa8pAkCZ1eR9CzJ2xd8zubVk7nZdBTdbfYiQQr+cSSYMVF5+ZF3mrfkKtSX1w8M2ExmeNMWt4uCVmrxWo28vD0Eq7vGUfos7j3UEqfPj2fffYZ/fv3J1u2N683FARBEARBeFcle4J17949Jk+ezNy5c2Nd2yFJEuWqNaND79EUKl4ek8mCNR4jCCmRLGvQ6TXcvn6RVfNGc3jXKiyWeE4Z02eMSLDypuzz9UipOcHSASe+hUvxT7AkjY7spTuSz28Qnj7FUSxWlFimhKY4EdMGjcGPuXtsJrcOTsMU9lzdK5r8+fMzaNAgunXrhpvbm/eDEwRBEARBeNckW4IVEhLCvHnzmDx5cpzVyfIUKk373qMoX7UpWp0LZtOb975KTbRaHVbFwtnje1gxeziXzx5Wd4lOmw7qHIBMpSGeOVmMZGwjKmYTaPW2/aqSQnIkWBK2+2KJuC+Kg4NFUsTj8/w8/NsLnsXjeQG88lanYO0RZCxUH5BQ4ps0p0CSpEHSyrx8cJYb+yfy6OwKW4GMOPj5+TFixAjq168v1v8IgiAIgiAkR4JlsVjYsmULY8aMiXN/Ha9MPrTsOpA6zbrjmc4Lk8lEEt+8t8A2bTA8LAT/7ctYs2Acjx/cVHeKKt178N5QyNPellAkJFmJTB6Cb8PFiRCwFwp9CQU/dSwpeZOkTrAkwBwCZ4bA412QrycU/Bj0ngm/jsjHJuQxXP0Zrs0AU6C6VzTuGQuQr8ZAspfpgkbvgdWc0qcDxp+k0QEWnl3dwbXdowm8fUjdJRqdTkf79u0ZOnQoxYoVU4cFQRAEQRDeKUmaYJ0+fZpx48axbt06TLFU+3Nx9aBavfa06T6U7LkLYjaZY12XlRZIkoxOpyXg8T3WL57M3s0LCQmO7eRegmz1odgIyOpna4rrIdIAhmC4PhuuTIWw+7Z2SQOVFkO+DglPSuKS1AmWDJz42pYQRfIub3tccjQHWY77cSHisTGFw60lcGkivLyi7hGNzs2bPFX6kaviZ7ikz47VYk7WkuvJx7Y+y2II4cF/i7ixfxJhz2+oO0WTKVMm+vbtS79+/cicObM6LAiCIAiC8E5IkgTr4cOHTJs2jZkzZ0avivcaSZIp5VuPtj2GU7xcDaxWKxZz6p1mlRiyRoNGo+HO9XOsmjeGI3vWxL4+S+MGebrCe4MgfQFbMqF+BmXAaoF7f8P5MRAUQ4VGb1+ovR+0rtH/3hFJmWDJwPOzsKsKWEKixiQN+DSFEqMgY/k3TxuUsSVFj/bA+dG2Eb04yBodWd5rQYE6I0jnUxrFmsrWWSWWJCNrNBiCH3LLfyr3js/BFBbbjwA2RYsWZciQIXTo0AEXFxd1WBAEQRAEIU1zaoIVHh7OX3/9xYQJE7hxI/ZfvLPnLkK7nsOpVr8DWq0OkzFtrLNKLK1WB8CxA+tZ9+cErpw7ou4SlWs2KPwNFPwMXDLYEhgp4gg4ZkseHm2GN1Vc1LjbimdkKBq/EZ/4SsoESwNcXwjHuqsjr2g8IH8vKDoAPHO+SkAjpwMGXoaL38Od5WCNew+oDLkrU7D2CDIVboQkaeK1LimtkWQNkizz8tFZru8ezaPza+NMMCVJonbt2owaNYqaNWuqw4IgCIIgCGmW0xKsnTt3MnLkSPz9/dWhKDJ4Z6Nxu77Ub/kJ3pmz2fazcs5NSBN0ej1GQzh7N//JmvnjCHgce0EQMpSyTY/L3Q5C78HFCXBzPlhC1T2jSl8Sau8Bl0wxj/QkVlImWDLweD/sbxz3/XPLAUUGQoFe4OIBYc/hyq+2qYXGuEvlu6bPRf6aA8hRvhcavXuaWmeVWJJGC4qVgMubub5nDEF3j6m7ROPi4kKXLl0YOnQoBQoUUIcFQRAEQRDSHIcTrEuXLjFu3DiWL18e6zorjUZLjUZdaNN9GDnzFcJksGCN41fwd5UkyehdtDx+cId/lv7Irg3zCAt9oe72iqSFTNUh9AaE3lZHo9J6QL6IER73nM7PGZIywSLi8p/9C+dGwsPNcSc9GStBjtZwezG8OKuORqPRu5PL92PyVv8WV69cWM2WN48CvpMi1mcZQ7h/Yj439k8iPOiuulM0WbJk4ZtvvqFPnz54eXmpw4IgCIIgCGlGohOs58+f8/PPP/Prr7/y9GnsIwLFy9WkXY8RlKhQB+CdW2eVWBqNBo1Ww5Vz/7Jy3mhO+P+j7hJ/kgw+zaD4KMhcPua1W86Q1AkWr60xu7sOLoyNeY1ZAkmSRJZirchfYxAZcld6d9ZZJVbE/llhz25xy38K907Mw2KMY1QRKFmyJMOGDaNdu3ZoNBp1WBAEQRCEt8xsNmMwxL2MIi6urq7v7Hd9ohOsH3/8kf/973/q5ih8chakbY/hVKnTDld3j3d+nVViaXU6zCYDxw9sZOW8Udy+FvdITBRe5aD4SMjxPsga5665UkuOBCuSBjC8sFVJvDwVwh+oe8RLOp/SFKg9nCzFWiLJOpR3cJ1VYkWuzwq6c5hru0bz9Oo2lDhG/Nzc3Dhy5AilSpVSh3j58iUBAQGpYk8tvV6Pu7s7Hh4eaLVaddghiqLw4MEDjEZjoh8LRVHw8PAgS5Ys6pCQRoWEhPDkyZNEv2YiZcuWDVdXV3Wz4ABnvKfVsmbNKjZ6f0c8ePAAg8GQ6NeOoii4u7uTNWtWdShGO3bs4Isvvkj0d1tkajF79myqVaumDr8TEp1gTZgwgSFDhqibAXD3zEC9Fr1p0flbvDP7YDKa4zzpEmInSbb9s4IDn7F743zWL55M4LNH6m5RueWEIt9Cgd6J2ycqMZIzwSLi+mQg+BZc+gFuLoh7fVYEF08f8tX4lhzle6Jz8xbrrBwga3RYLQaeXFzPtd1jePnozT8C6HQ6jhw5Qrly5dQh/vrrLz755JNUcXLn6uqKp6cn3t7e5MqVi6JFi1KuXDnKlStHgQIFHPrVLjQ0lLp163L27Fl0OlsBnIQKDw+nY8eOzJ8/Xx0S0qi1a9fSrVu3RL9mFEVBkiTWr19PjRo11GHBAWfOnKFJkyYEBwcjy7I6nGAGg4GRI0cycOBAdUhIY6xWKw0aNODw4cPo9Xp1OF4MBgNNmjRh9erV6lCMVq9eTbt27dTNCbZ161YaNmyobn4nJDrBmjhxIoMHD1Y3U6H6+3TuM4G8BUtitYLFkhY3C347JEmKKOsu8/DuDdYvnszO9bOjl3XXuEP+3lD0W/DMnXTTAWOS3AlWJDniup/EXUFRo3Mje5ku5K85GPfMBbCaLOIHAGeQJDQ6LaaQ59z9dzY3/adifPlY3Qu9Xs+RI0coW7asOsTcuXPp3bu3ujlVyZAhA+XKlaNt27a0a9cOHx8fdZc4hYaG4uvry4ULF9ShBPnggw9YsWKFullIo5YvX07Hjh3VzQm2a9cu6tSxTekXnOPrr7/m559f27/RCQoXLsyhQ4fIlCmTOiSkIVarlSpVqnDsWNyFpWLTsGFDtm7dqm6O0dq1a2nTpo1DI2YA27Zto0GDBurwO8Hxn1Fek94rC58O+oM8BUtiNpt5EfQEi8WEVpe4jFuIJEVUFwwlJDgQk9FM1hz5+OjLKfjkKqzuDHk6g+/P4J7bltgkV3L1Nlmx3dfMFcHvb9tGyrr06l7IGj2l2y+jeKvZuHrlJTzwIZJGRpISP9og2AqzyBot4YEPkfXpyF9zAL7dd+CaIZe6a7xIkpRqj6CgIPbs2UO/fv2oWLEiP/zwAyEhqn3b4kGK+GJTX358j9cvQ3g3iNdMynT79m2WL18ODjw3MR1XrlyJ94iEkLpJ4r2d6jg1wdJotUiyBqvFitVqZcb3PZk0oCVXzx9D76JHo0ncXM53mVarRavT8t+RHYz+oh5Lfh+MVqvFYrZgsVhifsNo3N680W5aZ8W26XCuluCaUx1F1rnhmb0skgyBd45w5I8qXN05BrMhCI1OBzE9nkIsJDQ6HWbjS67t/p4jsyoTeOsACuCWsSA6N2/1H6R5r3+p3b17l4EDB9KwYUMuXbqk7ioIwjtg0aJFPHz4MObvawfNnj2bsLAwdbMgpDomk4mgoKBEH+YUVkDPqQmWotj+o9HJHNi2hBP+/3Dm2A5G96vD/J++4XnAffQueiTJqVebJsmyBr2Lnnu3r/Dr2O5M/LYp1y8dZ8+mhfx3dDtanTYif4ohixJTMiMKecT0OChgtWAxGLm+ezThgbe4vnsUR2dX5/5/y0FRkDWJW7/wrpE1OpDgwZnVHJtTg2s7hxEedJtru0djDg9BUazv/PTgyETr4MGDNGvWjNOnT6u7CIKQhj179oyFCxeqm53m33//ZfPmzepmQUh1/vrrL4oWLUrp0qUTdJQqVYoyZcrw77//qi/yrUqSTMdqgVtXX5XONoSFsHH5NIZ95seW1b9jNhvQ6fXYFs0Ir5MkCb2LntCQQFbN+56RfWqwb/OfmM22ynZWi5nb12wnaeLRSyRJxhD8gPDAV3uGhTy5wJmVnTm1pBWBd44ga3VIshhxjYkka5C1OoLuHee/pW05s7wDLx+dsccNQXcxvLgnpl2+RpIkrl27RteuXbl//746LAhCGrVmzRouX76cJKNXkZc5a9asd/7HLCH18/f359GjR9y+fTtBx507d7h16xbh4eHqi3yrnJ5gKREL8jr3mci3E9aQr/CrSmEBD28xZ/LnjPuqIacOb0Oj1aDRitGCSJFr1Q5sW87Iz2uz7I9hvAh8Yo8XL1+b4dO30+SDLzGbzTGOzwhxU6xm3Lzz4ttzN/lrDkbrGrHxrWIl4PImji+ox8V/viI86A6yTidGXCNJMrJOhyH4AZc2f8vx+XV4cnE9imKrYKJ1SU/e6t/i22sP7pkKo1hT1nD92yZJEmfOnGHEiBHqkCAIaVB4eDizZ89WNzvdrl272L9/v7pZEFINs9nMuXPnIBHrzABkWU6SHzEckTRnjoqCLMtUqd2akb/upOvnk/DK9KqS1qUzB5k0oDm/je3OvZsX0bvonVK2NLXSaLTo9HqunDvK5EGt+XlkZ+5cf1XmOlvOgnw6aA5Dpm6iZIU6EVMxo1yEkECKoqD3zErhhuOp2HMP2Uq0tY9YWYwh3D48nWNzanD74G9YzGHIWt07PWYoa3UoFgN3jszi2Jwa3PKfitkQDIAkachSrCW+PXZTtMlkXNJlF1UZY7F48WIOHjyobhYEIY3ZunUrR48eVTc7lSRJmM1mZs2apQ4JQqrx8OFDrl+/rm5O1ZIsq1EUBaPRiKt7Olp9OIDRM/ZRt3kvdHrb/jZmk5F9W/5iZN9arJw7jpCXQRHrs96dk1hJktG76Hn25B7zp33D2K/qceLgRvvJqbtHBlp2HcCYGfto0KoXGo0uYrNmkV05g2K1YDWb8MxehtLtl1Om4yrS5Shvj4cH3ebixi84vqAhAZe3Ism2SnnvEkmjRdJoeXp1J8cXNubC+s8Ie37DHk/nU4bSHZZTtuMq0ucsj9VsQrEmdU3+1EuSJMLDw5k7d646JAhCGjNz5kx4bSpfUlq/fj1nz755/0FBSMmuXr1KQECAujlVS7IEK5JitWI0GPHJVZDPBs9myI+bKV6+tj0eHPiE5bOHM/LzWuzfZitjqkvzZd1tZdfNpnC2rPqd4X1qsGn5NMJDX0JEgYtKtVoz8tfddOs7iQyZsmE0GMWoQBJRIvZqy1q8Jb49d1Ok8RRc0mW3x4PuHOLkouacWfUhLx9ftE0bTOMjrlLEdMDQgCucW92Dk381JfDWqykottG/ifj22kO2km1RFLBabOsEhbjt2LGDJ09eTf8VBCFtOXDgADt27FA3JwlJknj58mWyTEcU3g1Wq+18U1GURB3qy4nLmTNnUCI2Ok8rku0s0WI2YzaZKVmhNkN/3EyfIXPJlrOgPX73xjmmj+zEDwNbcvncEXQuemRN2lskr4kou37q8DbGftWQOVM+J+DhLXs8X+Gy/G/8Kvp/v4L8RctiNBqxWsSIQNJTsJpNaHQe5KvxPyp+7E8u30+RtbYRV8Vq4uHpxRyb48e1HaMxhQWm0bLuErJOh9nwguu7vufYbD/un1qI1WIEQNa4kLN8Tyr19id/rYFo9emxmk0pclRV/YHv6OFMt2/f5syZV4VBBEFIW2bOnInZbE7WE8Zly5Zx+/ar4k2CkFgZM2akXLly+Pr6JuqoUKECFSpUwMsrYo17HE6dOqVuSvUkJZFnDhMnTmTw4MFR2rwyZeeHhSdJnyEz1limCUmShE6v49mTh2xc/hPb1s4kLOSFPe7i6kG9Fr1p3vl/ZPHJjclkRolnFpxSybIGrU7DnRsXWbNwPAd3LMMSURkQIEPGbLzfsT8NWn+KZ7oMGA2xn7RKkozRGMbQ3pW5e/NC1GDBL8D3F9vGu8lNAvY3gYdbbP+uuAAKfJS8t0UCzGGwozwEX4wS0rqmp0qfE7h5F4i1CIMka5Fkiec39nNt10ie3dgdJe6RpRgFao8gW8k2yBp9RJKRuskaHYrVzKML67i+azQvH0edbuKVtwaF6o4hY4HatqQjlscPScZqCuXo7Gq8fBT1cvR6PUeOHKFs2bJR2gHmzp1L7969HTopURSFHDlyUKtWrXj/evYmVquVhw8fcuHCBfv0BUduWyRFUfj555/58ssv1SEAQkNDqVixIufPn0/09SmKQvv27e0bnApp34oVK+jQoYNDrxlJkti5cyd16tRRh4V4OnfuHFWqVOHly5eJfi4SQ1EUvv/+e4YMGaIOCamY1WqlatWqHD16NNGvJ0VRaNSoEVu2RJybxUFRFIe/P4ln8Qmz2Uz16tUTff+UiLoPu3btolatWurwW5NsI1ivUxQFo8FIeu8sdOs7iVG/7aFSrTbIsm3EyhAewqYVPzP8Uz82r5yByRieasu6SxFl10NeBrJi7lhGfObH/i1/2ZMrnd6Vus17M3bmAVp/OABXVw+MBrHO6m1TrGasZhPe+WtQ/sPNlGizAPdMhe3xkCcXOLOqMycXtSTwduou6/6q7Pq/nFzSmtPLO0RJrtwyFqB4qzlU6L6VjAVrY7WYYk+uUoDy5cuzZMkSli1b5tCxYsUK9u7dy6lTp5gwYQLp06d32mhWWlvQKwiCzZw5c5I9uYq0YMECnj17pm4WhASRJAmNRuPwEZ/3wIMHD7h27Zq6OdV7KyNYalqdDqvVwvEDG1k1bzQ3Lp+MEi9Ssirteo6gTOWGgBRl5Ccl0+r0WEwGDu9Zw5oF33Pnhq0EZaSSFerQrscIipevhaIoWBKwC3WsI1iFvgTfnyH+F+c8aWQEKwpJQqPVEv7iEbcPTefu0d8xhT+3hzU6d3KU70U+v29x886DYrGkjvVykoSs0RIeeJdbB3/k7r+zsRht6wABtC4ZyFXxU/JW+xrXDNmxmC0Q3/v1lkewmjVrxj///KMOOWzFihV07twZi8Xi8G3s3LkzixcvVocghY9gKYrCgwcPOHPmDGfPnuXmzZs8evSIkJAQdVenUxQFvV5P5syZyZ07N8WKFaNUqVIULFgQvT551u5arVYMBoNTft11lKurK5rXptKnxBGssLAwhx+ryNvl4eGhDqU4d+7coVKlSjx8+DDRz4MjFEVh1qxZfPLJJ+qQQ5zxPGo0GlxdbdPuHWU2mzEYDOrmBFO/hxxhNBoxmZx7fipJEhaLhTp16nD8+PFEv6YSOoKVFMLCwggMDIxyH/R6PXv27KFdu3b293lCRY5grVq1ilq1amE02pY0xEZRFFxdXfH29laHnCZFJFhgO9nT6XS8fBHIzg2z+WfpTwQ+fWAPa7Q6qtXrQOsPB5OnYHHMJkvCryOZaDRaZI3M5bOHWT1/LCcPbYlywu2TsyCtPhyCX8NOuLi4YTLF/WJQizXB8mkKVVeA3iN5ExtSSIIlA+YQ2F4Bgi9FCSUqwYogyRokWebFg/+4sed7Hl9YG+UyXDPkJp/fAHKU747WxROr2ZxCRyIlZK0WsyGEB6f+4sb+SYQH3nwVlTRkea8FBWoPI33O8ihWa8IrA6bRBAugadOmbN682eHbGFvykxITrKCgINavX8+KFSs4evQoT548IZFfH07l4eFBiRIlaN68OR07dqRQoULqLommKAq3bt3i33//5cSJE1y9epX79+/z4sULh082HRF5IrJo0aIo76OUlmAdPnyYPn36YDQaE32bAAwGA+PHj+eDDz5Qh1KcyHMjR+6vIxRFoWLFiuzduxc3Nzd1OFHMZjOdOnXi9OnT6HSJ27vUYDDQsGFDfvvtN3UoUTZu3Mg333yT6B9WIk/KFyxYQIUKFdThOIWEhHD27FmOHj3K2bNnuXXrFgEBAUm22e2NGzcIDQ1N9OsqJSRYq1at4uOPP47ynEmSRFhYGC9evEj0fYvk5eWFXq+P1/eSwWDg/fffZ9GiReqQ06ScBCuCJMvodFru377K+sWT2bflL4yGMHs8XYbMNG73BY3bfk6GjFkwGW0V4FICSZLR6bU8fnCbDUumsvufuYSHvfpV190zAw1b96Fp+y/JmCU7JqM50SMdsSZYAN7l4L3hkKslSDIk7moS7m0mWFJEcvXyLlz+Ea79CtaovyY5kmBFsq1VsvDk8iau7x7Di/v/RolnyF2FArVHkLlwI5AkFEviricpSBotoPD06k6u7x5D4O0DUeLpspelQO0RZHmvObKsTXxlwDScYE2ePJkBAwY4fBtjS35SUoJlsVhYunQp48eP58KFqJ81ib1tzvT657+3tze9evXiu+++I2vWrFH6JUR4eDgbN25kwYIFHDx4MMVOuTpw4ADVq1e3/zslJViBgYE0atTIKftANWzYkL///ttpox9J5fnz51SpUoXLly8n+jlwVOT7YfXq1bRp00YdThSTyUTlypU5eTLq7KKEcubn8uLFi+natau6OUEkSWLPnj3UrFlTHXqja9eusXDhQtasWcPly5edPmL1Jo6+ntQJlqIonDx5ksDAwCTdh7ZMmTL2UaJFixbRrVs3dRdwwv1D9V0QH858PcYk6R7VRIos654tZwE+GTiTIT9upmSFuvZ4cFAAK+eOYuTntdm3dSmKYkX71su628qum4zhbF75GyM+82Pzyun25ErWaKhcuw2jft1D174TSO+dNenLrj8/CYfbw4EW8OyE7Zl2/PWbcmkiRq0u/wa7/eDKT9GSK2exRpZ1L9Yc3567KNLkR1zS5bDHg+4c5tTiFpxZ1ZWQxxci1me93beaJMnIWh0hTy5zdnV3Ti56P0pypffMRuFGP+Dbcw/ZSrQGUXb9jbJkyaJuShRn/bqclJ48eUK3bt348MMPuXDhApIkRTlSgtdvz/Pnz5kyZQq1a9fmwIGoPx7E1+7du6lXrx7t2rXjn3/+4dmzZ9Hu99s+eO1+p1SjRo2yL1pP7AGQM2dOpk+fnuKTK8B+0u3o85LQE8XXRV73H3/84dDlqEWehKufo/ger1+GM0Repvp64nu8/rfxERwczMiRI6lcuTJjx47l3LlzmEymaJebVIezKYpCv379qFevHnXr1nX6UadOHerUqcO//0b9AZo3PGfOoL7M2I7I/knJea92J4ss616ifC0GT93I50Pn45PrtbLuN8/zy6gu/DCwFVfOHkav16N5C5vAarU6tFoNJw9tZdzXDZg79QsCHt2xx/MXKcf/xq/mm7HLyVekDEZDMpZdV8zwYCPsqQ3/fgahd22JSNK+plSS+MrkiOPeZthXH05+AaGvyt4nnciy7u7k8/vGVta94mevlXU38/D0Uo7O8ePqzlGYwp6/nbLukoRGp8NsCOLa7nEcm+PHg1N/oUSWXde6kLNCbyp97E/+mt+h1Xum2LLrKYWzPpTz5s2rbkpRHjx4QJs2bVi6dCk48X4npcgvzwsXLtCiRQs2b96s7vJGVquV8ePH07RpUw4ePBjty1iIvzVr1vDrr7+qmxMkcjRt4sSJFC1aVB1OccLDwx3eh0pRFFxcXMicObPDydGuXbsS/SODENWVK1do0qQJY8aM4enTp2nmsyHyNabEsC2Jo4eQghMsGwWT0Ygsa6jbvDvjZh6kVbdBuHtksEUVhVOHtzC6X13mTv2SZ0/uoXfRJ8togSxr0LvouXfrItNHf8ikAc25fPawPe6V0YeufScz6rc9VK7VEquiYE6moeRozMFwfRbsrAyXZ9hGepyzpjMqKeIVFeXNZU2669IAgefgUAc42Aqevnr8k4uiWLGaTLh55aV4y9+p0H0HGQvUs8fNYc+5vns0x2bX4P6ppaBYkbWJm8OeULbrUXhweiVH59Tk2s7hmEJf7ZTuna8W5T/cSonWs3HzLoDVZEraUdU0wllfHiVLllQ3pRihoaH06NGDAwcOpMqTCCliNKtbt24cO3ZMHY5GURS+++47hg4dSnh4eKq8zynFzZs36d+/v8OFYAB69uzp8DSw5LJlyxaOHDmibk6wGjVqMHToUHVzgkiShMlkYtasWeqQkEDnz5+nSZMm+Pv7p4mk6nWR9+X1hNFZh5DiEywbJaKsu6dXJrr2ncDoGXupUqctcsSIldEQxuZVvzDs0+psWvHra2XdnU+yl11/zoo5Yxj+mR8Hti2OUna9XouPGTfLn1bdvsXF1d1Wdt1JJ2UOCb8PJ/vCnppwbxNIFue9AjSA4SmcHgVP/V+1X54GtzeDpDj5ugLgv0G2+3JnBVgTXijEmexl3fNVp3y3jZRssxD3TEXs8ZCAi5xZ2YWTi1oQeOtQkpZ1t5ddv3OUU4tbc3pFR0Iev6pg6ZaxIMVbzaX8R5vJWKAWVrM50evR3kX3799XNyWIoihkypSJihUrqkMpxpQpU9i6dWuq/qKUJImnT5/y1VdfxVnhcNq0afz444+QSkbqUiqz2Uz//v25deuWQ4+joiiULFmS77//Xh1KkZSIyn044fXTuXNnPvzwQ3x8fBz+MWfDhg1iQ3MHBAQE8OGHH3Lt2jWHn1fh3eOsU95kYbVYMBqM5C1Umq/HLON/41dRoOir6i9PH99h3o/9GPdVA04c3IxGo0HrxNECnU6PoljZt2UJIz+vxYo5I3n54tXi55IV6jL0py18OmgWWbLns00HfAuVpuL8IHh+AvxbwOGu8PyUY9MGNYBihOt/we7qcGE0mF+V+iboP9t1HeoAz884dl0yoBjg2jzbaNzFSWBMWYvPrWYTSBpyVPiQir33k7/WULSukWVAFZ5e3crxBfW5sKEf4UF3kHU6WxESZ5BkZJ0Ow4v7XNz4Df/Or0fA5Y320upal/TkqzGASr0PkKtiTyRZJ6YDJpDFYmHbtm3q5gSrX78++fLlUzenCNeuXWP69Onq5lRJkiQOHTrEX3/9pQ7ZnTp1ijFjxkB8PjuFWP3yyy+sXbtW3ZwgiqLg5ubGjz/+SLZs2dThFOnAgQPs3LlT3ZwgiqKQO3dumjZtSsaMGWnRooW6S4JIksSLFy+YN2+eOiTE07hx4xwqjS6825x0Zpe8zGZbkYFKNVsy4peddOs3Be/M2e3xy2cP88PAlvwy5kPu3DiP3kVv38Q4MTQaLTqdnktnDzF5YGt+Gd2VuzfO2+PZcxemz5B5DJryDyXK18JsMmF5i5XjWrZsyWeffYaLi4s69IpigTvLYHct+G8whN1LWPITufbp0X7Y3xSOfRStJLqdYoa7K2FPDTg1CMIfJ/y6JAUe7oa9deHf3hAS+yat+fPnJ0MG21TS5KdgNZnQe2SmcINxVOy1l2wl29tHrCymUO4c+ZWjs6tzy386VlNoxHS++D4gahKyVofVHMbtwzM4OseP24em2fe0kmQNWYu3wbfXXoo0moTeMytWkylljKqmMrNmzWLv3r3q5niLPHn84osv1KEUY8mSJfZ1BmnFvHnz3rhnzk8//RRtbxYh4Y4cOeK0RPXbb7+lQYMG6uYUa9asWfaCB45o06aNvfpl165d0el0Do9iLVu2jNu3b6ubhTicPn1aJKeCQ1JlgkXEiYrJaMTFzYOWXf7HmN8P0KDVp+hdbJW5LGYTB7YtYVTfWiz7YyQvg5/Z1mcl4ANQkmT0LnqePr7D3B+/ZNxXDTh5eLP9A8/D04vWHw5m9Ix91GvRA41GhykeG5wltTx58vD777+zefNmateurQ5HZX4BFyfC7hpwZSZYwmJfMyVFjFq9uAZHe8O+hvB4Z/xGQUxBcGkS7KoKV2eDJTye13UJjvWEA40h4GCs15UhQwYGDx7Mzp07yZUrlzqcrBSrBavZRDqfUpRuv4QyndaSPueraWGGF3e5tOkrji9owJOLm5BkKaKMevxJshZJlgm4vJXjCxpxcUNfwgNfFflIn6M8pTusokyH5aTPXhar2ZTwPa1SoYS8z2NjtVoJCQnh1KlTfPHFF/Tv3x8cvPx+/frh5+enbk4RzGZzkpatfVv+++8/Tp8+rW7m2rVrrF+/Xt0sJFBgYCBff/21w4mqoijUrl2bQYMGqUMp1tmzZx1+DSkRm56+vt6satWqVKtWLUq/hJIkiYcPHybpXj9p1dKlSwkODnbo9Sy821JtghUpsqx71hz5+HjA7wz9aQulfF8VGQgOesqqeWMY+Xkt9m1ZgqJY0cVV1l2KKLtuCmfTil8Z3qcGW1b98lrZdS1V6rRj5G976NJnPOm9siR92fUEiJyWWKdOHTZv3sy8efPi3nwz5Aac6AP7G8P9ba9GqF6niUiSzk2E3dXg5lywJmJTvZDrcPwT2NcAHux883UZnsDZcbCrGtxcEOs6K61WS7t27di3bx/jx4/Hx8fnrUzPjInVYkKxKmQt9j6+PXZQpMlPuKTLaY8H3T3CqSWtOLOyKy8fnUfW6ZDiGHGVZA2yTkdIwEXOrv6Ik4tbEHTnoD2u9/ShcKPJVOixi2wlWqG8Y2XXjx49SvPmzWnWrFmij0aNGlG7dm18fX2pVq0av/32m0MbpiqKQqtWrRg5cqQ6lGLcvn2bS5feMBKdQEoMlaUSczhKkiSMRmOM+zHt3bvX4aRAgNGjR3P48GGHHkclYm3itGnTcHd3V4dTrLlz5zrlRLxmzZr4+vra/63Vap1W4GPBggU8f/5c3Sy8gcFgcMpUcCFm6s94Z3zO84bLfdMR2T8pqU9rU63Isu7Fy9Vk0JR/6DtsAdlzF7bH7928wC+juzJpQEsunTmE7g1l3bVaHRqNhhMHNzPmy/rM+7EfT18ru16gaAW+Hb+Gr8cuI1/h0hiNxkRvqpwcXF1d6dGjBwcPHmTo0KF4eXmpu0T1ZB/4N4fDnSHwvC3R0QCY4eYK2x5TZweD4bH6LxMu4AAcaGpbCxZ0Kep13VhsW9N1bnic66wqVarE33//zfLlyyldurQ6nEJElnX3IJ/f11T62J9clT5H1tlGXBWriYdnlvHv3Bpc3T4CU9gz2/qsaNMGJWSdDlN4INd2juXYnBo8+G+Rquz6xxFl1799J8uuS5LEkydP+Oeff9i0aVOij23btrF//34uXrxIWFhYok+gIj/QW7duzbx581L0yeOtW7cICgpSNyeYoii4u7tTv359+vTpwxdffJGgo1+/frRv356cOXM67UswpsTx8GHnVR5Vf4En5fH69b1ta9eudUpJdoCxY8dSpkwZdTjFunv3LsuWLVM3J8qHH36obqJFixbkzZvXoedZkiSuXLnC6tWr1SHhDW7fvs21a9fUzYmifu8m9kgL0sr9iC9JSeQ9njhxIoMHD47S5pUpOz8sPEn6DJnfatIhSRI6vY7Ap4/ZuPxntq75jdCXr04a9C5u1Hm/Jy27DiBr9jyYjGYkSUKr03D72nlWLxjH4V0ro6yj8sqUneadv6V+i954pEuP0fB2T1olScZoDGNo78rcvXkhSuyLL77gl19+idIW6fz584wZM4bVq1djNsexTkzvDUX6Q+bacHE8PNwSr/vs4p6BIr6tCXx8lTuXDsTnT0DnDYX7Q+Yqtk2CH2xS94gmV65cDBw4kJ49e0Y7aQ0LC6NChQpcuBD1sdG6pqdKnxO4eRd4q5XzbFP7JAJvHeLqrhE8uxZ1mqV7piIUqDMCn5IfIGv0WC0mZI0Oq9XEo3NruL57NCFPot437/x1KFR3NN75a6BYlbd6/5BkrKZQjs6uxstHZ6OE9Ho9R44coWzZslHaifg1uHfv3olOZlKSyI9WFxcX+vfvz4gRI+K9WWpoaCgVK1bk/PnziX4sFEWhffv2LF++XB16o+XLl9OxY8dEXycR15sjRw6WLFlCrVq11OEEefToET179mTTpk0O36YOHTpEOxlu0KABO3bscPiyNRoNNWvWpH79+nh7eyfbiUSbNm3w8fGx/3vFihV06NAh0fdHidh7aufOndSpU0cdjubWrVvUrl2bmzdvJvo6ee35WbJkiVM3o01qkedBjt73woULc/jwYTJmzKgO079/f3766SeHr8PX15cDBw7Evjb7DUwmE1WrVnWo4IOiKDRv3tzh6ZSRlixZQpcuXRy6PbIss2fPHmrUqBEltnv3burWrQsOTgdXFAUfHx9atmxJyZIl0Wg0Cf5skCQJq9XKlClTHHqfKYpCo0aN2LJlC0TMdPLz8+PQoUPqrnaJvS5e+/7btm2bfT3l3bt3OXbsWJT3uF6vZ9euXUyZMiXR1xf5XI4dO5ayZctiiseWSFarlezZs1OlShV1yGnSZIIVSZY1aHUablw+zer5Yzm6bx3W15KmTFly0qLrQOq+3xOTMZzNq35h88pfolQG1OldqdXkQ1p2HUj23AUwmcwoKWDqWWITLCJejFu3brVP64idBJLGVqgiDrJGS6Fy71O11TB88lfAFB7C+YOLOLJxMs8fxvPXIEm2V717Ew8PD3r16sV33333xnVWKT3BiiRrdFgtBh6eWcn1veMIDXj9V3aJTAUbULDuKDLkqcqLu0e5tmsUAVeiJrruGQuRv9YQfEp3QqNzjRixesve8QRLURTSp09P7dq1GTBgANWrV1d3idXbSrAWLlxI9+7dE32dRFzv1KlT7evVHHX+/HkqV67My5cvE327lIgRxDVr1tjbLBYLVapU4d9//3Xocon4Phw4cKA6nOySM8GyWCy0b9+eNWvWJPr6iLjOAgUKsHv3bvLkyaMOp1iBgYFUrlyZy5cvO3z/hwwZ8saS9P/++y81a9Z0eBSdiNHGVq1aqcNxetcSrDVr1tC2bdtEXzYRl//ee++xfv16Chd+NZsqMaxWK9WqVePIkSOJvk1KDAlWgwYNOHDgAPoYtjUym81vLAwUH5GvudcTrDdx9Ie9yOdy9+7d1KxZUx1+a1LPT0WJYLVGlnUvxTdjl/HthDUUfO/VHOenT+4x/6cvGd2vLiP71mbl3NFRy6771mPYtK18OnAWWXPYyq6nhOTKUZIk0bhxY3bu3MmMGTPImzevustrlHglVz75y9H6q5W06LecbHnLYzYakDV6ytT9lM7D9lGl+Xe4eUSWK49FLMmVLMs0b96cPXv28PPPP78xuUpNrJaIsu7lu1Kx934K1BqGzi3yV0yFp9e2ceLPxhxf2IjjCxsRcGWz7TkBtK5e5K8xmIq995PTtweSrE0ZydU7TokY0WjXrh1Tp05NcHKVmkV+qTpzj68CBQokyYm34qSpNyVLlqRv377q5jTv119/jZKwJoaiKGi1WqZMmZIkz3FSWr16tVOSq3Tp0tGxY0d1yM7X19fhkeDI2zhr1iynvObTOmc9Rl9++aXDyVUkZ92mSLIs8+eff3Lu3DlOnToV5bhw4QI//vij06/zTZx1Pc66HGdJ0wlWJLPJhNVqpWKN5gz/ZQcffvkjGbO8KjJw9fxR7lx/9St79txF+HzYAgZP+Yfi5WpiMhmxxDWdLhVyd3enT58+HDp0iEGDBpEpUyZ1lzilz5Sb+h/+RIfBOylU3lZMwWK2rQdSFCtmowG3dFmp1eEHOgzeTrGq7e0bRCdE5cqVWb16NWvXro2yEDhNUCLKurtnolCDsfj22otPqY5Ism0PN7PhBc+ubsMcHggR0wuzFW+Lb889FG40XpRdT2GkiCkd8+bNw9fXl5YtW7J+/XqHfg1MTSRJQqdz3v6DGo3GqZfnbHny5MHT01PdnKrFNU3v6NGj9mItjiQYAH379qV169bq5hTNYDAwe/ZsdXOi1KtXj1KlSqmbo+jWrZu6KVF27tzJ/v371c2Ck0We6DsruUoqOXPmpFChQhQsWDDKkStXLrJnf7X1kZA4sX+KpiFKZFl3Vw9adP6GMTP20aDVZ2h1r+Yje6Tzps1HQxg9Yy913/8IWdakiLLrSS179ux06dIlQRufurilo3yDz+k8bC8VGn6NTu+J2WSI8SRfsVowmwxkzVuOZp8tovVXq8hRqLK62xtJkkTt2rVp3LgxGk3s1fVSM3tZ92wlKPXBIsp2jlrWHSB9jgqU6bia0h2WkT57mXem7HpqJEkSQUFBrF+/nlatWtGoUSP27dun7pYmOfuXRGdfnhC7RYsWMXnyZCZMmBDtmDRpEp9++ilBQUEOJVeKolCpUqUUXVXzTbZs2cKRI0fUzQkS+ZqOqbiFWpMmTShSpIhD7wNJkjCZTPzxxx/qkCBE48hrTbB5ZxKsSJFl3bPkyMcnA3+nSMmq9tgHvUbRrd/3pPeOLLue9l9gDx8+5LvvvqNatWocP35cHY5GkmUKlX+fDwZuof5Hv5IuUx7MJkO8StRbzLZy5YXKt6T9gC006D6dDJnjnhaiKAqTJk2iUqVKrFq1CoslbScUVovZVta9RDOKvf+rvWS7i6cPZTuvI1uJFu9c2fXUSpIkJElCURT27t1LkyZNmDx5corZQkAQXheZMM2ZM4cBAwYwZMiQaMegQYM4deqUw8lV+vTp+emnn/D2jsfU8RREURRmzZoFThi9K1myJPXr11c3R+Pt7c0HH3ygbk6U9evXc+bMGXWzIAhO9s4lWJEsZjOKFTTaV9PVPDwzYDGDNY2fwBNRBGLmzJlUqVKFKVOmEBwcrO4STba8ZWj++SJafbmaHAWrYjEZoxQNiR8Fs8mAVu9B+Qb96DxsHxWbfIXeNe4pNmfOnKFDhw40b96cY8eOqcNpjILVbJsOGFmqXdLqkfUeWM0W4leaUUgpIhOt0NBQBgwYwIABA96JH3CE1Cny9Rrb4aihQ4c6vJHu23DgwAF27Nihbk6Ujh07ki5dOnVzjDp16oSnp6dDnxuSJBEcHMy8efPUIUEQnOydTbAAFJQoU9riMwqT2imKwo4dO6hbty59+vTh1q1b6i7RuKfPQq2O4+kweCfFqnaKss4qsSLXZ3l656JO55/oNHQXhSs0R4pj7r/VamXz5s3UqlWLfv36ce/ePXWXNOa1L1OFiCIgjp/cCG9H5Inp1KlTmTZtmjosCGmeoig0bdqUb775Rh1KFf744w9MJpNDSaaiKHh5edGhQwd16I1KlCgRr9Gu+Fi2bBm3b99WNwuC4ESxn80KacqFCxfo0qULTZs2jUd5dtDqXChb92O6DN9HleaD0btlwGw0OHX0xGo1YzEbyZbPl5b9VtGq3wqy5ol9wS8RI3C//vorlSpV4ueffyYkJETdRXjHKTFs1uiMw1GRJ2YjRoyIdQ8SQUhrlIg90n766acUXbjkTc6ePeu0MuNNmjShUKFC6uZYde/eXd2UYJIk8fDhQxYtWqQOCYLgRCLBegcEBAQwfPhwqlevztKlS+PchE2SJPKVrEv7gVto2GMmXtmKYDYakrSYgsVsRAGKVGxLp6F7qdNpEp7eOdTdorl//z5ff/01tWrVYsOGDWJti4CiKLi4uJAjRw6yZ8/utMPHxwd3d3enJFqSJPHy5UtGjhwZ94bfgpAGKBHbF0yePJkiRYqow6nCvHnzePHihcOjV8SzuIVa/fr1KVGihMOfPwALFizg6dOn6mZBEJxEJFhpUOSHv8FgYMGCBVSrVo1x48bx/PlzdddoMuUoQrPPFtLmm/XkKlobi9mcfMUUFNv6LJ2LJ5WaDaDzsD2UrfsxelcPdc9ojh8/TuvWrWnXrh2nT5926AtQSP38/Pw4c+YMJ06ccOpx9OhRFi5cSI0aNZxykrN9+3a2bt2qbhaENCl//vw0adJE3Zwq3LlzJ0GbdsfG19c3zo2cY+Lh4UGXLl3UzQkmSRJXrlxxeB8zQRDeTCRYadSRI0do3LgxPXr04MqVK+pwNO7pMlG99VA6Dd1LierdkDV6LGbnTgeML0WxYjYZyJClAA17zKLdtxvJX7pBnEmTxWJh7dq11KxZk4EDBxIWFqbuIrwjXF1dyZgxIz4+Pk47smfPTokSJfjwww/Zvn07X375pUNJVuTref78+eqQIKQ5kiRx9epVZs6cqQ6lCosXL+b+/ftxfg/Fx/vvv4/JZOLJkycJOgIDA6lbty7p06d36LMn0uzZswkPD1c3C4LgBCLBSoNWrlxJ/fr12bNnjzoUjUbnQgm/LnQetg+/tuNw9cwc77LrSc1qMWMxm8hVtCZtvvmbZp8tJEvukupu0QQFBTF9+nRu3rypDgnvCGecfMTGxcWFsWPHUqZMGYeva+/evdy9e1fdLAhp0qRJk+K1JUhK8vz5cxYsWKBuThRJkvj9998pXrw45cuXT9BRqlQpPvjgA6clRceOHRMj6IKQRESClQY9fPiQly9fqpujyV20Om2+XkOzT//EO/t7tsQqCddZJY5iq1goaSjh140Og3dQo91o3NJlUncUhGSVPn16mjVrpm5OEEmSCAgI4MSJE+qQIKQ5UsTm2wMGDHBakpAc1qxZw6VLl5wyegXw6NEj7ty5w927dxN83Llzx+Eqhrw2gp5aRxQFIaUTCVYykSQJjUbr8IeinQRarS7OsuYx8c5WkMa9ZvLBwG3kL9M0eddZJZaiYDYacPXIRLXWI+gyfD+la3VHo01oJSoJWat34vMgI+t0aHQ6kBL+XAipW758+dRNiSI2/hRSEnXlTPXhCEmS2LVrFzNmzFCHUiSDwcAff/yhbnaIFMO+Ygk5nGnHjh34+/urmwVBcJA4I0wGsiyjKFYe3b+O1WJG62B5Wo1Gi1aj5eJpf4KePVaH38jVPQNVmg+g8/C9lKn7KbKsw2J6O+usEkuxWjAbDXj7FKVRrzl8MGAzud/zs2Wc8WAOf8Et/2kYXj5E1jqSFEnIWh1WUyi3D/3GtV3fYw57FrExsCAkTHz2oxOE5FK0aFEqVqyIr69vlKNixYoULVrU4SQLYPz48anih4WtW7dy9OhRdXOaIEkSZrOZ33//XR0SBMFBiT27FOJJlmXCw0P544fP+PbDMkwZ0pbLZw6j0+vRaBN2Mi7LGvQueh7dv87MSZ8w6bvmvAh8ou4WjazRUqxqezoO2UWtDpNwS5fNVnY9BayzSiyrxYTVYiFP8Xq0+24LTT+Zg3e2gupuMVC4dfBHjs724+6xuSgWgy3RimeCBiBrdEgSPD6/nn/n1eXiP19wdecwzqzqitkQjJTopE1IbZz1a3J8KnwKQlKLTJx+++03jh49yqFDh6Ichw8f5sCBAw6vPZQkiadPnzJ48OA4tw152yKn0DnrvZ4SrV+/nnPnzqmbBUFwgDgTTGKyRsu6hePZs3EBxvBQTh7azJiv6jP7h895fP8mehc9chzT/CRJQqfXExoSxJqFExnxmR87/56N0RB3lbwchSrR5ps1vP/ZIrLmLZdC11klloLFZECj0VOqZk86D99PtVZDcPPMqO4YTdiza5z/uzcnFjbh6ZUdSBoZWRN7wivJGmStjqB7x/lvWXv+W9aGF/f/tcefXt3GvRNzkTSaKH8npF2hoaHqpkQxGAzqJkF4azQRn2FarTbKIcsymTNnZtKkSeh0OoeSLICNGzcye/ZsdXOK4e/vz/bt29XNaYokSQQHBzN37lx1SBAEB8R+Zi84RKPR8uTBTfZsXhil3Rgeyra1vzOijx9r//yB0JAX6PV6iOEXMq1Oh6JY8d+xgtFf1GHJ74MJfPZI3S2a9Jnz0KD7dD4YsJWCZZtjtUYUi0iDIsu6u6fLQo1239Np6G6KV+2AVuei7hrN81v7OLGoGWdXd+fl44vIWh2SpEqQItZZhQfd49LGbzg+vw6PL6yNMVF9cuFvrGZTgkbEhNTr2LFj6qZEcXGJ+7WamqTlX/vfBXElTo0aNeLzzz9XNydI5GtkzJgxXLhwQR1OEWbOnInZbH4nXs9Lly7lzp076manehcex9e9a/dXiEokWElIkmUCHt0h8GnMCdHzgAcsnjGQ0V/UxX/HSkBBp9NDRHKm0+m5fPYIUwa35eeRnbh19bT6IqLRu3pSscnXdB62l/L1+6HTe2BOZeusEstqtWA2GcicsyTN+iyi1VeryVm4irpbNIrFyINTf3Fsbk2u7hyNKexpRKIl29dZ3fL/hWNz/Lh1aBpmQ7D6IlTS/mMt2PaaW79+vbo5UTJkyKBucgqz2axuShZxnaALqd/QoUMpUaKEQ8+1JEk8evSIYcOGYbWmrCnr586dc9r7O6WTJImHDx+yePFidcipQkJC1E1pmpiZkHysVisWS/Qfvd8mkWAlIavFgk+uQhQtXU0diuLW1f+YNrIjkwe24tJZ2/qsgMd3mDu1H+O+qs+JgxtR4vjykWUNhcs3p+OQndTp/CPpMuZOMftZJTeLxYTVYqVA2Wa0H7iNBt1/wStrfnW3aEyhAVzfPYpjc2py/9RiLOYwHl/YwL/z63Jp05eEB91W/8lrJDIVbECRxlORZJ1Ist6yuKbdOsJisbBp0ya6devGixcvnPIrZbZs2dRNTnHu3LlkXd8lSRKKojh1X6/AwEACAgLUzSlGQEAARmPanB0QmyxZsjBx4kS0Wq1DSRYRZdCdtc+Us8yfP99p7+/UYsGCBUn6eXH06FEOHjyobo4Xs9nMo0ePOHLkCHPmzElxr5fXRb5mli1bpg7FW0hICFeuXGHDhg2MHDmSa9euqbsIESIf70OHDqlDb5WkJPKTceLEiQwePDhKm1em7Pyw8CTpM2TGGsP0qZRGo9Ux7qsGnPl3JwCfD51H3eY9MBqc92UpyxrCw16ya8NcNiydyvOA++ouUbi6eVKmciOuXzrOkwfx2yg3a97SVGs5jEIVWiHL2jQ7FTAxJElGo9MR/PQOx7f+zKndszGEvlB3i0aStbhnLEhY4E2s5th/hfLIUpwCtYeTrURrZI0eq8U5owaSRkfw/eMcmVUFxWrGNUMeqnx+Ap2rN4qSwt9fkozVFMrR2dV4+ehslJBer+fIkSOULVs2SjvA3Llz6d27t0MnNYqiULp0ab7++munjOBIkoTRaCQkJIR79+5x+PBhTpw44ZS9aIi4vfPnz6d79+72trCwMCpVqsTZs2cdug5FUejduzdTpkyJ1yjZokWL6Natm8PX2aBBA9auXYuHh4c6nGBTp07l22+/dfg2tW3bllWrVtnbzGYzVapU4fjx44m+bEVRkCSJ6dOn88UXX6jDDlMUBZPJRGhoKMHBwQQHB/P8+XOePXvGs2fPaNy4cZTkfMWKFXTo0MHh+7Nz507q1KmjDseoT58+zJw5M9HXScT15sqVi71791KgQAF1ONndvXuXSpUq8eDBA4fuF8k4muvo7STits6ZM4devXpFaTeZTFSpUoUTJ044dD2KopA3b15Gjx5NrVq18PT0tF+exWLBaDRiNpt5+fIljx8/5u7du9y8eZNLly5x+fJl7ty5Q0BAgH2kwtHbIssye/bsoUaNGlFiq1evpl27dg5fPkDXrl358ssvyZ07N7rXKkgbDAYsFgvh4eEEBgby4MEDbt68ybVr17h06RLXr1/nwYMH9j1NHbktRNyeRo0asWXLFnUoRmvXrqVNmzaJvt7I+79t2zYaNGigDkexbNkyOnXqlOjrIuL6vLy8+O233+jQoYN9HenbJBKsJE6wwDZVUKfX8ujuTf5ePJm9mxZgCHd8cbynd3Z8G31Fmbqf4OrujdlshMQ9nWmeLGuQtVoeXv+XwxvGc/nf9TGuoUoIvUcWclf9ityVPsfFwxuLyYwzR65EguWYRH60xYszbh8Rt1Gr1XL48GEqVKhgbzeZTPj5+XH06FGHr0tRFAoWLEjVqlXJnDlzlNG9yJOMfv36kTdvXjZt2mTfPNmR61UUBT8/P3r37k2RIkVwd3dP0OUZDAYePnzI33//zaJFizAYDAn6ezVFUejVqxdz5syxt1ksFqpXr86RI0ccvmydTkfLli1p1KgR3t7e8XrtmUwm+2a7ISEhGAwGgoODefHiBc+fP+fp06f2ZCo4OJiQkBBCQkIwGo32yz9w4ADVq1e3X+bbSLAePnxI7dq1Hd6IV1EUOnXqxJIlS9ShZPfDDz8wcOBAh+4PEffJ09OTHDlyxOs1kRhSRJEKZyWDlStXZs+ePbi6utrbrVYrVatWddrnEREbtasTLJPJhMViISQkJNbqko7eBl777IspwXI0uXhd5OeDl5eXba19BKPRiMViwWAwEBYW9sYpss64DUTcjpSaYP3999+0atUq0dcVSYn4Pi1VqhQFChRI0OUZjUaqVKkSLa9xhEiwkiHBiqTRaJE1MpfPHmH1/LGcPLw5zql/MdG5uFPCrysVm/yPjNmLYDGZ3smpgImh0eqxWkxcP72JQ+u+58H1V1UA40vWupK9TBfy1RiER5ZCKGZLkjz+IsFK+xRFoWjRohw/fjzaaE/jxo3ZunWrUx6L2D7mJUnC39+fqlWrcvr0aSpVquRwQoPqOvX6hG3u/XoSgRNOMhRFYdy4cQwdOjRKe8uWLVm/fr3Dl08cj3FSkCSJAwcOUK3aqynobyPBAli1ahUdO3bEYrE4dN1EjKJ26dJFHU42gYGBVK1alYsXLyb6vkRSFIUJEybwv//9z55MO5tWq+Xy5cvUrl2bwMBAh25z5HOwbt06WrZsGSXWrFkzNm3a5NDlvy4+7xdnXVdMlFgSrH379lGnTh2sVqtTbsPbvq+k8ATr8OHD+Pn5OfT58br4PN4xadq0KRs3blQ3J1rSLVQQorFYzJiMRgqXqMx3E9fwzZjl5Csc/STzTSRJpmDZJnzw3UYadp+JV9aCqX4/q+RmMRtRFChcvhXtB26lXtcfSZcxp7pbzCSJTIUaUuGjrRRvNRv3TAWxiuRWcFDTpk2jJVcAxYoVUzclmiRJMR6vxwDy5ctH7ty5VX+dOK9frtFoxGAwxPuI/IJ8/TIcVa5cOXUTZcqUUTclmvqxTcojpWnXrl2UKa6JEXm/hg8fnuTV7GKzdu1aLl68qG5OMEVRyJ49O127dkWn05EuXbokOdzc3ChTpgzNmzdX34QEi3wOZs2aFe0ktXjx4lH+7Sj1azqm423JmzcvGTPGvd1LfKnvV0zHuyxfvnxkyZJF3Zxo6sc2PgdJsHbbuZcmxIvZZAQkqtVvx8hfd9Gt72S8M+dQd4sic67ivP/5n7Tpv5Y8xWpjMZucttbn3aNgNhnQuaajUrNv6DrqIBUa9kXn4q7uaOeeqQil2i6iXJf1eOeriWIxo4jHX3CAoih4eHjw4YcfqkMA1KxZExz4NS4x0qdPH+3XXEepv8gScjiDoijkzp0bX19fdYjatWvb+wiOGTlyJAUKFHDosZQkiRs3bjBy5Eh1KFkYDAb7vlzOeP21bduWXLlyqZuTRK9evZxScARg586d+Pv7R2l7G59Hb0vu3LkpVaqUullIIj4+PlGmyKcVIsF6SxRFwWgw4uaenlYffsvQn7bilclH3Q2AIhVb0WnoHkr6deHZ/asEPrmD9g37ZgnxI0kyGq2OgHtXUCwWGvT4lbb9/8bVw0vdFYB8ft+S07czyBqsljfPDReEhOjWrVuMUyWJOPkvVKiQujnJdenSBSmiGmBa0apVK7Jmzapuplq1alSqVEndLCRC7ty5GT9+vFNeOwsXLoxSkCS5bN261SmVyBRFwc3NjR49eqhDSaZGjRpR1uMllhRR1GfWrFlR2mvUqMF7770XpS2tkmWZdu3aqZuFJNSpUydIYwm8SLDeMqvVgtFoJnO23Li5p1eHAciWrwKe3lkIDQ7in5kfsXR8Lc7u+xMUKxrtq0WTQnxIaHUumE3hHN/yC4vH+LF9YT8sJitZ85RF75ZO/Qc2koxiAVFERHAGRVEoVqwYI0aMUIfsvL29+fTTT9XNSa5evXpOmW6UEiiKQpYsWejbt686BICrqyv9+/eHNPbF/rZ06NCBzp07q5sTRJIkrFYrw4YN4+HDh+pwkopMKpwxelWvXj3Kly+vbk4ysizTu3dvdXOirV+/nnPnztn/7eXlxWeffQbvyHulQ4cOvPfee+/EfU0JWrduTdWqVdXNqZpIsFIIW1GQmN/IitWMLMPJHTN4dPM4QY9vsHFWd1ZPbcHdywfR6vTIGq36zwQVWatDo9Fy7dQmlk9swI6/viT0xWOundrIhUPLkCRZJFBCklMUhRw5crBgwQKyZ8+uDkfRp08fatSokexf8uPHjydbtmzJfr3OFHnbhw0bRtGiRdVhuw4dOvDRRx+pm4VEGj9+PHny5HHotSNJEpcuXWLMmDHqUJLx9/dnx44d6uYEi7zfH3/8sTqU5Jo3b06RIkUceuyJePxfvHjB3Llzo7R//PHHCSp+klQURbEfSSVTpkyMGTMGjUaTpNcTH0l9X1MCd3d3Jk6cSLp06dLMfXVqgiVJUoqoPZ8WWS22UuN6t8hRLoWbZ7ezYlIDts7/nOCnd9DqXWxJghCFJGvQ6l14du8iG37vypqfWvLg2hF73D19FhTFKopVOJEkychakfS/LvJLsnjx4qxbty5eU9M8PDyYPXs2hQsXTtYvnRIlSvDHH3+k2i+7yNv85Zdf0q9fP3U4mmnTptGoUaN34kQmqeXJk4dx48aBE0Y65syZw6ZNm9TNSeKPP/7AaDQ6ZfSqfPnyNGzYUN2c5DJkyEC3bt3UzYm2dOnSKAVH3N3dmTVrVrJ/HkWKfH/KskzDhg0ZPnx4kiZAH3zwgX2WQVJdR2wi76+Pjw+jRo2iWrVqb+V2JJeaNWsybdo09Hp9mrifTj0bN4SF8OjuNXR6DbJItJzKaoVKzb6jy/ADvFe5vX3EymwM49TOmSwaU51jm6dhNoWh1bmI9VkRCb9W70J4yHMOrBrF4nE1uHBoqb04iFbnRpk6n9B15CFK1uiKRaytcpwkIWt1WAwvuOU/jdCnV9U93imRX5BKREGLvn37smvXLipWrKju+kZFixZl7dq1lCxZMlkTgBYtWrBkyRJ8fHyS9XodpSgKGo2GAQMGMHXq1HidMHt5ebF06VI6duwIb+lkKi3p2rUr7du3VzcniCRJmEwmBg4cSEBAgDrsVOfPn2fdunXq5kT76KOPouwjlZw6d+5MpkyZHH4NS5LEw4cPWbx4cZT2woULs2bNGsqWLZssnwvqz9DWrVuzefNmtmzZwmeffUamTJnUf+JUI0aMYOzYsU4rIBKX1+9vkSJFGDduHMeOHWPkyJHUq1dP3T3N6dmzJ/PmzbPvJ5gcj3lScWqCFRoSxPffNGbprFEEBwagd9GLERUnspiNZMlVguafL6b1V2vJXuDVL+Avn99n16JvWDahPldObECWZGTNu7s+S6PVoyhWzh1YxNJxNfFfO5rwl88iohJ5S9TngwFbaNRzJhmy5MNiFhUBHSMha3RIKDw6u5Jjc2pwZfsQrOak2fslpXj9yzCmQ5Ik8uXLR79+/Th48CC//vor2bJlU19MnEqUKMH27dvp3r07Op0u2b543n//fXbt2sX777+PLMvJdr0J9fpjXrhwYZYuXcqkSZPQJmAU1dvbm7/++ovffvuNnDlzRrnM5KJ+/bzpeL1vSiRJEt9//73DG+xKksTZs2ftI2JJZe7cubx48SJeyXhsFEUhZ86cfPDBB+pQsilQoEC0PawcMW/ePJ4/fx6lrWTJkmzdupWePXs6/fNI/VrX6/WUL1+eUaNGceTIEVavXk3Dhg2RJIns2bM7dTuLNxk2bBgrV660j9wl5f3NmjUrH3zwAatWreLYsWMMHTrUXomySpUq9r9Jy7p06cKOHTuoW7cupPDPutgkOvuxWGLe6DTkZSCr5o1m2KfV2fXPQsxmAzrdu3ui72wWiwmr1Uqh8u/TftA26nb9iXQZX5WBfXj9GOt+bsOGGV15cuc0Wp0LkvzujCbKshaNTs+9KwdZ81MrNs78iKf3X+1pktGnCE0/mUfb/60n93s1sZiNoty9gyRZg6zVEnT3KKeWtOH08o4EPzqj7mZntVrfuGt95Ieo+ksnpR6RZFnGzc2NTJky8d5779GkSROGDh3Kpk2bOHHiBNOnT6d06dKv3dOE8/HxYd68eWzatInmzZvj6ekZ7fYk9CAeX17FihVj7dq1rFu3jsaNGzvlep19aLVaSpcuzeTJkzl48GCiT3C1Wi2ff/45R48eZfz48ZQpU8Y+XSU5Dq1Wi6urKx4eHqRLl44MGTKQKVMmcuXKRdGiRalQoQL169enc+fOfPvtt+TNmzfK7Y98X6kvN77H63/rqEKFCjF69Ghw4PZE3o4ZM2bEe4PUhLp9+7Z9lEZ93Qk9ANq3bx/n2sqk1rNnT6e8bgGuXLnCihUr1FdB1qxZmTNnDlu3bqVly5b26cSOHkSsf6pbty7jxo1j3759HDx4kJEjR1KiRIkoSbAkSVSuXBkS8dy9/jfx0apVK/z9/fn+++8pUqQIUkS1TEcPvV5P0aJF6dGjB0uXLuXEiROsWLGCtm3bkj591MJnpUqVsu8Xpb6cuA5e+3yID2d8lkT+fWKUL1+ezZs3s3LlSho2bJjk3zsk8PGJD0mJvOQEWrduHd27dycoKEgdiqJ4uVq07z2aEuVrYbVaU9RIgUarY9xXDTjz704APh86j7rNe2A0GNVdk5Qky4SFvGDox1V4cOeKOoxf25FUbzMKs9EQpT2y1Hjg4xsc2TSFs/sWYDaG2uOuHt6Uq/855Rv2w9MrG5Y0vCmuJMlodDoCH9/k2MYpnNm/AJMhxB53dfeibP3PqdCwH57ePlhMRvubiogkISz4CX+NrMSLp3ft7ZGKt5pD7oq9sJiSbxqhpNERfP84R2ZVQbGacc2Qhyqfn0Dn6o2ixPwDR3KSJBlJqyHs2S1u+U/h3on5WIyvHvM3KVu2LBs2bIhxf5jr169z6NChVLGWU6PR4OnpiSRJuLm52U+Gvb298fT0VHd3KqvVysWLF9mxYwf+/v5cunSJR48eERoaav/xS4rYS0qn06HX6+0n7V5eXmTKlImsWbOSLVs2cubMSevWreM11cZqtXLp0iX27t3LwYMHuXTpEg8ePCA4OBiz2YzFYnnjj2+Oirwvsizj7u5O5syZKVCgABUqVKB27dr4+vri7v7mvewSIzQ0lLNnz3LkyBHOnDnDzZs3ef78OUZj4r8j3NzccHV1xdPTk4wZM5IlSxayZ89Orly5yJ07N66urri4uKDT6ewJl16vx8XFBTc3N3Q6nfoi7W7fvs2BAwcc3jCzbt26MZa1TyiDwcDWrVsJCQlxaHTIbDZTqFAh+y/4znTv3j327NnjlM8cRVGoWbMmOXPGc/P6JGIymdi2bRtBQUEOvxbMZjP58+ePtQS8oihcvHiRnTt3cuDAAS5dusTDhw/tn0dmsznq920M7+U8efJQunRpKleuTLly5cidO3e8bvv169c5fPhwvPqqSZJE3bp1E7zJbVBQEAcPHmTXrl38+++/3L59m8DAQIxGY4yfgVqtFlmW0ev1pE+fnuzZs1O4cGF8fX2pVKkSxYsXJ126N1Qwfo3FYmHbtm08f/48wffXYrGQK1cuatWqpQ7F6O7du+zfv9+h9y0R2434+MS8BVF8WSwWLl++zMGDBzl27BhXr17l8ePHvHz5kvDw2GfJaDQaXFxccHFxwdPT0/6Dlbu7O4qi4OnpSfr06fH29qZ06dJO/YxJdIJFxLzl8ePHs3Llyli/cHR6V2o27kqLLt+RK18RTEaz0zPFxEjtCVYkWaNFkmXuXT6I/9ox3DyzndcrEmb0KUKVlkMoVqUDWp0rZlPMl5M6SWh1egyhLzizbz5HN00m+Nk9e1TWaCni25qqLYeSNU8ZLBYzijX6CaBIsBJCQtZqMRtecv/kAm7u/4HwoFcLod8kS5YsfPXVV/Tp04eMGTOqw4IDDAYDgYGBvHjxApPJhBKxEDwy+XN3d7d/yej1eoe/NCOZTCaCg4MJCgoiPDwck8kU63eBIyJHCbVaLenTpyd9+vS4ubmpuyW5yJOoxNLpdGg0Gqc9B4KQ0hgMBoKCgggKCsJkMhEWFhYlwdJoNLi6ur7197IzWK1W+2dgaGgoRqMx2mdg5A8m7u7upE+fHk9PzwRNXxaiUhSF8PBwjEYjpjjOyWRZRqvV2hOt5HzcHUqwIm3fvp1Ro0Zx8OBBdSiKDBmz0bjtFzRu15d0GbwxGkxREoHkllYSrEgarR6L2cjFIys59Pc4nj24FCWet0Q9qrcZSa6ifihWa6qfGidrdIDC9f+2cHDtaB5cPxYl7pPfl2qtR1CwbBMkScZifvMbUSRY8SNptKBYeHJxAzf2TSDobtTHPCYuLi506tSJoUOHvpWNcwVBEARBEJJTwsYY36BBgwbs2LGDWbNmRZsT/rqgZ49YPns4I/rU5PDutcgaSazPciKL2QiSRMkaXek8fD/VWg3H1cPbHr91bicrJjZi27w+vHh6O9WWdZcjyq4/vXeeDTO6sHZaqyjJlYdXdup2+ZGOQ3ZSqHxzrBZLrMlVfKTGx8mZJFmDRqcj5PE5Ti/vyH9L28UruapVqxbbtm1j/vz5IrkSBEEQBOGd4LSzRjc3Nz755BMOHz7Md999F21x3uvuXD/Lj0M/YEL/Zpw/tQ+9Xo8mGYftUhpZ1qDV6Zyzx62iYDYacPXwpsYHY+g0bC/vVenwqqy7KYxTu2axeLQfRzf9hMkYmmrKuksRZdfDQp6zf+UIloyrycXDy6OUXS9b9zO6jjhAxabfoNW5YXHSdEizIQhJY0s03imSjKzTYXz5gEubB3BsTk0enVsd51q+woULM2/ePLZu3UrNmjXVYUEQBEEQhDTLaQlWJB8fH3744Qf27dtH27Zt3zjf0Wq18N/RbYzv34Tfvu/J43s30LvoE7xwLzWTJBm9i57gwCesmjeWJw9vqrskmmK1YDYa7GXd23zzN9kL2qrtALwMvM/uxf1ZPqEeV06sR5bliCl3KZNGq8dqtXJ2358sGVuDg+vGEh4SUTpWkshXsgHtB22jYc/fSZ85L2ajIc4kICGu7RrFlS0jMIU+RdbpIM2PaNn2s1IsBu6f+JOjs2tw88BkTGFRy/WqZcyYkWHDhuHv70+PHj1wcXFRdxEEQRAEQUjTkuwssUyZMixfvpw1a9bg6+urDtsZwkPZ/c98hvfxY8OSnwgPC4nYPyvlj6gknoROr8dsCmfvpkWM6FOT9YsnOzyNLSYWswmrxULBsk3pMGgb9bpOI13G3Pb4wxvHWfdzW9b/1tle1l1OQaM0skaLRqvn7mV/1vzUko1/dI+ytixj9qI0/Xg+bfr/Ta4i1bGYDEmytswcHsS1PWM5NqcGd4/+gWIJR9bqgLT3OpU0OiRZ5umVbZz8swln13xE2PMb6m5R6HQ6OnXqxL59+xg7dmyCqzIJgiAIgiCkFUmWYBFRKaZ58+bs3r2badOmxViWOVLg04csnN6fkZ/b1mdJsoQ2lnK0qZVWq0Or03L62E7GftWQX8Z04/7tqMUonE/BbDKg1bnh2+QrOg/fR/kGfdG5eABgtZi5dGQlS7+vw94VQwkNDohYn/X2kgdJktHqXXgRcIvtC/qyclIjbp7ZRuQ8SlcPb6q2HEanoXsoVesjZFljW4OWxEICLnH+70858WdTnl3fg6SRbYUf0gBJ1iBHrLM6u7obJxa9z7Ob++KsQ1OtWjU2bNjA4sWLKVGihDosCIIgCILwTknSBCuSp6cnX331FQcPHqRfv354eNhO7GNy6+ppfhzajp9HdOb6xRO2aYNO2J/ibZNlDXpXPXdvXuD38b2Z0L8Jl88eUndLUopixWw0kD5Tbup/9AvtB24jf+nG9kTKEBrI4fXjWTKuFqf3zMdqtaBN9iIkElqdCyZTGMc2TWPJ2Jqc3Pk7poj9vWSNlvcqd6DT0L3UbD8Wt3SZI6YDxpEFONnzm/s48Wdjzq/pRWjAZWStLhUXwpCQdTpMIU+4tnM0x+bW5MF/S1AssY+o5suXj5kzZ7J9+3YaNWr0VhNyQRAEQRCElCJZzwhz587N9OnT2b17N82aNXvjeiur1cqhXSsZ/UUdFk7/jucB93Fx1afKE1hJktC76Hn54hkrZo9h5Oc12f3PPMxJMB0wvqwWMxaTkZyFq9Lmm3U0++wvMuZ4zx5//vAym2f3ZPWU97l9cT8and5eJCMpyVodskbD1ZP/sHx8PXYt/obg56/2tPIpUJHWX6+jed9FZMlVwpZYxbCnVXKxmg3cO7mAY7Orc333GMyGoIj1Wakl0bCtswIL90/8ybG5Nbm2axSm0GfqjlGkT5+e//3vfxw8eJBPP/3U6Zu7CoIgCIIgpGZvJWOpWLEi69atY8WKFZQqVUodtgsLDWbDkikM/9SPjct/xWI2oHfRp5oTWJ3OtpZl/7ZljPy8JivmjCQ46Km621tjMRuRJIkSfl3oMnw/1duMjFrW/fwuVk5qxNa5n/Ii4Da6JCrrHll2PeDOOdb/1ok1P7Xi4Y1/7XFP7xzU6zqNjoN3UqhcM6wWK5Y4RleSkzH0KVd3juTYnBo8OLkICSXFr8+SZC2yVsvzm/s5uag5Z1d/REjAZXW3KGRZpnXr1uzbt48pU6aQPXt2dRdBEARBEIR3nvPPluNJq9XStm1b9u/fz8SJE8mWLZu6i13Ao9vM+7EfY75swLF9G9BobGXNUyqNRoNOr+fS2cNM6N+U6aO6cO/WRXU3O29vb7788kvy5MmjDiU5JaKsu4u7F35tR9F5+H6KVe1kryhoNoXz3+7ZLBpTnSMbp2IyhtjKujshebCXXX/5lH0rhrNkXE0uHVlpH5XS6d0pV68PXUb449vkK7Q6V8wmw1vZnDp//vy4urqqm6N4+fg8Z1Z/yMlFzQm8dRBZo0WSk37kL0Eiyq6HPb3CubU9Ob6gAU+vblf3iqZChQqsXbuWVatWUaZMGXVYEARBEARBiPDWEqxIGTJkYODAgRw8eJCPP/441pPYy2cPMWVwG34a1oHrl06muPVZsmwrux7w+C4zJ3zM2C8b8N/RbSjWmMuFa7Va2rVrx759+5gwYQJubm7qLskmsqx7phzFeL/PX7Tp/zc5XivrHhL4gN1LvmXZhPpcOf43siyh0SY+ydXqXFCsVs7sXciScbU49Pc4DKGBEVGJfCUb8sHArTTo/hvpM+V2etn1hBo2bBjr1q2jbNmy6lBUikLAla0cX1CfCxs+J/zFbWSdDkl6269TGVmrw2IM5sae8Ryd48e94/OxmmPfJyxnzpz89NNP7NmzhxYtWrxxWq8gCIIgCIJgk2LOlgoUKMAff/zB9u3badCgwRsXzFssZg7vXsXYfvVYPGMIwUFPI8q6v727Ikm2suvhoS/ZuPwXhn1SjZ3r52AID1F3tatUqRLr1q1j+fLllCxZEqvVmuyFGmJitUSUdS/ThPaDtlOv23TSZXpV1v3RjeOs+7kdf//Wmce3T6PVJ6yse2TZ9TuX9rP6x+Zs+qNHtLLrzT5bSNv/RZRdNxuTpOx6QsmyTKNGjdi7dy9TpkwhR44c6i5RWExh3Dn6O0dnVePG3klvdX2WrNWBZOHh6aX8O7cmV7YPxRjyRN0tCg8PD7744gsOHjzI119/jaenp7qLIAiCIAiCEIO3l5W8gZ+fH//88w9//fUXxYoVU4ftQl4GsvbPCQz7uCo7/p6DxWJCp0/uindEVNlTOLhzJcP7+DH/py95HnBf3c0uT548/PLLL+zatSvWQh9vV2RZd1d8G/ejy/D9lG/Y71VZd6uZy0dXsfT72uxdNpjQF0/Q6mIv6x5Zdj3oyU22ze/DikmNuHl2h326n6tnRqq1HkHnYXspWaMbkpQ8ZdcTKrLAg7+/P3369ImzwIMh+D5Xtg3i33m1eXR6BSjWZNvQWZI1yFodgbcOcmpRc86s7ErwwzPqblHIskyzZs3YuXMnv/zyy1uZtioIgiAIgpCapcSze/R6PV26dGH//v2MHj2aTJkyqbvYPbp/nZkTPmbMl/U4fWwnWp0WrQNT1+JLo9Gid9Fz9fwRJn7bnGkjOnLn+jl1N7vIUvX+/v588cUXsZaqTykiy7qn885F/W4/02HQNgqUafJaWfcgDm+YaCvrvndeRFl3l6gXIkWUXTeGcnTTTywZV4tTu2ZhNoYBIGt0FKvSkU5D9lCj7WhcPTO99emA8ZEvXz5mzJjBjh074lWiPPjhaU6v6Mx/S9sQdO+Yrax7Akb+EkKKWGcVHniLCxv6cvzPRgRc2RbnY1qqVCmWLVvGunXrqFz51fRQQRAEQRAEIf5SZIIVKVOmTIwYMQJ/f38+/PBD9LGMUF0+c4gJ/Zswc+Kn3Lt9CZ0+adZnSbKMi6uegMd3mD+tP6O+qBvrOitZlmnRogV79uyJc7PllMpqNWMxG8lRqCqtv17L+30WkylHcXv8+aMrbJ7di1VTmnHrwh40WltZd1mrQ5ZlrpxYz/IJ9di9uD8vXyu7nr1gJdp8s473P19EltwlMJvebtn1xKhatSobNmxgyZIlcW6yqygWnlzayL/z6nBp41cYXtyNmDbopLehZNvPymIK5rb/zxyd48edIzOwGF6qe0aRLVs2Jk6cyP79+/nggw/QalNYYQ5BEARBEIRUxElndkmraNGiLFy4kK1bt1KjRg112M5sNrFr/RyG9q7CslnDCQl+HrF/VuyjC/Gld9FjDA/ln6XTGfZJNTYu+wljuG0D3JiULl2aVatWsWbNGipUqKAOpzqRZd2LV+9E5+F78Ws7GlePjPb47fO7WfVDE7bM/YSggNs8vXue9b92ZO20Njy8cdzez9M7J/W6TafjoJ0ULNsUq8WC5S3uC+YonU5Hx44dOXDgAN9//z2ZM2dWd4nCYgzh1qHpHPmjKrf9f0Yxhzlc1l3WaJGAx+f+5tjcOlzc9DWGF2+eqgrg6upK7969OXToEAMHDiRDhgzqLoIgCIIgCEICpYoEK1Lt2rXZtm0bc+bMoWDBguqwXWhIEKsXjGNEn5rs3bQYRbHEa33Wm2pMaLU6tDodx/03M+bLesyf9lWs66x8fHyYPHkyBw4coHXr1miSYCTtbbGXdXfzonqbEbay7tU6RynrfnrPHBaPrsqS72tz6ehq+6iUVu9Oufqf03WEP76N+6HRuby1sutJwcvLiyFDhnDw4EF69OiBi4tquqSK4cV9Lm76mn8X1OfJxfVIsoykWp8V9TUZ/XGSZA2yTkfwg5OcXtGR/5a2IfjBKXW3aOrWrcu2bduYPXs2+fPnV4cFQRAEQRCEREpVCRYRv7r36tWLgwcPMnjwYLy8vNRd7O7dvMD00V2ZNKAl547vQaezTV2zU8DV3RO9ixt6Fzd0uqhJmKzRoHfRc+vaGX4a1oHJA1tx7cKrDXDV3N3d+fTTTzl06BDffvst6dKlU3dJMxTFVtY9c473eP+zP2nbfz05ClW1x0OCHhH+MmJTZUkif+lGdBi0jQbdfyNdplypYp1VYhUuXJh58+axdetWateurQ5HE3TnCKeWtOXMys68fHj61fosxZZAaV290Og80LpkiBjlUpAkGY1Oh+HFPa5sGcCxefV4dG51nI9p0aJF+euvv9i8eXOso8GCIAiCIAhC4khKSqgN7oAzZ84wbtw41qxZg9n85nLeOp0LNZt0o/WHQ/DJlR+TyYxitRIcFIDREA6AZ/qMuLp5ABI6vZbnAQ9Zv2QquzfM5WXwc/VF2kmSRMOGDRkxYgTVqlVTh+Pl5cuXVKhQgcuXL6tD+LUdSfU2ozAbY9+z6O2R0Or0GMOCObN/IQfWjCT85TMAvH0KU731SIpWaotG54LFlPIqAxIxEhQW/IS/RlbixdO76jDz58+ne/fu6uY4GQwGli5dyoQJE2J8btW0rl7krvQpeap8iUuGHFgM4RhfPrQlVbIWvUc2ZJ0eizGE+ycWcGP/D4QH3VZfTDSZMmWiX79+fPHFF7EWjREEQRAEQRAck+pGsNRKlSrF0qVL+fvvv6lSpYo6bGcyGdi5fg4j+vix9s9JGMND0On1ZMjoQ5bs+ciSPR+u7p5odTosZiObV81g2Kd+bFgyJdbkqnjx4ixatIj169cnOrlK/Wxl3TU6V3wbf0H2/BXtkUrNvqN07S4gySk2uUpKLi4udO/enQMHDjBs2DAyZny1Zi0m5vBAbuybxNHZ1blzZCYoZtwz58PVOz+u3rmRNBoCLm/l+IJGXPjniziTKxcXF7p168aBAwcYOXKkSK4EQRAEQRCSWKpPsIio1Ne0aVN27NjBr7/+St68edVd7J49uc/iGYMY0acmB3euBMWCTiej08loZJmTh7Ywul895k7py6N719R/bpclSxbGjh3L/v376dy5c6wVDt8VimLFYrKgvLZWSJY0WMzRFhO9c9SvF50u9q0Ewp7f5ML6Phxf0ICAy9uxmsIJfnCGs6u6cmpxcwJv+6v/JJoaNWrwzz//sHDhQt577z11WBAEQRAEQUgCaSLBiuTh4UHfvn05ePAg33zzTaxroG5dPc204R35cVgHtq6ZzbY1s/l1bHd+GNCSK+cOq7vbRY5I+Pv/v707DY6qztc4/pw+3dkIQURSRViLAhWBMoKg4BUX1BFZFIFb7o5lhikFRyguguVCioSEiAIBzcDgHQSELBBCggwxELMvbOIOKigKyiDcEA2YkK3vC8SRf0fSaAtZvp+X/Xs6VYG8OE+d/1Lk1RuJ1u6XZQv/eeP51ltvefXGs/xgqd5bPUalfx+gnf97kw5/kKT6unOfuNizZ08tW7ZMWVlZuu2223x2iiYAAAAa16IK1hlhYWGaP3++8vLyNGbMGDkcDf+abne9tuel6R9xE7U0bqLyM1eptvbXl7HddNNNyszM1PLly9W7d29zDHjlzJ69rVu3asmSJed84ypJdTVVOnl0j2oqf32pqiS1a9dOM2fOVElJiSIiIhQQEGBGAAAA8AdruHm0ENdcc43S0tKUmpqq8PBwc+y1Xr16ndepcIA3AgMDfXLqpNPp1IQJE1RYWKjY2FiFhoaaEQAAAFwgLbpg6af9Wffcc4/y8/P18ssvKywszIz8qvbt2+u5557z+l4j4Lfo1KmT5s2bp/z8fN17771yOn9xlUAjrrvuOqWnpyspKUn9+vUzxwAAALjAWnzBOqNt27aaNm2aioqK9MQTTygoKMiM/Mzlcum+++5TQUGBoqOj1bFjRzMC+Fx4eLhSUlK0fv16DRw40ByfpWvXrlq8eLGys7N11113/eoyWAAAAFxYre6prEePHkpISNDWrVt15513ehwAMHToUGVkZGjNmjXq27fvWTPgj2bbtkaPHq3c3FwtWLBAXbp0OWvetm1bTZkyRSUlJZo8ebLatGlz1hwAAAAXV6srWGcMGTLk5yLVp08fdevWTQkJCdqyZUuDxQu4kIKDgzVlyhQVFxdr8uTJCgkJ0ahRo5STk6MFCxaoc+fO5lcAAADQBLTagqVfLAXMzc1VcXFxo0sHgQuta9euio+P165du7R27dpGlw4CAADg4mrVBeuM0NBQ3gigyXI4HOrVqxfHrgMAADQDFCwAAAAA8BEKFgAAAAD4CAULAAAAAHyEggUAAAAAPkLBAgAAAAAfoWABAAAAgI9QsAAAAADARyhYAAAAAOAjFCwAAAAA8BEKFgAAAAD4CAULAAAAAHyEggUAAAAAPkLBagYsyyHL/BA+Z1mWxL80AAAAfgcKVjNQdbJMlkNy2E5zBF+wLDldTtWcOqm62mpzCgAAAHiNgtUM7M5eqs3LJur7o1/K6ecvy8F/m6/YTj9ZlvTZjjRtWDReJ78/YkYAAAAAr/Gk3gzUVlfpvXeWKTF6mEozYlRd+YNslz/L2X4Hy+GU0+Wvf3+xTemLJiht4XgdOfCeGQMAAADOCwWriXC73XK73ebHZ6k4flh5yc8pOXa4PtueIstyy3b6mTGcg2U55PLz14njB5WTOE3Jc+/Q57sy5HbXm1EAAADgvFGwmoigoCCNGzdOgYGB5sjDka/eV8arDygt/l4d3l8q2+mSw8H+rHOz5HT5q662UruyFilpzi3avmm+TlVWmEEPvXv3Vr9+/cyPAQAAAA8UrCbCtm3FxsYqLy9PI0eOlKORfVb19XXav/tfSp57u955c4oqjh+U0+Uvyzr391ojh+2Sw3Zo/+6NSon7k7aseFrlRw+YMQ+XXnqpZs2apZKSEl177bXmGAAAAPDA03gTM2jQIG3YsEEpKSnq37+/OfZQXXVSO99erDWzb9SurHjVVJ+U0+UvWezPshy2nC5/Hf16tzYmPKC0+PH65vNSM+bB5XLpoYceUlFRkSIjI9WhQwczAgAAADSIgtUEOZ1OjRs3ToWFhZo7d65CQ0PNiIcfyg5p68opWht3h/btTpdlWa12f5ZlOeT081dlxVHlJc9QUuzt2lu61qsj2IcOHarNmzdr1apVuvLKK80xAAAAcE4UrCYsJCREM2bM0LZt2xQRESF/f38z4uHb/TuUtmCc3kq4X0cO7JTT5d+K7s+yZLv8VV9Xrfdz/qE1Uf+l0o0vqerkcTPooXv37lq2bJmys7M1fPhwcwwAAAB4hYLVDPTo0ePnh/9bb73VHHuor6/T3m2pSpwzXHnJz+hk+ben789qwfuzTu+zsnVwzztaO2+EMl//q44f+cKMeQgJCdEzzzyjHTt2KCIiQgEBAWYEAAAA8FrLfeJugW644QZlZmbqzTff9Gr5WnVVhUo3ztOa6GHavTVBdbVVp/dntaD7sxw/7bMq+/ZjbV72mFLiRujg3gIz5sG2bY0fP16FhYWKi4tTx44dzQgAAABw3ihYzYzL5dKDDz54XgcwlH93QFnLJ2ntvBH64oPNcti2HLbLjDUrP++zOnFMxemzlTjnVn1UsMqrfVaDBg1Senq6kpOTvTpIBAAAAPAWBauZOnOEeFFRkR5++GH5+TV+oMWhT4uUtmCsNi15SP/37cenj3V32GasybNd/qqvr9HHhSuVFDtcBWtn6ceKY2bMQ5cuXbRo0SLl5OR4dRQ+AAAAcL54wmzmrrjiCq1cuVKZmZm68cYbzbGH2ppT+qQ4SYnRN6sg9XlVnTjWbO7PcthO2U4/Hdqbq7SF92jTkj/r2KFPzJiHNm3a6Omnn1ZpaameeuoptWnTxowAAAAAPtH0n6rhlVtuuUVZWVl6/fXX1bNnT3PsofJEmYrT5mhN9DB9VPCG6utrZDfR/VmW4/RywPLv9itr+V+1dt5IffnBFrndbjN6FofDoVGjRikvL08LFy5U586dzQgAAADgUxSsFiQgIECPP/64SktL9eyzz6pdu3ZmxEPZ4c+1aeljSn1lpA7tzZHtdDad/VmWJafLXzVVFSpNj1Fi9E16751lqjn1o5n00L9/f61bt04bNmzQwIEDzTEAAADwh6BgtUAdO3ZUTEyMioqKNGHCBDmdjd+D9dXHuUqee6fe/udfVH7ks4u+P8t2+smStHdbshLn3Ky8lOd0ovzfZsxDaGioXnrpJRUXF2vs2LGy7Yv3OwAAAKD1oWC1YH379lVycrIyMjI0ePBgc+yhrrZa7+f8U6ujhqkkY45O/Xj8p/uzLtyywTP7rA5/sU0b4scq47UH9d3XH5oxD4GBgZo4caK2b9+u6dOnKzg42IwAAAAAfzgKVgtnWZZGjBihnJwcvfrqq+rWrZsZ8fDjD0eVn/K8kmOHa0/xGrnd9bKd/mbMpyyHQ06XvyrKvlb2qr8pKWa49u3+l9z1dWb0LJZl6fbbb1d2draWLl2q7t27mxEAAADggqFgtRJBQUGaNGmSSkpKNHXqVK/e8Hz39YfamPCQNsSP1Tef5ct2+clhN77c8Pz8Z5/Vzsz5Wj37Ru3KetWrfVZXXXWVVq9erU2bNmnIkCHmGAAAALjgKFitTFhYmObPn6+8vDyNGTOm0T1Kbrdb+9/L1Np5I7V1xSR9f+zL08sGfbA/y3b6yXJY+vzddKW8dKey35ymirJvzJiHDh06KCoqSoWFhbr//vvlcjWRQzkAAADQ6lGwWqkBAwZo/fr1Sk1NVXh4uDn2UF11Qu9u+bsSo2/Wto1xqjlVIafLX/oN+7McDltOP38dObBTbyXcrw3x43V4/w4z5sHPz0+PPvqoSktL9fzzz6t9+/ZmBAAAALioKFitmG3buvvuu1VQUKBXXnlFnTp1MiMeKsq+UW7STCXF3KLPdqbKYVmynX5mrEGW5ZDLz18nvj+s3MTpSoq9TXu3paq+rtaMehg2bJiysrL0xhtvqFevXuYYAAAAaBIsd2O3taLVOHjwoGJiYrRixQpVVlaaYw+Ww6HeA0Zr6D0vKLTHALnr6+V2u7V1xSR9vSdPklvD/jtGVwwaJ7ek2lMn9XHhCm3b9LLKv/vS/HEN6tmzp1544QU98MAD8vPzrsgBAAAAFwsFCx5KS0sVGRmprKwsefPn4RcQrPBb/6KBf5qikMu6qbb6lOp/Ov3P6Tp9+uCBD99WSUaMDn1aZHy7YZdccomefPJJTZ06VZdddpk5BgAAAJokChYaVFtbq9TUVM2ePVuffPKJOW5QyGVddf2oZ3TV0IcVENxObrd07NBHKkmP0afbU1VXW21+xYPT6dT48eP14osvqk+fPuYYAAAAaNIoWDin8vJyvfbaa4qPj9fRo0fNcYO6XD5Ug0f+j458tVvvZr2myhNlZqRB119/vSIjI3XHHXdc0MuNAQAAAF+hYMEr+/btU0xMjBITE1VVVWWOPViW5dXyQknq3r27Zs6cqUceeURBQUHmGAAAAGg2KFg4L/n5+Zo1a5Zyc3PN0Xlr27atJk6cqGnTpnl1giEAAADQ1FGwcN6qq6uVmJio6Oho7du3zxw3yrZtjR49WpGRkbr66qvNMQAAANBsUbDwm5WVlWnhwoVavHixysvLzXGDwsPDFRUVpZEjR7LPCgAAAC0OBQu/2549exQVFaV169appqbGHEuSwsLCNH36dEVERCg4ONgcAwAAAC0CBQs+s2XLFs2aNUslJSU/fxYUFKTHHntMM2bMUNeuXc/KAwAAAC0NBQs+VVlZqZUrVyouLk6XX365Zs+ercGDB5sxAAAAoEWiYOEPcfz4cQUGBiogIMAcAQAAAC0WBQsAAAAAfMRhfgAAAAAA+G0oWAAAAADgIxQsAAAAAPARChYAAAAA+AgFCwAAAAB8hIIFAAAAAD5CwQIAAAAAH6FgAQAAAICPULAAAAAAwEcoWAAAAADgIxQsAAAAAPARChYAAAAA+AgFCwAAAAB8hIIFAAAAAD5CwQIAAAAAH6FgAQAAAICPULAAAAAAwEf+H/smnf6HOLheAAAAAElFTkSuQmCC

" alt="The Block Audit Logo" class="header-logo">
            </div>
            <div class="header-content">
                <h1>B.A.T.S.</h1>
                <div class="subtitle">Block Audit Tracing Standard - Professional Crypto Investigation Documentation</div>
            </div>
            <div style="position: relative;">
                <button onclick="toggleFileMenu()" style="background: #3498db; color: white; padding: 10px 20px; border: none; border-radius: 6px; cursor: pointer; font-size: 16px;">
                    File ▼
                </button>
                <div id="fileDropdown" style="display: none; position: absolute; right: 0; top: 100%; margin-top: 5px; background: white; border: 1px solid #ddd; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; min-width: 200px;">
                    <button onclick="saveInvestigation(); toggleFileMenu();" style="display: block; width: 100%; padding: 12px 20px; border: none; background: none; text-align: left; cursor: pointer; font-size: 14px; transition: background 0.2s;" onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background='none'">
                        💾 Save .bats File
                    </button>
                    <button onclick="handleLoadFile(); toggleFileMenu();" style="display: block; width: 100%; padding: 12px 20px; border: none; background: none; text-align: left; cursor: pointer; font-size: 14px; transition: background 0.2s;" onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background='none'">
                        📂 Load .bats File
                    </button>
                    <button onclick="document.getElementById('excelInput').click(); toggleFileMenu();" style="display: block; width: 100%; padding: 12px 20px; border: none; background: none; text-align: left; cursor: pointer; font-size: 14px; transition: background 0.2s;" onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background='none'">
                        📊 Import Excel Traces
                    </button>
                    <button onclick="document.getElementById('graphImageInput').click(); toggleFileMenu();" style="display: block; width: 100%; padding: 12px 20px; border: none; background: none; text-align: left; cursor: pointer; font-size: 14px; transition: background 0.2s; position: relative;" onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background='none'" title="Import a PNG graph exported from BATS - contains embedded investigation data!">
                        🖼️ Import Graph Image
                        <span style="position: absolute; right: 20px; top: 50%; transform: translateY(-50%); width: 16px; height: 16px; background: #ff9800; color: white; border-radius: 50%; font-size: 10px; display: flex; align-items: center; justify-content: center; font-weight: bold;">✨</span>
                    </button>
                    <div style="border-top: 1px solid #e0e0e0; margin: 5px 0;"></div>
                    <button onclick="showNavigationMenu(); toggleFileMenu();" style="display: block; width: 100%; padding: 12px 20px; border: none; background: none; text-align: left; cursor: pointer; font-size: 14px; transition: background 0.2s;" onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background='none'">
                        📍 Navigate
                    </button>
                    <button onclick="window.open('training.html', '_blank'); toggleFileMenu();" style="display: block; width: 100%; padding: 12px 20px; border: none; background: none; text-align: left; cursor: pointer; font-size: 14px; transition: background 0.2s;" onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background='none'">
                        📚 Training Materials
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Hidden file inputs -->
        <input type="file" id="fileInput" accept=".bats,.json" onchange="loadInvestigation(event)" style="display: none;">
        <input type="file" id="excelInput" accept=".xlsx,.xls,.csv" onchange="importExcelTraces(event)" style="display: none;">
        <input type="file" id="graphImageInput" accept=".png" onchange="importGraphImage(event)" style="display: none;">

        <!-- Progress Indicator (hidden by default, shown when case is loaded) -->
        <div id="progressIndicator" style="display: none; background: linear-gradient(90deg, #2c3e50 0%, #34495e 100%); color: white; padding: 15px; border-radius: 8px; margin-bottom: 20px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                <h3 style="margin: 0; font-size: 16px;">Investigation Progress</h3>
                <span id="progressPercentage" style="font-weight: bold;">0%</span>
            </div>
            <div style="background: rgba(255,255,255,0.2); border-radius: 10px; height: 8px; overflow: hidden;">
                <div id="progressBar" style="background: #3498db; height: 100%; width: 0%; transition: width 0.3s ease; border-radius: 10px;"></div>
            </div>
            <div id="progressStatus" style="margin-top: 10px; font-size: 14px; opacity: 0.9;">Loading...</div>
        </div>

        <!-- Workflow Steps -->
        <div class="workflow-steps">
            <div class="steps-grid">
                <div class="step-item" id="step1">
                    <div class="step-number">1</div>
                    <div><strong>Investigation Setup</strong></div>
                    <div>Case details & investigator info</div>
                </div>
                <div class="step-item" id="step2">
                    <div class="step-number">2</div>
                    <div><strong>Add Victims</strong></div>
                    <div>Document victim transactions</div>
                </div>
                <div class="step-item" id="step3">
                    <div class="step-number">3</div>
                    <div><strong>Confirm Root Total</strong></div>
                    <div>Establish investigation baseline</div>
                </div>
                <div class="step-item" id="step4">
                    <div class="step-number">4</div>
                    <div><strong>Document Traces</strong></div>
                    <div>Record blockchain hops</div>
                </div>
                <div class="step-item" id="step5">
                    <div class="step-number">5</div>
                    <div><strong>Add Write-offs</strong></div>
                    <div>Document abandoned paths</div>
                </div>
                <div class="step-item" id="step6">
                    <div class="step-number">6</div>
                    <div><strong>Validate & Export</strong></div>
                    <div>Generate B.A.T.S. report</div>
                </div>
            </div>
        </div>


        <div class="main-content" style="display: block;">
            <!-- Main Panel -->
            <div class="main-panel" style="margin: 0; width: 100%;">
                <!-- Simplified Action Bar with Breadcrumbs -->
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px 20px; background: #f8f9fa; border-bottom: 2px solid #e8f0fe;">
                    <div id="breadcrumbs" style="font-size: 14px; color: #666;">
                        <!-- Breadcrumbs will be dynamically updated -->
                    </div>
                    <button id="undoButton" class="btn" onclick="performUndo()" disabled
                            style="background: #95a5a6; padding: 8px 16px;"
                            title="No actions to undo">
                        ↶ Undo
                    </button>
                </div>
                
                <div class="nav-tabs" id="mainNavTabs" style="display: none;">
                    <button class="nav-tab" onclick="returnToLanding()" style="background: #34495e; color: white;">🏠 Home</button>
                    <button class="nav-tab" onclick="switchTab('casedetails')">Case Details</button>
                    <button class="nav-tab active" onclick="switchTab('victims')">Victims & Transactions</button>
                    <button class="nav-tab" onclick="switchTab('traces')">Trace Documentation</button>
                    <button class="nav-tab" onclick="switchTab('walletindexes')">Wallet Indexes</button>
                    <button class="nav-tab" onclick="switchTab('pkconverter')">🔑 PK Converter</button>
                    <button class="nav-tab" onclick="switchTab('flowdiagram')">Flow Diagram</button>
                    <button class="nav-tab" onclick="switchTab('summary')">Summary & Export</button>
                </div>

                <!-- Welcome Screen / Landing Page -->
                <!-- BATS Info Tab -->
                <div id="batsinfo-tab" class="tab-content">
                    <div class="section-title">B.A.T.S. Framework Education Center</div>
                    
                    <!-- Key Benefit Highlight -->
                    <div style="background: #e8f4f8; border: 2px solid #3498db; border-radius: 12px; padding: 30px; margin-bottom: 30px; text-align: center;">
                        <h2 style="color: #2c3e50; margin-bottom: 15px;">The Key Benefit of B.A.T.S.</h2>
                        <p style="font-size: 1.3rem; color: #2c3e50; font-weight: 600; margin-bottom: 15px;">
                            Standardized Documentation = Reproducible Results
                        </p>
                        <p style="color: #34495e; font-size: 1.1rem; line-height: 1.6;">
                            Any investigator following the B.A.T.S. methodology will arrive at the same conclusions, creating legally defensible evidence that withstands scrutiny and enables successful asset forfeiture.
                        </p>
                    </div>

                    <!-- Quick Navigation -->
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 30px;">
                        <button class="btn" style="background: #3498db;" onclick="document.getElementById('batsOverview').scrollIntoView({behavior: 'smooth'})">
                            Overview
                        </button>
                        <button class="btn" style="background: #27ae60;" onclick="document.getElementById('batsMethodology').scrollIntoView({behavior: 'smooth'})">
                            Methodology
                        </button>
                        <button class="btn" style="background: #e74c3c;" onclick="document.getElementById('batsNotation').scrollIntoView({behavior: 'smooth'})">
                            V-T-H Notation
                        </button>
                        <button class="btn" style="background: #9b59b6;" onclick="document.getElementById('batsColors').scrollIntoView({behavior: 'smooth'})">
                            Wallet Colors
                        </button>
                        <button class="btn" style="background: #f39c12;" onclick="document.getElementById('batsGoldenThread').scrollIntoView({behavior: 'smooth'})">
                            Golden Thread
                        </button>
                        <button class="btn" style="background: #1abc9c;" onclick="document.getElementById('batsQuickRef').scrollIntoView({behavior: 'smooth'})">
                            Quick Reference
                        </button>
                    </div>

                    <!-- Overview Section -->
                    <div id="batsOverview" style="background: white; border-radius: 8px; padding: 30px; margin-bottom: 30px; box-shadow: 0 2px 10px rgba(0,0,0,0.08);">
                        <h3 style="color: #2c3e50; margin-bottom: 20px;">What is B.A.T.S.?</h3>
                        <p style="line-height: 1.8; margin-bottom: 15px;">
                            The <strong>Block Audit Tracing Standard (B.A.T.S.)</strong> is a revolutionary framework for cryptocurrency investigation that transforms blockchain analysis from an art into a science. It provides the mathematical certainty required for successful asset forfeiture cases.
                        </p>
                        <div style="background: #ecf0f1; padding: 20px; border-radius: 8px; margin: 20px 0;">
                            <h4 style="color: #2c3e50; margin-bottom: 15px;">Core Principles:</h4>
                            <ul style="line-height: 1.8;">
                                <li><strong>Mathematical Precision</strong> - Every dollar accounted for</li>
                                <li><strong>Standardized Process</strong> - Consistent methodology across all cases</li>
                                <li><strong>Legal Compliance</strong> - Meets court requirements for asset forfeiture</li>
                                <li><strong>Scope Control</strong> - Prevents investigation creep</li>
                                <li><strong>Complete Documentation</strong> - Full audit trail for legal review</li>
                            </ul>
                        </div>
                        <div style="background: #d5f4e6; padding: 20px; border-radius: 8px; border-left: 4px solid #27ae60;">
                            <p style="margin: 0;">
                                <strong>Remember:</strong> B.A.T.S. ensures that two different investigators analyzing the same case will reach identical conclusions, providing the reproducibility that courts demand.
                            </p>
                        </div>
                    </div>

                    <!-- Methodology Section -->
                    <div id="batsMethodology" style="background: white; border-radius: 8px; padding: 30px; margin-bottom: 30px; box-shadow: 0 2px 10px rgba(0,0,0,0.08);">
                        <h3 style="color: #2c3e50; margin-bottom: 20px;">The B.A.T.S. Methodology</h3>
                        
                        <div style="margin-bottom: 30px;">
                            <h4 style="color: #27ae60; margin-bottom: 15px;">Step 1: Establish Root Total</h4>
                            <p style="line-height: 1.8; margin-bottom: 10px;">Document all victim losses to create your mathematical baseline. This becomes your Adjusted Root Total (ART) after any justified write-offs.</p>
                            <div style="background: #f8f9fa; padding: 15px; border-radius: 6px; font-family: monospace;">
                                Example: Victim 1 lost $10,000 + Victim 2 lost $5,000 = $15,000 Root Total
                            </div>
                        </div>

                        <div style="margin-bottom: 30px;">
                            <h4 style="color: #27ae60; margin-bottom: 15px;">Step 2: Apply V-T-H Notation</h4>
                            <p style="line-height: 1.8; margin-bottom: 10px;">Assign unique identifiers to every transaction maintaining clear lineage from victims.</p>
                            <div style="background: #f8f9fa; padding: 15px; border-radius: 6px; font-family: monospace;">
                                V1-T1 V1-T1-H1 V1-T1-H2 Terminal Wallet
                            </div>
                        </div>

                        <div style="margin-bottom: 30px;">
                            <h4 style="color: #27ae60; margin-bottom: 15px;">Step 3: Classify Wallets by Color</h4>
                            <p style="line-height: 1.8; margin-bottom: 10px;">Assign permanent colors based on wallet function, not ownership assumptions.</p>
                        </div>

                        <div style="margin-bottom: 30px;">
                            <h4 style="color: #27ae60; margin-bottom: 15px;">Step 4: Validate at Each Hop</h4>
                            <p style="line-height: 1.8; margin-bottom: 10px;">Ensure all thread totals at each hop level sum to your ART. This mathematical validation proves completeness.</p>
                            <div style="background: #fee; padding: 15px; border-radius: 6px; border-left: 4px solid #e74c3c;">
                                <strong>Critical:</strong> If totals don't match, you've missed transactions!
                            </div>
                        </div>

                        <div style="margin-bottom: 30px;">
                            <h4 style="color: #27ae60; margin-bottom: 15px;">Step 5: Document Terminal Points</h4>
                            <p style="line-height: 1.8;">Identify where funds reach exchanges (PURPLE) or cold storage (BLUE) for legal process or monitoring.</p>
                        </div>
                    </div>

                    <!-- V-T-H Notation Section -->
                    <div id="batsNotation" style="background: white; border-radius: 8px; padding: 30px; margin-bottom: 30px; box-shadow: 0 2px 10px rgba(0,0,0,0.08);">
                        <h3 style="color: #2c3e50; margin-bottom: 20px;">Understanding V-T-H Notation</h3>
                        
                        <div style="background: #e8f5e8; padding: 25px; border-radius: 8px; margin-bottom: 20px;">
                            <h4 style="color: #27ae60; margin-bottom: 15px;">The Formula: V[#]-T[#]-H[#]</h4>
                            <ul style="line-height: 2; font-size: 1.1rem;">
                                <li><strong>V</strong> = Victim number (V1, V2, V3...)</li>
                                <li><strong>T</strong> = Transaction number (T1, T2, T3...)</li>
                                <li><strong>H</strong> = Hop count from victim (H1, H2, H3...)</li>
                            </ul>
                        </div>

                        <div style="margin-bottom: 20px;">
                            <h4 style="color: #3498db; margin-bottom: 15px;">Practical Examples:</h4>
                            <table style="width: 100%; border-collapse: collapse;">
                                <tr style="background: #f8f9fa;">
                                    <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Notation</th>
                                    <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Meaning</th>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #ddd; padding: 12px; font-family: monospace;">V1-T1</td>
                                    <td style="border: 1px solid #ddd; padding: 12px;">First victim's first transaction (at RED wallet)</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #ddd; padding: 12px; font-family: monospace;">V1-T1-H1</td>
                                    <td style="border: 1px solid #ddd; padding: 12px;">One hop away from victim's transaction</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #ddd; padding: 12px; font-family: monospace;">V2-T3-H5</td>
                                    <td style="border: 1px solid #ddd; padding: 12px;">Second victim's third transaction, five hops away</td>
                                </tr>
                            </table>
                        </div>

                        <div style="background: #ffeaa7; padding: 20px; border-radius: 8px; border-left: 4px solid #fdcb6e;">
                            <p style="margin: 0;">
                                <strong>Why This Matters:</strong> V-T-H notation creates an unambiguous audit trail that any investigator can follow, ensuring reproducible results.
                            </p>
                        </div>
                    </div>

                    <!-- Wallet Colors Section -->
                    <div id="batsColors" style="background: white; border-radius: 8px; padding: 30px; margin-bottom: 30px; box-shadow: 0 2px 10px rgba(0,0,0,0.08);">
                        <h3 style="color: #2c3e50; margin-bottom: 20px;">Wallet Color Classification</h3>
                        
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                            <div style="background: #ffebee; padding: 20px; border-radius: 8px; border-left: 4px solid #e74c3c;">
                                <h4 style="color: #c0392b; margin-bottom: 10px;">RED Wallets</h4>
                                <p><strong>Definition:</strong> Victim-facing wallets</p>
                                <p><strong>Rule:</strong> First wallet to receive victim funds</p>
                                <p><strong>Example:</strong> Scammer's receiving address</p>
                            </div>

                            <div style="background: #fff8e1; padding: 20px; border-radius: 8px; border-left: 4px solid #f39c12;">
                                <h4 style="color: #f39c12; margin-bottom: 10px;">YELLOW Wallets</h4>
                                <p><strong>Definition:</strong> Convergence/hub wallets</p>
                                <p><strong>Rule:</strong> Where multiple victim traces meet</p>
                                <p><strong>Example:</strong> Criminal consolidation wallet</p>
                            </div>

                            <div style="background: #f3e5f5; padding: 20px; border-radius: 8px; border-left: 4px solid #9b59b6;">
                                <h4 style="color: #8e44ad; margin-bottom: 10px;">PURPLE Wallets</h4>
                                <p><strong>Definition:</strong> Exchange deposit addresses</p>
                                <p><strong>Rule:</strong> Known VASP/exchange wallets</p>
                                <p><strong>Example:</strong> Binance deposit address</p>
                            </div>

                            <div style="background: #e3f2fd; padding: 20px; border-radius: 8px; border-left: 4px solid #3498db;">
                                <h4 style="color: #2980b9; margin-bottom: 10px;">BLUE Wallets</h4>
                                <p><strong>Definition:</strong> Cold storage wallets</p>
                                <p><strong>Rule:</strong> Long-term holding addresses</p>
                                <p><strong>Example:</strong> Criminal savings wallet</p>
                            </div>

                            <div style="background: #f5f5f5; padding: 20px; border-radius: 8px; border-left: 4px solid #34495e;">
                                <h4 style="color: #2c3e50; margin-bottom: 10px;">BLACK Wallets</h4>
                                <p><strong>Definition:</strong> Standard intermediary</p>
                                <p><strong>Rule:</strong> Default for unclassified</p>
                                <p><strong>Example:</strong> Pass-through addresses</p>
                            </div>

                            <div style="background: #e8f5e8; padding: 20px; border-radius: 8px; border-left: 4px solid #27ae60;">
                                <h4 style="color: #27ae60; margin-bottom: 10px;">Remember</h4>
                                <p><strong>Colors are permanent!</strong></p>
                                <p>Once assigned, never change</p>
                                <p>Based on function, not ownership</p>
                            </div>
                        </div>
                    </div>

                    <!-- Golden Thread Section -->
                    <div id="batsGoldenThread" style="background: white; border-radius: 8px; padding: 30px; margin-bottom: 30px; box-shadow: 0 2px 10px rgba(0,0,0,0.08);">
                        <h3 style="color: #2c3e50; margin-bottom: 20px;">The Golden Thread Principle</h3>
                        
                        <div style="background: linear-gradient(135deg, #ffeaa7 0%, #fab1a0 100%); padding: 25px; border-radius: 8px; margin-bottom: 20px;">
                            <h4 style="color: #2c3e50; margin-bottom: 15px;">Definition</h4>
                            <p style="font-size: 1.1rem; line-height: 1.8;">
                                The unbroken connection between a victim's original funds and any assets ultimately seized by law enforcement. This principle is essential for proving in court that specific seized cryptocurrency originated from criminal activity.
                            </p>
                        </div>

                        <div style="margin-bottom: 20px;">
                            <h4 style="color: #e74c3c; margin-bottom: 15px;">The PIFO Method (Proceeds In First Out)</h4>
                            <p style="line-height: 1.8; margin-bottom: 15px;">
                                When traced funds enter a wallet, the very next outbound transaction contains those funds. Apply this strictly chronologically to maintain the golden thread through commingled funds.
                            </p>
                            <div style="background: #f8f9fa; padding: 20px; border-radius: 8px;">
                                <strong>Example:</strong><br>
                                Wallet has 5 BTC existing balance<br>
                                Victim sends 2 BTC (our traced funds)<br>
                                Next transaction out is 3 BTC<br>
                                We trace 2 BTC of that 3 BTC transaction
                            </div>
                        </div>

                        <div style="background: #fee; padding: 20px; border-radius: 8px; border-left: 4px solid #e74c3c;">
                            <h4 style="color: #c0392b; margin-bottom: 10px;">Breaking the Thread</h4>
                            <p style="margin: 0;">
                                The golden thread breaks if you cannot mathematically prove the connection. Common breaks: mixers, privacy coins, or poor documentation. Document these as write-offs.
                            </p>
                        </div>
                    </div>

                    <!-- Quick Reference Section -->
                    <div id="batsQuickRef" style="background: white; border-radius: 8px; padding: 30px; margin-bottom: 30px; box-shadow: 0 2px 10px rgba(0,0,0,0.08);">
                        <h3 style="color: #2c3e50; margin-bottom: 20px;">Quick Reference Guide</h3>
                        
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 20px;">
                            <div style="background: #e8f8f5; padding: 20px; border-radius: 8px;">
                                <h4 style="color: #1abc9c; margin-bottom: 15px;">B.A.T.S. Checklist</h4>
                                <ul style="line-height: 1.8;">
                                    <li>☐ Document all victim transactions</li>
                                    <li>☐ Calculate and confirm root total</li>
                                    <li>☐ Apply V-T-H notation consistently</li>
                                    <li>☐ Classify wallets by color (permanent!)</li>
                                    <li>☐ Validate totals at each hop level</li>
                                    <li>☐ Document all write-offs with justification</li>
                                    <li>☐ Identify terminal wallets (PURPLE/BLUE)</li>
                                    <li>☐ Export comprehensive report</li>
                                </ul>
                            </div>

                            <div style="background: #fef9e7; padding: 20px; border-radius: 8px;">
                                <h4 style="color: #f39c12; margin-bottom: 15px;">Key Terms</h4>
                                <dl style="line-height: 1.8;">
                                    <dt><strong>ART</strong></dt>
                                    <dd>Adjusted Root Total (after write-offs)</dd>
                                    
                                    <dt><strong>Thread Total</strong></dt>
                                    <dd>Amount being traced at specific hop</dd>
                                    
                                    <dt><strong>Convergence</strong></dt>
                                    <dd>Multiple traces meeting at one wallet</dd>
                                    
                                    <dt><strong>Write-off</strong></dt>
                                    <dd>Documented abandonment of trace</dd>
                                    
                                    <dt><strong>Terminal Wallet</strong></dt>
                                    <dd>Exchange or cold storage endpoint</dd>
                                </dl>
                            </div>
                        </div>

                        <div style="background: #d5f4e6; padding: 20px; border-radius: 8px; margin-top: 20px; text-align: center;">
                            <h4 style="color: #27ae60; margin-bottom: 15px;">Always Remember</h4>
                            <p style="font-size: 1.2rem; font-weight: 600; margin: 0;">
                                Standardized Process = Reproducible Results = Successful Forfeiture
                            </p>
                        </div>
                    </div>

                    <!-- Getting Started -->
                    <div style="background: linear-gradient(135deg, #a29bfe 0%, #6c5ce7 100%); color: white; padding: 30px; border-radius: 8px; text-align: center;">
                        <h3 style="margin-bottom: 20px;">Ready to Begin?</h3>
                        <p style="font-size: 1.1rem; margin-bottom: 20px;">
                            Now that you understand the B.A.T.S. methodology, start your investigation with confidence!
                        </p>
                        <button class="btn btn-large" style="background: white; color: #6c5ce7;" onclick="switchTab('victims')">
                            Start Investigation
                        </button>
                    </div>
                </div>

                <!-- Case Details Tab -->
                <div id="casedetails-tab" class="tab-content">
                    <div class="section-title">Case Information & Management</div>
                    
                    <div class="case-details-card" style="max-width: 900px; margin: 0 auto;">
                        <div style="background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-radius: 12px; padding: 30px; margin-bottom: 30px;">
                            <h3 style="color: #2c3e50; margin-bottom: 25px;">Investigation Details</h3>
                            
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                                <div class="form-group">
                                    <label for="caseId">Case ID</label>
                                    <input type="text" id="caseId" placeholder="e.g., CASE-2025-001">
                                </div>
                                <div class="form-group">
                                    <label for="investigator">Investigator</label>
                                    <input type="text" id="investigator" placeholder="Your name">
                                </div>
                            </div>
                            
                            <div class="form-group">
                                <label for="caseType">Case Type</label>
                                <select id="caseType">
                                    <option value="">Select type...</option>
                                    <option value="investment_fraud">Investment Fraud</option>
                                    <option value="ransomware">Ransomware</option>
                                    <option value="romance_scam">Romance Scam</option>
                                    <option value="business_email_compromise">Business Email Compromise</option>
                                    <option value="crypto_theft">Cryptocurrency Theft</option>
                                    <option value="other">Other</option>
                                </select>
                            </div>
                            
                            <div class="form-group">
                                <label for="caseSynopsis">Case Synopsis</label>
                                <textarea id="caseSynopsis" rows="5" placeholder="Briefly describe the circumstances that led to the victim's asset loss (e.g., investment platform, romance scam details, ransomware attack, etc.)" style="width: 100%; padding: 12px; border: 2px solid #e8f0fe; border-radius: 6px; resize: vertical;"></textarea>
                                <div style="font-size: 12px; color: #666; margin-top: 5px;">This will be included in the final report</div>
                            </div>
                            
                            <!-- Tracing Method Selection -->
                            <div class="form-group" style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin-top: 20px;">
                                <label style="font-weight: bold; margin-bottom: 10px; display: block;">Tracing Method</label>
                                <div style="display: flex; gap: 20px; align-items: flex-start;">
                                    <label style="flex: 1; cursor: pointer;">
                                        <input type="radio" name="tracingMethod" value="PIFO" checked onchange="updateTracingMethod('PIFO')">
                                        <strong>PIFO (Default)</strong> - Proceeds In First Out
                                        <div style="font-size: 12px; color: #666; margin-top: 5px;">
                                            When traced funds enter a wallet, the very next outbound transaction contains those funds. 
                                            Best for rapid fund movement scenarios.
                                        </div>
                                    </label>
                                    <label style="flex: 1; cursor: pointer;">
                                        <input type="radio" name="tracingMethod" value="LIBR" onchange="updateTracingMethod('LIBR')">
                                        <strong>LIBR</strong> - Lowest Intermediate Balance Rule
                                        <div style="font-size: 12px; color: #666; margin-top: 5px;">
                                            Arrests asset flow, keeping funds in fewer wallets closer to RED wallet.
                                            Use for stablecoin burn/reissue or when wallet access may be obtained.
                                        </div>
                                    </label>
                                </div>
                                <div style="background: #fff3cd; border: 1px solid #ffc107; border-radius: 4px; padding: 10px; margin-top: 15px; font-size: 12px;">
                                    <strong>⚠️ Important:</strong> Once chosen, maintain the same method throughout your investigation for consistency.
                                </div>
                            </div>
                            
                            <div style="text-align: center; margin-top: 30px;">
                                <button class="btn btn-confirm" onclick="saveCaseDetails()" style="padding: 15px 40px; font-size: 18px;">
                                    Save Case Details
                                </button>
                                <div id="nextStepContainer" style="display: none; margin-top: 20px;">
                                    <button class="btn btn-primary" onclick="switchTab('victims')" style="padding: 15px 40px; font-size: 18px; background: #27ae60;">
                                        Next: Add Victims →
                                    </button>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Investigation Statistics -->
                        <div style="background: white; border-radius: 12px; padding: 30px; box-shadow: 0 2px 10px rgba(0,0,0,0.08);">
                            <h3 style="color: #2c3e50; margin-bottom: 25px;">Investigation Progress</h3>
                            <div id="caseStats" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;">
                                <!-- Stats will be populated dynamically -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Victims Tab -->
                <div id="victims-tab" class="tab-content">
                    <div class="section-title">Step 2: Victim Transactions</div>
                    
                    <div id="addVictimSection" style="text-align: center; margin: 30px 0;">
                        <!-- Add New Victim button will be shown conditionally -->
                    </div>
                    
                    <!-- Enhanced Instructions -->
                    <div id="victimInstructions" style="background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%); border: 2px solid #2196f3; border-radius: 12px; padding: 25px; margin-bottom: 30px;">
                        <h3 style="color: #1976d2; margin-bottom: 15px;">Document All Victim Transactions</h3>
                        <p style="color: #2c3e50; margin-bottom: 15px;">
                            Enter ALL transactions where victims sent assets to scammer-controlled wallets. This creates the foundation for your entire investigation.
                        </p>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                            <div style="background: white; padding: 15px; border-radius: 6px;">
                                <strong style="color: #1976d2;">Required Information:</strong>
                                <ul style="margin: 10px 0 0 20px; color: #555;">
                                    <li>Transaction hash</li>
                                    <li>Amount & currency</li>
                                    <li>Date & time (UTC)</li>
                                    <li>Receiving (RED) wallet</li>
                                </ul>
                            </div>
                            <div style="background: white; padding: 15px; border-radius: 6px;">
                                <strong style="color: #27ae60;">Pro Tips:</strong>
                                <ul style="margin: 10px 0 0 20px; color: #555;">
                                    <li>Use API lookup to auto-fill</li>
                                    <li>Paste multiple hashes at once</li>
                                    <li>V-T notation auto-assigns</li>
                                    <li>Save regularly (.bats file)</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                    
                    <div id="victimsList"></div>
                    
                    <!-- Generate Root Total Section -->
                    <div id="generateRootSection" style="display: none; max-width: 800px; margin: 0 auto;">
                        <div class="generate-root-section">
                            <h3>Ready to Generate Root Total?</h3>
                            <p>You've entered victim transaction data. The next step is to establish your investigation baseline by generating and confirming your Root Total.</p>
                            <div id="saveRequiredMessage" style="display: none; background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 20px; margin: 20px 0;">
                                <h4 style="color: #856404; margin: 0 0 10px 0;">Save Required to Continue</h4>
                                <p style="color: #666; margin-bottom: 15px;">
                                    Before proceeding, you must save your investigation file. This will enable automatic saving at each hop.
                                </p>
                                <button class="btn btn-confirm" onclick="saveAndCaptureFilePath()" style="background: #ffc107; color: #333; padding: 10px 30px;">
                                    Save Investigation and Calculate ART
                                </button>
                            </div>
                            <div style="text-align: center; margin: 20px 0;">
                                <button class="btn btn-confirm btn-large" id="generateRootBtn" onclick="generateRootTotal()" style="display: none; padding: 15px 40px; font-size: 1.2rem; margin: 0 auto;">
                                    Generate Root Total & Begin Tracing
                                </button>
                            </div>
                        </div>
                    </div>
                    
                </div>

                <!-- Wallet Indexes Tab -->
                <div id="walletindexes-tab" class="tab-content">
                    <div class="section-title">Wallet Indexes</div>
                    
                    <!-- Dropdown selector for different indexes -->
                    <div style="margin-bottom: 20px;">
                        <label style="font-weight: bold; margin-right: 10px;">Select Index:</label>
                        <select id="walletIndexSelector" onchange="switchWalletIndex(this.value)" style="padding: 8px 15px; border: 2px solid #3498db; border-radius: 4px; font-size: 16px;">
                            <option value="universal">Universal Wallet Index (All Wallets)</option>
                            <option value="red">Red Wallet Index (Victim-Facing)</option>
                            <option value="purple">Purple Wallet Index (Exchanges)</option>
                            <option value="blue">Blue Wallet Index (Cold Storage)</option>
                        </select>
                    </div>
                    
                    <!-- Universal Wallet Index -->
                    <div id="universalWalletIndexContent" class="wallet-index-content">
                        <div style="background: #e8f4f8; border: 2px solid #3498db; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
                            <h4 style="color: #2c3e50; margin-bottom: 15px;">About the Universal Wallet Index</h4>
                            <p style="color: #2c3e50; margin-bottom: 10px;">This index catalogs all wallets involved in your investigation with their permanent classifications. Use this to:</p>
                            <ul style="color: #2c3e50; margin-left: 20px;">
                                <li>Maintain consistent wallet identification across your investigation</li>
                                <li>Document wallet classifications per BATP color system</li>
                                <li>Add notes about wallet behavior, exchange identifications, or other findings</li>
                                <li>Provide technical appendix for legal proceedings</li>
                            </ul>
                        </div>
                        <div id="universalWalletIndexList"></div>
                        <button class="btn" onclick="addManualWallet()">+ Add Manual Wallet Entry</button>
                        <button class="btn btn-success" onclick="exportWalletIndex('universal')">Export Universal Index to Excel</button>
                        <button class="btn btn-primary" onclick="openApiSettings()">⚙️ API Settings</button>
                    </div>
                    
                    <!-- Red Wallet Index -->
                    <div id="redWalletIndexContent" class="wallet-index-content" style="display: none;">
                        <div style="background: #ffe4e4; border: 2px solid #dc3545; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
                            <h4 style="color: #dc3545; margin-bottom: 15px;">About the Red Wallet Index</h4>
                            <p style="color: #2c3e50; margin-bottom: 10px;">This index summarizes all victim deposits to RED wallets (victim-facing wallets). Use this reference throughout your investigation to:</p>
                            <ul style="color: #2c3e50; margin-left: 20px;">
                                <li>Quickly reference victim loss amounts and dates</li>
                                <li>Identify which wallets received initial victim funds</li>
                                <li>Add investigative notes and findings for each deposit</li>
                                <li>Cross-reference with blockchain analysis tools</li>
                            </ul>
                        </div>
                        <div id="redWalletIndexList"></div>
                        <button class="btn btn-success" onclick="exportWalletIndex('red')">Export Red Index to Excel</button>
                    </div>
                    
                    <!-- Purple Wallet Index -->
                    <div id="purpleWalletIndexContent" class="wallet-index-content" style="display: none;">
                        <div style="background: #f3e5ff; border: 2px solid #6f42c1; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
                            <h4 style="color: #6f42c1; margin-bottom: 15px;">About the Purple Wallet Index</h4>
                            <p style="color: #2c3e50; margin-bottom: 10px;">This index lists all PURPLE wallets (exchanges/VASPs) identified in your investigation. Use this for:</p>
                            <ul style="color: #2c3e50; margin-left: 20px;">
                                <li>Compiling exchange addresses for legal service requests</li>
                                <li>Tracking which exchanges received traced funds</li>
                                <li>Documenting exchange identification methodology</li>
                                <li>Preparing subpoena/warrant applications</li>
                            </ul>
                        </div>
                        <div id="purpleWalletIndexList"></div>
                        <button class="btn btn-success" onclick="exportWalletIndex('purple')">Export Purple Index to Excel</button>
                    </div>
                    
                    <!-- Blue Wallet Index -->
                    <div id="blueWalletIndexContent" class="wallet-index-content" style="display: none;">
                        <div style="background: #e3f2fd; border: 2px solid #2196f3; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
                            <h4 style="color: #2196f3; margin-bottom: 15px;">About the Blue Wallet Index</h4>
                            <p style="color: #2c3e50; margin-bottom: 10px;">This index tracks all BLUE wallets (cold storage) where funds remain stationary. Use this for:</p>
                            <ul style="color: #2c3e50; margin-left: 20px;">
                                <li>Monitoring cold storage wallets for future movement</li>
                                <li>Recording amounts held in cold storage at trace completion</li>
                                <li>Setting up blockchain alerts for fund movement</li>
                                <li>Documenting temporary trace endpoints</li>
                            </ul>
                        </div>
                        <div id="blueWalletIndexList"></div>
                        <button class="btn btn-success" onclick="exportWalletIndex('blue')">Export Blue Index to Excel</button>
                    </div>
                    
                    <!-- Next Step Button -->
                    <div style="margin-top: 30px; padding: 20px; background: #f8f9fa; border-radius: 8px; border: 2px solid #e74c3c; text-align: center;">
                        <h4 style="color: #2c3e50; margin-bottom: 15px;">Ready to Begin Tracing?</h4>
                        <p style="color: #666; margin-bottom: 20px;">Now that you understand your wallet classifications, start documenting the cryptocurrency trace through hops.</p>
                        <button class="btn btn-confirm" onclick="switchTab('traces')" style="background: #e74c3c; color: white; padding: 12px 30px; font-size: 16px;">
                            Next: Begin Trace Documentation
                        </button>
                    </div>
                </div>

                <!-- Traces Tab -->
                <div id="traces-tab" class="tab-content">
                    <div class="section-title">Step 4: Trace Documentation</div>
                    
                    <!-- Investigation Dashboard -->
                    <div id="investigationDashboard" style="background: #f8f9fa; border: 1px solid #e0e0e0; border-radius: 8px; padding: 15px; margin-bottom: 30px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                            <h4 style="color: #7f8c8d; margin: 0; font-size: 1rem;">Investigation Dashboard</h4>
                            <button class="btn btn-sm" onclick="toggleDashboard()" id="dashboardToggle" style="font-size: 0.8rem; padding: 5px 10px;">Hide</button>
                        </div>
                        
                        <div id="dashboardContent">
                            <!-- Quick Stats -->
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">
                                <div class="dashboard-stat">
                                    <div class="stat-label">Total Victims</div>
                                    <div class="stat-value" id="dashStatVictims">0</div>
                                </div>
                                <div class="dashboard-stat">
                                    <div class="stat-label">Total Hops</div>
                                    <div class="stat-value" id="dashStatHops">0</div>
                                </div>
                                <div class="dashboard-stat">
                                    <div class="stat-label">Active Threads</div>
                                    <div class="stat-value" id="dashStatThreads">0</div>
                                </div>
                                <div class="dashboard-stat">
                                    <div class="stat-label">Terminal Wallets</div>
                                    <div class="stat-value" id="dashStatTerminal">0</div>
                                </div>
                            </div>
                            
                            <!-- ART Progress -->
                            <div style="background: white; border-radius: 6px; padding: 15px; margin-bottom: 20px;">
                                <h4 style="color: #2c3e50; margin-bottom: 15px;">Adjusted Root Total (ART) by Currency</h4>
                                <div id="artProgressBars"></div>
                            </div>
                            
                            <!-- Thread Status Bar -->
                            <div style="background: white; border-radius: 6px; padding: 15px; margin-bottom: 20px;">
                                <h4 style="color: #2c3e50; margin-bottom: 15px;">Thread Status Overview</h4>
                                <div id="threadStatusBar"></div>
                            </div>
                            
                            <!-- Quick Navigation -->
                            <div style="background: white; border-radius: 6px; padding: 15px;">
                                <h4 style="color: #2c3e50; margin-bottom: 15px;">Quick Navigation</h4>
                                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                                    <select id="hopJumpMenu" onchange="jumpToHop(this.value)" style="padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                                        <option value="">Jump to Hop...</option>
                                    </select>
                                    <input type="text" id="globalSearch" placeholder="Search wallets, amounts, hashes..." onkeyup="globalSearchDebounce()" style="padding: 8px; border: 1px solid #ddd; border-radius: 4px; flex: 1; min-width: 200px;">
                                    <button class="btn btn-sm" onclick="showThreadFilter()">Filter Threads</button>
                                    <button class="btn btn-sm" onclick="showAnalysisTools()">Analysis Tools</button>
                                    <button class="btn btn-sm" onclick="exportInvestigation()">Export</button>
                                    <button class="btn btn-sm" onclick="document.getElementById('importFile').click()">Import</button>
                                    <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importInvestigation(event)">
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Pagination Controls -->
                    <div id="paginationControls" style="display: none; margin-bottom: 20px; text-align: center;">
                        <button class="btn btn-sm" onclick="changeHopPage(-1)" id="prevPageBtn">← Previous</button>
                        <span id="pageInfo" style="margin: 0 20px; font-weight: bold;"></span>
                        <button class="btn btn-sm" onclick="changeHopPage(1)" id="nextPageBtn">Next</button>
                        <select id="hopsPerPage" onchange="updateHopsPerPage()" style="margin-left: 20px; padding: 5px;">
                            <option value="10">10 hops per page</option>
                            <option value="20" selected>20 hops per page</option>
                            <option value="50">50 hops per page</option>
                            <option value="all">Show all</option>
                        </select>
                    </div>
                    
                    <div id="hopsList"></div>
                    <button class="btn" onclick="addNewHop()" id="addHopBtn">Start Next Hop</button>
                    
                    <!-- Complete Investigation Section -->
                    <div id="completeInvestigationSection" style="display: none;">
                        <div style="background: linear-gradient(135deg, #e8f5e8 0%, #d4edda 100%); border: 3px solid #27ae60; border-radius: 12px; padding: 30px; text-align: center; margin-top: 30px; box-shadow: 0 4px 15px rgba(39, 174, 96, 0.2);">
                            <h3 style="color: #27ae60; font-size: 1.5rem; margin-bottom: 15px;">Investigation Complete</h3>
                            <p style="color: #2c3e50; margin-bottom: 25px; font-size: 16px; line-height: 1.6;">
                                All trace paths have been documented and validated. Review your final thread values below.
                            </p>
                            <div id="finalThreadSummary" style="background: white; border-radius: 8px; padding: 20px; margin: 20px 0; border: 2px solid #27ae60;"></div>
                            <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                                <button class="btn btn-success btn-large" onclick="exportReport()">
                                    Export B.A.T.S. Report
                                </button>
                                <button class="btn btn-secondary" onclick="exportJSON()">
                                    Export JSON Data
                                </button>
                                <button class="btn" onclick="exportCSV()">
                                    Export CSV
                                </button>
                                <button class="btn btn-confirm" onclick="saveInvestigation()">
                                    Save Investigation and Calculate ART
                                </button>
                            </div>
                        </div>
                    </div>

                    <!-- Visualization prompt section - only shown when investigation is complete -->
                    <div id="visualizationPromptSection" style="display: none; margin-top: 30px; padding: 20px; background: #f8f9fa; border-radius: 8px; border: 2px solid #9b59b6; text-align: center;">
                        <h4 style="color: #2c3e50; margin-bottom: 15px;">Ready to Visualize Your Investigation</h4>
                        <p style="color: #666; margin-bottom: 20px;">Create a visual flow diagram of your cryptocurrency trace to better understand fund movement patterns.</p>
                        <button class="btn btn-confirm" onclick="switchTab('flowdiagram')" style="background: #9b59b6; color: white; padding: 12px 30px; font-size: 16px;">
                            Generate Flow Diagram
                        </button>
                    </div>
                </div>

                <!-- PK Converter Tab -->
                <div id="pkconverter-tab" class="tab-content">
                    <div class="section-title">Public Key Converter & Cross-Chain Analysis</div>

                    <div style="background: #e8f4fd; border-left: 4px solid #3498db; padding: 15px; margin-bottom: 25px; border-radius: 4px;">
                        <strong>Cross-Chain Forensics Tool:</strong> Convert public keys to addresses across all blockchain networks and instantly check for activity.
                    </div>

                    <div style="background: white; padding: 30px; border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.08);">
                        <div style="text-align: center; padding: 40px;">
                            <h3 style="color: #2c3e50; margin-bottom: 20px;">🔑 Public Key Converter</h3>
                            <p style="color: #666; margin-bottom: 30px;">This tool helps investigators identify addresses controlled by the same entity across different blockchains</p>
                            <button onclick="openPKConverter()" class="btn btn-primary" style="padding: 15px 40px; font-size: 18px;">
                                Open PK Converter Tool
                            </button>
                        </div>
                    </div>
                </div>

                <!-- Flow Diagram Tab -->
                <div id="flowdiagram-tab" class="tab-content">
                    <!-- Enhanced Graph Visualization Container -->
                    <div id="visualizationContainer" style="width: 100%; min-height: 800px; background: #f8f9fa;">
                        <div class="visualization-header" style="padding: 25px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                            <h2 style="margin: 0 0 10px 0; font-size: 2rem;">🌐 Investigation Flow Visualization</h2>
                            <p style="margin: 0; opacity: 0.95;">Interactive graph showing the complete flow of stolen funds through the blockchain</p>
                        </div>

                        <div class="visualization-controls" style="padding: 15px 20px; background: white; border-bottom: 1px solid #dee2e6; display: flex; justify-content: space-between; align-items: center; flex-wrap: wrap; gap: 15px; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
                            <div class="zoom-controls" style="display: flex; gap: 8px;">
                                <button onclick="zoomIn()" class="btn btn-secondary" title="Zoom In">🔍+</button>
                                <button onclick="zoomOut()" class="btn btn-secondary" title="Zoom Out">🔍-</button>
                                <button onclick="resetZoom()" class="btn btn-secondary" title="Reset View">🎯</button>
                                <button onclick="fitToScreen()" class="btn btn-secondary" title="Fit to Screen">📐</button>
                                <span id="zoomLevel" style="padding: 8px 12px; background: #f8f9fa; border-radius: 4px; font-family: monospace;">100%</span>
                            </div>

                            <!-- DAG-only visualization - no layout selector needed -->

                            <div class="filter-controls" style="display: flex; gap: 8px;">
                                <input type="text" id="searchWallet" placeholder="Search wallet..." onkeyup="searchGraph(this.value)"
                                       style="padding: 8px 12px; border: 1px solid #dee2e6; border-radius: 4px; width: 200px;">
                                <button onclick="toggleLabels()" class="btn btn-secondary" title="Toggle Labels">🏷️</button>
                                <button onclick="toggleAmounts()" class="btn btn-secondary" title="Toggle Amounts">💰</button>
                            </div>

                            <div class="export-controls" style="display: flex; gap: 8px;">
                                <button onclick="expandAllHops()" class="btn btn-primary" title="Expand All Hops">📂 Expand All</button>
                                <button onclick="collapseAllHops()" class="btn btn-primary" title="Collapse All Hops">📁 Collapse All</button>
                                <button onclick="showExportOptions()" class="btn btn-success" title="Export Graph">💾 Export</button>
                                <button onclick="shareGraph()" class="btn btn-info" title="Share">📤 Share</button>
                                <button onclick="showComprehensiveReport()" class="btn btn-warning" title="View Report" style="background: linear-gradient(135deg, #f39c12, #e67e22); color: white; font-weight: bold;">📄 Full Report</button>
                                <button onclick="showTab('summary')" class="btn btn-secondary" title="Go to Summary">📊 Summary</button>
                            </div>
                        </div>

                        <div style="position: relative; width: 100%; background: white; max-height: 80vh; overflow-y: auto;">
                            <div id="graphContainer" style="width: 100%; height: 700px; position: relative; overflow: hidden; cursor: grab;">
                                <svg id="investigationGraph" width="100%" height="100%">
                                    <defs>
                                        <!-- Define gradients and patterns -->
                                        <linearGradient id="victimGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                            <stop offset="0%" style="stop-color:#ff6b6b;stop-opacity:1" />
                                            <stop offset="100%" style="stop-color:#ee5a24;stop-opacity:1" />
                                        </linearGradient>
                                        <linearGradient id="exchangeGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                            <stop offset="0%" style="stop-color:#a29bfe;stop-opacity:1" />
                                            <stop offset="100%" style="stop-color:#6c5ce7;stop-opacity:1" />
                                        </linearGradient>
                                        <linearGradient id="mixerGradient" x1="0%" y1="0%" x2="100%" y2="100%">
                                            <stop offset="0%" style="stop-color:#636e72;stop-opacity:1" />
                                            <stop offset="100%" style="stop-color:#2d3436;stop-opacity:1" />
                                        </linearGradient>
                                        <!-- Arrow markers for different edge types -->
                                        <marker id="arrowhead" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                                            <polygon points="0 0, 10 3, 0 6" fill="#555" />
                                        </marker>
                                        <marker id="arrowhead-terminal" markerWidth="10" markerHeight="10" refX="9" refY="3" orient="auto">
                                            <polygon points="0 0, 10 3, 0 6" fill="#6c5ce7" />
                                        </marker>
                                    </defs>
                                    <g id="graphContent" transform="translate(0,0) scale(1)">
                                        <!-- Graph will be dynamically generated here -->
                                    </g>
                                </svg>

                                <!-- Minimap for navigation -->
                                <div id="miniMap" style="position: absolute; bottom: 20px; right: 20px; width: 200px; height: 150px; background: white; border: 2px solid #dee2e6; border-radius: 8px; box-shadow: 0 2px 8px rgba(0,0,0,0.1); overflow: hidden;">
                                    <svg id="miniMapSvg" width="100%" height="100%" style="background: #f8f9fa;">
                                        <!-- Minimap content -->
                                    </svg>
                                    <div id="viewportIndicator" style="position: absolute; border: 2px solid #007bff; background: rgba(0,123,255,0.1); pointer-events: none;"></div>
                                </div>

                                <!-- Node details popup -->
                                <div id="nodeDetailsPopup" style="display: none; position: absolute; background: white; padding: 15px; border-radius: 8px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; max-width: 300px;">
                                    <div id="nodeDetailsContent"></div>
                                </div>
                            </div>
                        </div>

                        <div class="visualization-legend" style="padding: 20px; background: white; border-top: 1px solid #dee2e6;">
                            <h4 style="margin: 0 0 15px 0; color: #495057;">Legend</h4>
                            <div style="display: flex; flex-wrap: wrap; gap: 20px; font-size: 14px;">
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <span style="display: inline-block; width: 24px; height: 24px; background: linear-gradient(135deg, #ff6b6b, #ee5a24); border-radius: 50%;"></span>
                                    <span>Victim / RED Wallet</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <span style="display: inline-block; width: 24px; height: 24px; background: #2d3436; border-radius: 50%;"></span>
                                    <span>BLACK Wallet (Attacker)</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <span style="display: inline-block; width: 24px; height: 24px; background: linear-gradient(135deg, #a29bfe, #6c5ce7); border-radius: 50%;"></span>
                                    <span>PURPLE (Exchange)</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <span style="display: inline-block; width: 24px; height: 24px; background: #636e72; border-radius: 50%;"></span>
                                    <span>GRAY (Mixer/Obfuscated)</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <span style="display: inline-block; width: 24px; height: 24px; background: #fdcb6e; border-radius: 50%;"></span>
                                    <span>YELLOW (Hub/Convergence)</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <span style="display: inline-block; width: 24px; height: 24px; background: #00b894; border-radius: 50%;"></span>
                                    <span>GREEN (Clean/Verified)</span>
                                </div>
                                <div style="display: flex; align-items: center; gap: 8px;">
                                    <span style="display: inline-block; width: 0; height: 0; border-left: 15px solid transparent; border-right: 15px solid transparent; border-bottom: 20px solid #e17055;"></span>
                                    <span>Swap/Conversion</span>
                                </div>
                            </div>
                        </div>

                        <!-- Statistics panel -->
                        <div id="graphStats" style="padding: 20px; background: #f8f9fa; border-top: 1px solid #dee2e6;">
                            <h4 style="margin: 0 0 15px 0; color: #495057;">Graph Statistics</h4>
                            <div id="statsContent" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                                <!-- Stats will be populated dynamically -->
                            </div>
                        </div>
                    </div>
                    <div class="section-title">Visual Flow Diagram</div>
                    
                    <div id="flowDiagramControls" style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                        <button class="btn btn-secondary" onclick="generateFlowDiagram()" style="margin-right: 10px;">
                            Generate/Refresh Diagram
                        </button>
                        <button class="btn" onclick="exportFlowDiagram('svg')" style="margin-right: 10px;">
                            Export SVG
                        </button>
                        <button class="btn" onclick="exportFlowDiagram('png')" style="margin-right: 10px;">
                            Export PNG
                        </button>
                        <button class="btn" onclick="printFlowDiagram()" style="margin-right: 10px;">
                            Print
                        </button>
                        <button class="btn btn-success" onclick="generateBATSTrainingExample()" style="margin-left: 20px;">
                            Show Training Example
                        </button>
                    </div>
                    
                    <div id="flowDiagramContainer" style="background: white; border: 1px solid #e8f0fe; border-radius: 8px; padding: 20px; min-height: 600px; overflow: auto;">
                        <svg id="flowDiagramSVG" width="100%" height="100%">
                            <!-- Flow diagram will be generated here -->
                        </svg>
                    </div>
                    <!-- Summary prompt will be added dynamically when investigation is complete -->
                </div>

                <!-- Summary Tab -->
                <div id="summary-tab" class="tab-content">
                    <div class="section-title">Step 6: Investigation Summary & Case Conclusion</div>

                    <!-- Case Conclusion Dashboard -->
                    <div id="caseConclusionDashboard" style="margin-bottom: 30px;">
                        <div style="background: linear-gradient(135deg, #3498db 0%, #2c3e50 100%); color: white; padding: 25px; border-radius: 12px 12px 0 0; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                            <h2 style="margin: 0 0 10px 0; font-size: 1.8rem;">📊 Case Conclusion Dashboard</h2>
                            <p style="margin: 0; opacity: 0.95;">Complete overview of your investigation with all indexes and reports</p>
                        </div>

                        <!-- Quick Stats Cards -->
                        <div style="background: white; padding: 20px; border: 1px solid #dee2e6; display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">
                            <div class="stat-card" style="background: #fff3e0; border-left: 4px solid #ff9800; padding: 15px; border-radius: 4px;">
                                <h4 style="color: #ff9800; margin: 0 0 5px 0;">Victims</h4>
                                <div id="victimCountStat" style="font-size: 24px; font-weight: bold; color: #333;">0</div>
                            </div>
                            <div class="stat-card" style="background: #e3f2fd; border-left: 4px solid #2196f3; padding: 15px; border-radius: 4px;">
                                <h4 style="color: #2196f3; margin: 0 0 5px 0;">Total Wallets</h4>
                                <div id="walletCountStat" style="font-size: 24px; font-weight: bold; color: #333;">0</div>
                            </div>
                            <div class="stat-card" style="background: #f3e5f5; border-left: 4px solid #9c27b0; padding: 15px; border-radius: 4px;">
                                <h4 style="color: #9c27b0; margin: 0 0 5px 0;">Terminal Wallets</h4>
                                <div id="terminalCountStat" style="font-size: 24px; font-weight: bold; color: #333;">0</div>
                            </div>
                            <div class="stat-card" style="background: #e8f5e9; border-left: 4px solid #4caf50; padding: 15px; border-radius: 4px;">
                                <h4 style="color: #4caf50; margin: 0 0 5px 0;">Funds Traced</h4>
                                <div id="fundsTracedStat" style="font-size: 24px; font-weight: bold; color: #333;">0</div>
                            </div>
                        </div>

                        <!-- Index Access Section -->
                        <div style="background: white; padding: 20px; border: 1px solid #dee2e6; margin-bottom: 20px;">
                            <h3 style="color: #2c3e50; margin-bottom: 20px; border-bottom: 2px solid #3498db; padding-bottom: 10px;">📁 Investigation Indexes</h3>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px;">
                                <!-- Victim Index -->
                                <div class="index-card" style="border: 1px solid #ffc107; border-radius: 8px; padding: 15px; background: #fffaf0;">
                                    <h4 style="color: #ff6b6b; margin: 0 0 10px 0;">🎯 Victim Index</h4>
                                    <p style="color: #666; font-size: 14px; margin-bottom: 15px;">All victim deposits and initial transactions</p>
                                    <button class="btn btn-sm" onclick="viewVictimIndex()" style="background: #ff6b6b; color: white; width: 100%;">View & Export</button>
                                </div>

                                <!-- Red Wallet Index -->
                                <div class="index-card" style="border: 1px solid #dc3545; border-radius: 8px; padding: 15px; background: #fff5f5;">
                                    <h4 style="color: #dc3545; margin: 0 0 10px 0;">🔴 Red Wallet Index</h4>
                                    <p style="color: #666; font-size: 14px; margin-bottom: 15px;">Victim-facing wallets that received initial funds</p>
                                    <button class="btn btn-sm" onclick="switchTab('walletindexes'); switchWalletIndex('red');" style="background: #dc3545; color: white; width: 100%;">View & Export</button>
                                </div>

                                <!-- Universal Wallet Index -->
                                <div class="index-card" style="border: 1px solid #3498db; border-radius: 8px; padding: 15px; background: #f0f8ff;">
                                    <h4 style="color: #3498db; margin: 0 0 10px 0;">🌐 Universal Wallet Index</h4>
                                    <p style="color: #666; font-size: 14px; margin-bottom: 15px;">Complete catalog of all wallets in investigation</p>
                                    <button class="btn btn-sm" onclick="switchTab('walletindexes'); switchWalletIndex('universal');" style="background: #3498db; color: white; width: 100%;">View & Export</button>
                                </div>

                                <!-- Terminal Wallet Index -->
                                <div class="index-card" style="border: 1px solid #9c27b0; border-radius: 8px; padding: 15px; background: #faf0ff;">
                                    <h4 style="color: #9c27b0; margin: 0 0 10px 0;">🏦 Terminal Wallet Index</h4>
                                    <p style="color: #666; font-size: 14px; margin-bottom: 15px;">All exchange arrivals and terminal points</p>
                                    <button class="btn btn-sm" onclick="viewTerminalWalletIndex()" style="background: #9c27b0; color: white; width: 100%;">View & Export</button>
                                </div>
                            </div>
                        </div>

                        <!-- Reports Section -->
                        <div style="background: white; padding: 20px; border: 1px solid #dee2e6; border-radius: 0 0 12px 12px;">
                            <h3 style="color: #2c3e50; margin-bottom: 20px; border-bottom: 2px solid #27ae60; padding-bottom: 10px;">📄 Generate Reports</h3>
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 15px;">
                                <button class="btn btn-success btn-large" onclick="exportReport()" style="padding: 15px;">
                                    📊 Export Complete B.A.T.S. Report
                                </button>
                                <button class="btn btn-primary btn-large" onclick="exportNarrativeReport()" style="background: #0066cc; padding: 15px;">
                                    📝 Export Narrative Report (Word)
                                </button>
                                <button class="btn btn-secondary btn-large" onclick="exportTerminalWalletReport()" style="padding: 15px;">
                                    🏦 Export Terminal Wallet Report
                                </button>
                                <button class="btn btn-info btn-large" onclick="exportAllIndexes()" style="background: #17a2b8; padding: 15px;">
                                    📦 Export All Indexes (ZIP)
                                </button>
                                <button class="btn btn-warning btn-large" onclick="exportJSON()" style="background: #ffc107; color: #333; padding: 15px;">
                                    💾 Export JSON Data
                                </button>
                                <button class="btn btn-large" onclick="exportCSV()" style="padding: 15px;">
                                    📋 Export CSV Data
                                </button>
                            </div>
                        </div>
                    </div>

                    <div id="summaryContent"></div>

                    <div class="export-section" style="display: none;">
                        <div class="section-title">Export Options</div>
                        <button class="btn btn-success" onclick="exportReport()">Export B.A.T.S. Report</button>
                        <button class="btn btn-primary" onclick="exportNarrativeReport()" style="background: #0066cc;">📄 Export Narrative Report (Word)</button>
                        <button class="btn btn-secondary" onclick="exportJSON()">Export JSON Data</button>
                        <button class="btn" onclick="exportCSV()">Export CSV</button>
                        <button class="btn" onclick="openApiSettings()" style="background: #95a5a6;">⚙️ API Settings</button>
                    </div>
                    
                    <!-- Investigation Complete Message -->
                    <div style="margin-top: 30px; padding: 20px; background: linear-gradient(135deg, #e8f5e8 0%, #d4edda 100%); border-radius: 8px; border: 2px solid #27ae60; text-align: center;">
                        <h4 style="color: #27ae60; margin-bottom: 15px;">Investigation Complete!</h4>
                        <p style="color: #2c3e50; margin-bottom: 20px;">
                            Congratulations! You have successfully completed your B.A.T.S. cryptocurrency investigation. 
                            Your report is ready for legal proceedings and regulatory compliance.
                        </p>
                        <p style="color: #666; font-size: 14px;">
                            Remember to save your investigation file regularly and keep backup copies of all exported reports.
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Root Total Confirmation Modal -->
    <div id="rootTotalModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Confirm Investigation Root Total</h2>
                <p>Review your baseline before beginning trace documentation</p>
            </div>
            
            <!-- Root Total Explanation -->
            <div class="root-explanation">
                <h4>📚 What is a Root Total?</h4>
                <ul>
                    <li><strong>Investigation Baseline:</strong> The total amount of confirmed victim losses</li>
                    <li><strong>Mathematical Foundation:</strong> All traced amounts must sum back to this total</li>
                    <li><strong>Golden Thread:</strong> Ensures complete accounting and prevents scope creep</li>
                    <li><strong>Legal Requirement:</strong> Essential for asset forfeiture case integrity</li>
                </ul>
            </div>

            <!-- Transaction Breakdown -->
            <div id="rootTotalBreakdown"></div>
            
            <!-- Root Total Display -->
            <div class="root-total-display">
                <div style="font-size: 1.2rem; margin-bottom: 10px;">🔢 Total Root Amount</div>
                <div id="totalRootAmount" class="root-total-amount">$0</div>
                <div style="font-size: 0.9rem; color: #666; margin-top: 10px;">
                    This becomes your Adjusted Root Total (ART) for validation
                </div>
            </div>
            
            <div style="text-align: center; margin-top: 30px;">
                <button class="btn btn-confirm btn-large" onclick="confirmAndProceed()">
                    Confirm Root Total & Start Tracing
                </button>
                <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Convergence Modal -->
    <div id="convergenceModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Record Convergence</h2>
                <p>Select multiple traces that are merging at a single wallet</p>
            </div>
            <div id="convergenceTraceSelection"></div>
            <div class="form-group">
                <label>Resulting Notation</label>
                <input type="text" id="convergenceNotation" placeholder="e.g., V1-T1(3)-H6 or V1,V2-T1-H4">
            </div>
            <div class="form-group">
                <label>Resulting Hop Level</label>
                <input type="number" id="convergenceHopLevel" readonly>
            </div>
            <div class="form-group">
                <label>Total Amount</label>
                <input type="number" id="convergenceAmount" readonly>
            </div>
            <div style="text-align: center; margin-top: 25px;">
                <button class="btn btn-confirm" onclick="createConvergenceTrace()">Create Merged Trace</button>
                <button class="btn btn-secondary" onclick="closeConvergenceModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Asset Conversion Modal -->
    <div id="assetConversionModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Asset Conversion Documentation</h2>
                <p>Document the cryptocurrency conversion process</p>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                <div class="form-group">
                    <label>Original Currency (From Source Thread)</label>
                    <select id="conversionFromCurrency" disabled style="background: #f8f9fa;">
                        <option value="">Not Set</option>
                        <option value="USD">US Dollar</option>
                        <option value="BTC">Bitcoin</option>
                        <option value="ETH">Ethereum</option>
                        <option value="USDT">Tether</option>
                        <option value="USDC">USD Coin</option>
                        <option value="TRX">TRON</option>
                        <option value="SOL">Solana</option>
                        <option value="ADA">Cardano</option>
                        <option value="DAI">DAI</option>
                        <option value="BNB">BNB</option>
                        <option value="MATIC">MATIC</option>
                        <option value="AVAX">AVAX</option>
                        <option value="HYPE">HYPE</option>
                        <option value="MNT">MNT</option>
                        <option value="CUSTOM">Custom Currency</option>
                    </select>
                    <div style="font-size: 11px; color: #666; margin-top: 5px;">
                        Currency is inherited from the selected source thread
                    </div>
                </div>
                <div class="form-group">
                    <label>Converted To Currency</label>
                    <select id="conversionToCurrency">
                        <option value="USD">US Dollar</option>
                        <option value="BTC">Bitcoin</option>
                        <option value="ETH">Ethereum</option>
                        <option value="USDT">Tether</option>
                        <option value="USDC">USD Coin</option>
                        <option value="TRX">TRON</option>
                        <option value="SOL">Solana</option>
                        <option value="ADA">Cardano</option>
                        <option value="DAI">DAI</option>
                        <option value="BNB">BNB</option>
                        <option value="MATIC">MATIC</option>
                        <option value="AVAX">AVAX</option>
                        <option value="HYPE">HYPE</option>
                        <option value="MNT">MNT</option>
                        <option value="CUSTOM">Custom Currency</option>
                    </select>
                </div>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                <div class="form-group" id="customFromCurrencyGroup" style="display: none;">
                    <label>Custom Original Currency</label>
                    <input type="text" id="conversionFromCurrencyCustom" placeholder="e.g., DOGE, SHIB">
                </div>
                <div class="form-group" id="customToCurrencyGroup" style="display: none;">
                    <label>Custom Converted Currency</label>
                    <input type="text" id="conversionToCurrencyCustom" placeholder="e.g., DOGE, SHIB">
                </div>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                <div class="form-group">
                    <label>Original Amount</label>
                    <div style="display: flex; gap: 10px;">
                        <input type="number" step="0.01" id="conversionFromAmount" placeholder="Amount sent" style="flex: 1;">
                        <button class="btn btn-sm" onclick="copyConversionAmount()" title="Copy amount for stablecoin swaps" style="padding: 8px 12px;">
                            📋 Copy
                        </button>
                    </div>
                </div>
                <div class="form-group">
                    <label>Converted Amount</label>
                    <input type="number" step="0.01" id="conversionToAmount" placeholder="Amount received">
                </div>
            </div>

            <div class="form-group">
                <label>Conversion Platform/Service</label>
                <input type="text" id="conversionPlatform" placeholder="e.g., Uniswap, PancakeSwap, Bridge Protocol">
            </div>

            <div class="form-group">
                <label>Conversion Notes</label>
                <textarea id="conversionNotes" rows="3" placeholder="Additional details about the conversion process, fees, slippage, etc."></textarea>
            </div>
            
            <div style="text-align: center; margin-top: 25px;">
                <button class="btn btn-confirm" onclick="confirmAssetConversion()">Document Conversion</button>
                <button class="btn btn-secondary" onclick="closeAssetConversionModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Smart Allocation Modal -->
    <div id="smartAllocationModal" class="modal">
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-header">
                <h2>🎯 Smart Amount Allocation</h2>
                <p>Automatically calculate how to split a transaction amount across available funds</p>
            </div>
            
            <div style="background: #e3f2fd; border: 2px solid #2196f3; border-radius: 8px; padding: 20px; margin: 20px 0;">
                <h4 style="color: #1976d2; margin-bottom: 15px;">📚 What is this for?</h4>
                <p style="margin-bottom: 15px; font-size: 16px;">
                    When you see a transaction on the blockchain (e.g., 50 BTC sent), but you have funds from multiple sources 
                    (e.g., 30 BTC from one victim, 40 BTC from another), this tool helps you determine which funds were used.
                </p>
                <div style="background: white; border-radius: 6px; padding: 15px; margin-top: 10px;">
                    <strong>Example:</strong> If the scammer has 30 BTC from Victim 1 and 40 BTC from Victim 2, and sends 50 BTC:
                    <ul style="margin: 10px 0 0 20px;">
                        <li>The tool will automatically use all 30 BTC from Victim 1</li>
                        <li>Then take 20 BTC from Victim 2</li>
                        <li>Following FIFO (First In, First Out) principle</li>
                    </ul>
                </div>
            </div>
            
            <div style="background: #e8f5e8; border: 2px solid #27ae60; border-radius: 8px; padding: 20px; margin: 20px 0;">
                <h4 style="color: #27ae60; margin-bottom: 15px;">🔧 How it works:</h4>
                <p style="margin-bottom: 10px;">Enter the total amount from the blockchain transaction, and the system will:</p>
                <ol style="margin-left: 20px; color: #2c3e50;">
                    <li>Use available funds in chronological order (oldest first)</li>
                    <li>Fully deplete each source before using the next</li>
                    <li>Show you exactly how the amount is distributed across sources</li>
                </ol>
                <div style="margin-top: 15px; padding: 15px; background: white; border-radius: 6px; font-family: monospace; font-size: 12px;">
                    <div style="margin-bottom: 5px;"><strong>Example:</strong> You need 20 BTC</div>
                    <div style="margin-bottom: 3px;">• Source 1: V1-T1 has 10 BTC Use all 10 BTC</div>
                    <div style="margin-bottom: 3px;">• Source 2: V1-T2 has 15 BTC Use 10 BTC (5 BTC remains)</div>
                    <div style="color: #27ae60; font-weight: bold;">Total allocated: 20 BTC</div>
                </div>
            </div>
            
            <div style="margin-bottom: 20px;">
                <h4 style="color: #2c3e50; margin-bottom: 15px;">Target Amount:</h4>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="number" 
                           id="smartAllocationTargetAmount"
                           step="0.00000001" 
                           placeholder="Enter amount to allocate"
                           style="flex: 1; padding: 12px; border: 2px solid #27ae60; border-radius: 6px; font-size: 16px;">
                    <select id="smartAllocationTargetCurrency" 
                            style="padding: 12px; border: 2px solid #27ae60; border-radius: 6px; font-size: 16px;">
                        <option value="">Select currency...</option>
                    </select>
                </div>
            </div>
            
            <div id="smartAllocationAvailableSources" style="margin-bottom: 20px; display: none;">
                <h4 style="color: #2c3e50; margin-bottom: 15px;">Available Source Threads:</h4>
                <div id="availableSourcesList" style="max-height: 200px; overflow-y: auto;"></div>
            </div>
            
            <div id="smartAllocationPreview" style="display: none;">
                <h4 style="color: #2c3e50; margin-bottom: 15px;">Allocation Preview:</h4>
                <div id="allocationPreviewContent"></div>
            </div>
            
            <div id="smartAllocationError" style="display: none; background: #fee; border: 1px solid #c00; border-radius: 6px; padding: 15px; margin: 20px 0; color: #c00;">
            </div>
            
            <div style="text-align: center; margin-top: 25px;">
                <button class="btn btn-confirm" id="confirmSmartAllocation" onclick="confirmSmartAllocation()" style="display: none;">
                    Apply Allocation
                </button>
                <button class="btn btn-secondary" onclick="closeSmartAllocationModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Excel Import Modal -->
    <div id="excelImportModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>📊 Import Excel Traces</h2>
                <p>Import blockchain traces from your analysis software</p>
            </div>
            
            <div style="background: #e8f4f8; border: 2px solid #3498db; border-radius: 8px; padding: 20px; margin: 20px 0;">
                <h4 style="color: #2c3e50; margin-bottom: 15px;">Required Excel Format</h4>
                <div style="font-family: monospace; font-size: 12px; background: white; padding: 15px; border-radius: 6px;">
                    <div style="font-weight: bold; margin-bottom: 8px; color: #666;">
                        Hop_Notation | Wallet_Address | Wallet_ID | Amount | Currency
                    </div>
                    <div style="margin-bottom: 4px;">V1-T1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| bc1q...abc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| RED1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 5000&nbsp;&nbsp;&nbsp;| USD</div>
                    <div style="margin-bottom: 4px;">V1-T1-H1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 1A2B...def&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| BLACK1&nbsp;&nbsp;&nbsp;&nbsp;| 5000&nbsp;&nbsp;&nbsp;| USD</div>
                    <div style="margin-bottom: 4px;">V1-T1-H2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 3CdE...ghi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| BLUE1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 4950&nbsp;&nbsp;&nbsp;| USD</div>
                    <div>V2-T1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| bc1q...xyz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| RED2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 2500&nbsp;&nbsp;&nbsp;| BTC</div>
                </div>
                <div style="margin-top: 15px; font-size: 14px; color: #2c3e50;">
                    <strong>Supported Wallet IDs:</strong> RED1, BLACK1, BLUE1, PURPLE1, YELLOW1, ORANGE1, BROWN1, PINK1, GRAY1, GREEN1
                </div>
            </div>
            
            <div id="importPreview" style="display: none;">
                <h4 style="color: #2c3e50; margin-bottom: 15px;">Import Preview</h4>
                <div id="importSummary" style="background: #f8f9fa; padding: 15px; border-radius: 6px; margin-bottom: 15px;"></div>
                <div id="importErrors" style="display: none;"></div>
            </div>
            
            <div style="text-align: center; margin-top: 25px;">
                <button class="btn btn-confirm" id="confirmImportBtn" onclick="confirmExcelImport()" style="display: none;">
                    Import Investigation
                </button>
                <button class="btn btn-secondary" onclick="closeExcelImportModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Bulk Transaction Modal -->
    <div id="bulkTransactionModal" class="modal">
        <div class="modal-content" style="max-width: 900px;">
            <div class="modal-header">
                <h2>Bulk Add Transactions</h2>
                <p>Paste multiple transaction hashes (one per line) to add them all at once. They will be automatically sorted by date.</p>
            </div>
            
            <div style="margin: 20px 0;">
                <label style="display: block; font-weight: bold; margin-bottom: 10px;">Transaction Hashes:</label>
                <textarea id="bulkTransactionHashes" 
                          placeholder="Paste transaction hashes here, one per line&#10;&#10;Example:&#10;0x123abc...&#10;0x456def...&#10;0x789ghi..."
                          style="width: 100%; height: 200px; padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace; font-size: 13px;"></textarea>
                
                <div style="margin-top: 15px; padding: 15px; background: #e8f4f8; border: 1px solid #3498db; border-radius: 6px;">
                    <h4 style="color: #2c3e50; margin-bottom: 10px;">💡 How it works:</h4>
                    <ul style="margin: 0; padding-left: 20px; color: #34495e;">
                        <li>Paste all transaction hashes at once</li>
                        <li>Click "Process Transactions" to fetch all data</li>
                        <li>Transactions will be automatically sorted by date</li>
                        <li>V-T notation will be assigned in chronological order</li>
                        <li>Failed lookups will be created as empty transactions for manual entry</li>
                    </ul>
                </div>
                
                <div id="bulkProcessingStatus" style="margin-top: 15px; display: none;">
                    <div style="padding: 10px; background: #f8f9fa; border-radius: 4px;">
                        <div id="bulkProgressBar" style="background: #e0e0e0; height: 20px; border-radius: 10px; overflow: hidden;">
                            <div id="bulkProgressFill" style="background: #3498db; height: 100%; width: 0%; transition: width 0.3s;"></div>
                        </div>
                        <div id="bulkProgressText" style="text-align: center; margin-top: 10px; font-size: 14px; color: #666;">Processing...</div>
                    </div>
                </div>
                
                <div id="bulkProcessingResults" style="margin-top: 15px; display: none;">
                    <h4>Processing Results:</h4>
                    <div id="bulkResultsList" style="max-height: 300px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px; padding: 10px; background: #f8f9fa;"></div>
                </div>
            </div>
            
            <div style="text-align: center; margin-top: 25px;">
                <button class="btn btn-confirm" onclick="processBulkTransactions()" id="bulkProcessBtn">
                    🚀 Process Transactions
                </button>
                <button class="btn btn-secondary" onclick="closeBulkTransactionModal()">
                    Cancel
                </button>
            </div>
        </div>
    </div>

    <!-- Transfer Selection Modal -->
    <div id="transferSelectionModal" class="modal">
        <div class="modal-content" style="max-width: 900px;">
            <div class="modal-header">
                <h2>Select Transfer</h2>
                <p>This transaction contains multiple token transfers. Please select the one that belongs to your victim:</p>
            </div>
            
            <!-- Filter Section -->
            <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 15px 0;">
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr auto; gap: 10px; align-items: end;">
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: 500;">Filter by Asset:</label>
                        <select id="transferAssetFilter" 
                               style="width: 100%; padding: 8px; border: 2px solid #e8f0fe; border-radius: 6px;"
                               onchange="filterTransfers()">
                            <option value="">All Assets</option>
                        </select>
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: 500;">Filter by Amount:</label>
                        <input type="text" id="transferAmountFilter" placeholder="e.g., 1000 or 1000.50" 
                               style="width: 100%; padding: 8px; border: 2px solid #e8f0fe; border-radius: 6px;"
                               oninput="filterTransfers()">
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: 500;">Filter by Address:</label>
                        <input type="text" id="transferAddressFilter" placeholder="To or From address" 
                               style="width: 100%; padding: 8px; border: 2px solid #e8f0fe; border-radius: 6px;"
                               oninput="filterTransfers()">
                    </div>
                    <button class="btn btn-secondary" onclick="clearTransferFilters()" style="padding: 8px 15px;">
                        Clear
                    </button>
                </div>
                <div id="filterResultsInfo" style="margin-top: 10px; font-size: 14px; color: #666;"></div>
            </div>
            
            <div id="transfersList" style="margin: 20px 0; max-height: 400px; overflow-y: auto;">
                <!-- Transfers will be populated here -->
            </div>
            
            <div style="text-align: center; margin-top: 25px;">
                <button class="btn btn-secondary" onclick="closeTransferSelectionModal()">
                    Cancel
                </button>
            </div>
        </div>
    </div>

    <!-- Address Attribution Modal -->
    <div id="attributionModal" class="modal">
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-header">
                <h2>🔍 Address Attribution Detected</h2>
                <button class="close" onclick="hideModal('attributionModal')">&times;</button>
            </div>
            
            <div id="attributionContent" style="padding: 20px;">
                <!-- Content will be dynamically populated -->
            </div>
            
            <div style="text-align: center; margin-top: 20px; padding-top: 20px; border-top: 1px solid #e8f0fe;">
                <button class="btn btn-primary" onclick="applyAttribution()">
                    Apply Attribution to Wallet
                </button>
                <button class="btn btn-secondary" onclick="hideModal('attributionModal')">
                    Ignore
                </button>
            </div>
        </div>
    </div>

    <!-- API Settings Modal -->
    <div id="apiSettingsModal" class="modal">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-header">
                <h2>⚙️ Blockchain API Settings</h2>
                <p>Configure API keys for enhanced reliability and higher rate limits</p>
            </div>
            
            <div style="background: #e8f4f8; border: 2px solid #3498db; border-radius: 8px; padding: 20px; margin: 20px 0;">
                <h4 style="color: #2c3e50; margin-bottom: 15px;">Why Use API Keys?</h4>
                <ul style="margin-left: 20px; color: #34495e;">
                    <li>Higher rate limits (more lookups per day)</li>
                    <li>More reliable service</li>
                    <li>Access to additional features</li>
                    <li>All services offer FREE tiers</li>
                </ul>
            </div>
            
            <div style="margin: 20px 0;">
                <h4>API Key Configuration</h4>
                
                <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 6px;">
                    <label style="display: block; font-weight: bold; margin-bottom: 5px;">
                        Ethereum - Etherscan API Key
                    </label>
                    <input type="text" id="etherscanApiKey" placeholder="Your Etherscan API key" 
                           style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace;">
                    <div style="font-size: 12px; color: #666; margin-top: 5px;">
                        Get free key at: <a href="https://etherscan.io/apis" target="_blank" style="color: #3498db;">https://etherscan.io/apis</a>
                    </div>
                </div>
                
                <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 6px;">
                    <label style="display: block; font-weight: bold; margin-bottom: 5px;">
                        Bitcoin - Blockchain.com API Key (Optional)
                    </label>
                    <input type="text" id="blockchainApiKey" placeholder="Your Blockchain.com API key (optional)" 
                           style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace;">
                    <div style="font-size: 12px; color: #666; margin-top: 5px;">
                        Works without key, but get one for higher limits at: <a href="https://www.blockchain.com/api" target="_blank" style="color: #3498db;">https://www.blockchain.com/api</a>
                    </div>
                </div>
                
                <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 6px;">
                    <label style="display: block; font-weight: bold; margin-bottom: 5px;">
                        Tron - TronGrid API Key (Optional)
                    </label>
                    <input type="text" id="trongridApiKey" placeholder="Your TronGrid API key (optional)" 
                           style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace;">
                    <div style="font-size: 12px; color: #666; margin-top: 5px;">
                        Works without key, but get one for stability at: <a href="https://www.trongrid.io/" target="_blank" style="color: #3498db;">https://www.trongrid.io/</a>
                    </div>
                </div>
                
                <div style="margin-bottom: 20px; padding: 15px; background: #e8f5e9; border-radius: 6px; border: 2px solid #4caf50;">
                    <label style="display: block; font-weight: bold; margin-bottom: 5px; color: #2e7d32;">
                        🔑 Solscan Pro API (Attribution Enabled by Default)
                    </label>
                    <div style="background: #d4edda; padding: 10px; border-radius: 4px; margin-bottom: 10px;">
                        <strong style="color: #27ae60;">✓ Solana attribution is enabled for all users</strong><br>
                        <span style="font-size: 12px; color: #555;">Solscan Pro API provides enhanced wallet attribution for Solana addresses</span>
                    </div>
                    <input type="text" id="solscanApiKey" placeholder="Optional: Override with your own API key"
                           style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace;">
                    <div style="font-size: 12px; color: #666; margin-top: 5px;">
                        Advanced users can override with their own key. Get one at: <a href="https://pro-api.solscan.io/pro-api-docs/v2.0" target="_blank" style="color: #3498db;">https://pro-api.solscan.io/</a>
                    </div>
                </div>

                <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 6px;">
                    <label style="display: block; font-weight: bold; margin-bottom: 5px;">
                        Solana RPC Endpoint
                    </label>
                    <input type="text" id="solanaRpcEndpoint" placeholder="https://api.mainnet-beta.solana.com"
                           value="https://api.mainnet-beta.solana.com"
                           style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace;">
                    <div style="font-size: 12px; color: #666; margin-top: 5px;">
                        Default public RPC or use: <a href="https://www.helius.dev/" target="_blank" style="color: #3498db;">Helius</a>,
                        <a href="https://www.quicknode.com/" target="_blank" style="color: #3498db;">QuickNode</a>
                    </div>
                </div>
                
                <div style="margin-bottom: 20px; padding: 15px; background: #e6f3ff; border-radius: 6px; border: 2px solid #0066cc;">
                    <label style="display: block; font-weight: bold; margin-bottom: 5px; color: #0066cc;">
                        🔍 Arkham Intelligence API (Attribution Enabled by Default)
                    </label>
                    <div style="background: #d4edda; padding: 10px; border-radius: 4px; margin-bottom: 10px;">
                        <strong style="color: #27ae60;">✓ Attribution is enabled for all users</strong><br>
                        <span style="font-size: 12px; color: #555;">Both Arkham and Etherscan attribution checks are active by default</span>
                    </div>
                    <input type="text" id="arkhamApiKey" placeholder="Optional: Override with your own API key" 
                           style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace;">
                    <div style="font-size: 12px; color: #666; margin-top: 5px;">
                        Advanced users can override with their own key. Get one at: <a href="https://info.arkm.com/api-platform" target="_blank" style="color: #3498db;">https://info.arkm.com/api-platform</a>
                    </div>
                    <div style="margin-top: 10px;">
                        <label style="display: flex; align-items: center; font-size: 13px;">
                            <input type="checkbox" id="arkhamAutoCheck" style="margin-right: 8px;" checked>
                            Automatically check addresses for attribution (recommended)
                        </label>
                    </div>
                </div>
                
                <div style="margin-bottom: 20px; padding: 15px; background: #fff3cd; border: 2px solid #ffc107; border-radius: 6px;">
                    <h5 style="color: #856404; margin-bottom: 10px;">🔐 Security Note</h5>
                    <p style="font-size: 13px; color: #856404; margin: 0;">
                        API keys are stored locally in your browser only. They are never sent to any server except the official blockchain APIs.
                        For production use, consider using a backend proxy for additional security.
                    </p>
                </div>
                
            </div>
            
            <div style="text-align: center; margin-top: 25px;">
                <button class="btn btn-confirm" onclick="saveApiSettings()">
                    Save Settings
                </button>
                <button class="btn btn-secondary" onclick="closeApiSettingsModal()">
                    Cancel
                </button>
            </div>
        </div>
    </div>

    <!-- Blockchain Lookup Modal -->
    <div id="blockchainLookupModal" class="modal">
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-header">
                <h2>Blockchain Transaction Lookup</h2>
                <p>Automatically fetch transaction details from the blockchain</p>
            </div>
            
            <div style="margin: 20px 0;">
                <div class="form-group" style="margin-bottom: 15px;">
                    <label>Select Blockchain</label>
                    <select id="chainSelector" style="width: 100%; padding: 12px; border: 2px solid #3498db; border-radius: 6px; font-size: 14px;" onchange="updateChainDisplay()">
                        <option value="">Auto-detect from transaction hash</option>
                        <option value="bitcoin">Bitcoin</option>
                        <option value="ethereum">Ethereum</option>
                        <option value="base">Base</option>
                        <option value="arbitrum">Arbitrum</option>
                        <option value="optimism">Optimism</option>
                        <option value="polygon">Polygon</option>
                        <option value="bsc">BNB Chain</option>
                        <option value="tron">Tron</option>
                        <option value="solana">Solana</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Transaction Hash</label>
                    <input type="text" id="txHashInput" placeholder="Enter transaction hash..." 
                           style="width: 100%; padding: 12px; border: 2px solid #3498db; border-radius: 6px; font-family: monospace; font-size: 14px;"
                           onkeyup="detectBlockchainFromHash(this.value)">
                    <div id="detectedBlockchain" style="margin-top: 10px; font-size: 14px; color: #666;"></div>
                </div>
                
                <div id="lookupError" style="display: none; background: #fee; border: 1px solid #c00; border-radius: 6px; padding: 15px; margin: 20px 0; color: #c00;"></div>
                <div id="lookupLoading" style="display: none; text-align: center; margin: 20px 0;">
                    <div style="font-size: 24px; margin-bottom: 10px;">⏳</div>
                    <div>Fetching transaction data...</div>
                </div>
                
                <div id="lookupResult" style="display: none; margin-top: 20px;">
                    <h4 style="color: #2c3e50; margin-bottom: 15px;">Transaction Details</h4>
                    <div id="txDetailsDisplay" style="background: #f8f9fa; padding: 15px; border-radius: 6px;"></div>
                </div>
            </div>
            
            <div style="text-align: center; margin-top: 25px;">
                <button class="btn btn-primary" onclick="lookupTransaction()" id="lookupBtn">
                    Lookup Transaction
                </button>
                <button class="btn btn-confirm" id="applyTxDataBtn" onclick="applyTransactionData()" style="display: none;">
                    Apply to Entry
                </button>
                <button class="btn btn-secondary" onclick="openApiSettings()" style="background: #95a5a6;">
                    ⚙️ API Settings
                </button>
                <button class="btn btn-secondary" onclick="closeBlockchainLookupModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- PK Converter Modal -->
    <div id="pkConverterModal" class="modal">
        <div class="modal-content" style="max-width: 1200px; height: 90vh; overflow-y: auto;">
            <div class="modal-header" style="background: linear-gradient(135deg, #3498db 0%, #2980b9 100%); color: white; padding: 20px; border-radius: 8px 8px 0 0;">
                <h2 style="color: white; margin-bottom: 10px;">🔑 Multi-Blockchain Public Key Converter</h2>
                <p style="color: rgba(255,255,255,0.9); font-size: 14px;">Convert public keys to addresses across all blockchain networks and check for activity</p>
                <button onclick="closePKConverterModal()" style="position: absolute; right: 20px; top: 20px; background: none; border: none; color: white; font-size: 24px; cursor: pointer;">&times;</button>
            </div>

            <div style="padding: 30px;">
                <!-- Instructions -->
                <div style="background: #e8f4fd; border-left: 4px solid #3498db; padding: 15px; margin-bottom: 25px; border-radius: 4px;">
                    <strong style="color: #2c3e50;">How to Extract Public Keys:</strong>
                    <span style="color: #555;">Use blockchain explorers to find transaction details. Look for "pubkey" field in transaction inputs when spending from an address.</span>
                </div>

                <!-- Input Section -->
                <div style="background: #f8f9fa; padding: 25px; border-radius: 8px; margin-bottom: 30px; border: 1px solid #dee2e6;">
                    <label for="pkInput" style="display: block; font-weight: 600; margin-bottom: 10px; color: #2c3e50; font-size: 16px;">Enter Public Key (Hex Format):</label>
                    <div style="display: flex; gap: 10px;">
                        <input type="text" id="pkInput" placeholder="Enter public key or public key hash (hex format)"
                               style="flex: 1; padding: 12px; border: 2px solid #3498db; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 14px;">
                        <button onclick="convertPKAddresses()" class="btn btn-primary" style="padding: 12px 30px; background: #3498db; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">
                            Convert & Check Activity
                        </button>
                    </div>
                    <div style="margin-top: 10px;">
                        <small style="color: #666;">Examples: </small>
                        <a href="#" onclick="document.getElementById('pkInput').value='04c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5628f5c6c7c7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7b7'; return false;" style="color: #3498db; text-decoration: underline; font-size: 12px;">Use sample uncompressed key</a> |
                        <a href="#" onclick="document.getElementById('pkInput').value='02c6047f9441ed7d6d3045406e95c07cd85c778e4b8cef3ca7abac09b95c709ee5'; return false;" style="color: #3498db; text-decoration: underline; font-size: 12px;">Use sample compressed key</a>
                    </div>
                </div>

                <!-- Results Section -->
                <div id="pkConverterResults" style="display: none;">
                    <h3 style="color: #2c3e50; margin-bottom: 20px;">Generated Addresses & Activity Status</h3>
                    <div id="pkAddressGrid" style="display: grid; grid-template-columns: repeat(auto-fill, minmax(400px, 1fr)); gap: 20px;">
                        <!-- Results will be populated here -->
                    </div>
                </div>

                <!-- Loading Indicator -->
                <div id="pkConverterLoading" style="display: none; text-align: center; padding: 40px;">
                    <div class="loading-spinner" style="margin: 0 auto 20px;"></div>
                    <p style="color: #666;">Converting addresses and checking blockchain activity...</p>
                </div>

                <!-- Error Display -->
                <div id="pkConverterError" style="display: none; background: #fee; border: 1px solid #fcc; padding: 15px; border-radius: 6px; color: #c00; margin-top: 20px;">
                </div>
            </div>
        </div>
    </div>

    <!-- Address Finder Modal -->
    <div id="addressFinderModal" class="modal">
        <div class="modal-content" style="max-width: 1200px; height: 90vh; overflow-y: auto;">
            <div class="modal-header" style="background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%); color: white; padding: 20px; border-radius: 8px 8px 0 0;">
                <h2 style="color: white; margin-bottom: 10px;">🔍 Blockchain Address Finder</h2>
                <p style="color: rgba(255,255,255,0.9); font-size: 14px;">Find complete addresses using partial information - perfect for investigations with limited data</p>
                <button onclick="closeAddressFinderModal()" style="position: absolute; right: 20px; top: 20px; background: none; border: none; color: white; font-size: 24px; cursor: pointer;">&times;</button>
            </div>

            <div style="padding: 30px;">
                <!-- Instructions -->
                <div style="background: #f3e5f5; border-left: 4px solid #9b59b6; padding: 15px; margin-bottom: 25px; border-radius: 4px;">
                    <strong style="color: #2c3e50;">How it works:</strong>
                    <span style="color: #555;">Enter the characters you know from an address. For example: first 6 characters "1A2B3C" or first 6 and last 4 "1A2B3C...wxyz". We'll search blockchain records for matching addresses.</span>
                </div>

                <!-- Search Options -->
                <div style="background: #f8f9fa; padding: 25px; border-radius: 8px; margin-bottom: 30px; border: 1px solid #dee2e6;">
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                        <div>
                            <label style="display: block; font-weight: 600; margin-bottom: 10px; color: #2c3e50;">Select Blockchain:</label>
                            <select id="addressFinderChain" style="width: 100%; padding: 12px; border: 2px solid #9b59b6; border-radius: 6px; font-size: 14px;">
                                <option value="bitcoin">Bitcoin (BTC)</option>
                                <option value="ethereum">Ethereum (ETH)</option>
                                <option value="bsc">Binance Smart Chain (BSC)</option>
                                <option value="polygon">Polygon (MATIC)</option>
                                <option value="tron">Tron (TRX)</option>
                                <option value="solana">Solana (SOL)</option>
                            </select>
                        </div>
                        <div>
                            <label style="display: block; font-weight: 600; margin-bottom: 10px; color: #2c3e50;">Search Type:</label>
                            <select id="addressFinderType" style="width: 100%; padding: 12px; border: 2px solid #9b59b6; border-radius: 6px; font-size: 14px;" onchange="updateAddressFinderInputs()">
                                <option value="prefix">Starts with (first characters)</option>
                                <option value="suffix">Ends with (last characters)</option>
                                <option value="both">First and Last characters</option>
                                <option value="contains">Contains anywhere</option>
                            </select>
                        </div>
                    </div>

                    <div id="addressFinderInputs">
                        <label style="display: block; font-weight: 600; margin-bottom: 10px; color: #2c3e50;">Enter known characters:</label>
                        <div id="singleInput" style="display: flex; gap: 10px;">
                            <input type="text" id="addressPrefix" placeholder="Enter first characters (e.g., 1A2B3C or bc1qxy)"
                                   style="flex: 1; padding: 12px; border: 2px solid #9b59b6; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 14px;">
                        </div>
                        <div id="doubleInput" style="display: none; gap: 10px;">
                            <input type="text" id="addressPrefixDouble" placeholder="First characters (e.g., 1A2B3C)"
                                   style="flex: 1; padding: 12px; border: 2px solid #9b59b6; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 14px;">
                            <span style="padding: 12px; color: #666;">...</span>
                            <input type="text" id="addressSuffix" placeholder="Last characters (e.g., XyZ9)"
                                   style="flex: 1; padding: 12px; border: 2px solid #9b59b6; border-radius: 6px; font-family: 'Courier New', monospace; font-size: 14px;">
                        </div>
                    </div>

                    <div style="margin-top: 20px; display: flex; gap: 10px; align-items: center;">
                        <button onclick="searchAddresses()" class="btn btn-primary" style="padding: 12px 30px; background: #9b59b6; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: 600;">
                            Search Blockchain
                        </button>
                        <label style="display: flex; align-items: center; gap: 8px; margin: 0;">
                            <input type="checkbox" id="activeOnly" checked>
                            <span style="color: #666;">Show only addresses with activity</span>
                        </label>
                    </div>
                </div>

                <!-- Results Section -->
                <div id="addressFinderResults" style="display: none;">
                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                        <h3 style="color: #2c3e50; margin: 0;">Search Results</h3>
                        <span id="resultCount" style="color: #666; font-size: 14px;"></span>
                    </div>
                    <div id="addressResultsGrid" style="display: grid; gap: 15px;">
                        <!-- Results will be populated here -->
                    </div>
                </div>

                <!-- Loading Indicator -->
                <div id="addressFinderLoading" style="display: none; text-align: center; padding: 40px;">
                    <div class="loading-spinner" style="margin: 0 auto 20px;"></div>
                    <p style="color: #666;">Searching blockchain records for matching addresses...</p>
                </div>

                <!-- Error Display -->
                <div id="addressFinderError" style="display: none; background: #fee; border: 1px solid #fcc; padding: 15px; border-radius: 6px; color: #c00; margin-top: 20px;">
                </div>
            </div>
        </div>
    </div>

    <script>
        // HTTPS Enforcement and Security Check
        (function() {
            // List of trusted domains (add your domains here)
            const trustedDomains = [
                'batstool.com',
                'www.batstool.com',
                'netlify.app',
                'localhost',
                '127.0.0.1'
            ];
            
            // Check if current domain is trusted
            const currentHost = window.location.hostname;
            const isTrusted = trustedDomains.some(domain => 
                currentHost === domain || currentHost.endsWith('.' + domain)
            );
            
            // Check if we're running on HTTP (not HTTPS or file://)
            if (window.location.protocol === 'http:' && currentHost !== 'localhost' && currentHost !== '127.0.0.1') {
                // Only redirect to HTTPS for trusted domains
                if (isTrusted) {
                    window.location.href = 'https:' + window.location.href.substring(5);
                    return; // Stop execution
                } else {
                    console.warn('⚠️ Running on HTTP. For security, please use HTTPS.');
                }
            }
            
            // Security warning for file:// protocol
            if (window.location.protocol === 'file:') {
                console.warn('⚠️ Running from file:// protocol. Some features may be limited. For full functionality, serve over HTTPS.');
            }
        })();

        // Global constants
        // Note: walletTypes is declared later with full emoji support

        // Global CORS helper - automatically tries multiple proxies
        async function fetchWithCORS(url, options = {}) {
            // List of public CORS proxies to try in order
            const corsProxies = [
                '', // Try direct first
                'https://corsproxy.io/?',
                'https://api.allorigins.win/raw?url=',
                'https://cors.bridged.cc/',
            ];

            let lastError = null;

            for (const proxy of corsProxies) {
                try {
                    const finalUrl = proxy ? proxy + encodeURIComponent(url) : url;
                    const response = await fetch(finalUrl, {
                        method: 'GET',
                        headers: { 'Accept': 'application/json' },
                        mode: 'cors',
                        ...options
                    });

                    // Return first successful response
                    return response;
                } catch (e) {
                    lastError = e;
                    // Try next proxy silently
                    continue;
                }
            }

            // If all attempts failed, throw the last error
            throw lastError || new Error('All connection attempts failed');
        }

        // Define switchTab function early to ensure it's available when HTML loads
        function switchTab(tabName) {
            // Show navigation tabs when switching away from welcome screen
            const navTabs = document.getElementById('mainNavTabs');
            if (navTabs) {
                navTabs.style.display = 'flex';
            }

            // First, ensure all tabs are visible (in case they were hidden)
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.style.display = '';
                tab.classList.remove('active');
            });
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });

            const tabElement = document.getElementById(tabName + '-tab');
            if (tabElement) tabElement.classList.add('active');
            
            const tabContent = document.getElementById(tabName + 'Tab');
            if (tabContent) tabContent.classList.add('active');
            
            // Find and activate the corresponding nav tab
            const navTab = document.querySelector(`[onclick="switchTab('${tabName}')"]`);
            if (navTab) {
                navTab.classList.add('active');
            }

            // Tab-specific actions (these functions will be defined later)
            if (typeof window.tabActions !== 'undefined' && window.tabActions[tabName]) {
                window.tabActions[tabName]();
            }
            
            // Update the workflow indicators (function will be defined later)
            if (typeof updateWorkflowSteps !== 'undefined') {
                updateWorkflowSteps();
            }
            
            // Update breadcrumbs if function exists
            if (typeof updateBreadcrumbs !== 'undefined') {
                updateBreadcrumbs();
            }
        }
        
        // Make switchTab globally available immediately
        window.switchTab = switchTab;
        
        // Helper function to safely get currency with validation
        function getCurrencyFromTransaction(transaction) {
            if (!transaction) return null;
            
            if (transaction.currency === 'CUSTOM') {
                if (!transaction.customCurrency || transaction.customCurrency.trim() === '') {
                    console.warn('Transaction has CUSTOM currency but no customCurrency value:', transaction);
                    return null;
                }
                return transaction.customCurrency.trim();
            }
            
            return transaction.currency || null;
        }
        
        // Helper function to safely get currency from entry
        function getCurrencyFromEntry(entry) {
            if (!entry) return null;
            
            if (entry.currency === 'CUSTOM') {
                if (!entry.customCurrency || entry.customCurrency.trim() === '') {
                    console.warn('Entry has CUSTOM currency but no customCurrency value:', entry);
                    return null;
                }
                return entry.customCurrency.trim();
            }
            
            return entry.currency || null;
        }
        
        // Validate wallet address format
        function validateWalletAddress(address, currency) {
            if (!address || address.trim() === '') return { valid: false, error: 'Wallet address cannot be empty' };
            
            const trimmedAddress = address.trim();
            
            // Basic validation patterns for common cryptocurrencies
            const patterns = {
                'BTC': /^(bc1|[13])[a-zA-HJ-NP-Z0-9]{25,62}$/,  // Bitcoin (Legacy, SegWit, Native SegWit)
                'ETH': /^0x[a-fA-F0-9]{40}$/,  // Ethereum
                'USDT': /^0x[a-fA-F0-9]{40}$/,  // USDT on Ethereum
                'USDC': /^0x[a-fA-F0-9]{40}$/,  // USDC on Ethereum
                'TRX': /^T[a-zA-Z0-9]{33}$/,    // TRON
                'SOL': /^[1-9A-HJ-NP-Za-km-z]{32,44}$/,  // Solana
                'ADA': /^(addr1|DdzFF|Ae2)[a-zA-Z0-9]{50,}$/,  // Cardano
                'BNB': /^(bnb1|0x)[a-zA-Z0-9]+$/,  // BNB (Beacon Chain or BSC)
            };
            
            // If we have a pattern for this currency, validate it
            if (patterns[currency]) {
                if (!patterns[currency].test(trimmedAddress)) {
                    return { 
                        valid: false, 
                        error: `Invalid ${currency} wallet address format`,
                        suggestion: getWalletFormatHint(currency)
                    };
                }
            }
            
            // General validation for any address
            if (trimmedAddress.length < 10) {
                return { valid: false, error: 'Wallet address seems too short' };
            }
            
            if (trimmedAddress.length > 150) {
                return { valid: false, error: 'Wallet address seems too long' };
            }
            
            // Check for common invalid patterns
            if (/\s/.test(trimmedAddress)) {
                return { valid: false, error: 'Wallet address cannot contain spaces' };
            }
            
            return { valid: true };
        }
        
        // Get wallet format hint for a currency
        function getWalletFormatHint(currency) {
            const hints = {
                'BTC': 'Bitcoin addresses start with 1, 3, or bc1',
                'ETH': 'Ethereum addresses start with 0x and are 42 characters long',
                'USDT': 'USDT addresses depend on the blockchain (usually Ethereum: 0x...)',
                'USDC': 'USDC addresses depend on the blockchain (usually Ethereum: 0x...)',
                'TRX': 'TRON addresses start with T and are 34 characters long',
                'SOL': 'Solana addresses are 32-44 characters of base58',
                'ADA': 'Cardano addresses start with addr1, DdzFF, or Ae2',
                'BNB': 'BNB addresses start with bnb1 (Beacon) or 0x (BSC)'
            };
            
            return hints[currency] || 'Please check the address format for this currency';
        }
        
        // Get decimal precision for currency
        function getCurrencyPrecision(currency) {
            const precisions = {
                'USD': 2,
                'BTC': 8,
                'ETH': 18,
                'USDT': 6,
                'USDC': 6,
                'TRX': 6,
                'SOL': 9,
                'ADA': 6,
                'DAI': 18,
                'BNB': 8
            };
            return precisions[currency] || 2;
        }
        
        // Safe addition for currency amounts
        function addCurrencyAmounts(amount1, amount2, currency) {
            const precision = getCurrencyPrecision(currency);
            const factor = Math.pow(10, precision);
            return Math.round((amount1 * factor) + (amount2 * factor)) / factor;
        }
        
        // Safe subtraction for currency amounts
        function subtractCurrencyAmounts(amount1, amount2, currency) {
            const precision = getCurrencyPrecision(currency);
            const factor = Math.pow(10, precision);
            return Math.round((amount1 * factor) - (amount2 * factor)) / factor;
        }
        
        // Format currency amount with proper precision
        // Simple wrapper for backwards compatibility
        function formatCurrency(amount, currency) {
            // Default to no currency symbol if not provided
            if (!currency) {
                return amount.toLocaleString();
            }
            return formatCurrencyAmount(amount, currency);
        }

        function formatCurrencyAmount(amount, currency) {
            const precision = getCurrencyPrecision(currency);
            return parseFloat(amount).toFixed(precision);
        }

        // Safe amount parsing with validation
        function parseAmount(value, currency = null) {
            // Handle various input types
            if (value === null || value === undefined || value === '') {
                return 0;
            }

            // Convert to string and clean
            const cleanValue = String(value).trim().replace(/,/g, '');

            // Parse the number
            const parsed = parseFloat(cleanValue);

            // Check for invalid numbers
            if (isNaN(parsed) || !isFinite(parsed)) {
                return 0;
            }

            // Apply precision if currency specified
            if (currency) {
                const precision = getCurrencyPrecision(currency);
                const factor = Math.pow(10, precision);
                return Math.round(parsed * factor) / factor;
            }

            return parsed;
        }

        // Validate if amount is valid and positive
        function isValidAmount(value) {
            const parsed = parseAmount(value);
            return parsed > 0 && isFinite(parsed);
        }

        // Enhanced fetch with timeout and retry logic
        async function fetchWithTimeout(url, options = {}, timeoutMs = 30000, retries = 3) {
            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), timeoutMs);

            const fetchOptions = {
                ...options,
                signal: controller.signal
            };

            let lastError = null;
            for (let attempt = 0; attempt <= retries; attempt++) {
                try {
                    if (attempt > 0) {
                        // Wait before retry (exponential backoff)
                        await new Promise(resolve => setTimeout(resolve, Math.min(1000 * Math.pow(2, attempt - 1), 5000)));
                    }

                    const response = await fetch(url, fetchOptions);
                    clearTimeout(timeout);

                    if (!response.ok) {
                        throw new Error(`HTTP ${response.status}: ${response.statusText}`);
                    }

                    return response;
                } catch (error) {
                    lastError = error;
                    if (error.name === 'AbortError') {
                        console.log(`Request timeout for ${url} (attempt ${attempt + 1}/${retries + 1})`);
                    } else {
                        console.log(`Request failed for ${url} (attempt ${attempt + 1}/${retries + 1}):`, error.message);
                    }

                    // Don't retry on certain errors
                    if (error.message.includes('HTTP 404') || error.message.includes('HTTP 403')) {
                        break;
                    }
                }
            }

            clearTimeout(timeout);
            throw lastError || new Error('Failed to fetch after retries');
        }
        
        // Add entry to validation history
        function addValidationHistoryEntry(type, details, status = 'info') {
            if (!investigation.validationHistory) {
                investigation.validationHistory = [];
            }
            
            investigation.validationHistory.push({
                timestamp: new Date().toISOString(),
                type: type,
                status: status, // 'success', 'warning', 'error', 'info'
                details: details,
                user: investigation.investigator || 'Unknown'
            });
            
            // Keep only last 100 entries
            if (investigation.validationHistory.length > 100) {
                investigation.validationHistory = investigation.validationHistory.slice(-100);
            }
        }
        
        // Convert datetime from any timezone to UTC for reports
        function convertDateTimeToUTC(datetime, timezone) {
            if (!datetime) return null;
            
            // If already UTC, just return it
            if (timezone === 'UTC') {
                return new Date(datetime);
            }
            
            // Convert to UTC timestamp using our timezone conversion
            const utcTimestamp = convertToUTC(datetime, timezone);
            return new Date(utcTimestamp);
        }
        
        // Format datetime for UTC display in reports
        function formatDateTimeForReport(datetime, timezone) {
            if (!datetime) return 'No date';
            
            const utcDate = convertDateTimeToUTC(datetime, timezone);
            if (!utcDate) return 'Invalid date';
            
            // Format as ISO string but make it more readable
            const year = utcDate.getUTCFullYear();
            const month = String(utcDate.getUTCMonth() + 1).padStart(2, '0');
            const day = String(utcDate.getUTCDate()).padStart(2, '0');
            const hours = String(utcDate.getUTCHours()).padStart(2, '0');
            const minutes = String(utcDate.getUTCMinutes()).padStart(2, '0');
            const seconds = String(utcDate.getUTCSeconds()).padStart(2, '0');
            
            return `${year}-${month}-${day} ${hours}:${minutes}:${seconds} UTC`;
        }
        
        // Convert all investigation timestamps to UTC for reporting
        function prepareInvestigationForUTCReport() {
            const utcInvestigation = JSON.parse(JSON.stringify(investigation)); // Deep clone
            
            // Convert victim transaction times
            utcInvestigation.victims.forEach(victim => {
                victim.transactions.forEach(transaction => {
                    if (transaction.datetime && transaction.timezone) {
                        transaction.utcDatetime = formatDateTimeForReport(transaction.datetime, transaction.timezone);
                        transaction.originalDatetime = transaction.datetime;
                        transaction.originalTimezone = transaction.timezone;
                    }
                });
            });
            
            // Convert hop entry times
            utcInvestigation.hops.forEach(hop => {
                hop.entries.forEach(entry => {
                    if (entry.timestamp && entry.timezone) {
                        entry.utcTimestamp = formatDateTimeForReport(entry.timestamp, entry.timezone);
                        entry.originalTimestamp = entry.timestamp;
                        entry.originalTimezone = entry.timezone;
                    }
                });
            });
            
            return utcInvestigation;
        }

        // Global state
        let investigation = {
            caseId: '',
            investigator: '',
            caseType: '',
            caseSynopsis: '',
            setupComplete: false,
            victims: [],
            hops: [],
            conversions: [],
            redWalletIndex: [],
            universalWalletIndex: [],
            terminalWalletIndex: [],  // New: Track all terminal wallet arrivals
            rootTotalConfirmed: false,
            confirmedRootTotal: 0,
            confirmedRootTotalsByCurrency: {},
            currentART: {},
            created: new Date().toISOString(),
            availableThreads: {},
            threadAssignments: {},
            sourceChainData: {},
            enhancedNotationEnabled: true,
            validationHistory: [],
            lastValidationTimestamp: null,
            threadValidationErrors: [],
            sourceChainReports: [],
            integrationVersion: '4.0',
            tracingMethod: 'PIFO' // Default to PIFO, can be changed to 'LIBR'
        };
        
        // Undo system
        let undoHistory = [];
        const MAX_UNDO_HISTORY = 20;
        
        // File system integration
        let savedFilePath = null;
        let isFileSystemAvailable = false;
        let fileHandle = null;
        
        // Blockchain API Integration
        let targetEntryContext = null;
        
        // Wallet Types - Per B.A.T.S. Official Framework
        const walletTypes = {
            'red': '🔴 RED - Victim-Facing',
            'pink': '🌸 PINK - Dividend/Deception',
            'yellow': '🟡 YELLOW - Hub (Convergence)',
            'orange': '🟠 ORANGE - Bitcoin Change',
            'brown': '🟤 BROWN - Asset Conversion',
            'black': '⚫ BLACK - Default Intermediary',
            'blue': '🔵 BLUE - Cold Storage',
            'purple': '🟣 PURPLE - Exchange Deposit',
            'gray': '⚪ GRAY - Obfuscated/Diluted',
            'green': '🟢 GREEN - Victim Owned'
        };
        
        // Entry Types - defined later with full descriptions
        
        // Timezones
        const timezones = {
            'UTC': 'UTC',
            'LOCAL': 'Local',
            'EST': 'EST',
            'EDT': 'EDT',
            'CST': 'CST',
            'CDT': 'CDT',
            'MST': 'MST',
            'MDT': 'MDT',
            'PST': 'PST',
            'PDT': 'PDT',
            'GMT': 'GMT',
            'CET': 'CET',
            'CEST': 'CEST',
            'JST': 'JST',
            'ET': 'Eastern Time',
            'CT': 'Central Time',
            'MT': 'Mountain Time',
            'PT': 'Pacific Time'
        };
        
        // Currencies
        const currencies = {
            'BTC': { name: 'Bitcoin', symbol: '₿', decimals: 8 },
            'ETH': { name: 'Ethereum', symbol: 'Ξ', decimals: 18 },
            'USDT': { name: 'Tether', symbol: '₮', decimals: 6 },
            'USDC': { name: 'USD Coin', symbol: '$', decimals: 6 },
            'MATIC': { name: 'Polygon', symbol: 'MATIC', decimals: 18 },
            'USD': { name: 'US Dollar', symbol: '$', decimals: 2 },
            'TRX': { name: 'TRON', symbol: 'TRX', decimals: 6 },
            'SOL': { name: 'Solana', symbol: 'SOL', decimals: 9 },
            'ADA': { name: 'Cardano', symbol: 'ADA', decimals: 6 },
            'DAI': { name: 'DAI', symbol: 'DAI', decimals: 18 },
            'BNB': { name: 'BNB', symbol: 'BNB', decimals: 18 },
            // Native currencies for newer chains
            'HYPE': { name: 'HyperEVM', symbol: 'HYPE', decimals: 18 },
            'AVAX': { name: 'Avalanche', symbol: 'AVAX', decimals: 18 },
            'MNT': { name: 'Mantle', symbol: 'MNT', decimals: 18 },
            'xDAI': { name: 'Gnosis', symbol: 'xDAI', decimals: 18 },
            'CELO': { name: 'Celo', symbol: 'CELO', decimals: 18 },
            'GLMR': { name: 'Moonbeam', symbol: 'GLMR', decimals: 18 },
            'MOVR': { name: 'Moonriver', symbol: 'MOVR', decimals: 18 },
            'frxETH': { name: 'Fraxtal', symbol: 'frxETH', decimals: 18 },
            'BTT': { name: 'BitTorrent', symbol: 'BTT', decimals: 18 },
            'CUSTOM': { name: 'Custom', symbol: '', decimals: 8 }
        };
        let currentTxData = null;
        let currentBulkVictimId = null;
        let pendingTransfers = null;
        let pendingTransferCallback = null;

        // Cache for wallet attributions to reduce API calls
        const walletAttributionCache = {};

        // Add entry to terminal wallet index
        function addToTerminalWalletIndex(entry) {
            if (!investigation.terminalWalletIndex) {
                investigation.terminalWalletIndex = [];
            }

            const terminalRecord = {
                id: Date.now(),
                timestamp: entry.timestamp || new Date().toISOString(),
                hopNumber: entry.hopNumber,
                txHash: entry.txHash,
                fromWallet: entry.fromWallet,
                toWallet: entry.toWallet,
                exchangeName: entry.exchangeAttribution?.name || entry.exchangeAttribution?.label || 'Unknown Exchange',
                exchangeType: entry.exchangeAttribution?.type || 'Terminal',
                amount: parseFloat(entry.amount),
                currency: entry.currency,
                notation: entry.notation,
                detectionSource: entry.exchangeAttribution?.source || 'manual',
                notes: entry.notes || ''
            };

            investigation.terminalWalletIndex.push(terminalRecord);
            console.log('Added to terminal wallet index:', terminalRecord);
            saveToStorage();
        }

        // Get Solana wallet attribution from known addresses and patterns
        async function getSolanaWalletAttribution(address) {
            if (!address) return null;

            console.log(`Checking Solana attribution for ${address}`);

            // NO HARDCODED ADDRESSES - Only use API calls for attribution

            // Try to use Solscan API with API key (default provided for all users)
            const solscanApiKey = localStorage.getItem('bats_solscan_api_key') || 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJjcmVhdGVkQXQiOjE3NTg4OTk1ODMyNTksImVtYWlsIjoiamVzc2VAdGhlYmxvY2thdWRpdC5jb20iLCJhY3Rpb24iOiJ0b2tlbi1hcGkiLCJhcGlWZXJzaW9uIjoidjIiLCJpYXQiOjE3NTg4OTk1ODN9.C3By0UPXwI5bmLrAl9o1U_SDnT7uQLoizbd8qr36GmQ';

            try {
                // Use proxy to avoid CORS issues
                let proxyUrl;

                if (solscanApiKey) {
                    // Use Pro API with API key through proxy
                    proxyUrl = `/.netlify/functions/solscan-proxy?address=${address}&apiKey=${encodeURIComponent(solscanApiKey)}`;
                    console.log('🔍 Using Solscan Pro API (via proxy)');
                    console.log('📡 Proxy URL:', proxyUrl);
                    console.log('🔑 API Key present:', true);
                } else {
                    // Fall back to public API through proxy
                    proxyUrl = `/.netlify/functions/solscan-proxy?address=${address}`;
                    console.log('Using Solscan public API (via proxy)');
                }

                const response = await fetch(proxyUrl).catch(err => {
                    console.log('❌ Solscan proxy call failed:', err);
                    return null;
                });

                console.log('📊 Solscan response status:', response?.status);
                console.log('📊 Solscan response ok:', response?.ok);
                console.log('📊 Solscan response headers:', response?.headers);

                if (response && response.ok) {
                    const data = await response.json();
                    console.log('📦 Solscan API response data:', JSON.stringify(data, null, 2));

                    // Handle Pro API v2.0 metadata response
                    if (solscanApiKey && data.success && data.data) {
                        // Pro API metadata response
                        const metadata = data.data;
                        console.log('🔍 Solscan Pro API v2.0 metadata:');
                        console.log('  - account_label:', metadata.account_label);
                        console.log('  - account_tags:', metadata.account_tags);
                        console.log('  - account_type:', metadata.account_type);
                        console.log('  - Full metadata:', JSON.stringify(metadata, null, 2));

                        // Check for label or tags in the metadata response
                        if (metadata.account_label || metadata.account_tags?.length > 0) {
                            const label = metadata.account_label || metadata.account_tags?.[0];

                            // Check if it's an exchange based on label or tags
                            const exchangeKeywords = ['exchange', 'cex', 'dex', 'binance', 'coinbase', 'kraken', 'kucoin', 'okx', 'bybit', 'gate', 'huobi', 'ftx', 'bitfinex', 'bitmex'];
                            const labelLower = label.toLowerCase();
                            const isExchange = exchangeKeywords.some(keyword => labelLower.includes(keyword)) ||
                                             metadata.account_tags?.some(tag => exchangeKeywords.some(kw => tag.toLowerCase().includes(kw)));

                            if (label) {
                                const attribution = {
                                    name: metadata.account_label || label,
                                    label: metadata.account_label || label,
                                    type: isExchange ? 'CEX' : (metadata.account_type || 'Service'),
                                    tags: metadata.account_tags || [],
                                    source: 'solscan_pro_api',
                                    isExchange: isExchange
                                };
                                console.log(`✅ Solscan Pro API attribution found: ${attribution.name}`);
                                return attribution;
                            }
                        }
                    } else if (data.tag || data.tags || data.label) {
                        // Public API response (legacy structure)
                        console.log('🔍 Solscan Public API response:');
                        console.log('  - tag:', data.tag);
                        console.log('  - tags:', data.tags);
                        console.log('  - label:', data.label);
                        console.log('  - Full data:', JSON.stringify(data, null, 2));
                        const tag = data.tag || data.tags?.[0] || data.label;

                        // Check if it's an exchange based on the tag
                        const exchangeKeywords = ['exchange', 'cex', 'binance', 'coinbase', 'kraken', 'kucoin', 'okx', 'bybit', 'gate'];
                        const isExchange = exchangeKeywords.some(keyword => tag.toLowerCase().includes(keyword));

                        if (isExchange) {
                            const attribution = {
                                name: tag,
                                label: tag,
                                type: 'CEX',
                                source: 'solscan_public_api',
                                isExchange: true
                            };
                            console.log(`Solscan public API attribution found: ${attribution.name}`);
                            return attribution;
                        }
                    }
                } else {
                    console.log('❌ Solscan API returned error or no data');
                    if (response) {
                        console.log('  Status:', response.status);
                        console.log('  StatusText:', response.statusText);
                        try {
                            const errorText = await response.text();
                            console.log('  Error response:', errorText);
                        } catch (e) {
                            console.log('  Could not read error response');
                        }
                    }
                }
            } catch (error) {
                console.log('❌ Error checking Solscan:', error);
                console.log('  Error details:', error.message);
                console.log('  Error stack:', error.stack);
            }

            return null;
        }

        // Get wallet attribution - checks multiple sources with Arkham as primary
        async function getWalletAttribution(address, chainId = null) {
            if (!address) return null;

            const lowerAddress = address.toLowerCase();

            // Check cache first
            if (walletAttributionCache[lowerAddress]) {
                console.log(`Using cached attribution for ${address}`);
                return walletAttributionCache[lowerAddress];
            }

            let attribution = null;

            try {
                // ALWAYS CHECK ARKHAM FIRST - IT'S OUR PRIMARY SOURCE FOR ALL CHAINS
                console.log(`🔍 Checking Arkham Intelligence for address: ${address}`);
                const arkhamApiKey = localStorage.getItem('bats_arkham_api_key') || 'd377a526-c9ea-4cb6-a647-775559583ff6';

                if (arkhamApiKey) {
                    try {
                        // Use the new enhanced Arkham endpoint for better attribution data
                        const proxyUrl = `/.netlify/functions/arkham3?endpoint=/intelligence/address_with_extra_enrichment/${address}/all`;
                        console.log(`📡 Arkham API URL (enhanced endpoint): ${proxyUrl}`);
                        console.log(`🔑 Using API key: ${arkhamApiKey.substring(0, 10)}...`);

                        const arkhamResponse = await fetch(proxyUrl, {
                            headers: {
                                'X-Arkham-API-Key': arkhamApiKey,
                                'Accept': 'application/json'
                            }
                        }).catch(err => {
                            console.error('❌ Arkham API fetch failed:', err);
                            return null;
                        });

                        console.log(`📊 Arkham response status: ${arkhamResponse?.status}`);

                        if (arkhamResponse && arkhamResponse.ok) {
                            const arkhamData = await arkhamResponse.json();
                            console.log('📦 Arkham API full response:', JSON.stringify(arkhamData, null, 2));

                            // The /all endpoints return an object with chain names as keys
                            // Each chain can have arkhamEntity or arkhamLabel
                            console.log('🔍 Arkham response structure:');
                            console.log('  - Response type:', typeof arkhamData);
                            console.log('  - Keys:', Object.keys(arkhamData || {}));

                            // Check if this is a multi-chain response (object with chain keys)
                            const chains = Object.keys(arkhamData || {});
                            let foundAttribution = null;

                            // Look through all chains for attribution
                            for (const chain of chains) {
                                const chainData = arkhamData[chain];
                                console.log(`  - Chain ${chain} data:`, chainData);

                                if (chainData?.arkhamEntity) {
                                    // arkhamEntity = actual exchange or service (terminal wallet)
                                    console.log(`    Found arkhamEntity on ${chain}:`, chainData.arkhamEntity);
                                    foundAttribution = {
                                        name: chainData.arkhamEntity.name || chainData.arkhamEntity.service,
                                        label: chainData.arkhamEntity.type || 'Exchange',
                                        type: chainData.arkhamEntity.type || 'CEX',
                                        service: chainData.arkhamEntity.service,
                                        chain: chain,
                                        source: 'arkham_intelligence',
                                        isExchange: true,  // arkhamEntity = real exchange/service = terminal wallet
                                        isPersonalLabel: false
                                    };
                                    break;
                                } else if (chainData?.arkhamLabel) {
                                    console.log(`    Found arkhamLabel on ${chain}:`, chainData.arkhamLabel);

                                    const labelName = chainData.arkhamLabel.name || '';
                                    const indicators = checkExchangeIndicators(labelName);

                                    if (indicators.isLikely) {
                                        // Likely an exchange/service - mark appropriately
                                        console.log(`    High confidence (${indicators.confidence}%) exchange detected: ${labelName}`);
                                        foundAttribution = {
                                            name: chainData.arkhamLabel.name,
                                            label: chainData.arkhamLabel.name,
                                            type: indicators.suggestedType === 'DEX/Bridge' ? 'Bridge/DEX' : 'CEX',
                                            chain: chain,
                                            source: 'arkham_intelligence',
                                            isExchange: true,
                                            isPersonalLabel: false,
                                            detectionConfidence: indicators.confidence,
                                            detectionMatches: indicators.matches
                                        };
                                    } else {
                                        // Treat as personal label but track any weak indicators
                                        foundAttribution = {
                                            name: chainData.arkhamLabel.name,
                                            label: chainData.arkhamLabel.name,
                                            type: 'Personal Label',
                                            chain: chain,
                                            source: 'arkham_intelligence',
                                            isExchange: false,
                                            isPersonalLabel: true,
                                            noteText: `Label: ${chainData.arkhamLabel.name}`,
                                            suspectedExchange: indicators.confidence > 0,
                                            detectionConfidence: indicators.confidence,
                                            detectionMatches: indicators.matches
                                        };
                                    }
                                    break;
                                }
                            }

                            // If we found attribution on any chain, return it
                            if (foundAttribution) {
                                console.log(`✅ Arkham attribution found for ${address}:`, foundAttribution);
                                walletAttributionCache[lowerAddress] = foundAttribution;
                                return foundAttribution;
                            }

                            // Also check if it's a single chain response (not using /all endpoint)
                            if (arkhamData?.arkhamEntity) {
                                // arkhamEntity = actual exchange or service (terminal wallet)
                                attribution = {
                                    name: arkhamData.arkhamEntity.name || arkhamData.arkhamEntity.service,
                                    label: arkhamData.arkhamEntity.type || 'Exchange',
                                    type: arkhamData.arkhamEntity.type || 'CEX',
                                    service: arkhamData.arkhamEntity.service,
                                    source: 'arkham_intelligence',
                                    isExchange: true,  // arkhamEntity = real exchange/service = terminal wallet
                                    isPersonalLabel: false
                                };
                                console.log(`✅ Arkham attribution found (single chain) for ${address}:`, attribution);
                                walletAttributionCache[lowerAddress] = attribution;
                                return attribution;
                            } else if (arkhamData?.arkhamLabel) {
                                const labelName = arkhamData.arkhamLabel.name || '';
                                const indicators = checkExchangeIndicators(labelName);

                                if (indicators.isLikely) {
                                    // Likely an exchange/service - mark appropriately
                                    console.log(`    High confidence (${indicators.confidence}%) exchange detected: ${labelName}`);
                                    attribution = {
                                        name: arkhamData.arkhamLabel.name,
                                        label: arkhamData.arkhamLabel.name,
                                        type: indicators.suggestedType === 'DEX/Bridge' ? 'Bridge/DEX' : 'CEX',
                                        source: 'arkham_intelligence',
                                        isExchange: true,
                                        isPersonalLabel: false,
                                        detectionConfidence: indicators.confidence,
                                        detectionMatches: indicators.matches
                                    };
                                } else {
                                    // Treat as personal label but track any weak indicators
                                    attribution = {
                                        name: arkhamData.arkhamLabel.name,
                                        label: arkhamData.arkhamLabel.name,
                                        type: 'Personal Label',
                                        source: 'arkham_intelligence',
                                        isExchange: false,
                                        isPersonalLabel: true,
                                        noteText: `Label: ${arkhamData.arkhamLabel.name}`,
                                        suspectedExchange: indicators.confidence > 0,
                                        detectionConfidence: indicators.confidence,
                                        detectionMatches: indicators.matches
                                    };
                                }
                                console.log(`✅ Arkham personal label found for ${address}:`, attribution);
                                walletAttributionCache[lowerAddress] = attribution;
                                return attribution;
                            }

                            console.log('⚠️ No Arkham entity or label found in response');
                        } else {
                            const errorText = arkhamResponse ? await arkhamResponse.text() : 'No response';
                            console.log(`⚠️ Arkham API returned non-OK status. Response:`, errorText);
                        }
                    } catch (e) {
                        console.error('❌ Arkham API error:', e);
                    }
                } else {
                    console.log('⚠️ No Arkham API key configured');
                }

                // If Arkham didn't find attribution, check chain-specific secondary sources
                if (!attribution) {
                    console.log('Arkham did not find attribution, checking secondary chain-specific sources');

                    // Check if this looks like a Solana address (base58, typically 32-44 chars)
                    const isSolanaAddress = /^[1-9A-HJ-NP-Za-km-z]{32,44}$/.test(address);
                    if (isSolanaAddress) {
                        console.log('Detected Solana address format, checking Solana-specific sources');
                        const solanaAttribution = await getSolanaWalletAttribution(address);
                        if (solanaAttribution) {
                            attribution = solanaAttribution;
                            walletAttributionCache[lowerAddress] = attribution;
                            console.log('Found Solana attribution:', attribution);
                            return attribution;
                        }
                    }
                }

                // For EVM chains, check Etherscan as secondary source
                const apiKey = '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8';

                // Use the chainId if provided, otherwise default to Ethereum (1)
                const chainIdToUse = chainId || 1;

                // Use Etherscan v2 API with chainid parameter for all chains
                const balanceUrl = `https://api.etherscan.io/v2/api?chainid=${chainIdToUse}&module=account&action=balance&address=${address}&tag=latest&apikey=${apiKey}`;

                // Also fetch transactions to check for labeled addresses
                const txUrl = `https://api.etherscan.io/v2/api?chainid=${chainIdToUse}&module=account&action=txlist&address=${address}&startblock=0&endblock=99999999&page=1&offset=10&sort=desc&apikey=${apiKey}`;

                // Fetch both in parallel
                const [balanceResponse, txResponse] = await Promise.all([
                    fetch(balanceUrl),
                    fetch(txUrl)
                ]);

                if (txResponse.ok) {
                    const txData = await txResponse.json();

                    if (txData.result && Array.isArray(txData.result) && txData.result.length > 0) {
                        // Check transactions for exchange indicators
                        for (const tx of txData.result) {
                            // Etherscan provides labels in transaction responses
                            // Check both to and from labels
                            const labels = [];

                            // Collect all possible label fields
                            if (tx.to && tx.to.toLowerCase() === lowerAddress) {
                                if (tx.to_label) labels.push(tx.to_label);
                                if (tx.toLabel) labels.push(tx.toLabel);
                            }
                            if (tx.from && tx.from.toLowerCase() === lowerAddress) {
                                if (tx.from_label) labels.push(tx.from_label);
                                if (tx.fromLabel) labels.push(tx.fromLabel);
                            }

                            // Check for exchange indicators in labels
                            for (const label of labels) {
                                if (label && typeof label === 'string' && label.length > 0) {
                                    // Direct exchange match
                                    const exchangeNames = [
                                        'Bybit', 'Binance', 'Coinbase', 'Kraken', 'Huobi',
                                        'OKEx', 'OKX', 'KuCoin', 'Gate.io', 'Bitfinex',
                                        'Bitstamp', 'Gemini', 'FTX', 'Crypto.com', 'Bittrex',
                                        'Poloniex', 'BitMEX', 'Deribit', 'Bitget', 'MEXC'
                                    ];

                                    for (const exchange of exchangeNames) {
                                        if (label.toLowerCase().includes(exchange.toLowerCase())) {
                                            attribution = {
                                                name: exchange,
                                                label: label,
                                                type: 'CEX',
                                                source: 'etherscan_label'
                                            };
                                            break;
                                        }
                                    }

                                    // Check for other terminal wallet indicators
                                    if (!attribution) {
                                        const terminalIndicators = [
                                            'exchange', 'cex', 'hot wallet', 'cold wallet',
                                            'custody', 'vault', 'treasury', 'reserve'
                                        ];

                                        for (const indicator of terminalIndicators) {
                                            if (label.toLowerCase().includes(indicator)) {
                                                attribution = {
                                                    name: label,
                                                    label: label,
                                                    type: 'Terminal',
                                                    source: 'etherscan_label'
                                                };
                                                break;
                                            }
                                        }
                                    }
                                }
                                if (attribution) break;
                            }
                            if (attribution) break;
                        }
                    }
                }

                // Second try: Get token transfers which may have richer label data
                if (!attribution) {
                    const tokenUrl = `https://api.etherscan.io/v2/api?chainid=${chainIdToUse}&module=account&action=tokentx&address=${address}&startblock=0&endblock=99999999&page=1&offset=10&sort=desc&apikey=${apiKey}`;

                    try {
                        const tokenResponse = await fetch(tokenUrl);
                        if (tokenResponse.ok) {
                            const tokenData = await tokenResponse.json();

                            if (tokenData.result && Array.isArray(tokenData.result)) {
                                for (const tx of tokenData.result) {
                                    // Check for labels in token transfers
                                    const checkFields = ['to_label', 'from_label', 'toLabel', 'fromLabel'];

                                    for (const field of checkFields) {
                                        if (tx[field]) {
                                            const label = tx[field];
                                            // Use same exchange detection logic
                                            const exchangeKeywords = [
                                                'bybit', 'binance', 'coinbase', 'kraken', 'exchange',
                                                'okx', 'kucoin', 'gate', 'bitfinex', 'gemini'
                                            ];

                                            for (const keyword of exchangeKeywords) {
                                                if (label.toLowerCase().includes(keyword)) {
                                                    attribution = {
                                                        name: label,
                                                        label: label,
                                                        type: 'CEX',
                                                        source: 'etherscan_token_label'
                                                    };
                                                    break;
                                                }
                                            }
                                            if (attribution) break;
                                        }
                                    }
                                    if (attribution) break;
                                }
                            }
                        }
                    } catch (err) {
                        console.log('Token label check failed:', err);
                    }
                }

                // Third try: Check if it's a smart contract with exchange-like properties
                if (!attribution) {
                    const codeUrl = `https://api.etherscan.io/api?module=proxy&action=eth_getCode&address=${address}&apikey=${apiKey}`;

                    try {
                        const codeResponse = await fetch(codeUrl);
                        if (codeResponse.ok) {
                            const codeData = await codeResponse.json();

                            // If it has contract code and high activity, likely an exchange
                            if (codeData.result && codeData.result !== '0x') {
                                // It's a contract - check contract verification status
                                const contractUrl = `https://api.etherscan.io/api?module=contract&action=getsourcecode&address=${address}&apikey=${apiKey}`;

                                const contractResponse = await fetch(contractUrl);
                                if (contractResponse.ok) {
                                    const contractData = await contractResponse.json();

                                    if (contractData.result && contractData.result[0]) {
                                        const contractName = contractData.result[0].ContractName;

                                        if (contractName && contractName !== '') {
                                            // Check if contract name indicates exchange
                                            const exchangePatterns = [
                                                /bybit/i, /binance/i, /coinbase/i, /kraken/i,
                                                /exchange/i, /vault/i, /custody/i, /treasury/i
                                            ];

                                            for (const pattern of exchangePatterns) {
                                                if (pattern.test(contractName)) {
                                                    attribution = {
                                                        name: contractName,
                                                        label: contractName,
                                                        type: 'CEX/Contract',
                                                        source: 'etherscan_contract'
                                                    };
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    } catch (err) {
                        console.log('Contract check failed:', err);
                    }
                }

                // Final fallback: Known exchange addresses
                if (!attribution) {
                    const knownExchanges = {
                        // Bybit addresses
                        '0x07624a16592ab3ca24cccaee13d9ee21eea86fe8': { name: 'Bybit', label: 'Bybit Hot Wallet' },
                        '0xf89d7b9c864f589bbf53a82105107622b35eaa40': { name: 'Bybit', label: 'Bybit Exchange' },
                        // Binance addresses
                        '0x28c6c06298d514db089934071355e5743bf21d60': { name: 'Binance', label: 'Binance Hot Wallet' },
                        '0x21a31ee1afc51d94c2efccaa2092ad1028285549': { name: 'Binance', label: 'Binance 15' },
                        '0xdfd5293d8e347dfe59e90efd55b2956a1343963d': { name: 'Binance', label: 'Binance 16' },
                        // Coinbase
                        '0x71660c4005ba85c37ccec55d0c4493e66fe775d3': { name: 'Coinbase', label: 'Coinbase 1' },
                        '0x503828976d22510aad0201ac7ec88293211d23da': { name: 'Coinbase', label: 'Coinbase 2' },
                        // Kraken
                        '0x267be94bfcdf32565f3c99ec94af879a8829f7e5': { name: 'Kraken', label: 'Kraken Hot Wallet' },
                        '0x53d284357ec70ce289d6d64134dfac8e511c8a3d': { name: 'Kraken', label: 'Kraken Exchange' },
                        // Add more as needed
                    };

                    if (knownExchanges[lowerAddress]) {
                        attribution = {
                            ...knownExchanges[lowerAddress],
                            type: 'CEX',
                            source: 'known_addresses'
                        };
                    }
                }

                // Cache the result (even if null to avoid repeated lookups)
                walletAttributionCache[lowerAddress] = attribution;

                if (attribution) {
                    if (attribution.isPersonalLabel) {
                        console.log(`🏷️ Personal label found: ${attribution.name} (${address})`);
                        console.log(`   Source: ${attribution.source}`);
                        console.log(`   Note: This is NOT a terminal wallet`);
                    } else {
                        console.log(`🟣 Terminal wallet detected: ${attribution.name} (${address})`);
                        console.log(`   Label: ${attribution.label || 'N/A'}`);
                        console.log(`   Source: ${attribution.source}`);
                    }
                }

                return attribution;

            } catch (error) {
                console.error('Error fetching wallet attribution:', error);
                return null;
            }
        }

        // Synchronous check for known exchanges (for non-async contexts)
        function checkExchangeAttribution(address) {
            if (!address) return null;

            const lowerAddress = address.toLowerCase();

            // Check cache first
            if (walletAttributionCache[lowerAddress]) {
                return walletAttributionCache[lowerAddress];
            }

            // Basic known exchanges for synchronous checks
            const knownExchanges = {
                '0x07624a16592ab3ca24cccaee13d9ee21eea86fe8': { name: 'Bybit', type: 'CEX' },
                '0xf89d7b9c864f589bbf53a82105107622b35eaa40': { name: 'Bybit', type: 'CEX' },
                '0x28c6c06298d514db089934071355e5743bf21d60': { name: 'Binance', type: 'CEX' },
                '0x21a31ee1afc51d94c2efccaa2092ad1028285549': { name: 'Binance', type: 'CEX' }
            };

            if (knownExchanges[lowerAddress]) {
                walletAttributionCache[lowerAddress] = knownExchanges[lowerAddress];
                return knownExchanges[lowerAddress];
            }

            return null;
        }

        // Get Bitcoin wallet attribution from Arkham Intelligence or other sources
        async function getBitcoinWalletAttribution(address) {
            if (!address) return null;

            // Check cache first
            if (walletAttributionCache[address]) {
                console.log(`Using cached Bitcoin attribution for ${address}`);
                return walletAttributionCache[address];
            }

            try {
                let attribution = null;

                // Try Arkham Intelligence API first
                // Use the same key as in address search
                const arkhamApiKey = localStorage.getItem('bats_arkham_api_key') || 'd377a526-c9ea-4cb6-a647-775559583ff6';

                if (arkhamApiKey) {
                    try {
                        // Use Netlify Function proxy for Arkham API
                        const proxyUrl = `/.netlify/functions/arkham3?endpoint=/intelligence/address/${address}`;
                        const arkhamResponse = await fetch(proxyUrl, {
                            headers: {
                                'X-Arkham-API-Key': arkhamApiKey,
                                'Accept': 'application/json'
                            }
                        }).catch(err => {
                            console.log('Bitcoin Arkham attribution API failed:', err);
                            return null;
                        });

                        if (arkhamResponse && arkhamResponse.ok) {
                            const arkhamData = await arkhamResponse.json();
                            if (arkhamData && arkhamData.arkhamEntity) {
                                attribution = {
                                    name: arkhamData.arkhamEntity.name,
                                    label: arkhamData.arkhamEntity.type || 'Exchange',
                                    type: arkhamData.arkhamEntity.category || 'CEX',
                                    source: 'arkham_intelligence',
                                    metadata: arkhamData.arkhamEntity
                                };
                                console.log('Arkham Intelligence attribution found:', attribution);
                            }
                        }
                    } catch (err) {
                        console.log('Arkham API lookup failed:', err);
                    }
                }

                // Fallback to WalletExplorer API
                if (!attribution) {
                    try {
                        const walletExplorerUrl = `https://www.walletexplorer.com/api/1/address-lookup?address=${address}`;
                        const walletResponse = await fetch(walletExplorerUrl);

                        if (walletResponse.ok) {
                            const walletData = await walletResponse.json();
                            if (walletData.found && walletData.wallet && walletData.wallet.name) {
                                attribution = {
                                    name: walletData.wallet.name,
                                    label: walletData.wallet.category || 'Exchange/Service',
                                    type: walletData.wallet.category || 'Service',
                                    source: 'walletexplorer',
                                    isExchange: walletData.wallet.category === 'Exchange' ||
                                               walletData.wallet.name.toLowerCase().includes('exchange')
                                };
                                console.log(`WalletExplorer attribution found for ${address}:`, attribution);
                                walletAttributionCache[address] = attribution;
                                return attribution;
                            }
                        }
                    } catch (e) {
                        console.log('WalletExplorer API error:', e);
                    }
                }

                // Fallback to Blockchain.info transaction analysis
                if (!attribution) {
                    try {
                        // Check if address has known tags from blockchain.info
                        const blockchainInfoUrl = `https://blockchain.info/rawaddr/${address}?limit=1`;
                        const blockchainResponse = await fetch(blockchainInfoUrl);

                        if (blockchainResponse.ok) {
                            const blockchainData = await blockchainResponse.json();

                            // Check for high transaction count (indicator of exchange)
                            if (blockchainData.n_tx > 10000) {
                                attribution = {
                                    name: 'High-Activity Wallet',
                                    label: 'Possible Exchange',
                                    type: 'Possible CEX',
                                    source: 'transaction_analysis',
                                    transactionCount: blockchainData.n_tx
                                };
                            }
                        }
                    } catch (err) {
                        console.log('Blockchain.info check failed:', err);
                    }
                }

                // Fallback to known Bitcoin exchange addresses
                if (!attribution) {
                    const knownBitcoinExchanges = {
                        // Binance
                        '34xp4vRoCGJym3xR7yCVPFHoCNxv4Twseo': { name: 'Binance', label: 'Binance Cold Wallet' },
                        '3LYJfcfHPXYJreMsASk2jkn69LWEYKzexb': { name: 'Binance', label: 'Binance Hot Wallet' },
                        // Coinbase
                        '3PX76NNVuJUetXJRUrzLCqVssHGVPhBz5A': { name: 'Coinbase', label: 'Coinbase Cold Storage' },
                        // Bitfinex
                        '3D2oetdNuZUqQHPJmcMDDHYoqkyNVsFk9r': { name: 'Bitfinex', label: 'Bitfinex Cold Wallet' },
                        '1Kr6QSydW9bFQG1mXiPNNu6WpJGmUa9i1g': { name: 'Bitfinex', label: 'Bitfinex Old Cold Wallet' },
                        // Kraken
                        '3KBjvJZMRrjAqN5fCkPJBUXuLwR8Lq2Rpr': { name: 'Kraken', label: 'Kraken Cold Wallet' },
                        // Huobi
                        '3Kzh7ZV5NszLMLJrW5dgvgWb7PbYtLxm5W': { name: 'Huobi', label: 'Huobi Cold Wallet' },
                        // Bitstamp
                        '3CgUiDF7M76BkXaKvixMSrKhq1cVqAFetH': { name: 'Bitstamp', label: 'Bitstamp Cold Wallet' },
                        // Add more as needed
                    };

                    if (knownBitcoinExchanges[address]) {
                        attribution = {
                            ...knownBitcoinExchanges[address],
                            type: 'CEX',
                            source: 'known_btc_addresses'
                        };
                    }
                }

                // Cache the result
                walletAttributionCache[address] = attribution;

                if (attribution) {
                    console.log(`🟣 Bitcoin terminal wallet detected: ${attribution.name}`);
                    console.log(`   Address: ${address}`);
                    console.log(`   Source: ${attribution.source}`);
                }

                return attribution;

            } catch (error) {
                console.error('Error fetching Bitcoin wallet attribution:', error);
                return null;
            }
        }

        // Terminal wallet confirmation functions
        function confirmTerminalWallet() {
            if (!window.hopWizardData || !window.hopWizardData.detectedAttribution) {
                alert('No terminal wallet attribution detected.');
                return;
            }

            const attribution = window.hopWizardData.detectedAttribution;

            // Mark wizard data to create terminal entry (no confirmation dialog - it's required)
            window.hopWizardData.isTerminalWallet = true;
            window.hopWizardData.terminalWalletType = 'purple';

            // Update the UI to show terminal wallet will be created
            const resultDiv = document.getElementById('wizardTxResult');

            // Remove the action buttons div since decision was made
            const actionDiv = resultDiv.querySelector('div[style*="#fff3cd"]');
            if (actionDiv) {
                actionDiv.remove();
            }

            // Add confirmation message
            const terminalNote = document.createElement('div');
            terminalNote.style.cssText = 'background: #e1bee7; border: 2px solid #9c27b0; padding: 10px; margin-top: 10px; border-radius: 4px;';
            terminalNote.innerHTML = `
                <strong>✅ Terminal Wallet Entry Confirmed</strong><br>
                Exchange: ${attribution.name || attribution.label}<br>
                This will be marked as a PURPLE terminal wallet and added to the terminal index.
            `;

            const existingNote = resultDiv.querySelector('div[style*="#e1bee7"]');
            if (!existingNote) {
                resultDiv.appendChild(terminalNote);
            }

            // Re-enable and update the Next/Log Entry button
            const nextBtn = document.getElementById('wizardNextBtn');
            if (nextBtn) {
                nextBtn.disabled = false;
                nextBtn.textContent = 'Create Terminal Entry';
                nextBtn.style.background = '#9c27b0'; // Purple button for terminal
            }

            showNotification('✅ Terminal wallet confirmed. Click "Create Terminal Entry" to proceed.', 'success');
        }

        // Convert personal label to terminal wallet
        window.convertToTerminalWallet = function() {
            if (!window.hopWizardData || !window.hopWizardData.detectedAttribution) {
                alert('No label detected to convert.');
                return;
            }

            const attribution = window.hopWizardData.detectedAttribution;

            // Override the personal label flag and mark as terminal
            attribution.isPersonalLabel = false;
            attribution.isExchange = true;
            attribution.type = attribution.type || 'CEX';

            // Mark wizard data to create terminal entry
            window.hopWizardData.isTerminalWallet = true;
            window.hopWizardData.terminalWalletType = 'purple';

            // Update the UI
            const resultDiv = document.getElementById('wizardTxResult');
            const alertDiv = resultDiv.querySelector('div[style*="#e3f2fd"]');

            if (alertDiv) {
                // Replace the personal label UI with terminal wallet UI
                alertDiv.style.cssText = 'background: #e1bee7; border: 2px solid #9c27b0; border-radius: 8px; padding: 15px; margin-top: 15px;';
                alertDiv.innerHTML = `
                    <h4 style="margin: 0 0 10px 0; color: #6a1b9a;">🟣 Converted to Terminal Wallet</h4>
                    <div style="font-size: 14px;">
                        <strong>Exchange/Service:</strong> ${attribution.name || attribution.label}<br>
                        <strong>Type:</strong> Terminal Wallet (CEX)<br>
                        <strong>Wallet:</strong> <span style="font-family: monospace; font-size: 12px;">${window.hopWizardData.txData?.to || ''}</span><br>
                        <div style="margin-top: 10px; padding: 10px; background: white; border-radius: 4px;">
                            <strong>✅ Conversion Complete:</strong><br>
                            • This will now be treated as a terminal wallet<br>
                            • Thread will be marked as exhausted<br>
                            • Legal process required for fund recovery
                        </div>
                    </div>
                `;
            }

            // Update button
            const nextBtn = document.getElementById('wizardNextBtn');
            if (nextBtn) {
                nextBtn.disabled = false;
                nextBtn.textContent = 'Create Terminal Entry';
                nextBtn.style.background = '#9c27b0';
            }
        }

        // Keep as personal label (user chose to ignore exchange indicators)
        window.keepAsPersonalLabel = function() {
            if (!window.hopWizardData || !window.hopWizardData.detectedAttribution) {
                return;
            }

            const attribution = window.hopWizardData.detectedAttribution;

            // Ensure it stays as personal label
            attribution.isPersonalLabel = true;
            attribution.isExchange = false;
            attribution.userConfirmedPersonal = true; // Track that user explicitly chose this

            // Update the UI to show confirmation
            const resultDiv = document.getElementById('wizardTxResult');
            const alertDiv = resultDiv.querySelector('div[style*="#fff3cd"], div[style*="#e3f2fd"]');

            if (alertDiv) {
                alertDiv.style.cssText = 'background: #d4edda; border: 2px solid #27ae60; border-radius: 8px; padding: 15px; margin-top: 15px;';
                alertDiv.innerHTML = `
                    <h4 style="margin: 0 0 10px 0; color: #1e7e34;">✅ Confirmed as Personal Label</h4>
                    <div style="font-size: 14px;">
                        <strong>Label:</strong> ${attribution.name || attribution.label}<br>
                        <strong>Status:</strong> Will be treated as a personal label (not a terminal wallet)<br>
                        <div style="margin-top: 10px; padding: 10px; background: white; border-radius: 4px;">
                            <strong>Next steps:</strong><br>
                            • Continue tracing funds through this wallet<br>
                            • The label will be added to your entry notes<br>
                            • No thread exhaustion will occur
                        </div>
                    </div>
                `;
            }

            // Continue button remains enabled for normal tracing
            const nextBtn = document.getElementById('wizardNextBtn');
            if (nextBtn) {
                nextBtn.disabled = false;
                nextBtn.textContent = 'Continue to Next Step';
                nextBtn.style.background = '';
            }

            showNotification('Label confirmed as personal (not an exchange). Continue tracing normally.', 'success');
        }

        // Convert personal label to conversion wallet (brown)
        window.convertToConversionWallet = function() {
            if (!window.hopWizardData || !window.hopWizardData.detectedAttribution) {
                alert('No label detected to convert.');
                return;
            }

            const attribution = window.hopWizardData.detectedAttribution;

            // Mark as conversion/bridge
            attribution.isPersonalLabel = false;
            attribution.isConversion = true;
            attribution.type = 'Bridge/DEX';

            // Mark wizard data for conversion wallet
            window.hopWizardData.isConversionWallet = true;
            window.hopWizardData.terminalWalletType = 'brown';

            // Update the UI
            const resultDiv = document.getElementById('wizardTxResult');
            const alertDiv = resultDiv.querySelector('div[style*="#e3f2fd"]');

            if (alertDiv) {
                // Replace the personal label UI with conversion wallet UI
                alertDiv.style.cssText = 'background: #d7ccc8; border: 2px solid #8B4513; border-radius: 8px; padding: 15px; margin-top: 15px;';
                alertDiv.innerHTML = `
                    <h4 style="margin: 0 0 10px 0; color: #5d4037;">🟤 Converted to Conversion Wallet</h4>
                    <div style="font-size: 14px;">
                        <strong>Bridge/DEX:</strong> ${attribution.name || attribution.label}<br>
                        <strong>Type:</strong> Conversion Service<br>
                        <strong>Wallet:</strong> <span style="font-family: monospace; font-size: 12px;">${window.hopWizardData.txData?.to || ''}</span><br>
                        <div style="margin-top: 10px; padding: 10px; background: white; border-radius: 4px;">
                            <strong>✅ Conversion Complete:</strong><br>
                            • This will be treated as a bridge/swap<br>
                            • Use the 🌉 Log Bridge/Swap button<br>
                            • Track the converted currency output
                        </div>
                    </div>
                `;
            }

            // Update button
            const nextBtn = document.getElementById('wizardNextBtn');
            if (nextBtn) {
                nextBtn.disabled = false;
                nextBtn.textContent = 'Continue to Next Step';
                nextBtn.style.background = '#8B4513';
            }
        }

        // REMOVED: continueTraceFromTerminal function
        // Exchange wallets MUST be marked as terminal - no option to continue regular trace

        // Shared EVM chain response parser
        const parseEVMResponse = (data, receiptData, blockTimestamp, chainConfig) => {
            // This is the same parser used for all EVM chains
            console.log('parseEVMResponse called with:',
                'hasData:', !!data,
                'hasReceiptData:', !!receiptData,
                'receiptKeys:', receiptData ? Object.keys(receiptData) : [],
                'hasResult:', receiptData && receiptData.result ? true : false,
                'hasLogs:', receiptData && receiptData.result && receiptData.result.logs ? true : false,
                'logsLength:', receiptData && receiptData.result && receiptData.result.logs ? receiptData.result.logs.length : 0
            );

            // Check if we have a token transfer in the receipt logs
            if (receiptData && receiptData.result && receiptData.result.logs && receiptData.result.logs.length > 0) {
                console.log('Checking receipt logs for token transfers:', receiptData.result.logs);
                
                // Look for Transfer events (topic0 = 0xddf252ad...)
                const transferTopic = '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef';
                const transferLogs = receiptData.result.logs.filter(log => 
                    log.topics && log.topics[0] === transferTopic && log.topics.length >= 3
                );
                
                console.log(`Found ${transferLogs.length} token transfers in this transaction`);
                
                if (transferLogs.length > 0) {
                    // Always show selection modal when token transfers exist
                    console.log('Token transfers detected - user selection required');
                    
                    // Parse all transfers for selection
                    const transfers = transferLogs.map(log => {
                            const from = '0x' + log.topics[1].slice(26);
                            const to = '0x' + log.topics[2].slice(26);
                            const value = log.data;
                            const contractAddress = log.address;
                            
                            // Get chain ID for token lookup
                            const chainId = chainConfig && chainConfig.chainId ? chainConfig.chainId : 1;
                            const tokenAddr = contractAddress.toLowerCase();

                            // Convert amount
                            let amount = 0;
                            try {
                                const amountBN = parseInt(value, 16);

                                // Determine decimals based on token
                                let decimals = 18; // default

                                // Check if it's a known stablecoin (USDT/USDC typically use 6 decimals)
                                const stablecoins6Decimals = [
                                    // USDT on most chains (except BSC which uses 18)
                                    '0xdac17f958d2ee523a2206206994597c13d831ec7', // USDT Ethereum
                                    '0xc2132d05d31c914a87c6611c10748aeb04b58e8f', // USDT Polygon
                                    '0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9', // USDT Arbitrum
                                    '0x94b008aa00579c1307b0ef2c499ad98a8ce58e58', // USDT Optimism
                                    '0x9702230a8ea53601f5cd2dc00fdbc13d4df4a8c7', // USDT Avalanche
                                    '0xfde4c96c8593536e31f229ea8f37b2ada2699bb2', // USDT Base
                                    // USDC on all chains uses 6 decimals
                                    '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48', // USDC Ethereum
                                    '0x2791bca1f2de4661ed88a30c99a7a9449aa84174', // USDC Polygon (legacy)
                                    '0x3c499c542cef5e3811e1192ce70d8cc03d5c3359', // USDC Polygon (native)
                                    '0xaf88d065e77c8cc2239327c5edb3a432268e5831', // USDC Arbitrum
                                    '0x7f5c764cbc14f9669b88837ca1490cca17c31607', // USDC.e Optimism
                                    '0x0b2c639c533813f4aa9d7837caf62653d097ff85', // USDC Optimism
                                    '0xb97ef9ef8734c71904d8002f8b6bc66dd9c48a6e', // USDC Avalanche
                                    '0x833589fcd6edb6e08f4c7c32d4f71b54bda02913', // USDC Base
                                    '0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d', // USDC BSC (actually uses 18!)
                                ];

                                // Special case: BSC USDT uses 18 decimals
                                if (tokenAddr === '0x55d398326f99059ff775485246999027b3197955' && chainId === 56) {
                                    decimals = 18;
                                } else if (stablecoins6Decimals.includes(tokenAddr)) {
                                    decimals = 6;
                                }
                                // WBTC uses 8 decimals
                                else if (tokenAddr === '0x2260fac5e5542a773aa44fbcfedf7c193bc2c599' ||
                                         tokenAddr === '0x1bfd67037b42cf73acf2047067bd4f2c47d9bfd6' ||
                                         tokenAddr === '0x2f2a2543b76a4166549f7aab2e75bef0aefc5b0f') {
                                    decimals = 8;
                                }

                                amount = amountBN / Math.pow(10, decimals);
                            } catch (e) {
                                console.error('Error parsing amount:', e);
                            }
                            
                            // Get token symbol - check chain-specific addresses
                            // (chainId already declared above)
                            const tokenAddress = contractAddress.toLowerCase();

                            // Multi-chain token mappings
                            const multiChainTokens = {
                                // USDT addresses
                                1: { // Ethereum
                                    '0xdac17f958d2ee523a2206206994597c13d831ec7': { symbol: 'USDT', decimals: 6 }
                                },
                                56: { // BSC
                                    '0x55d398326f99059ff775485246999027b3197955': { symbol: 'USDT', decimals: 18 }
                                },
                                137: { // Polygon
                                    '0xc2132d05d31c914a87c6611c10748aeb04b58e8f': { symbol: 'USDT', decimals: 6 }
                                },
                                42161: { // Arbitrum
                                    '0xfd086bc7cd5c481dcc9c85ebe478a1c0b69fcbb9': { symbol: 'USDT', decimals: 6 }
                                },
                                10: { // Optimism
                                    '0x94b008aa00579c1307b0ef2c499ad98a8ce58e58': { symbol: 'USDT', decimals: 6 }
                                },
                                43114: { // Avalanche
                                    '0x9702230a8ea53601f5cd2dc00fdbc13d4df4a8c7': { symbol: 'USDT', decimals: 6 }
                                },
                                8453: { // Base
                                    '0xfde4c96c8593536e31f229ea8f37b2ada2699bb2': { symbol: 'USDT', decimals: 6 }
                                },

                                // Add USDC addresses for each chain
                                // (continuing pattern for other tokens...)
                            };

                            // Common token addresses across multiple chains (lowercase)
                            const commonTokenPatterns = {
                                // USDC patterns
                                '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48': 'USDC', // Ethereum
                                '0x8ac76a51cc950d9822d68b83fe1ad97b32cd580d': 'USDC', // BSC
                                '0x2791bca1f2de4661ed88a30c99a7a9449aa84174': 'USDC', // Polygon (legacy)
                                '0x3c499c542cef5e3811e1192ce70d8cc03d5c3359': 'USDC', // Polygon (native)
                                '0xaf88d065e77c8cc2239327c5edb3a432268e5831': 'USDC', // Arbitrum
                                '0x7f5c764cbc14f9669b88837ca1490cca17c31607': 'USDC.e', // Optimism (bridged)
                                '0x0b2c639c533813f4aa9d7837caf62653d097ff85': 'USDC', // Optimism (native)
                                '0xb97ef9ef8734c71904d8002f8b6bc66dd9c48a6e': 'USDC', // Avalanche
                                '0x833589fcd6edb6e08f4c7c32d4f71b54bda02913': 'USDC', // Base

                                // DAI patterns
                                '0x6b175474e89094c44da98b954eedeac495271d0f': 'DAI', // Ethereum
                                '0x1af3f329e8be154074d8769d1ffa4ee058b1dbc3': 'DAI', // BSC
                                '0x8f3cf7ad23cd3cadbd9735aff958023239c6a063': 'DAI', // Polygon
                                '0xda10009cbd5d07dd0cecc66161fc93d7c9000da1': 'DAI', // Arbitrum & Optimism
                                '0xd586e7f844cea2f87f50152665bcbc2c279d8d70': 'DAI', // Avalanche
                                '0x50c5725949a6f0c72e6c4a641f24049a917db0cb': 'DAI', // Base

                                // WBTC patterns
                                '0x2260fac5e5542a773aa44fbcfedf7c193bc2c599': 'WBTC', // Ethereum
                                '0x1bfd67037b42cf73acf2047067bd4f2c47d9bfd6': 'WBTC', // Polygon
                                '0x2f2a2543b76a4166549f7aab2e75bef0aefc5b0f': 'WBTC', // Arbitrum
                                '0x68f180fcce6836688e9084f035309e29bf0a2095': 'WBTC', // Optimism
                                '0x50b7545627a5162f82a992c33b87adc75187b218': 'WBTC', // Avalanche

                                // WETH patterns
                                '0xc02aaa39b223fe8d0a0e5c4f27ead9083c756cc2': 'WETH', // Ethereum
                                '0x4200000000000000000000000000000000000006': 'WETH', // Base & Optimism
                                '0x82af49447d8a07e3bd95bd0d56f35241523fbab1': 'WETH', // Arbitrum
                                '0x7ceb23fd6bc0add59e62ac25578270cff1b9f619': 'WETH', // Polygon
                                '0x49d5c2bdffac6ce2bfdb6640f4f80f226bc10bab': 'WETH', // Avalanche
                            };

                            // First check chain-specific mappings
                            let tokenInfo = null;
                            if (multiChainTokens[chainId] && multiChainTokens[chainId][tokenAddress]) {
                                tokenInfo = multiChainTokens[chainId][tokenAddress];
                            }

                            // Then check common patterns
                            const currency = tokenInfo ? tokenInfo.symbol :
                                           (commonTokenPatterns[tokenAddress] || 'Token');
                            
                            return {
                                from: from,
                                to: to,
                                amount: amount,
                                currency: currency,
                                contractAddress: contractAddress,
                                rawData: log
                            };
                        });
                    
                    // Use block timestamp if available, otherwise current time
                    let timestamp = blockTimestamp || Date.now();
                    const hasRealTimestamp = !!blockTimestamp;
                    if (!blockTimestamp) {
                        console.warn('No block timestamp available for token transfers');
                    }
                    
                    // Only add the ETH transaction if it has value > 0
                    const tx = data.result;
                    if (tx && parseInt(tx.value, 16) > 0) {
                        transfers.unshift({
                            from: tx.from,
                            to: tx.to,
                            amount: parseInt(tx.value, 16) / 1e18,
                            currency: chainConfig && chainConfig.nativeCurrency ? chainConfig.nativeCurrency : 'ETH',
                            contractAddress: `Native ${chainConfig && chainConfig.nativeCurrency ? chainConfig.nativeCurrency : 'ETH'} Transfer`,
                            rawData: tx
                        });
                    }
                    
                    // Always return multiple transfers to show selection modal
                    return {
                        multipleTransfers: true,
                        transfers: transfers,
                        transaction: data.result,
                        time: timestamp,
                        hasRealTimestamp: hasRealTimestamp
                    };
                }
            }
            // Otherwise use regular ETH transaction
            else if (data.result) {
                const tx = data.result;
                
                // For bulk upload, don't skip 0 ETH transactions - they might have token transfers
                // that we couldn't detect due to API limitations
                const ethAmount = parseInt(tx.value, 16) / 1e18;
                if (ethAmount === 0) {
                    console.log('Warning: 0 ETH transaction - may have token transfers not detected by API');
                    // Still return transaction data for user to review
                }
                
                // Use block timestamp if available, otherwise current time
                let timestamp = blockTimestamp || Date.now();
                const hasRealTimestamp = !!blockTimestamp;
                if (!blockTimestamp) {
                    console.warn('No block timestamp available for ETH transaction');
                }
                
                return {
                    time: timestamp,
                    amount: ethAmount,
                    currency: chainConfig && chainConfig.nativeCurrency ? chainConfig.nativeCurrency : 'ETH',
                    from: tx.from,
                    to: tx.to,
                    fee: tx.gasPrice && tx.gas ? 
                        parseInt(tx.gasPrice, 16) * parseInt(tx.gas, 16) / 1e18 : 0,
                    hasRealTimestamp: hasRealTimestamp
                };
            }
            return null;
        };
        
        // Blockchain API configurations
        // Make it globally accessible for other functions
        const blockchainAPIs = window.blockchainAPIs = {
            bitcoin: {
                name: 'Bitcoin',
                hashPattern: /^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$|^bc1[a-z0-9]{39,59}$/,
                addressPattern: /^([13][a-km-zA-HJ-NP-Z1-9]{25,34}|bc1[a-z0-9]{39,59})$/,
                addressPrefixes: ['1', '3', 'bc1'],
                txPattern: /^[a-f0-9]{64}$/i,
                apiUrl: 'https://blockchain.info/rawtx/',
                addressApiUrl: 'https://blockchain.info/rawaddr/',
                entityApiUrl: 'https://www.walletexplorer.com/api/1/address-lookup?address=',
                apiKey: null,
                fallbackUrls: [
                    'https://api.blockcypher.com/v1/btc/main/txs/',
                    'https://mempool.space/api/tx/',
                    'https://api.blockchair.com/bitcoin/raw/transaction/',
                    'https://btc.blockbook.api.blockchair.com/api/v2/tx/'
                ],
                parseResponse: (data) => {
                    if (data.hash) {
                        // blockchain.info format
                        console.log('Bitcoin transaction data from blockchain.info:', data);
                        
                        // blockchain.info may use 'inputs' or 'in' for inputs array
                        const inputs = data.inputs || data.in;
                        if (!inputs || !Array.isArray(inputs) || inputs.length === 0) {
                            console.error('No inputs found in transaction');
                            return null;
                        }
                        
                        const firstInput = inputs[0];
                        
                        // Check for timestamp - blockchain.info provides 'time' in unix seconds
                        if (!data.time) {
                            console.warn('No timestamp in Bitcoin transaction data! Using current time as fallback.');
                        } else {
                            console.log(`Bitcoin transaction timestamp: ${data.time} (${new Date(data.time * 1000).toISOString()})`);
                        }
                        
                        const timestamp = data.time ? data.time * 1000 : Date.now();
                        
                        // Check if there are multiple outputs
                        // Show ALL outputs for selection so user can choose the correct one
                        const senderAddress = firstInput.prev_out ? firstInput.prev_out.addr : null;
                        
                        // For victim transaction selection, we want to see ALL outputs
                        // The user will select which one represents their victim's transaction
                        
                        // Check if outputs exist - blockchain.info uses 'out' not 'outputs'
                        const outputs = data.outputs || data.out;
                        if (!outputs || !Array.isArray(outputs)) {
                            console.error('No outputs array in transaction data. Keys available:', Object.keys(data));
                            return null;
                        }
                        
                        // Use the correct outputs array for consistency
                        data.outputs = outputs;
                        
                        console.log(`Bitcoin transaction has ${data.outputs.length} total outputs`);
                        
                        const significantOutputs = data.outputs.filter(output => {
                            // Only filter out tiny dust outputs (< 546 satoshis, Bitcoin's dust limit)
                            if (output.value < 546) {
                                console.log(`Filtering out dust output: ${output.value} satoshis to ${output.addr}`);
                                return false;
                            }
                            
                            // Include everything else - let the user decide which output is relevant
                            return true;
                        });
                        
                        console.log(`After filtering: ${significantOutputs.length} significant outputs`);
                        
                        // Show selection modal if there are 2 or more outputs
                        // Even with just 2, user needs to choose which one is theirs
                        if (significantOutputs.length > 1) {
                            // Calculate total input amount for unnecessary input heuristic
                            let totalInputAmount = 0;
                            let inputDetails = [];

                            inputs.forEach(input => {
                                if (input.prev_out && input.prev_out.value) {
                                    const inputAmount = input.prev_out.value / 100000000;
                                    totalInputAmount += inputAmount;
                                    inputDetails.push({
                                        address: input.prev_out.addr || 'Unknown',
                                        amount: inputAmount
                                    });
                                }
                            });

                            // Multiple outputs - return them as transfers for selection
                            const transfers = significantOutputs.map((output, index) => ({
                                from: senderAddress || 'Unknown',
                                to: output.addr || 'Unknown',
                                amount: output.value / 100000000,
                                currency: 'BTC',
                                outputIndex: index,
                                scriptType: output.script ? output.script.substring(0, 6) : 'unknown',
                                rawData: output,
                                // Include input info for change detection
                                totalInputAmount: totalInputAmount,
                                inputCount: inputs.length,
                                inputDetails: inputDetails
                            }));
                            
                            return {
                                multipleTransfers: true,
                                transfers: transfers,
                                time: timestamp,
                                hasRealTimestamp: !!data.time,
                                fee: data.fee ? data.fee / 100000000 : null
                            };
                        } else {
                            // Single output transaction
                            const firstOutput = significantOutputs[0] || data.outputs[0];
                            return {
                                time: timestamp,
                                amount: firstOutput.value / 100000000,
                                currency: 'BTC',
                                from: senderAddress || 'Unknown',
                                to: firstOutput.addr || 'Unknown',
                                fee: data.fee ? data.fee / 100000000 : null
                            };
                        }
                    } else if (data.tx_hash) {
                        // blockcypher format
                        let timestamp;
                        try {
                            timestamp = new Date(data.received).getTime();
                            if (isNaN(timestamp)) timestamp = Date.now();
                            console.log(`BlockCypher timestamp: ${data.received} -> ${new Date(timestamp).toISOString()}`);
                        } catch (e) {
                            timestamp = Date.now();
                            console.warn('Failed to parse BlockCypher timestamp, using current time');
                        }
                        
                        // Check if outputs exist
                        if (!data.outputs || !Array.isArray(data.outputs)) {
                            console.error('No outputs array in BlockCypher data');
                            return null;
                        }
                        
                        // Check for multiple outputs
                        const senderAddress = data.inputs && data.inputs[0] && data.inputs[0].addresses ? data.inputs[0].addresses[0] : null;
                        
                        console.log(`BlockCypher transaction has ${data.outputs.length} total outputs`);
                        
                        // For victim transaction selection, show ALL non-dust outputs
                        const significantOutputs = data.outputs.filter(output => {
                            // Only filter out tiny dust outputs (< 546 satoshis)
                            if (output.value < 546) return false;
                            
                            // Include everything else for user selection
                            return true;
                        });
                        
                        if (significantOutputs.length > 1) {
                            // Multiple outputs - return them as transfers for selection
                            const transfers = significantOutputs.map((output, index) => ({
                                from: senderAddress || 'Unknown',
                                to: output.addresses ? output.addresses[0] : 'Unknown',
                                amount: output.value / 100000000,
                                currency: 'BTC',
                                outputIndex: index,
                                scriptType: output.script_type || 'unknown',
                                rawData: output
                            }));
                            
                            return {
                                multipleTransfers: true,
                                transfers: transfers,
                                time: timestamp,
                                hasRealTimestamp: true,
                                fee: data.fees ? data.fees / 100000000 : null
                            };
                        } else {
                            // Single output transaction
                            const firstOutput = significantOutputs[0] || data.outputs[0];
                            return {
                                time: timestamp,
                                amount: firstOutput.value / 100000000,
                                currency: 'BTC',
                                from: senderAddress || 'Unknown',
                                to: firstOutput.addresses ? firstOutput.addresses[0] : 'Unknown',
                                fee: data.fees ? data.fees / 100000000 : null
                            };
                        }
                    }
                    return null;
                }
            },
            ethereum: {
                name: 'Ethereum',
                nativeCurrency: 'ETH',
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                chainId: 1, // Ethereum mainnet
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=1&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=1&module=proxy&action=eth_getTransactionReceipt&txhash=',
                txReceiptUrl: 'https://api.etherscan.io/v2/api?chainid=1&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=1&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=1&module=account&action=txlist&address=',
                labelApiUrl: 'https://api.etherscan.io/v2/api?chainid=1&module=account&action=addressinfo&address=',
                apiKey: '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                fallbackUrls: [],
                parseResponse: parseEVMResponse
            },
            base: {
                name: 'Base',
                nativeCurrency: 'ETH',
                chainId: 8453,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=8453&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=8453&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=8453&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=8453&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            arbitrum: {
                name: 'Arbitrum',
                nativeCurrency: 'ETH',
                chainId: 42161,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=42161&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=42161&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=42161&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=42161&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            optimism: {
                name: 'Optimism',
                nativeCurrency: 'ETH',
                chainId: 10,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=10&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=10&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=10&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=10&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            polygon: {
                name: 'Polygon',
                nativeCurrency: 'MATIC',
                chainId: 137,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=137&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=137&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=137&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=137&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            bsc: {
                name: 'BNB Chain',
                nativeCurrency: 'BNB',
                chainId: 56,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=56&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=56&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=56&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=56&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            // Additional EVM chains supported by Etherscan API v2
            avalanche: {
                name: 'Avalanche C-Chain',
                nativeCurrency: 'AVAX',
                chainId: 43114,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=43114&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=43114&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=43114&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=43114&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            hyperevm: {
                name: 'HyperEVM',
                nativeCurrency: 'HYPE',
                chainId: 999,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=999&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=999&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=999&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=999&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            linea: {
                name: 'Linea',
                nativeCurrency: 'ETH',
                chainId: 59144,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=59144&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=59144&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=59144&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=59144&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            scroll: {
                name: 'Scroll',
                nativeCurrency: 'ETH',
                chainId: 534352,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=534352&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=534352&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=534352&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=534352&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            mantle: {
                name: 'Mantle',
                nativeCurrency: 'MNT',
                chainId: 5000,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=5000&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=5000&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=5000&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=5000&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            blast: {
                name: 'Blast',
                nativeCurrency: 'ETH',
                chainId: 81457,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=81457&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=81457&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=81457&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=81457&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            zksync: {
                name: 'zkSync',
                nativeCurrency: 'ETH',
                chainId: 324,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=324&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=324&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=324&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=324&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            gnosis: {
                name: 'Gnosis',
                nativeCurrency: 'xDAI',
                chainId: 100,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=100&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=100&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=100&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=100&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            celo: {
                name: 'Celo',
                nativeCurrency: 'CELO',
                chainId: 42220,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=42220&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=42220&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=42220&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=42220&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            moonbeam: {
                name: 'Moonbeam',
                nativeCurrency: 'GLMR',
                chainId: 1284,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=1284&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=1284&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=1284&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=1284&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            moonriver: {
                name: 'Moonriver',
                nativeCurrency: 'MOVR',
                chainId: 1285,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=1285&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=1285&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=1285&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=1285&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            fraxtal: {
                name: 'Fraxtal',
                nativeCurrency: 'frxETH',
                chainId: 252,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=252&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=252&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=252&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=252&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            taiko: {
                name: 'Taiko',
                nativeCurrency: 'ETH',
                chainId: 167000,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=167000&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=167000&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=167000&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=167000&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            arbitrumnova: {
                name: 'Arbitrum Nova',
                nativeCurrency: 'ETH',
                chainId: 42170,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=42170&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=42170&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=42170&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=42170&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            bittorrent: {
                name: 'BitTorrent Chain',
                nativeCurrency: 'BTT',
                chainId: 199,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=199&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=199&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=199&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=199&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            opbnb: {
                name: 'opBNB',
                nativeCurrency: 'BNB',
                chainId: 204,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=204&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=204&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=204&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=204&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            tron: {
                name: 'Tron',
                hashPattern: /^T[a-zA-Z0-9]{33}$/,
                addressPattern: /^T[a-zA-Z0-9]{33}$/,
                addressPrefixes: ['T'],
                txPattern: /^[a-f0-9]{64}$/i,
                apiUrl: 'https://api.trongrid.io/v1/transactions/',
                addressApiUrl: 'https://api.trongrid.io/v1/accounts/',
                apiKey: null,
                fallbackUrls: [
                    'https://apilist.tronscan.org/api/transaction-info?hash='
                ],
                parseResponse: (data) => {
                    if (data.data && data.data[0]) {
                        const tx = data.data[0];
                        return {
                            time: tx.block_timestamp,
                            amount: (tx.raw_data.contract[0].parameter.value.amount || 0) / 1e6,
                            currency: 'TRX',
                            from: tx.raw_data.contract[0].parameter.value.owner_address,
                            to: tx.raw_data.contract[0].parameter.value.to_address,
                            fee: tx.fee ? tx.fee / 1e6 : null
                        };
                    }
                    return null;
                }
            },
            solana: {
                name: 'Solana',
                hashPattern: /^[1-9A-HJ-NP-Za-km-z]{32,44}$/,
                addressPattern: /^[1-9A-HJ-NP-Za-km-z]{32,44}$/,
                addressPrefixes: ['1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'],
                txPattern: /^[1-9A-HJ-NP-Za-km-z]{87,88}$/,
                apiUrl: 'https://api.mainnet-beta.solana.com',
                addressApiUrl: 'https://api.mainnet-beta.solana.com',
                apiKey: null,
                fallbackUrls: [
                    'https://solana-mainnet.g.alchemy.com/v2/demo',
                    'https://rpc.ankr.com/solana'
                ],
                parseResponse: (data) => {
                    if (data.result) {
                        const tx = data.result;
                        const meta = tx.meta;

                        // Check for errors
                        if (meta.err) {
                            console.error('Transaction failed:', meta.err);
                            return null;
                        }

                        // Try to parse token transfers first (SPL tokens)
                        const transfers = [];

                        // Check for token balance changes (SPL tokens)
                        if (meta.postTokenBalances && meta.preTokenBalances) {
                            const tokenBalanceChanges = {};

                            // Process pre-balances
                            meta.preTokenBalances.forEach(balance => {
                                const key = `${balance.accountIndex}-${balance.mint}`;
                                tokenBalanceChanges[key] = {
                                    accountIndex: balance.accountIndex,
                                    mint: balance.mint,
                                    owner: balance.owner,
                                    preBalance: parseFloat(balance.uiTokenAmount.uiAmount || 0),
                                    postBalance: 0,
                                    decimals: balance.uiTokenAmount.decimals,
                                    symbol: null
                                };
                            });

                            // Process post-balances
                            meta.postTokenBalances.forEach(balance => {
                                const key = `${balance.accountIndex}-${balance.mint}`;
                                if (tokenBalanceChanges[key]) {
                                    tokenBalanceChanges[key].postBalance = parseFloat(balance.uiTokenAmount.uiAmount || 0);
                                } else {
                                    tokenBalanceChanges[key] = {
                                        accountIndex: balance.accountIndex,
                                        mint: balance.mint,
                                        owner: balance.owner,
                                        preBalance: 0,
                                        postBalance: parseFloat(balance.uiTokenAmount.uiAmount || 0),
                                        decimals: balance.uiTokenAmount.decimals,
                                        symbol: null
                                    };
                                }
                            });

                            // Create transfer objects for significant changes
                            // Group by mint to find paired transfers
                            const transfersByMint = {};
                            Object.values(tokenBalanceChanges).forEach(change => {
                                const amount = Math.abs(change.postBalance - change.preBalance);
                                if (amount > 0.0000001) { // Filter tiny amounts
                                    if (!transfersByMint[change.mint]) {
                                        transfersByMint[change.mint] = [];
                                    }
                                    transfersByMint[change.mint].push({
                                        owner: change.owner,
                                        amount: amount,
                                        isSender: change.postBalance < change.preBalance,
                                        mint: change.mint,
                                        decimals: change.decimals
                                    });
                                }
                            });

                            // Map known SPL token mints to symbols
                            const tokenSymbols = {
                                'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v': 'USDC',
                                'Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB': 'USDT',
                                'So11111111111111111111111111111111111111112': 'SOL',
                                'DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263': 'BONK',
                                'JUPyiwrYJFskUPiHa8hkeR8VUtAeFoSYbKedZNsDvCN': 'JUP'
                            };

                            // Create single transfers from paired debits/credits
                            Object.entries(transfersByMint).forEach(([mint, changes]) => {
                                const symbol = tokenSymbols[mint] || 'Unknown Token';

                                if (changes.length === 2) {
                                    // Paired transfer - combine into single entry
                                    const sender = changes.find(c => c.isSender);
                                    const receiver = changes.find(c => !c.isSender);

                                    if (sender && receiver) {
                                        transfers.push({
                                            from: sender.owner,
                                            to: receiver.owner,
                                            amount: Math.max(sender.amount, receiver.amount), // Use max in case of rounding
                                            currency: symbol,
                                            mint: mint,
                                            type: 'SPL Token'
                                        });
                                    }
                                } else {
                                    // Unpaired transfers - show each separately (might be mint/burn)
                                    changes.forEach(change => {
                                        transfers.push({
                                            from: change.isSender ? change.owner : 'Unknown',
                                            to: !change.isSender ? change.owner : 'Unknown',
                                            amount: change.amount,
                                            currency: symbol,
                                            mint: mint,
                                            type: 'SPL Token'
                                        });
                                    });
                                }
                            });
                        }

                        // If we found token transfers, return them
                        if (transfers.length > 0) {
                            if (transfers.length === 1) {
                                return {
                                    time: tx.blockTime * 1000,
                                    amount: transfers[0].amount,
                                    currency: transfers[0].currency,
                                    from: transfers[0].from,
                                    to: transfers[0].to,
                                    fee: meta.fee / 1e9,
                                    hasRealTimestamp: true
                                };
                            } else {
                                // Multiple transfers
                                return {
                                    multipleTransfers: true,
                                    transfers: transfers.map(t => ({
                                        ...t,
                                        time: tx.blockTime * 1000,
                                        hasRealTimestamp: true
                                    })),
                                    time: tx.blockTime * 1000,
                                    fee: meta.fee / 1e9,
                                    hasRealTimestamp: true
                                };
                            }
                        }

                        // Fallback to SOL transfer parsing
                        const accountKeys = tx.transaction.message.accountKeys;
                        const preBalances = meta.preBalances;
                        const postBalances = meta.postBalances;

                        // Find the main SOL transfer
                        let mainTransfer = null;
                        for (let i = 0; i < accountKeys.length && i < preBalances.length; i++) {
                            const diff = (postBalances[i] - preBalances[i]) / 1e9;
                            if (Math.abs(diff) > 0.000001 && i > 0) { // Skip system program (index 0) and tiny amounts
                                if (!mainTransfer || Math.abs(diff) > Math.abs(mainTransfer.amount)) {
                                    mainTransfer = {
                                        from: diff < 0 ? accountKeys[i] : accountKeys[0],
                                        to: diff > 0 ? accountKeys[i] : 'Unknown',
                                        amount: Math.abs(diff)
                                    };
                                }
                            }
                        }

                        if (mainTransfer) {
                            return {
                                time: tx.blockTime * 1000,
                                amount: mainTransfer.amount,
                                currency: 'SOL',
                                from: mainTransfer.from,
                                to: mainTransfer.to,
                                fee: meta.fee / 1e9,
                                hasRealTimestamp: true
                            };
                        }

                        // Last resort - basic parsing
                        const amount = Math.abs(postBalances[1] - preBalances[1]) / 1e9;
                        return {
                            time: tx.blockTime * 1000,
                            amount: amount,
                            currency: 'SOL',
                            from: accountKeys[0],
                            to: accountKeys[1] || 'Unknown',
                            fee: meta.fee / 1e9,
                            hasRealTimestamp: true
                        };
                    }
                    return null;
                }
            },
            ripple: {
                name: 'Ripple (XRP)',
                hashPattern: /^[A-F0-9]{64}$/i,
                addressPattern: /^r[0-9a-zA-Z]{24,34}$/,
                addressPrefixes: ['r'],
                txPattern: /^[A-F0-9]{64}$/i,
                apiUrl: 'https://api.xrpscan.com/api/v1/tx/',
                apiKey: null,
                parseResponse: (data) => {
                    if (data) {
                        return {
                            time: data.date ? new Date(data.date * 1000).getTime() : Date.now(),
                            amount: data.Amount ? (typeof data.Amount === 'string' ?
                                parseInt(data.Amount) / 1000000 :
                                parseFloat(data.Amount.value || 0)) : 0,
                            currency: data.Amount?.currency || 'XRP',
                            from: data.Account || '',
                            to: data.Destination || '',
                            fee: data.Fee ? parseInt(data.Fee) / 1000000 : 0,
                            hasRealTimestamp: !!data.date
                        };
                    }
                    return null;
                }
            }
        };

        // Currency decimal place configuration
        const currencyDecimals = {
            'USD': 2,
            'EUR': 2,
            'GBP': 2,
            'CAD': 2,
            'AUD': 2,
            'JPY': 0,  // Japanese Yen typically has no decimal places
            'BTC': 8,  // Bitcoin: 8 decimal places (satoshis)
            'ETH': 18, // Ethereum: 18 decimal places (wei)
            'USDT': 6, // Tether: 6 decimal places
            'USDC': 6, // USD Coin: 6 decimal places
            'DAI': 18, // DAI: 18 decimal places
            'TRX': 6,  // TRON: 6 decimal places
            'SOL': 9,  // Solana: 9 decimal places
            'ADA': 6,  // Cardano: 6 decimal places
            'BNB': 8,  // BNB: 8 decimal places
            'XRP': 6,  // Ripple: 6 decimal places
            'CUSTOM': 8 // Default for custom currencies
        };
        
        // Get decimal places for a currency
        function getCurrencyDecimals(currency) {
            return currencyDecimals[currency] || 8; // Default to 8 if not found
        }
        
        // Get step value for input based on currency
        function getCurrencyStep(currency) {
            const decimals = getCurrencyDecimals(currency);
            if (decimals === 0) return '1';
            return '0.' + '0'.repeat(decimals - 1) + '1';
        }
        
        // Format amount with proper decimal places
        function formatCurrencyAmount(amount, currency, preserveFullPrecision = false) {
            const decimals = getCurrencyDecimals(currency);
            const num = parseFloat(amount);
            if (isNaN(num)) return '0';
            
            // If preserveFullPrecision is true, keep all decimal places
            if (preserveFullPrecision) {
                return num.toFixed(decimals);
            }
            
            // For display, show meaningful decimals (remove trailing zeros)
            if (decimals > 2) {
                // For crypto, show up to decimals places but remove trailing zeros
                return num.toFixed(decimals).replace(/\.?0+$/, '');
            } else {
                // For fiat, always show 2 decimals
                return num.toFixed(decimals);
            }
        }
        
        function saveUndoState(description) {
            try {
                // Deep clone the current investigation state
                // Use structured clone if available (more efficient for large objects)
                let clonedInvestigation;
                if (typeof structuredClone === 'function') {
                    // Modern browsers support structuredClone (faster and handles more types)
                    clonedInvestigation = structuredClone(investigation);
                } else {
                    // Fallback to JSON method
                    clonedInvestigation = JSON.parse(JSON.stringify(investigation));
                }

                const state = {
                    timestamp: new Date().toISOString(),
                    description: description,
                    investigation: clonedInvestigation
                };

                undoHistory.push(state);

                // Keep history size manageable and clean up old references
                if (undoHistory.length > MAX_UNDO_HISTORY) {
                    const removed = undoHistory.shift();
                    // Clear the reference to help garbage collection
                    if (removed) {
                        removed.investigation = null;
                    }
                }

                updateUndoButton();
            } catch (error) {
                console.error('Failed to save undo state:', error);
                // If we can't save undo state, continue operation but log error
            }
        }
        
        function performUndo() {
            if (undoHistory.length === 0) {
                alert('No actions to undo.');
                return;
            }
            
            const lastState = undoHistory.pop();
            
            // Restore the investigation state
            investigation = JSON.parse(JSON.stringify(lastState.investigation));
            
            // Re-render everything
            renderAll();
            updateUndoButton();
            
            alert(`Undone: ${lastState.description}`);
        }
        
        function updateUndoButton() {
            const undoButton = document.getElementById('undoButton');
            if (undoButton) {
                if (undoHistory.length > 0) {
                    const lastAction = undoHistory[undoHistory.length - 1];
                    undoButton.disabled = false;
                    undoButton.title = `Undo: ${lastAction.description}`;
                } else {
                    undoButton.disabled = true;
                    undoButton.title = 'No actions to undo';
                }
            }
        }
        
        // Navigation functions
        function showNavigationMenu() {
            const menuHTML = `
                <div id="navigationModal" class="modal" style="display: block;">
                    <div class="modal-content" style="max-width: 600px;">
                        <div class="modal-header" style="position: relative;">
                            <h2>Navigate to...</h2>
                            <button class="close-btn" onclick="closeNavigationMenu()" 
                                    style="position: absolute; right: 15px; top: 15px; width: 40px; height: 40px; 
                                           font-size: 28px; background: #e74c3c; color: white; border: none; 
                                           border-radius: 50%; cursor: pointer; display: flex; align-items: center; 
                                           justify-content: center; box-shadow: 0 2px 5px rgba(0,0,0,0.2); 
                                           transition: all 0.3s ease; font-weight: bold;"
                                    onmouseover="this.style.background='#c0392b'; this.style.transform='scale(1.1)'" 
                                    onmouseout="this.style.background='#e74c3c'; this.style.transform='scale(1)'"
                                    title="Close Navigation (ESC)">×</button>
                        </div>
                        <div style="max-height: 400px; overflow-y: auto;">
                            <h3 style="margin-top: 20px;">Quick Navigation</h3>
                            <div style="display: grid; gap: 10px; margin-bottom: 20px;">
                                <button class="btn" onclick="navigateTo('victims'); closeNavigationMenu();">
                                    👥 Victims & Transactions
                                </button>
                                <button class="btn" onclick="navigateTo('traces'); closeNavigationMenu();">
                                    Trace Documentation
                                </button>
                            </div>
                            
                            <h3>Hops</h3>
                            ${investigation.hops.length === 0 ? 
                                '<p style="color: #666;">No hops created yet</p>' :
                                investigation.hops.map(hop => `
                                    <div style="background: #f8f9fa; padding: 10px; margin-bottom: 10px; border-radius: 6px;">
                                        <div style="display: flex; justify-content: space-between; align-items: center;">
                                            <strong>Hop ${hop.hopNumber}</strong>
                                            <button class="btn btn-sm" onclick="navigateToHop(${hop.hopNumber}); closeNavigationMenu();">
                                                Go to Hop
                                            </button>
                                        </div>
                                        ${hop.entries.length > 0 ? `
                                            <div style="margin-top: 10px; padding-left: 20px;">
                                                ${hop.entries.map(entry => `
                                                    <div style="display: flex; justify-content: space-between; align-items: center; margin: 5px 0;">
                                                        <span style="font-size: 14px;">
                                                            Entry ${entry.id}: ${entry.notation || 'No notation'} 
                                                            ${parseFloat(entry.amount) > 0 ? `(${entry.amount} ${entry.currency})` : ''}
                                                        </span>
                                                        <button class="btn btn-sm" style="padding: 2px 8px; font-size: 12px;" 
                                                                onclick="navigateToEntry(${hop.hopNumber}, ${entry.id}); closeNavigationMenu();">
                                                            Edit
                                                        </button>
                                                    </div>
                                                `).join('')}
                                            </div>
                                        ` : '<p style="font-size: 14px; color: #666; margin-left: 20px;">No entries yet</p>'}
                                    </div>
                                `).join('')
                            }
                        </div>
                        <div style="padding: 20px; border-top: 2px solid #e8f0fe; text-align: center; background: #f8f9fa;">
                            <button class="btn" onclick="closeNavigationMenu()" 
                                    style="background: #95a5a6; color: white; padding: 10px 30px; font-size: 16px;">
                                Close Navigation
                            </button>
                            <div style="margin-top: 10px; font-size: 12px; color: #666;">
                                Tip: Press ESC to close quickly
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            createCenteredModal('navigationModal', menuHTML);
            
            // Add ESC key listener
            const escHandler = (e) => {
                if (e.key === 'Escape') {
                    closeNavigationMenu();
                    document.removeEventListener('keydown', escHandler);
                }
            };
            document.addEventListener('keydown', escHandler);
        }
        
        function closeNavigationMenu() {
            const modal = document.getElementById('navigationModal');
            if (modal) modal.remove();
        }
        
        function navigateTo(tab) {
            switchTab(tab);
            const tabButton = document.querySelector(`[onclick="switchTab('${tab}')"]`);
            if (tabButton) tabButton.click();
            updateBreadcrumbs();
        }
        
        function navigateToHop(hopNumber) {
            // Switch to traces tab
            navigateTo('traces');

            // Scroll to and highlight the hop
            setTimeout(() => {
                const hopElement = document.querySelector(`#hopContent_${hopNumber}`);
                if (hopElement) {
                    // Expand the hop if collapsed
                    window.hopCollapseState[hopNumber] = false;
                    hopElement.style.display = 'block';

                    // Scroll into view
                    hopElement.scrollIntoView({ behavior: 'smooth', block: 'center' });

                    // Highlight briefly
                    const hopContainer = hopElement.closest('.hop-container');
                    if (hopContainer) {
                        hopContainer.style.transition = 'background-color 0.3s';
                        hopContainer.style.backgroundColor = '#fffbcc';
                        setTimeout(() => {
                            hopContainer.style.backgroundColor = '';
                        }, 2000);
                    }
                }
            }, 100);
        }
        
        function navigateToEntry(hopNumber, entryId) {
            // First navigate to the hop
            navigateToHop(hopNumber);
            
            // Then expand and highlight the entry
            setTimeout(() => {
                const entryKey = `${hopNumber}_${entryId}`;
                
                // Expand the entry
                window.entryCollapseState[entryKey] = false;
                const content = document.getElementById(`entryContent_${entryKey}`);
                const summary = document.getElementById(`entrySummary_${entryKey}`);
                
                if (content && summary) {
                    content.style.display = 'block';
                    summary.style.display = 'none';
                    
                    // Scroll to entry
                    content.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    
                    // Highlight the entry
                    const entryContainer = content.closest('div[style*="background"]');
                    if (entryContainer) {
                        entryContainer.style.transition = 'transform 0.3s, box-shadow 0.3s';
                        entryContainer.style.transform = 'scale(1.02)';
                        entryContainer.style.boxShadow = '0 4px 20px rgba(52, 152, 219, 0.3)';
                        setTimeout(() => {
                            entryContainer.style.transform = '';
                            entryContainer.style.boxShadow = '';
                        }, 2000);
                    }
                }
            }, 200);
        }
        
        function updateBreadcrumbs() {
            const breadcrumbsEl = document.getElementById('breadcrumbs');
            if (!breadcrumbsEl) return;
            
            let breadcrumbs = [];
            
            // Get current tab
            const activeTab = document.querySelector('.nav-tab.active');
            if (activeTab) {
                breadcrumbs.push(activeTab.textContent);
            }
            
            // Add case info if available
            if (investigation.caseId) {
                breadcrumbs.unshift(`Case: ${investigation.caseId}`);
            }
            
            breadcrumbsEl.innerHTML = breadcrumbs.join(' › ');
        }
        
        // Reopen a completed hop for editing
        function reopenHop(hopNumber) {
            event.stopPropagation(); // Prevent hop collapse toggle

            const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
            if (!hop) return;

            // Mark hop as not completed to allow editing
            hop.completed = false;
            hop.isCollapsed = false;
            window.hopCollapseState[hop.hopNumber] = false;

            // Check for dependent hops
            const dependentHops = investigation.hops.filter(h => h.hopNumber > hop.hopNumber);
            
            if (dependentHops.length > 0) {
                // Build detailed warning about impacts
                let impactSummary = `⚠️ WARNING: Editing Hop ${hop.hopNumber} will impact downstream hops!\n\n`;
                impactSummary += `Affected hops: ${dependentHops.map(h => `Hop ${h.hopNumber}`).join(', ')}\n\n`;
                
                // Check which threads from this hop are used downstream
                const threadsFromThisHop = [];
                hop.entries.forEach(entry => {
                    const amount = parseAmount(entry.amount);
                    if (entry.notation && amount > 0) {
                        const threadId = entry.notation;
                        threadsFromThisHop.push({
                            threadId: threadId,
                            amount: amount,
                            currency: entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency
                        });
                    }
                });
                
                // Find which downstream entries use these threads
                let affectedEntries = [];
                dependentHops.forEach(downstreamHop => {
                    downstreamHop.entries.forEach(entry => {
                        const usesThreads = threadsFromThisHop.some(thread => 
                            entry.sourceThreadId === thread.threadId ||
                            (entry.multipleSourceThreads && entry.multipleSourceThreads.includes(thread.threadId))
                        );
                        
                        if (usesThreads) {
                            affectedEntries.push({
                                hop: downstreamHop.hopNumber,
                                entry: entry.notation || `Entry ${entry.id}`,
                                amount: entry.amount,
                                currency: entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency
                            });
                        }
                    });
                });
                
                if (affectedEntries.length > 0) {
                    impactSummary += `Entries that will need updating:\n`;
                    affectedEntries.forEach(ae => {
                        impactSummary += `• Hop ${ae.hop}, ${ae.entry}: ${ae.amount} ${ae.currency}\n`;
                    });
                }
                
                impactSummary += `\nChanges to Hop ${hop.hopNumber} may require you to:\n`;
                impactSummary += `• Update thread amounts in downstream hops\n`;
                impactSummary += `• Reassign source threads if entries are removed\n`;
                impactSummary += `• Recalculate ART for all affected hops\n\n`;
                impactSummary += `Do you want to continue?`;
                
                if (!confirm(impactSummary)) {
                    return;
                }
            } else {
                // No downstream hops affected
                if (!confirm(`Are you sure you want to reopen Hop ${hop.hopNumber} for editing?\n\nThis will allow you to add or modify entries.`)) {
                    return;
                }
            }
            
            // Save undo state with full context
            saveUndoState(`Reopen Hop ${hop.hopNumber} for editing`);
            
            // Mark hop as not finalized
            hop.isFinalized = false;
            
            // Mark all downstream hops as needing validation
            dependentHops.forEach(h => {
                h.needsValidation = true;
            });
            
            // Re-render to show edit controls
            renderHops();
            saveToStorage();
            
            // Expand the hop
            // hopNumber is already available as the function parameter
            window.hopCollapseState[hopNumber] = false;
            const hopContent = document.getElementById(`hopContent_${hopNumber}`);
            if (hopContent) {
                hopContent.style.display = 'block';

                // Scroll to the hop
                setTimeout(() => {
                    const hopContainer = hopContent.closest('.hop-container');
                    if (hopContainer) {
                        hopContainer.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    }
                }, 100);
            }
            
            if (dependentHops.length > 0) {
                alert(`Hop ${hop.hopNumber} is now open for editing.\n\nWARNING: Changes here will affect Hops ${dependentHops.map(h => h.hopNumber).join(', ')}.\n\nAfter making changes, you'll need to validate and update the downstream hops.`);
            } else {
                alert(`Hop ${hop.hopNumber} is now open for editing.`);
            }
        }
        // Validate and update a hop after upstream changes
        function validateAndUpdateHop(hopNumber) {
            const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
            if (!hop) return;
            
            // Find the previous hop to check available threads
            const previousHopNumber = hop.hopNumber - 1;
            const availableThreads = getAvailableSourcesForHop(hop.hopNumber, null);
            
            let validationReport = `Validation Report for Hop ${hop.hopNumber}\n\n`;
            let hasIssues = false;
            let fixableIssues = [];
            
            // Check each entry in this hop
            hop.entries.forEach(entry => {
                if (entry.entryType === 'trace') {
                    let entryIssues = [];
                    
                    // Check single source thread
                    if (entry.sourceThreadId) {
                        const threadAvailable = availableThreads.find(t => t.threadId === entry.sourceThreadId);
                        if (!threadAvailable) {
                            entryIssues.push(`Source thread ${entry.sourceThreadId} no longer exists`);
                            hasIssues = true;
                        } else if (threadAvailable.availableAmount < parseAmount(entry.amount)) {
                            entryIssues.push(`Source thread ${entry.sourceThreadId} only has ${threadAvailable.availableAmount} available (needs ${entry.amount})`);
                            hasIssues = true;
                            fixableIssues.push({
                                entryId: entry.id,
                                issue: 'insufficient_amount',
                                currentAmount: parseAmount(entry.amount),
                                availableAmount: threadAvailable.availableAmount
                            });
                        }
                    }
                    
                    // Check multiple source threads
                    if (entry.multipleSourceThreads && entry.multipleSourceThreads.length > 0) {
                        entry.multipleSourceThreads.forEach(threadId => {
                            const threadAvailable = availableThreads.find(t => t.threadId === threadId);
                            if (!threadAvailable) {
                                entryIssues.push(`Source thread ${threadId} no longer exists`);
                                hasIssues = true;
                            }
                        });
                        
                        // Check individual assignments
                        if (entry.individualSourceAssignments) {
                            Object.entries(entry.individualSourceAssignments).forEach(([threadId, amount]) => {
                                const threadAvailable = availableThreads.find(t => t.threadId === threadId);
                                if (threadAvailable && threadAvailable.availableAmount < amount) {
                                    entryIssues.push(`Thread ${threadId} only has ${threadAvailable.availableAmount} available (assigned ${amount})`);
                                    hasIssues = true;
                                }
                            });
                        }
                    }
                    
                    if (entryIssues.length > 0) {
                        validationReport += `Entry ${entry.notation || entry.id}:\n`;
                        entryIssues.forEach(issue => {
                            validationReport += `  • ${issue}\n`;
                        });
                        validationReport += '\n';
                    }
                }
            });
            
            if (!hasIssues) {
                hop.needsValidation = false;
                renderHops();
                saveToStorage();
                alert(`Hop ${hop.hopNumber} validated successfully!\n\nAll source threads are valid and have sufficient amounts.`);
                return;
            }
            
            // Show validation report and options
            validationReport += `\nOptions:\n`;
            validationReport += `1. Manually fix each issue by editing the affected entries\n`;
            validationReport += `2. Auto-adjust amounts to match available threads\n`;
            validationReport += `3. Cancel and leave as-is\n`;
            
            const choice = prompt(validationReport + '\nEnter your choice (1, 2, or 3):');
            
            if (choice === '2') {
                // Auto-adjust amounts
                saveUndoState(`Auto-adjust amounts in Hop ${hop.hopNumber}`);
                
                fixableIssues.forEach(fix => {
                    const entry = hop.entries.find(e => e.id === fix.entryId);
                    if (entry && fix.issue === 'insufficient_amount') {
                        entry.amount = fix.availableAmount.toString();
                    }
                });
                
                hop.needsValidation = false;
                renderHops();
                saveToStorage();
                
                alert(`Hop ${hop.hopNumber} has been auto-adjusted.\n\nAmounts have been reduced to match available thread values.`);
            } else if (choice === '1') {
                // Open hop for manual editing
                reopenHop(hopNumber);
            }
        }
        
        function initializeCompleteIntegration(data = investigation) {
    console.log('Initializing complete integration...');
    
    // Initialize Phase 3 fields if missing
    if (!data.availableThreads) {
        data.availableThreads = {};
    }
    if (!data.threadAssignments) {
        data.threadAssignments = {};
    }
    if (!data.sourceChainData) {
        data.sourceChainData = {};
    }
    if (data.enhancedNotationEnabled === undefined) {
        data.enhancedNotationEnabled = true;
    }
    
    // Initialize Part 4 fields if missing
    if (!data.validationHistory) {
        data.validationHistory = [];
    }
    if (!data.lastValidationTimestamp) {
        data.lastValidationTimestamp = null;
    }
    if (!data.threadValidationErrors) {
        data.threadValidationErrors = [];
    }
    if (!data.sourceChainReports) {
        data.sourceChainReports = [];
    }
    if (!data.integrationVersion) {
        data.integrationVersion = '4.0';
    }
    
    // Initialize standard fields if missing
    if (!data.conversions) {
        data.conversions = [];
    }
    if (!data.redWalletIndex) {
        data.redWalletIndex = [];
    }
    if (!data.universalWalletIndex) {
        data.universalWalletIndex = [];
    }
    if (!data.confirmedRootTotalsByCurrency) {
        data.confirmedRootTotalsByCurrency = {};
    }
    if (!data.currentART) {
        data.currentART = {};
    }
    if (data.rootTotalConfirmed === undefined) {
        data.rootTotalConfirmed = false;
    }
    if (data.confirmedRootTotal === undefined) {
        data.confirmedRootTotal = 0;
    }
    if (!data.created) {
        data.created = new Date().toISOString();
    }
    
    console.log('Complete integration initialized');
}
function handleLoadFile() {
    console.log('Load file button clicked');
    const fileInput = document.getElementById('fileInput');
    if (fileInput) {
        console.log('File input found, triggering click');
        fileInput.click();
    } else {
        console.error('File input element not found');
        alert('Error: File input not found. Please refresh the page and try again.');
    }
}
        function validateEnhancedDataStructure() {
    const errors = [];
    
    if (!investigation.availableThreads) {
        errors.push('Missing availableThreads property');
    }
    if (!investigation.threadAssignments) {
        errors.push('Missing threadAssignments property');
    }
    if (!investigation.sourceChainData) {
        errors.push('Missing sourceChainData property');
    }
    
    investigation.hops.forEach((hop, hopIndex) => {
        hop.entries.forEach((entry, entryIndex) => {
            if (!Array.isArray(entry.sourceChain)) {
                errors.push(`Hop ${hopIndex + 1}, Entry ${entryIndex + 1}: Missing or invalid sourceChain`);
            }
            if (typeof entry.displayNotation !== 'string') {
                errors.push(`Hop ${hopIndex + 1}, Entry ${entryIndex + 1}: Missing displayNotation`);
            }
        });
    });
    
    return errors;
}

function renderHopEntry(entry, hop) {
    const isWriteoff = entry.entryType === 'writeoff';
    const isColdStorage = entry.entryType === 'cold_storage';
    const isTrace = entry.entryType === 'trace';
    
    // Get available source threads for this hop - pass null to get all currencies
    const availableSourceThreads = getAvailableSourcesForHop(entry.hopNumber, null);
    
    // Build source options with real-time amounts
    const sourceOptions = availableSourceThreads.map(source => {
        const dateStr = source.datetime ? 
            ` (${formatDateTimeForReport(source.datetime, source.timezone)})` : '';
        return `<option value="${source.threadId}" 
                ${entry.sourceThreadId === source.threadId ? 'selected' : ''}
                title="${source.displayText}${dateStr}">
            ${source.displayText} - ${source.availableAmount.toLocaleString()} ${source.currency} available${dateStr}
        </option>`;
    }).join('');
    
    // Calculate max amount for input field
    let maxAmount = 0;
    if (entry.multipleSourceThreads && entry.multipleSourceThreads.length > 0) {
        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
        entry.multipleSourceThreads.forEach(sourceId => {
            maxAmount += getMaxAssignableAmount(sourceId, currency);
        });
    } else if (entry.sourceThreadId) {
        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
        maxAmount = getMaxAssignableAmount(entry.sourceThreadId, currency);
    }
    
    // Visual flow indicators
    const isFinalized = entry.isFinalized || false;
    const hasAmount = parseFloat(entry.amount) > 0;
    const hasRequiredData = (isTrace && entry.txHash && entry.fromWallet && entry.toWallet) || 
                           (isWriteoff && hasAmount) || 
                           (isColdStorage && hasAmount);
    
    return `
        <div style="background: ${isFinalized ? '#f0f8ff' : hasRequiredData ? '#f8fdff' : '#fffbf0'}; 
                    border: 2px solid ${isFinalized ? '#4a90e2' : hasRequiredData ? '#5cb85c' : '#f0ad4e'}; 
                    border-left-width: 8px;
                    border-radius: 8px; 
                    padding: 20px; 
                    margin-bottom: 15px; 
                    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
                    position: relative;
                    transition: all 0.3s ease;">
            
            <!-- Flow Arrow Indicator -->
            ${hasRequiredData && isTrace ? `
                <div style="position: absolute; right: -25px; top: 50%; transform: translateY(-50%); 
                            width: 40px; height: 40px; background: #5cb85c; border-radius: 50%;
                            display: flex; align-items: center; justify-content: center;
                            box-shadow: 0 2px 5px rgba(0,0,0,0.2);">
                    <span style="color: white; font-size: 20px;">→</span>
                </div>
            ` : ''}
            
            <div class="trace-header" style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 15px;">
                <div>
                    <div style="display: flex; align-items: center; gap: 10px;">
                        <span class="trace-notation" style="font-size: 18px; font-weight: bold; color: #2c3e50;">
                            ${entry.notation || `Entry ${entry.id}`}
                        </span>
                        <span style="background: ${isWriteoff ? '#9e9e9e' : isColdStorage ? '#3498db' : '#5cb85c'}; 
                                   color: white; 
                                   padding: 4px 12px; 
                                   border-radius: 20px; 
                                   font-size: 12px; 
                                   font-weight: 600;">
                            ${entryTypes[entry.entryType]}
                        </span>
                    </div>
                    
                    <!-- Status Indicators -->
                    <div style="margin-top: 8px; display: flex; gap: 8px; flex-wrap: wrap;">
                        ${hasAmount ? 
                            `<span style="background: #27ae60; color: white; padding: 3px 10px; border-radius: 12px; font-size: 11px; display: inline-flex; align-items: center; gap: 4px;">
                                <span style="font-size: 14px;">✓</span> ${parseFloat(entry.amount).toLocaleString()} ${entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency || ''}
                            </span>` : 
                            `<span style="background: #e74c3c; color: white; padding: 3px 10px; border-radius: 12px; font-size: 11px;">⚠️ No amount</span>`}
                        
                        ${isTrace && entry.txHash ? 
                            `<span style="background: #3498db; color: white; padding: 3px 10px; border-radius: 12px; font-size: 11px;">📋 Tx: ${entry.txHash.substring(0, 8)}...</span>` : ''}
                        
                        ${entry.toWalletType ? 
                            `<span style="background: ${getWalletColor(entry.toWalletType)}; color: white; padding: 3px 10px; border-radius: 12px; font-size: 11px;">
                                ${walletTypes[entry.toWalletType] || entry.toWalletType}
                            </span>` : ''}
                    </div>
                </div>
                <div style="display: flex; gap: 8px;">
                    ${isTrace && !isFinalized ? `<button class="btn btn-primary" onclick="reopenHopWizard(${hop.hopNumber}, ${entry.id})" style="padding: 8px 15px;">🔄 Wizard</button>` : ''}
                    ${hasRequiredData && !isFinalized ? `<button class="btn btn-success" onclick="toggleEntryCollapse('${hop.hopNumber}_${entry.id}')" style="padding: 8px 15px;">✓ Finalize</button>` : ''}
                    <button class="btn btn-danger" onclick="removeHopEntry(${hop.hopNumber}, ${entry.id})" style="padding: 8px 15px;">✕</button>
                </div>
            </div>
            
            ${isTrace ? `
                <div class="form-group" style="background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%); padding: 20px; border-radius: 8px; border: 2px solid #2196f3; margin-bottom: 15px;">
                    <label style="font-weight: bold; color: #0d47a1; font-size: 16px;">Transaction Hash (Start Here)</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <input type="text"
                               id="txHash_${hop.hopNumber}_${entry.id}"
                               value="${entry.txHash || ''}"
                               placeholder="Paste transaction hash to auto-fill details"
                               onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'txHash', this.value)"
                               style="flex: 1; font-size: 16px; padding: 14px; border: 2px solid #2196f3;">
                        <button type="button"
                                class="btn btn-primary"
                                onclick="lookupHopTransaction(${hop.hopNumber}, ${entry.id})"
                                style="background: #2196f3; color: white; padding: 14px 20px; font-size: 16px; font-weight: bold;">
                            🔍 Auto-fill
                        </button>
                    </div>
                    <div style="font-size: 12px; color: #0d47a1; margin-top: 8px;">
                        Enter transaction hash above to automatically populate amount, wallets, and timestamp
                    </div>
                </div>
            ` : ''}
            
            <div class="form-group">
                <label>Entry Type</label>
                <select onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'entryType', this.value)">
                    ${Object.entries(entryTypes).map(([key, value]) => 
                        `<option value="${key}" ${entry.entryType === key ? 'selected' : ''}>${value}</option>`
                    ).join('')}
                </select>
                ${isColdStorage ? `
                    <div style="background: #e8f4f8; border: 1px solid #3498db; border-radius: 4px; padding: 10px; margin-top: 8px; font-size: 12px;">
                        <strong>Cold Storage:</strong> Funds remain in current wallet, classified as BLUE (cold storage). 
                        This accounts for the amount in ART without requiring further tracing.
                    </div>
                ` : ''}
            </div>
            
            ${!isWriteoff ? `
                <div class="form-group">
                    <label>Source Thread Selection ${availableSourceThreads.length > 1 ? '(Multiple allowed)' : ''}</label>
                    ${availableSourceThreads.length > 1 ? `
                        <!-- Multiple Source Thread Selection -->
                        <div style="background: #f8f9fa; border: 1px solid #ddd; border-radius: 4px; padding: 15px;">
                            <div style="margin-bottom: 10px; font-weight: bold;">Select source threads and allocate amounts:</div>
                            ${availableSourceThreads.map(source => {
                                const isSelected = entry.multipleSourceThreads && entry.multipleSourceThreads.includes(source.threadId);
                                const proposedAmount = entry.individualSourceAssignments && entry.individualSourceAssignments[source.threadId] || 0;
                                
                                return `
                                    <div style="margin-bottom: 12px;">
                                        <!-- Source Selection Row -->
                                        <div style="padding: 8px; background: white; border-radius: 3px; border: 1px solid ${isSelected ? '#3498db' : '#ddd'};">
                                            <input type="checkbox" 
                                                value="${source.threadId}" 
                                                ${isSelected ? 'checked' : ''}
                                                onchange="updateMultipleSourceSelection(${hop.hopNumber}, ${entry.id})"
                                                style="margin-right: 10px; vertical-align: middle;"> 
                                            <span style="font-weight: bold; color: #2c3e50;">${source.displayText} - ${source.availableAmount.toLocaleString()} ${source.currency} available</span>
                                        </div>
                                        
                                        <!-- Amount Input Row (only show if selected) -->
                                        ${isSelected ? `
                                            <div style="margin-top: 6px; margin-left: 30px; display: flex; align-items: center; gap: 8px;">
                                                <span style="font-size: 12px; color: #666; min-width: 80px;">Allocate:</span>
                                                <input type="number" 
                                                    step="${getCurrencyStep(source.currency)}" 
                                                    min="0" 
                                                    max="${source.availableAmount}"
                                                    value="${proposedAmount}"
                                                    style="width: 120px; padding: 4px 6px; border: 1px solid #ddd; border-radius: 3px;"
                                                    onchange="updateIndividualSourceAssignment(${hop.hopNumber}, ${entry.id}, '${source.threadId}', this.value)"
                                                    placeholder="0.00">
                                                <button type="button" 
                                                        onclick="assignMaxToIndividualSource(${hop.hopNumber}, ${entry.id}, '${source.threadId}')"
                                                        style="padding: 4px 8px; font-size: 11px; background: #3498db; color: white; border: none; border-radius: 3px; cursor: pointer;">
                                                    Max
                                                </button>
                                                <span style="font-size: 11px; color: #666;">
                                                    (${(source.availableAmount - proposedAmount).toLocaleString()} would remain)
                                                </span>
                                            </div>
                                        ` : ''}
                                    </div>
                                `;
                            }).join('')}
                            
                            <!-- Preview for multiple sources -->
                            <div id="multipleSourcePreview_${hop.hopNumber}_${entry.id}"></div>
                        </div>
                    ` : `
                        <!-- Single Source Thread Selection -->
                        <select id="sourceSelect_${hop.hopNumber}_${entry.id}" 
                                onchange="handleSourceSelection(${hop.hopNumber}, ${entry.id}, this.value)">
                            <option value="">Select source thread...</option>
                            ${sourceOptions}
                        </select>
                        ${entry.sourceThreadId ? `
                            <div style="margin-top: 8px; padding: 10px; background: #e8f4f8; border-radius: 4px;">
                                <strong>Selected:</strong> ${entry.sourceThreadId}<br>
                                <small style="color: #666;">You can allocate any portion of the available amount</small>
                            </div>
                        ` : ''}
                    `}
                </div>
            ` : ''}
            
            ${isTrace && availableSourceThreads.length > 0 ? `
            <!-- Smart Allocation Button -->
            <div class="form-group" style="text-align: center; margin: 20px 0;">
                <button type="button" 
                        class="btn btn-confirm"
                        onclick="openSmartAllocationModal(${hop.hopNumber}, ${entry.id})"
                        style="background: linear-gradient(135deg, #27ae60 0%, #219a52 100%); padding: 12px 30px;">
                    🎯 Smart Amount Allocation - Auto-Calculate Source Usage
                </button>
                <div style="font-size: 11px; color: #666; margin-top: 8px;">
                    ${availableSourceThreads.length > 1 
                        ? `You have ${availableSourceThreads.length} fund sources. This tool helps split the transaction amount across them.`
                        : `Calculate how much of the available ${availableSourceThreads[0]?.availableAmount.toLocaleString()} ${availableSourceThreads[0]?.currency} to use`
                    }
                </div>
                <div style="background: #e8f5e8; border: 1px solid #27ae60; border-radius: 4px; padding: 8px; margin-top: 8px; font-size: 11px;">
                    <strong>💡 When to use:</strong> You know the transaction amount from the blockchain, but need help determining 
                    which victim funds were used. The tool follows FIFO (First In, First Out) to match real blockchain behavior.
                </div>
            </div>
            ` : ''}
            
            <div class="form-group">
                <label>${isWriteoff ? 'Write-off Amount' : isColdStorage ? 'Cold Storage Amount' : 'Trace Amount'}</label>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="number" step="${getCurrencyStep(entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency)}" 
                           id="assignAmount_${hop.hopNumber}_${entry.id}"
                           value="${entry.amount || ''}"
                           max="${maxAmount}"
                           onchange="updateAssignmentAmount(${hop.hopNumber}, ${entry.id}, this.value)">
                    <button type="button" class="btn btn-secondary" 
                            onclick="${isWriteoff ? 'assignMaxWriteoffAmount' : 'assignMaxAmount'}(${hop.hopNumber}, ${entry.id})"
                            ${!isWriteoff && !entry.sourceThreadId ? 'disabled' : ''}>
                        ${isWriteoff ? 'Balance ART' : 'Max'}
                    </button>
                </div>
                <div style="font-size: 11px; color: #666; margin-top: 5px;">
                    ${isWriteoff ? 'Amount to write off from ART' : isColdStorage ? 'Amount remaining in cold storage' : 'Amount to trace forward'}
                    ${!isWriteoff && !isColdStorage && entry.sourceThreadId && maxAmount > 0 ? 
                        `<br><span style="color: #3498db;">💡 You can allocate any amount up to ${maxAmount.toLocaleString()} ${entry.currency || 'units'}</span>` : ''
                    }
                    ${!isWriteoff && entry.sourceThreadId ? 
                        `<br><span style="background: #e8f0fe; padding: 4px 8px; border-radius: 3px; display: inline-block; margin-top: 5px;">
                            <strong>Max button:</strong> Quickly allocates ALL available funds from selected source(s). 
                            Use when you want to trace the entire amount forward.
                        </span>` : ''
                    }
                </div>
                <div id="assignmentPreview_${hop.hopNumber}_${entry.id}" 
                     style="font-size: 12px; margin-top: 5px;"></div>
            </div>

            <div class="form-group">
                <label>Notation Builder</label>
                <div style="display: flex; align-items: center; gap: 5px; font-family: monospace; font-weight: bold;">
                    <span>V</span>
                    <input type="text" style="width: 60px; text-align: center;" 
                           placeholder="1" 
                           value="${entry.victimNumbers || ''}"
                           onchange="updateNotationField(${hop.hopNumber}, ${entry.id}, 'victims', this.value)">
                    <span>-T</span>
                    <input type="text" style="width: 80px; text-align: center;" 
                           placeholder="1,2,3" 
                           value="${entry.transactionNumbers || ''}"
                           onchange="updateNotationField(${hop.hopNumber}, ${entry.id}, 'transactions', this.value)">
                    <span>-H${entry.hopNumber}${isWriteoff ? '-WO' : isColdStorage ? '-CS' : ''}</span>
                </div>
                <div style="font-size: 12px; color: #666; margin-top: 5px;">
                    Preview: <span id="notation_preview_${hop.hopNumber}_${entry.id}" style="font-family: monospace; font-weight: bold;">${entry.notation || 'Enter V and T numbers'}</span>
                </div>
            </div>
            
            <div class="form-group">
                <label>Currency</label>
                <div style="padding: 10px; background: #f8f9fa; border: 1px solid #ddd; border-radius: 4px;">
                    <strong>${entry.currency ? (entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency) : '---'}</strong>
                    ${entry.sourceThreadId ? `
                        <div style="font-size: 11px; color: #666; margin-top: 5px;">
                            Currency inherited from source thread: ${entry.sourceThreadId}
                        </div>
                    ` : `
                        <div style="font-size: 11px; color: #e74c3c; margin-top: 5px;">
                            ⚠️ Select a source thread to set currency
                        </div>
                    `}
                </div>
                ${entry.toWalletType === 'brown' ? `
                    <div style="margin-top: 10px; padding: 10px; background: #fff3cd; border: 1px solid #ffc107; border-radius: 4px;">
                        <strong>Asset Conversion Detected</strong><br>
                        <small>Brown wallet allows currency conversion. Use the conversion modal to change currency.</small>
                    </div>
                ` : ''}
            </div>
            
            ${isTrace ? `
                <div class="form-group">
                    <label>To Wallet Address</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <div class="wallet-autocomplete-container" style="flex: 1;">
                            <input type="text" 
                                   id="toWallet_${hop.hopNumber}_${entry.id}"
                                   value="${entry.toWallet || ''}" 
                                   placeholder="Select existing or enter new wallet address"
                                   onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'toWallet', this.value)"
                                   oninput="handleWalletAutocomplete(this, ${hop.hopNumber}, ${entry.id})"
                                   onblur="checkWalletEntity(this.value, ${hop.hopNumber}, ${entry.id})"
                                   autocomplete="off"
                                   list="walletList_${hop.hopNumber}_${entry.id}"
                                   style="width: 100%;">
                            <div id="autocomplete_${hop.hopNumber}_${entry.id}" class="wallet-autocomplete-dropdown"></div>
                        </div>
                        <datalist id="walletList_${hop.hopNumber}_${entry.id}">
                            ${(investigation.universalWalletIndex || []).map(wallet => `
                                <option value="${wallet.address}">
                                    ${wallet.permanentId} - ${wallet.address.substring(0, 20)}...
                                </option>
                            `).join('')}
                        </datalist>
                        <button type="button" class="btn btn-secondary" style="padding: 6px 12px; font-size: 12px;"
                                onclick="showWalletSelector(${hop.hopNumber}, ${entry.id})">
                            📋 Browse
                        </button>
                    </div>
                    <div style="font-size: 11px; color: #666; margin-top: 5px;">
                        Type to search existing wallets or enter a new address
                    </div>
                    <div id="entityInfo_${hop.hopNumber}_${entry.id}" style="display: none; margin-top: 10px; padding: 10px; background: #f3e6ff; border: 2px solid #9b59b6; border-radius: 4px;">
                        <!-- Entity information will be displayed here -->
                    </div>
                </div>
                <div class="form-group">
                    <label>To Wallet Classification</label>
                    <select onchange="updateHopEntryWalletType(${hop.hopNumber}, ${entry.id}, this.value)">
                        <option value="">Select classification...</option>
                        ${Object.entries(walletTypes).filter(([key]) => key !== 'red').map(([key, value]) => 
                            `<option value="${key}" ${entry.toWalletType === key ? 'selected' : ''}>${value}</option>`
                        ).join('')}
                    </select>
                </div>
                <!-- Transaction hash moved to top of form -->
                <div class="form-group">
                    <label>Timestamp with Timezone</label>
                    <div class="datetime-timezone">
                        <input type="datetime-local" 
                               id="timestamp_${hop.hopNumber}_${entry.id}"
                               value="${entry.timestamp || ''}" 
                               onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'timestamp', this.value)">
                        <select onchange="onTimezoneChange('timestamp_${hop.hopNumber}_${entry.id}', 'hop', ${hop.hopNumber}, ${entry.id})">
                            ${Object.entries(timezones).map(([key, value]) => 
                                `<option value="${key}" ${entry.timezone === key ? 'selected' : ''}>${value}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
            ` : ''}
            
            ${isColdStorage ? `
                <div class="form-group">
                    <label>Current Wallet Address</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <input type="text" 
                               id="toWallet_${hop.hopNumber}_${entry.id}"
                               list="walletList_${hop.hopNumber}_${entry.id}"
                               value="${entry.toWallet || entry.fromWallet || ''}" 
                               placeholder="Select existing or enter new wallet address"
                               onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'toWallet', this.value)"
                               style="flex: 1;">
                        <button type="button" class="btn btn-secondary" style="padding: 6px 12px; font-size: 12px;"
                                onclick="showWalletSelector(${hop.hopNumber}, ${entry.id})">
                            📋 Browse
                        </button>
                    </div>
                    <div style="font-size: 11px; color: #666; margin-top: 5px;">
                        Wallet where ${formatNumber(entry.amount || '0')} ${entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency} remains in cold storage
                    </div>
                </div>
                <div class="form-group">
                    <label>Cold Storage Classification</label>
                    <select onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'toWalletType', this.value)">
                        <option value="blue" ${entry.toWalletType === 'blue' ? 'selected' : ''}>BLUE - Cold Storage</option>
                    </select>
                    <div style="font-size: 11px; color: #666; margin-top: 5px;">
                        Cold storage is automatically classified as BLUE wallet type
                    </div>
                </div>
            ` : ''}
            
            ${isWriteoff ? `
                <div class="form-group">
                    <label>Write-off Category</label>
                    <select onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'category', this.value)">
                        <option value="">Select category...</option>
                        ${Object.entries(writeoffCategories).map(([key, value]) => 
                            `<option value="${key}" ${entry.category === key ? 'selected' : ''}>${value}</option>`
                        ).join('')}
                    </select>
                </div>
                <div class="form-group" style="grid-column: span 2;">
                    <label>Justification</label>
                    <textarea rows="3" placeholder="Detailed explanation for abandoning this trace path..." 
                              onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'justification', this.value)">${entry.justification || ''}</textarea>
                </div>
            ` : isColdStorage ? `
                <div class="form-group" style="grid-column: span 2;">
                    <label>Cold Storage Notes</label>
                    <textarea rows="2" placeholder="Details about why funds remain in cold storage..." 
                              onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'notes', this.value)">${entry.notes || ''}</textarea>
                </div>
            ` : `
                <div class="form-group" style="grid-column: span 2;">
                    <label>Notes</label>
                    <textarea rows="2" placeholder="PIFO application, convergence notes, etc." 
                              onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'notes', this.value)">${entry.notes || ''}</textarea>
                </div>
            `}
            
            <!-- Log Entry Button -->
            <div style="margin-top: 20px; text-align: center; border-top: 2px solid #e8f0fe; padding-top: 20px;">
                <button class="btn btn-confirm" onclick="logAndCollapseEntry(${hop.hopNumber}, ${entry.id})" 
                        style="padding: 12px 30px; font-size: 16px; background: #27ae60;">
                    ✅ Log Entry
                </button>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    This will save and collapse the entry. You can click the header to expand it again.
                </p>
            </div>
        </div>
    `;
}
function initializeEnhancedInvestigation() {
    if (!investigation.availableThreads) {
        investigation.availableThreads = {};
    }
    if (!investigation.threadAssignments) {
        investigation.threadAssignments = {};
    }
    if (!investigation.sourceChainData) {
        investigation.sourceChainData = {};
    }
    if (!investigation.enhancedNotationEnabled) {
        investigation.enhancedNotationEnabled = true;
    }
}

function migrateToEnhancedStructure() {
    initializeEnhancedInvestigation();
    
    investigation.hops.forEach(hop => {
        hop.entries.forEach(entry => {
            if (!entry.sourceChain) entry.sourceChain = [];
            if (!entry.displayNotation) entry.displayNotation = '';
            if (!entry.summaryNotation) entry.summaryNotation = '';
            if (!entry.victimNumbers) entry.victimNumbers = '';
            if (!entry.transactionNumbers) entry.transactionNumbers = '';
            if (!entry.availableSourceAmount) entry.availableSourceAmount = 0;
            if (!entry.sourceThreadId) entry.sourceThreadId = '';
            if (!entry.sourceThreadData) entry.sourceThreadData = null;
            if (!entry.assignmentPercentage) entry.assignmentPercentage = 0;
            if (!entry.generatedNotation) entry.generatedNotation = '';
            if (entry.isConvergence === undefined) entry.isConvergence = false;
            if (!entry.convergenceData) entry.convergenceData = null;
        });
    });
    
    console.log('Investigation migrated to enhanced structure');
    saveToStorage();
}
// =================================
// PHASE 2: CORE THREAD TRACKING FUNCTIONS
// =================================

// Generate unique internal ID for threads
function generateInternalThreadId(notation, currency, forceUnique = false) {
    // For bridge outputs and swaps, we want deterministic IDs based on notation
    // so that multiple bridge outputs with same notation update the same thread
    if (forceUnique) {
        // Original behavior for when we truly need unique IDs
        const timestamp = Date.now();
        const random = Math.random().toString(36).substring(2, 8);
        return `${notation}_${currency}_${timestamp}_${random}`;
    } else {
        // Deterministic ID based on notation and currency only
        // This allows bridge outputs to find and update existing threads
        return `${notation}_${currency}`;
    }
}

// Check if we're using the legacy system (threads indexed by notation)
function isLegacyThreadSystem() {
    if (!investigation.availableThreads) return false;

    // Check if any thread lacks internalId - indicates legacy system
    for (const currency in investigation.availableThreads) {
        for (const key in investigation.availableThreads[currency]) {
            const thread = investigation.availableThreads[currency][key];
            if (!thread.internalId) return true;
        }
    }
    return false;
}

// Migrate from legacy notation-based system to dual-layer system
function migrateThreadsToDualLayer() {
    if (!isLegacyThreadSystem()) {
        console.log('Already using dual-layer system');
        return;
    }

    console.log('Migrating to dual-layer thread system...');
    const newThreads = {};

    // Migrate existing threads
    for (const currency in investigation.availableThreads) {
        newThreads[currency] = {};

        for (const notation in investigation.availableThreads[currency]) {
            const thread = investigation.availableThreads[currency][notation];

            // Generate internal ID if missing
            if (!thread.internalId) {
                thread.internalId = generateInternalThreadId(notation, currency);
                thread.notation = notation;
            }

            // Re-index by internal ID
            newThreads[currency][thread.internalId] = thread;
        }
    }

    investigation.availableThreads = newThreads;
    console.log('Thread migration complete');
}

// Consolidate duplicate threads with the same notation
function consolidateDuplicateThreads() {
    if (!investigation.availableThreads) return 0;

    console.log('Consolidating duplicate threads...');
    let duplicatesFound = 0;

    for (const currency in investigation.availableThreads) {
        const threads = investigation.availableThreads[currency];
        const threadsByNotation = {};
        const threadsToDelete = [];

        // Group threads by notation
        for (const threadId in threads) {
            const thread = threads[threadId];
            if (!thread.notation) continue;

            if (!threadsByNotation[thread.notation]) {
                threadsByNotation[thread.notation] = [];
            }
            threadsByNotation[thread.notation].push({ id: threadId, thread });
        }

        // Consolidate duplicates
        for (const notation in threadsByNotation) {
            const duplicates = threadsByNotation[notation];
            if (duplicates.length > 1) {
                console.log(`Found ${duplicates.length} threads with notation ${notation} in ${currency}`);
                duplicatesFound += duplicates.length - 1;

                // Keep the thread with highest amount or most recent
                let keepThread = duplicates[0];
                for (let i = 1; i < duplicates.length; i++) {
                    if (duplicates[i].thread.totalAmount > keepThread.thread.totalAmount) {
                        threadsToDelete.push(keepThread.id);
                        keepThread = duplicates[i];
                    } else {
                        threadsToDelete.push(duplicates[i].id);
                    }
                }

                // Update the kept thread to use deterministic ID
                const deterministicId = generateInternalThreadId(notation, currency, false);
                if (keepThread.id !== deterministicId) {
                    threads[deterministicId] = keepThread.thread;
                    keepThread.thread.internalId = deterministicId;
                    threadsToDelete.push(keepThread.id);
                }
            }
        }

        // Delete duplicate threads
        for (const threadId of threadsToDelete) {
            delete threads[threadId];
        }
    }

    if (duplicatesFound > 0) {
        console.log(`Consolidated ${duplicatesFound} duplicate threads`);
        showNotification(`✅ Consolidated ${duplicatesFound} duplicate threads`, 'success', 3000);
    }

    return duplicatesFound;
}

// Helper function to get thread by notation
function getThreadByNotation(notation) {
    if (!notation || !investigation.availableThreads) return null;

    // Search through all currencies
    for (const currency in investigation.availableThreads) {
        for (const threadId in investigation.availableThreads[currency]) {
            const thread = investigation.availableThreads[currency][threadId];
            if (thread.notation === notation) {
                return thread;
            }
        }
    }

    return null;
}

// 2.1 Build Available Threads Index
function buildAvailableThreadsIndex() {
    // Check if we need to migrate existing data
    if (investigation.availableThreads && isLegacyThreadSystem()) {
        migrateThreadsToDualLayer();
        // After migration, the existing threads are preserved, so return
        // The rest of the function only needs to run if we're rebuilding from scratch
        return;
    }

    // CRITICAL FIX: Preserve manually created swap and bridge output threads
    // Store existing swap/bridge output threads before rebuilding
    const existingSwapOutputs = {};
    if (investigation.availableThreads) {
        for (const currency in investigation.availableThreads) {
            for (const threadKey in investigation.availableThreads[currency]) {
                const thread = investigation.availableThreads[currency][threadKey];
                // Preserve swap output threads and bridge output threads that were manually created
                if (thread.sourceType === 'swap_output' || thread.swapConverted ||
                    thread.sourceType === 'bridge_output' || thread.bridgeConverted) {
                    if (!existingSwapOutputs[currency]) {
                        existingSwapOutputs[currency] = {};
                    }
                    existingSwapOutputs[currency][threadKey] = thread;
                }
            }
        }
    }

    investigation.availableThreads = {};

    // Restore preserved swap output threads
    for (const currency in existingSwapOutputs) {
        if (!investigation.availableThreads[currency]) {
            investigation.availableThreads[currency] = {};
        }
        for (const threadKey in existingSwapOutputs[currency]) {
            investigation.availableThreads[currency][threadKey] = existingSwapOutputs[currency][threadKey];
        }
    }

    // Start with ALL victim transactions (RED wallets) from ALL victims
    investigation.victims.forEach(victim => {
        victim.transactions.forEach(transaction => {
            if (parseFloat(transaction.amount) > 0 && transaction.receivingWallet) {
                const currency = transaction.currency === 'CUSTOM' ?
                    transaction.customCurrency : transaction.currency;
                const notation = `V${victim.id}-T${transaction.id}`;
                const internalId = generateInternalThreadId(notation, currency);

                if (!investigation.availableThreads[currency]) {
                    investigation.availableThreads[currency] = {};
                }

                // Index by internal ID, but store notation for display
                investigation.availableThreads[currency][internalId] = {
                    // Dual-layer tracking
                    notation: notation,              // Human-readable (V-T-H)
                    internalId: internalId,          // Unique identifier

                    // Standard fields
                    totalAmount: roundAmount(parseFloat(transaction.amount)),
                    availableAmount: roundAmount(parseFloat(transaction.amount)),
                    assignments: [],
                    sourceWallet: transaction.receivingWallet,
                    sourceType: 'victim_transaction',
                    hopLevel: 0,
                    createdAt: transaction.datetime || new Date().toISOString(),
                    isActive: true,
                    parentThreads: [],
                    childThreads: [],
                    currency: currency,
                    victimId: victim.id,
                    transactionId: transaction.id,

                    // Chain tracking - store blockchain info internally
                    chainId: transaction.chain || null,  // Store the blockchain type
                    chainName: transaction.chain ? (window.blockchainAPIs?.[transaction.chain]?.name || transaction.chain) : null
                };
            }
        });
    });
    
    // First, collect ALL swapped thread IDs across ALL hops (global)
    const globalSwappedThreadIds = new Set();
    investigation.hops.forEach(hop => {
        hop.entries.forEach(entry => {
            if (entry.entryType === 'swap') {
                if (entry.sourceThreadId) {
                    globalSwappedThreadIds.add(entry.sourceThreadId);
                } else if (entry.multipleSourceThreads) {
                    entry.multipleSourceThreads.forEach(id => globalSwappedThreadIds.add(id));
                }
            }
        });
    });

    // Process ALL hop entries to update available threads
    investigation.hops.forEach(hop => {
        // Also collect swapped thread IDs within this hop (for backward compatibility)
        const swappedThreadIds = new Set();
        hop.entries.forEach(entry => {
            if (entry.entryType === 'swap') {
                if (entry.sourceThreadId) {
                    swappedThreadIds.add(entry.sourceThreadId);
                } else if (entry.multipleSourceThreads) {
                    entry.multipleSourceThreads.forEach(id => swappedThreadIds.add(id));
                }
            }
        });

        // IMPORTANT: Process swaps FIRST, then traces
        // This ensures swaps replace threads before traces try to use them

        // First pass: Process all swaps to update thread currencies
        hop.entries.forEach(entry => {
            if (entry.entryType === 'swap' && entry.swapDetails) {
                // Check if this swap has already been processed
                if (!entry._swapProcessed) {
                    // For swap entries, we need to handle the currency conversion
                    // The output replaces the input thread with new currency
                    console.log(`Processing swap entry in hop ${hop.hopNumber}:`, entry);
                    // Make sure the entry has the hop number
                    if (!entry.hopNumber) {
                        entry.hopNumber = hop.hopNumber;
                    }
                    updateThreadAvailabilityFromSwap(entry);
                    // Mark as processed to prevent duplicate processing
                    entry._swapProcessed = true;
                } else {
                    console.log('Skipping already processed swap entry:', entry.id);
                }
            }
        });

        // Second pass: Process traces and change entries (after swaps have updated threads)
        hop.entries.forEach(entry => {
            // Handle change entries - create same-hop threads
            if (entry.entryType === 'change' && parseFloat(entry.amount) > 0 && entry.notation) {
                console.log(`Processing change entry: ${entry.notation} with ${entry.amount} ${entry.currency}`);

                // Change entries create threads at the SAME hop level (like swaps)
                // They consume the source thread and create a new thread available for the current hop
                const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;

                if (!investigation.availableThreads[currency]) {
                    investigation.availableThreads[currency] = {};
                }

                // Generate internal ID for the change thread
                const newInternalId = generateInternalThreadId(entry.notation, currency);

                // Inherit chain from parent threads if not set on entry
                let chainId = entry.chain || null;
                let chainName = entry.chain ? (window.blockchainAPIs?.[entry.chain]?.name || entry.chain) : null;

                if (!chainId) {
                    // Try to inherit from parent threads
                    const parentIds = entry.multipleSourceInternalIds || [entry.sourceThreadInternalId];
                    for (const parentId of parentIds) {
                        // Look through all currencies for parent thread
                        for (const curr in investigation.availableThreads) {
                            const parentThread = investigation.availableThreads[curr]?.[parentId];
                            if (parentThread && parentThread.chainId) {
                                chainId = parentThread.chainId;
                                chainName = parentThread.chainName;
                                console.log(`Change entry inherited chain ${chainId} from parent thread`);
                                break;
                            }
                        }
                        if (chainId) break;
                    }
                }

                // Create the change thread at the same hop level
                investigation.availableThreads[currency][newInternalId] = {
                    notation: entry.notation,
                    internalId: newInternalId,
                    totalAmount: roundAmount(parseFloat(entry.amount)),
                    availableAmount: roundAmount(parseFloat(entry.amount)),
                    assignments: [],
                    sourceWallet: entry.toWallet,
                    sourceType: 'change_output',
                    hopLevel: hop.hopNumber - 1, // Same hop level as source
                    createdAt: entry.timestamp || new Date().toISOString(),
                    isActive: true,
                    currency: currency,
                    isChange: true,
                    parentInternalIds: entry.multipleSourceInternalIds || [entry.sourceThreadInternalId],
                    parentNotations: entry.multipleSourceThreads || [entry.sourceThreadId],

                    // Chain tracking - inherit from entry or parent
                    chainId: chainId,
                    chainName: chainName
                };

                console.log(`Created change thread ${entry.notation} in ${currency} with ${entry.amount} at hop level ${hop.hopNumber - 1}`);
            }
            // Handle regular trace entries
            else if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0 && entry.notation) {
                // Don't create thread if this trace has been swapped (check both local and global)
                if (!swappedThreadIds.has(entry.notation) && !globalSwappedThreadIds.has(entry.notation)) {
                    // Don't create output threads for terminal wallets (purple, gray, blue) UNLESS they're bridges
                    const isTerminal = (entry.toWalletType === 'purple' && !entry.isBridge) ||
                                     entry.toWalletType === 'gray' ||
                                     entry.toWalletType === 'blue' ||
                                     (entry.isTerminalWallet === true && !entry.isBridge);

                    if (isTerminal) {
                        console.log(`Skipping thread creation for terminal wallet (${entry.toWalletType}): ${entry.notation}`);

                        // For terminal wallets, deduct the allocated amounts from source threads
                        // Only mark as fully exhausted if the entire thread was actually used
                        if (entry.individualSourceAssignments && typeof entry.individualSourceAssignments === 'object') {
                            Object.entries(entry.individualSourceAssignments).forEach(([threadId, allocatedAmount]) => {
                                // Find the thread and deduct the allocated amount
                                for (const currency in investigation.availableThreads) {
                                    const thread = investigation.availableThreads[currency][threadId];
                                    if (thread) {
                                        const amountUsed = parseFloat(allocatedAmount) || 0;
                                        console.log(`Terminal wallet: Deducting ${amountUsed} from thread ${threadId} (had ${thread.availableAmount} available)`);

                                        // Use proper rounding to avoid floating point errors
                                        thread.availableAmount = roundAmount(Math.max(0, thread.availableAmount - amountUsed));

                                        // Only mark as fully exhausted if less than 0.01 remains
                                        if (thread.availableAmount < 0.01) {
                                            thread.availableAmount = 0;
                                            thread.fullyExhausted = true;
                                            thread.exhaustedByTerminal = entry.notation;
                                            console.log(`Thread ${threadId} fully exhausted by terminal wallet`);
                                        } else {
                                            console.log(`Thread ${threadId} has ${thread.availableAmount} remaining after terminal wallet`);
                                        }
                                    }
                                }
                            });
                        }
                    } else {
                        // updateThreadAvailabilityFromHop will handle bridge output check internally
                        updateThreadAvailabilityFromHop(entry);
                    }
                } else {
                    console.log(`Skipping thread creation for swapped trace: ${entry.notation}`);
                }
            }
        });
    });

    console.log('Available threads index built for ALL victims:', investigation.availableThreads);

    // Note: We don't consolidate threads anymore as bridge outputs can have same notation
}

// 2.2 Update Thread Availability from Hop Entry
function updateThreadAvailabilityFromHop(entry) {
    // CRITICAL FIX: Don't create threads for bridge entries that have already been logged
    // Bridge outputs are created manually in confirmBridgeOutput with the converted currency
    if (entry.isBridge && entry.bridgeOutputLogged && entry.bridgeDetails) {
        console.log(`Skipping thread creation for logged bridge entry: ${entry.notation} (output thread already created in ${entry.bridgeDetails.destinationAsset})`);
        return;
    }

    // Skip terminal wallets - they don't create output threads (UNLESS they're unlogged bridges)
    if ((entry.toWalletType === 'purple' && !entry.isBridge) ||
        entry.toWalletType === 'gray' ||
        entry.toWalletType === 'blue' ||
        (entry.isTerminalWallet && !entry.isBridge)) {
        console.log(`Not creating output thread for terminal wallet entry: ${entry.notation}`);
        return;
    }

    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    const amount = parseFloat(entry.amount);

    if (!investigation.availableThreads[currency]) {
        investigation.availableThreads[currency] = {};
    }

    // Create internal ID for this new thread
    const notation = entry.notation;
    const internalId = generateInternalThreadId(notation, currency);

    // Try to get chain info - for bridges use destination chain, otherwise use entry chain or inherit
    let chainId = entry.chain || null;
    let chainName = entry.chain ? (window.blockchainAPIs?.[entry.chain]?.name || entry.chain) : null;

    // If this is a bridge entry, use the destination chain
    if (entry.isBridge && entry.bridgeDetails?.destinationChain) {
        chainId = entry.bridgeDetails.destinationChain;
        chainName = window.blockchainAPIs?.[chainId]?.name || chainId;
        console.log(`Using bridge destination chain: ${chainId}`);
    } else if (!chainId) {
        // Try to inherit from parent threads
        const parentIds = entry.sourceThreadInternalId ? [entry.sourceThreadInternalId] :
                         (entry.multipleSourceInternalIds || []);
        for (const parentId of parentIds) {
            // Look through all currencies for parent thread
            for (const curr in investigation.availableThreads) {
                const parentThread = investigation.availableThreads[curr]?.[parentId];
                if (parentThread && parentThread.chainId) {
                    chainId = parentThread.chainId;
                    chainName = parentThread.chainName;
                    console.log(`Inherited chain ${chainId} from parent thread ${parentId}`);
                    break;
                }
            }
            if (chainId) break;
        }
    }

    investigation.availableThreads[currency][internalId] = {
        // Dual-layer tracking
        notation: notation,                 // Human-readable
        internalId: internalId,            // Unique identifier

        // Standard fields
        totalAmount: roundAmount(amount),
        availableAmount: roundAmount(amount),  // This thread's full amount is available
        assignments: [],
        sourceWallet: entry.toWallet,
        sourceType: 'hop_output',
        hopLevel: entry.hopNumber,
        createdAt: entry.timestamp || new Date().toISOString(),
        isActive: true,
        parentInternalIds: entry.sourceThreadInternalId ? [entry.sourceThreadInternalId] :
                          (entry.multipleSourceInternalIds || []),
        childThreads: [],
        currency: currency,

        // Chain tracking - inherit from entry or parent
        chainId: chainId,
        chainName: chainName
    };

    // Don't modify availableAmount - getMaxAssignableAmount calculates it dynamically based on assignments
}

// Handle swap entries to create threads with the output currency
function updateThreadAvailabilityFromSwap(entry) {
    const inputCurrency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    // Fix: Get output currency and amount from swapDetails
    const outputCurrency = entry.swapDetails?.toCurrency || entry.outputCurrency;
    const inputAmount = parseFloat(entry.amount);
    const outputAmount = parseFloat(entry.swapDetails?.toAmount || entry.outputAmount || 0);

    console.log(`Processing swap: ${inputAmount} ${inputCurrency} → ${outputAmount} ${outputCurrency}`);
    console.log(`Swap entry details:`, entry);

    if (!outputCurrency || !outputAmount) {
        console.error('Swap is missing output currency or amount!');
        console.log('Entry swapDetails:', entry.swapDetails);
        return;
    }

    // For dual-layer: Get internal IDs of source threads
    const sourceInternalIds = entry.sourceThreadInternalId ? [entry.sourceThreadInternalId] :
                             (entry.multipleSourceInternalIds || []);

    // Also get notation for backward compatibility
    const sourceNotations = entry.sourceThreadId ? [entry.sourceThreadId] :
                           (entry.multipleSourceThreads || []);

    if (sourceInternalIds.length === 0 && sourceNotations.length === 0) {
        console.error('No source threads found for swap');
        return;
    }

    // Find ALL threads that match our source notations/IDs in the input currency
    let threadsToProcess = [];
    let totalAvailableInput = 0;

    // Search by both internal ID and notation
    if (investigation.availableThreads[inputCurrency]) {
        for (const key in investigation.availableThreads[inputCurrency]) {
            const thread = investigation.availableThreads[inputCurrency][key];

            // Check if this thread matches any of our source threads
            let isMatch = false;
            let matchedNotation = null;

            // Check by internal ID
            if (sourceInternalIds.includes(key) || sourceInternalIds.includes(thread.internalId)) {
                isMatch = true;
                matchedNotation = thread.notation || sourceNotations[0];
            }
            // Check by notation
            else if (sourceNotations.includes(thread.notation) || sourceNotations.includes(key)) {
                isMatch = true;
                matchedNotation = thread.notation || sourceNotations[0];
            }
            // Legacy check - key might be the notation itself
            else if (sourceNotations.some(n => key.includes(n))) {
                isMatch = true;
                matchedNotation = sourceNotations.find(n => key.includes(n));
            }

            if (isMatch) {
                const available = thread.totalAmount; // Use total amount for swaps
                console.log(`Found matching thread: ${key} with ${available} ${inputCurrency}`);

                threadsToProcess.push({
                    key: key,
                    internalId: thread.internalId || key,
                    notation: matchedNotation || thread.notation || key,
                    thread: thread,
                    available: available
                });
                totalAvailableInput += available;
            }
        }
    }

    if (threadsToProcess.length === 0) {
        console.error(`No threads found in ${inputCurrency} for swap. Looking for:`, sourceNotations);
        return;
    }

    // Determine if this is a partial swap
    const isPartialSwap = totalAvailableInput > inputAmount;

    if (isPartialSwap) {
        console.log(`Partial swap: Using ${inputAmount} of ${totalAvailableInput} ${inputCurrency}`);

        // For partial swaps, keep remainder in original currency
        threadsToProcess.forEach(item => {
            const consumedRatio = inputAmount / totalAvailableInput;
            const consumedAmount = item.available * consumedRatio;
            const remainingAmount = item.available - consumedAmount;

            if (remainingAmount > 0.01) { // Keep if more than dust
                item.thread.totalAmount = remainingAmount;
                item.thread.availableAmount = remainingAmount;
                console.log(`Thread ${item.notation} keeps ${remainingAmount} ${inputCurrency}`);
            } else {
                // Remove if dust amount
                delete investigation.availableThreads[inputCurrency][item.key];
                console.log(`Removed thread ${item.key} from ${inputCurrency} (dust)`);
            }
        });
    } else {
        // Full swap - remove ALL matching threads from input currency
        threadsToProcess.forEach(item => {
            delete investigation.availableThreads[inputCurrency][item.key];
            console.log(`Removed thread ${item.key} from ${inputCurrency}`);
        });
    }

    // Create thread(s) in output currency
    if (outputAmount > 0) {
        if (!investigation.availableThreads[outputCurrency]) {
            investigation.availableThreads[outputCurrency] = {};
        }

        // Create output threads with same notation
        threadsToProcess.forEach(item => {
            const notation = item.notation;

            // Check if this swap output already exists (prevent duplicates)
            let existingOutputThread = null;
            for (const key in investigation.availableThreads[outputCurrency]) {
                const thread = investigation.availableThreads[outputCurrency][key];
                if (thread.notation === notation && thread.sourceType === 'swap_output') {
                    existingOutputThread = { key, thread };
                    console.log(`Swap output thread ${notation} already exists in ${outputCurrency}, skipping creation`);
                    break;
                }
            }

            // If thread already exists, skip creation
            if (existingOutputThread) {
                console.log(`Skipping duplicate swap output creation for ${notation} in ${outputCurrency}`);
                return;
            }

            const newInternalId = generateInternalThreadId(notation, outputCurrency);

            // Calculate proportional output for this thread
            const outputPortion = outputAmount * (item.available / totalAvailableInput);

            investigation.availableThreads[outputCurrency][newInternalId] = {
                // Dual-layer identifiers
                notation: notation,
                internalId: newInternalId,

                // Amounts
                totalAmount: roundAmount(outputPortion),
                availableAmount: roundAmount(outputPortion),

                // Tracking
                assignments: [],
                sourceWallet: entry.toWallet || entry.swapDetails?.dexAddress || '',
                sourceType: 'swap_output',
                hopLevel: entry.hopNumber || 1,
                createdAt: entry.timestamp || new Date().toISOString(),
                isActive: true,

                // Parent tracking
                parentInternalIds: [item.internalId],
                parentNotations: [item.notation],

                // Currency and swap details
                currency: outputCurrency,
                swapDetails: {
                    fromCurrency: inputCurrency,
                    fromAmount: item.available,
                    toCurrency: outputCurrency,
                    toAmount: outputPortion,
                    provider: entry.swapDetails?.providerName || 'Unknown',
                    isPartial: isPartialSwap
                },

                // Chain tracking for bridges/swaps
                // If this is a bridge, the chain changes. Otherwise inherit from parent
                chainId: entry.swapDetails?.toChain || entry.chain || item.thread.chainId || null,
                chainName: entry.swapDetails?.toChain ?
                    (window.blockchainAPIs?.[entry.swapDetails.toChain]?.name || entry.swapDetails.toChain) :
                    (entry.chain ? (window.blockchainAPIs?.[entry.chain]?.name || entry.chain) :
                     (item.thread.chainId ? (window.blockchainAPIs?.[item.thread.chainId]?.name || item.thread.chainId) : null))
            };

            console.log(`✅ Created swap output thread ${notation} in ${outputCurrency}: ${outputPortion} (ID: ${newInternalId})`);
            console.log(`Thread details:`, investigation.availableThreads[outputCurrency][newInternalId]);
        });
    }

    console.log('Swap thread conversion complete');
}

// Universal threads database is the single source of truth

function getAvailableSourcesForHop(hopNumber, targetCurrency) {
    console.log(` Getting available sources for Hop ${hopNumber}, Currency filter: ${targetCurrency || 'ALL'}`);

    // Ensure the threads database is up to date
    buildAvailableThreadsIndex();

    console.log('Available threads database:', investigation.availableThreads);

    const availableSources = [];

    // Simply consult the universal threads database
    for (const currency in investigation.availableThreads) {
        // Skip if filtering by currency and this doesn't match
        if (targetCurrency && currency !== targetCurrency) continue;

        for (const threadKey in investigation.availableThreads[currency]) {
            const thread = investigation.availableThreads[currency][threadKey];

            // Filter by hop level appropriately
            if (hopNumber === 1) {
                // Hop 1: Show victim threads AND same-hop conversions (swap/bridge outputs)
                if (thread.sourceType !== 'victim_transaction' &&
                    thread.sourceType !== 'swap_output' &&
                    thread.sourceType !== 'bridge_output' &&
                    thread.sourceType !== 'change_output') {
                    continue;
                }
                // For conversion outputs, only show if they're from hop 1
                if ((thread.sourceType === 'swap_output' ||
                     thread.sourceType === 'bridge_output' ||
                     thread.sourceType === 'change_output') &&
                    thread.hopLevel !== 1 && thread.hopLevel !== 0) {
                    continue;
                }
            } else {
                // Other hops: Show threads from previous hop or same-hop conversions
                // Exclude victim threads
                if (thread.sourceType === 'victim_transaction') continue;

                // Check hop level - should be from previous hop or same hop (for swaps/bridges)
                const expectedHopLevel = hopNumber - 1;
                if (thread.hopLevel !== expectedHopLevel && thread.hopLevel !== hopNumber) {
                    // Skip unless it's a same-hop conversion (swap/bridge/change)
                    if (thread.sourceType !== 'swap_output' &&
                        thread.sourceType !== 'bridge_output' &&
                        thread.sourceType !== 'change_output') {
                        continue;
                    }
                }
            }

            // Calculate available amount using internal ID or notation
            const availableAmount = getMaxAssignableAmount(
                thread.internalId || threadKey,
                currency
            );

            // Only include threads with available amount
            if (availableAmount > 0) {
                // Use notation for display, internal ID for tracking
                const notation = thread.notation || threadKey;
                let displayText = notation;
                if (thread.sourceType === 'victim_transaction') {
                    displayText = `${notation} (RED Wallet)`;
                } else if (thread.sourceType === 'bridge_output') {
                    displayText = `${notation} (Bridge Output - ${currency})`;
                } else if (thread.sourceType === 'swap_output') {
                    displayText = `${notation} (Swap Output - ${currency})`;
                } else if (thread.sourceType === 'change_output') {
                    displayText = `${notation} (Change - ${currency})`;
                }

                availableSources.push({
                    // Dual-layer support
                    threadId: notation,  // For backward compatibility and display
                    internalId: thread.internalId || threadKey,  // For precise tracking

                    // Display and metadata
                    displayText: displayText,
                    availableAmount: availableAmount,
                    currency: currency,
                    sourceWallet: thread.sourceWallet,
                    sourceType: thread.sourceType || 'hop_output',
                    hopLevel: thread.hopLevel || 0,
                    datetime: thread.createdAt || null,
                    timezone: 'UTC',

                    // Chain information for transaction lookups
                    chainId: thread.chainId || null,
                    chainName: thread.chainName || null
                });
            }
        }
    }

    console.log(` Final available sources from database (${availableSources.length}):`, availableSources);

    // Sort by notation for consistent display
    return availableSources.sort((a, b) => a.threadId.localeCompare(b.threadId));
}

// DEPRECATED - Complex hop traversal logic - replaced by database approach
function getAvailableSourcesForHop_OLD(hopNumber, targetCurrency) {
    console.log('DEPRECATED FUNCTION CALLED');

    const availableSources = [];

    if (hopNumber === 1) {
        // First hop: ALL victim transactions (RED wallets) from ALL victims, ALL currencies
        console.log(`📋 Checking ${investigation.victims.length} victims for available transactions`);
        
        investigation.victims.forEach(victim => {
            victim.transactions.forEach(transaction => {
                console.log(`Checking V${victim.id}-T${transaction.id}: Amount=${transaction.amount}, Wallet=${transaction.receivingWallet}, Currency=${transaction.currency}`);
                
                if (parseFloat(transaction.amount) > 0 && transaction.receivingWallet && transaction.receivingWallet.trim() !== '') {
                    const currency = transaction.currency === 'CUSTOM' ? transaction.customCurrency : transaction.currency;
                    
                    console.log(`Transaction currency: ${currency}, Target filter: ${targetCurrency || 'NONE'}`);
                    
                    // Only filter by currency if targetCurrency is specified
                    if (!targetCurrency || currency === targetCurrency) {
                        const threadId = `V${victim.id}-T${transaction.id}`;
                        
                        // Use the REAL-TIME availability calculation
                        const currentAvailable = getMaxAssignableAmount(threadId, currency);
                        
                        console.log(`Thread ${threadId}: Available ${currentAvailable} ${currency} from real-time calculation`);
                        
                        if (currentAvailable > 0) {
                            const source = {
                                threadId: threadId,
                                displayText: `${threadId} (RED Wallet)`,
                                availableAmount: currentAvailable,
                                currency: currency, // ENSURE CURRENCY IS INCLUDED
                                sourceWallet: transaction.receivingWallet,
                                sourceType: 'victim_transaction',
                                hopLevel: 0,
                                datetime: transaction.datetime || null,
                                timezone: transaction.timezone || 'UTC'
                            };
                            
                            console.log(` Adding source:`, source);
                            availableSources.push(source);
                        } else {
                            console.log(` Skipping ${threadId}: No availability remaining`);
                        }
                    }
                }
            });
        });
    } else {
        // Subsequent hops: Check both previous hop outputs AND current hop swaps
        const previousHopNumber = hopNumber - 1;
        console.log(`📋 Checking hops for available sources (previous: ${previousHopNumber}, current: ${hopNumber})`);

        // First, collect ALL swapped thread IDs across relevant hops
        const globalSwappedThreadIds = new Set();
        investigation.hops.forEach(hop => {
            if (hop.hopNumber === previousHopNumber || hop.hopNumber === hopNumber) {
                hop.entries.forEach(entry => {
                    if (entry.entryType === 'swap') {
                        if (entry.sourceThreadId) {
                            globalSwappedThreadIds.add(entry.sourceThreadId);
                        } else if (entry.multipleSourceThreads) {
                            entry.multipleSourceThreads.forEach(id => globalSwappedThreadIds.add(id));
                        }
                    }
                });
            }
        });

        // Process previous hop entries
        investigation.hops.forEach(hop => {
            if (hop.hopNumber === previousHopNumber) {
                console.log(`Processing previous hop ${previousHopNumber} entries`);

                hop.entries.forEach(entry => {
                    if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0 && entry.notation) {
                        // Skip this trace entry if it's been swapped
                        if (globalSwappedThreadIds.has(entry.notation)) {
                            console.log(`Skipping trace thread ${entry.notation} - has been swapped`);
                            return;
                        }

                        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;

                        if (!targetCurrency || currency === targetCurrency) {
                            const threadId = entry.notation;
                            const currentAvailable = getMaxAssignableAmount(threadId, currency);

                            if (currentAvailable > 0) {
                                availableSources.push({
                                    threadId: threadId,
                                    displayText: `${threadId}`,
                                    availableAmount: currentAvailable,
                                    currency: currency,
                                    sourceWallet: entry.toWallet,
                                    sourceType: 'hop_output',
                                    hopLevel: previousHopNumber,
                                    datetime: entry.timestamp || null,
                                    timezone: entry.timezone || 'UTC'
                                });
                            }
                        }
                    } else if (entry.entryType === 'swap' && entry.outputAmount && parseFloat(entry.outputAmount) > 0 && entry.notation) {
                        // Handle swap entries from previous hop
                        const currency = entry.outputCurrency;

                        if (!targetCurrency || currency === targetCurrency) {
                            const threadId = entry.notation;
                            const currentAvailable = getMaxAssignableAmount(threadId, currency);

                            if (currentAvailable > 0) {
                                availableSources.push({
                                    threadId: threadId,
                                    displayText: `${threadId} (swapped to ${currency})`,
                                    availableAmount: currentAvailable,
                                    currency: currency,
                                    sourceWallet: entry.toWallet,
                                    sourceType: 'swap_output',
                                    hopLevel: previousHopNumber,
                                    datetime: entry.timestamp || null,
                                    timezone: entry.timezone || 'UTC'
                                });
                            }
                        }
                    }
                });
            }

            // ALSO check current hop for swap outputs (same-hop swaps)
            if (hop.hopNumber === hopNumber) {
                console.log(`Checking current hop ${hopNumber} for swap outputs`);

                hop.entries.forEach(entry => {
                    if (entry.entryType === 'swap' && entry.outputAmount && parseFloat(entry.outputAmount) > 0 && entry.notation) {
                        const currency = entry.outputCurrency;
                        console.log(`Found swap in current hop: ${entry.notation} with ${entry.outputAmount} ${currency}`);

                        if (!targetCurrency || currency === targetCurrency) {
                            const threadId = entry.notation;
                            const currentAvailable = getMaxAssignableAmount(threadId, currency);

                            if (currentAvailable > 0) {
                                availableSources.push({
                                    threadId: threadId,
                                    displayText: `${threadId} (swapped to ${currency})`,
                                    availableAmount: currentAvailable,
                                    currency: currency,
                                    sourceWallet: entry.toWallet,
                                    sourceType: 'swap_output',
                                    hopLevel: hopNumber, // Same hop level
                                    datetime: entry.timestamp || null,
                                    timezone: entry.timezone || 'UTC'
                                });
                                console.log(`Added swap output from current hop: ${threadId}`);
                            }
                        }
                    }
                });
            }
        });
    }
    
    console.log(` Final available sources (${availableSources.length}):`, availableSources);
    
    return availableSources.sort((a, b) => a.threadId.localeCompare(b.threadId));
}

// 2.4 Get Wallet Type Display Name
function getWalletTypeDisplayName(walletAddress) {
    // Try to find wallet in universal wallet index
    const wallet = investigation.universalWalletIndex?.find(w => w.address === walletAddress);
    if (wallet) {
        return wallet.permanentId;
    }
    
    // Fallback to abbreviated address
    if (walletAddress && walletAddress.length > 10) {
        return walletAddress.substring(0, 6) + '...' + walletAddress.substring(walletAddress.length - 4);
    }
    
    return walletAddress || 'Unknown';
}

// 2.5 Get Maximum Assignable Amount - Function moved to line 6710 with enhanced functionality

// 2.8 Calculate Total Assigned Amount by Currency
function calculateTotalAssignedAmount(currency) {
    let totalAssigned = 0;
    
    if (!investigation.availableThreads[currency]) {
        return 0;
    }
    
    Object.values(investigation.availableThreads[currency]).forEach(thread => {
        thread.assignments.forEach(assignment => {
            if (assignment.isActive) {
                totalAssigned += assignment.amount;
            }
        });
    });
    
    return totalAssigned;
}

// 2.9 Get Thread Chain History
function getThreadChainHistory(threadId, currency) {
    const chain = [];
    
    if (!investigation.availableThreads[currency] || !investigation.availableThreads[currency][threadId]) {
        return chain;
    }
    
    const thread = investigation.availableThreads[currency][threadId];
    chain.push({
        threadId: threadId,
        amount: thread.totalAmount,
        hopLevel: thread.hopLevel,
        sourceType: thread.sourceType
    });
    
    // Trace back through parent threads
    thread.parentThreads.forEach(parentId => {
        const parentChain = getThreadChainHistory(parentId, currency);
        chain.unshift(...parentChain);
    });
    
    return chain;
}

// 2.10 Enhanced getCurrentART with Thread Tracking
function getCurrentARTWithThreads() {
    const artByCurrency = {};
    
    // Start with root totals by currency from victims
    investigation.victims.forEach(victim => {
        victim.transactions.forEach(transaction => {
            if (parseFloat(transaction.amount) > 0) {
                const currency = transaction.currency === 'CUSTOM' ? transaction.customCurrency : transaction.currency;
                if (!artByCurrency[currency]) {
                    artByCurrency[currency] = {
                        rootTotal: 0,
                        writeoffs: 0,
                        adjustedTotal: 0,
                        assignedAmount: 0,
                        unassignedAmount: 0
                    };
                }
                artByCurrency[currency].rootTotal += parseFloat(transaction.amount);
            }
        });
    });
    
    // Subtract write-offs from hop entries by currency
    investigation.hops.forEach(hop => {
        hop.entries.forEach(entry => {
            if (entry.entryType === 'writeoff' && parseFloat(entry.amount) > 0) {
                const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                if (artByCurrency[currency]) {
                    artByCurrency[currency].writeoffs += parseFloat(entry.amount);
                }
            }
        });
    });
    
    // Calculate adjusted totals and assigned amounts
    Object.keys(artByCurrency).forEach(currency => {
        const art = artByCurrency[currency];
        art.adjustedTotal = art.rootTotal - art.writeoffs;
        art.assignedAmount = calculateTotalAssignedAmount(currency);
        art.unassignedAmount = art.adjustedTotal - art.assignedAmount;
    });
    
    return artByCurrency;
}
// =================================
// PHASE 3: ENHANCED UI COMPONENTS
// =================================

// 3.1 Enhanced Notation Field Functions
function updateNotationField(hopNumber, entryId, field, value) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    
    if (field === 'victims') {
        entry.victimNumbers = value;
    } else if (field === 'transactions') {
        entry.transactionNumbers = value;
    }
    
    // Generate the notation preview
    generateNotationPreview(hopNumber, entryId);
    saveToStorage();
}

function generateNotationPreview(hopNumber, entryId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    
    if (!entry.victimNumbers || !entry.transactionNumbers) {
        entry.notation = '';
        const previewElement = document.getElementById(`notation_preview_${hopNumber}_${entryId}`);
        if (previewElement) {
            previewElement.textContent = 'Enter victim and transaction numbers';
        }
        return;
    }
    
    // Generate V-T-H notation with suffix for writeoffs and cold storage
    let notation = `V${entry.victimNumbers}-T${entry.transactionNumbers}-H${entry.hopNumber}`;
    
    // Add suffix based on entry type
    if (entry.entryType === 'writeoff') {
        notation += '-WO';
    } else if (entry.entryType === 'cold_storage') {
        notation += '-CS';
    }
    
    entry.notation = notation;
    entry.generatedNotation = notation;
    
    // Update preview element
    const previewElement = document.getElementById(`notation_preview_${hopNumber}_${entryId}`);
    if (previewElement) {
        previewElement.textContent = notation;
    }
    
    // If we have source and amount, update the full display notation
    if ((entry.sourceThreadId || (entry.multipleSourceThreads && entry.multipleSourceThreads.length > 0)) && entry.amount) {
        updateFullNotationDisplay(hopNumber, entryId);
    }
}

// 3.2 Source Selection Handler
function handleSourceSelection(hopNumber, entryId, sourceThreadId) {
    console.log(` Handling source selection: ${sourceThreadId} for hop ${hopNumber} entry ${entryId}`);
    
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    
    if (!hop || !entry) {
        console.error('❌ Could not find hop or entry:', { hopNumber, entryId });
        return;
    }
    
    // Clear previous assignments
    entry.sourceThreadId = sourceThreadId;
    entry.multipleSourceThreads = [];
    entry.isConvergence = false;
    entry.individualSourceAssignments = {};
    
    if (sourceThreadId) {
        // Get the source thread details to determine its currency
        const availableSources = getAvailableSourcesForHop(hop.hopNumber, null);
        const selectedSource = availableSources.find(s => s.threadId === sourceThreadId);
        
        if (selectedSource) {
            // Auto-update the currency to match the source thread
            const sourceCurrency = selectedSource.currency;
            
            // Check if it's a custom currency
            const isCustomCurrency = !Object.keys(currencies).includes(sourceCurrency);
            
            if (isCustomCurrency) {
                entry.currency = 'CUSTOM';
                entry.customCurrency = sourceCurrency;
            } else {
                entry.currency = sourceCurrency;
                entry.customCurrency = '';
            }
            
            // Update the currency dropdown in the UI
            const currencySelect = document.querySelector(`select[onchange="updateHopEntry(${hopNumber}, ${entryId}, 'currency', this.value)"]`);
            if (currencySelect) {
                currencySelect.value = entry.currency;
            }
            
            // Show/hide custom currency input if needed
            const customCurrencyDiv = document.getElementById(`customEntryCurrency_${hopNumber}_${entryId}`);
            if (customCurrencyDiv) {
                if (isCustomCurrency) {
                    customCurrencyDiv.classList.remove('custom-currency-input');
                    const customInput = customCurrencyDiv.querySelector('input');
                    if (customInput) {
                        customInput.value = sourceCurrency;
                    }
                } else {
                    customCurrencyDiv.classList.add('custom-currency-input');
                }
            }
            
            console.log(`💱 Auto-updated currency to: ${sourceCurrency} (${isCustomCurrency ? 'custom' : 'standard'})`);
        }
        
        // Now use the updated currency from the source thread
        const currency = selectedSource.currency;
        const maxAmount = getMaxAssignableAmount(sourceThreadId, currency, entryId, hopNumber);
        
        console.log(`💡 Max available for ${sourceThreadId}: ${maxAmount} ${currency}`);
        
        // Update max amount for input
        const amountInput = document.getElementById(`assignAmount_${hopNumber}_${entryId}`);
        if (amountInput) {
            amountInput.max = maxAmount;
            
            // Only auto-fill if current amount exceeds new max (to prevent invalid amounts)
            if (parseFloat(entry.amount) > maxAmount) {
                entry.amount = maxAmount.toString();
                amountInput.value = maxAmount;
            }
            // Don't auto-fill otherwise - let user decide how much to assign
        }
        
        // Update source thread data
        if (investigation.availableThreads[currency] && investigation.availableThreads[currency][sourceThreadId]) {
            entry.sourceThreadData = investigation.availableThreads[currency][sourceThreadId];
            entry.availableSourceAmount = maxAmount;
        }
        
        // Auto-generate notation from source thread
        autoGenerateNotationFromSource(hopNumber, entryId, sourceThreadId);
        
        updateAssignmentPreview(hopNumber, entryId);
        updateFullNotationDisplay(hopNumber, entryId);
    } else {
        // Clear selection
        const amountInput = document.getElementById(`assignAmount_${hopNumber}_${entryId}`);
        if (amountInput) {
            amountInput.max = 0;
            amountInput.value = '';
        }
        entry.amount = '';
        entry.sourceThreadData = null;
        entry.availableSourceAmount = 0;
        
        clearNotationFields(hopNumber, entryId);
    }
    
    saveToStorage();
    
    // CRITICAL: Force refresh of ALL entries to show updated availability
    refreshAllSourceAvailability(hopNumber);
}
function refreshAllSourceAvailability(currentHopId) {
    console.log(`Refreshing source availability for all entries in hop ${currentHopId}`);
    
    // Find the current hop
    const currentHop = investigation.hops.find(h => h.hopNumber === currentHopId);
    if (!currentHop) return;
    
    // Update each entry's source dropdown with real-time availability
    currentHop.entries.forEach(entry => {
        if (entry.entryType === 'trace') {
            const sourceSelect = document.getElementById(`sourceSelect_${currentHop.id}_${entry.id}`);
            if (sourceSelect) {
                const selectedValue = sourceSelect.value;
                const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                
                // Get fresh availability data - get all currencies since we auto-set based on selection
                const availableSourceThreads = getAvailableSourcesForHop(currentHop.hopNumber, null);
                
                // Rebuild options with current availability
                let newOptions = '<option value="">Select source thread...</option>';
                availableSourceThreads.forEach(source => {
                    const realTimeAvailable = getMaxAssignableAmount(source.threadId, null);
                    const isSelected = selectedValue === source.threadId ? 'selected' : '';
                    const availabilityText = realTimeAvailable > 0 ? 
                        `${realTimeAvailable.toLocaleString()} ${source.currency} available` : 
                        'FULLY ASSIGNED';
                    const isDisabled = realTimeAvailable <= 0 && selectedValue !== source.threadId ? 'disabled' : '';
                    
                    newOptions += `<option value="${source.threadId}" ${isSelected} ${isDisabled}>
                        ${source.displayText} - ${availabilityText}
                    </option>`;
                });
                
                sourceSelect.innerHTML = newOptions;
                
                // If current selection is now unavailable, show warning
                if (selectedValue && getMaxAssignableAmount(selectedValue, null) <= 0 && entry.amount && parseFloat(entry.amount) > 0) {
                    const warningDiv = document.getElementById(`assignmentPreview_${currentHop.id}_${entry.id}`);
                    if (warningDiv) {
                        warningDiv.innerHTML = '<div style="color: #e74c3c; font-weight: bold;">⚠️ Source thread is now fully assigned!</div>';
                    }
                }
            }
        }
    });
}

// 3.3 Assignment Amount Handler
function updateAssignmentAmount(hopNumber, entryId, amount) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    if (!hop) {
        console.error('Hop not found:', hopNumber);
        return;
    }
    
    const entry = hop.entries.find(e => e.id === entryId);
    if (!entry) {
        console.error('Entry not found:', entryId);
        return;
    }
    
    entry.amount = amount;
    
    if (entry.sourceThreadData) {
        entry.assignmentPercentage = (parseFloat(amount) / entry.sourceThreadData.totalAmount) * 100;
    }
    
    updateAssignmentPreview(hopNumber, entryId);
    updateFullNotationDisplay(hopNumber, entryId);
    saveToStorage();
    
    // CRITICAL: Refresh availability after amount changes
    refreshAllSourceAvailability(hopNumber);
    buildAvailableThreadsIndex(); // Rebuild thread index when amounts change
    
    // Auto-collapse entry if amount is set and valid
    if (parseFloat(amount) > 0) {
        const entryKey = `${hopNumber}_${entryId}`;
        window.entryCollapseState[entryKey] = true;
        const content = document.getElementById(`entryContent_${entryKey}`);
        const summary = document.getElementById(`entrySummary_${entryKey}`);
        if (content && summary) {
            content.style.display = 'none';
            summary.style.display = 'block';
        }
    }
}

// 3.4 Assignment Preview Updater
function updateAssignmentPreview(hopNumber, entryId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    const previewElement = document.getElementById(`assignmentPreview_${hopNumber}_${entryId}`);
    
    if (!previewElement || !entry.sourceThreadId || !entry.amount) {
        if (previewElement) previewElement.innerHTML = '';
        return;
    }
    
    const amount = parseFloat(entry.amount);
    const maxAmount = getMaxAssignableAmount(entry.sourceThreadId, null, entryId, hopNumber); // Real-time calculation, let it find the currency
    
    // Get the actual currency from the source thread
    let currency = '';
    const availableSources = getAvailableSourcesForHop(hop.hopNumber, null);
    const sourceThread = availableSources.find(s => s.threadId === entry.sourceThreadId);
    if (sourceThread) {
        currency = sourceThread.currency;
    }
    const remaining = maxAmount + amount; // Total available if this assignment wasn't made
    const afterAssignment = remaining - amount;
    
    // Validate assignment with real-time data
    const validation = validateThreadAssignment(entry.sourceThreadId, amount, null, entryId, hopNumber);
    
    let previewHTML = '';
    if (validation.valid) {
        previewHTML = `
            <div style="color: #27ae60; background: #d4f8d4; padding: 8px; border-radius: 4px; margin-top: 5px;">
                ✓ Assigning ${amount.toLocaleString()} ${currency} from ${entry.sourceThreadId}
                <br><small style="color: #666;">
                    Available before: ${remaining.toLocaleString()} | After: ${afterAssignment.toLocaleString()} ${currency}
                    ${afterAssignment === 0 ? ' (FULLY ALLOCATED)' : ''}
                </small>
            </div>
        `;
        if (entry.assignmentPercentage) {
            previewHTML += `<div style="font-size: 11px; color: #666; margin-top: 3px;">Using ${entry.assignmentPercentage.toFixed(1)}% of source thread</div>`;
        }
    } else {
        previewHTML = `
            <div style="color: #e74c3c; background: #fdf2f2; padding: 8px; border-radius: 4px; margin-top: 5px;">
                ⚠ ${validation.error}
                <br><small style="color: #666;">Currently available: ${maxAmount.toLocaleString()} ${currency}</small>
            </div>
        `;
    }
    
    previewElement.innerHTML = previewHTML;
}

// 3.5 Assign Maximum Amount
function assignMaxAmount(hopNumber, entryId) {
    console.log(` assignMaxAmount called for hop ${hopNumber}, entry ${entryId}`);
    
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    if (!hop) {
        console.error('Hop not found:', hopNumber);
        return;
    }
    
    const entry = hop.entries.find(e => e.id === entryId);
    if (!entry) {
        console.error('Entry not found:', entryId);
        return;
    }
    
    console.log('Entry state:', {
        sourceThreadId: entry.sourceThreadId,
        multipleSourceThreads: entry.multipleSourceThreads,
        currentAmount: entry.amount
    })
    
    let maxAmount = 0;
    let currency = '';
    
    // Check if multiple sources are selected
    if (entry.multipleSourceThreads && entry.multipleSourceThreads.length > 0) {
        // First, validate that all sources have the same currency
        const availableSources = getAvailableSourcesForHop(hop.hopNumber, null);
        const currencies = new Set();
        
        entry.multipleSourceThreads.forEach(sourceId => {
            const source = availableSources.find(s => s.threadId === sourceId);
            if (source) {
                currencies.add(source.currency);
            }
        });
        
        if (currencies.size > 1) {
            alert(`ERROR:  Cannot mix different asset types!\n\nSelected threads contain: ${Array.from(currencies).join(', ')}\n\nPlease select threads with the same currency only.`);
            return;
        }
        
        // Calculate total from multiple sources using real-time availability
        entry.multipleSourceThreads.forEach(sourceId => {
            const availableAmount = getMaxAssignableAmount(sourceId, null);
            maxAmount += availableAmount;
            
            // Get currency from source thread
            const source = availableSources.find(s => s.threadId === sourceId);
            if (source && !currency) {
                currency = source.currency;
            }
            
            console.log(`Source ${sourceId}: ${availableAmount} available`);
        });
        console.log(`Total from ${entry.multipleSourceThreads.length} sources: ${maxAmount}`);
    } else if (entry.sourceThreadId) {
        // Single source selected
        maxAmount = getMaxAssignableAmount(entry.sourceThreadId, null, entry.id, hop.hopNumber);
        
        // Get currency from source thread
        const availableSources = getAvailableSourcesForHop(hop.hopNumber, null);
        const source = availableSources.find(s => s.threadId === entry.sourceThreadId);
        if (source) {
            currency = source.currency;
        }
        
        console.log(`Single source ${entry.sourceThreadId}: ${maxAmount} ${currency} available`);
    } else {
        alert('Please select source thread(s) first.');
        return;
    }
    
    // Update entry amount
    entry.amount = maxAmount.toString();
    
    // Update the input field - force update even if element seems unresponsive
    const amountInput = document.getElementById(`assignAmount_${hopNumber}_${entryId}`);
    if (amountInput) {
        console.log(`Updating amount input to ${maxAmount}`);
        amountInput.value = maxAmount;
        // Force a change event to ensure updates propagate
        amountInput.dispatchEvent(new Event('change', { bubbles: true }));
    } else {
        console.error(`Could not find amount input: assignAmount_${hopNumber}_${entryId}`);
    }
    
    // Trigger the amount update handler to ensure all related updates occur
    updateAssignmentAmount(hopNumber, entryId, maxAmount.toString());
    
    // Update appropriate preview based on source type
    if (entry.multipleSourceThreads && entry.multipleSourceThreads.length > 0) {
        updateMultipleSourcePreview(hopNumber, entryId);
        updateFullNotationDisplayMultiple(hopNumber, entryId);
    } else {
        updateAssignmentPreview(hopNumber, entryId);
        updateFullNotationDisplay(hopNumber, entryId);
    }
    
    saveToStorage();
}

// 3.6 Full Notation Display Updater
function updateFullNotationDisplay(hopNumber, entryId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    const previewElement = document.getElementById(`notationPreview_${hopNumber}_${entryId}`);
    
    if (!previewElement) return;
    
    if (!entry.sourceThreadId || !entry.amount || !entry.notation) {
        previewElement.innerHTML = 'Select source, amount, and complete notation to generate full display';
        return;
    }
    
    const amount = parseFloat(entry.amount);
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    
    // Generate source chain notation
    const sourceChainEntry = {
        sourceNotation: entry.sourceThreadId,
        amount: amount,
        currency: currency,
        percentage: entry.assignmentPercentage || 100
    };
    
    // Create display notation
    const displayNotation = `${entry.sourceThreadId}(${amount.toLocaleString()}) ${entry.notation}`;
    const summaryNotation = `${entry.notation} (${amount.toLocaleString()} ${currency})`;
    
    // Update entry with generated notations
    entry.displayNotation = displayNotation;
    entry.summaryNotation = summaryNotation;
    entry.sourceChain = [sourceChainEntry];
    
    // Update preview display
    previewElement.innerHTML = `
        <div style="margin-bottom: 8px;"><strong>Display:</strong> ${displayNotation}</div>
        <div style="margin-bottom: 8px;"><strong>Summary:</strong> ${summaryNotation}</div>
        <div style="font-size: 11px; color: #666;">Source Chain: ${entry.sourceThreadId} ${entry.notation}</div>
    `;
}

// 3.7 Enhanced Hop Entry Renderer (replaces renderHopEntry)
function renderEnhancedHopEntry(entry) {
    const isWriteoff = entry.entryType === 'writeoff';
    const isColdStorage = entry.entryType === 'cold_storage';
    
    // Get available source wallets for this hop
    const availableSourceWallets = getAvailableSourcesForHop(entry.hopNumber, entry.currency);
    const sourceOptions = availableSourceWallets.map(source => 
        `<option value="${source.threadId}" ${entry.sourceThreadId === source.threadId ? 'selected' : ''}>
            ${source.displayText} - ${source.availableAmount.toLocaleString()} ${source.currency} available
        </option>`
    ).join('');

    return `
        <div style="background: white; border: 2px solid #e8f0fe; border-radius: 8px; padding: 20px; margin-bottom: 15px;">
            <div class="trace-header">
                <div>
                    <span class="trace-notation">Entry ${entry.id} - ${entryTypes[entry.entryType]}</span>
                    ${entry.notation ? `<br><small style="color: #666;">${entry.notation}</small>` : ''}
                </div>
                <button class="btn btn-danger" onclick="removeHopEntry(${hop.hopNumber}, ${entry.id})">Remove</button>
            </div>
            
            <div class="form-group">
                <label>Entry Type</label>
                <select onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'entryType', this.value)">
                    ${Object.entries(entryTypes).map(([key, value]) => 
                        `<option value="${key}" ${entry.entryType === key ? 'selected' : ''}>${value}</option>`
                    ).join('')}
                </select>
            </div>
            
            ${!isWriteoff ? `
                <div class="form-group">
                    <label>Source Thread Selection</label>
                    <select id="sourceSelect_${hop.hopNumber}_${entry.id}" 
                            onchange="handleSourceSelection(${hop.hopNumber}, ${entry.id}, this.value)">
                        <option value="">Select source thread...</option>
                        ${sourceOptions}
                    </select>
                    ${entry.sourceThreadId ? `
                        <div style="margin-top: 8px; font-size: 11px; color: #666;">
                            <strong>Source:</strong> ${entry.sourceThreadId}
                        </div>
                    ` : ''}
                </div>
                
               <div class="form-group">
                    <label>New Thread Total</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <input type="number" step="0.01" 
                               id="assignAmount_${hop.hopNumber}_${entry.id}"
                               value="${entry.amount || ''}"
                               max="${entry.sourceThreadId ? getMaxAssignableAmount(entry.sourceThreadId, entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency) : 0}"
                               onchange="updateAssignmentAmount(${hop.hopNumber}, ${entry.id}, this.value)">
                        <button type="button" class="btn btn-secondary" 
                                onclick="assignMaxAmount(${hop.hopNumber}, ${entry.id})"
                                ${!entry.sourceThreadId ? 'disabled' : ''}>Max</button>
                    </div>
                    <div id="assignmentPreview_${hop.hopNumber}_${entry.id}" 
                         style="font-size: 12px; margin-top: 5px;"></div>
                </div>
            ` : ''}

            <div class="form-group">
                <label>Notation Builder</label>
                <div style="display: flex; align-items: center; gap: 5px; font-family: monospace; font-weight: bold;">
                    <span>V</span>
                    <input type="text" style="width: 60px; text-align: center;" 
                           placeholder="1" 
                           value="${entry.victimNumbers || ''}"
                           onchange="updateNotationField(${hop.hopNumber}, ${entry.id}, 'victims', this.value)">
                    <span>-T</span>
                    <input type="text" style="width: 80px; text-align: center;" 
                           placeholder="1,2,3" 
                           value="${entry.transactionNumbers || ''}"
                           onchange="updateNotationField(${hop.hopNumber}, ${entry.id}, 'transactions', this.value)">
                    <span>-H${entry.hopNumber}</span>
                </div>
                <div style="font-size: 12px; color: #666; margin-top: 5px;">
                    Preview: <span id="notation_preview_${hop.hopNumber}_${entry.id}" style="font-family: monospace; font-weight: bold;">${entry.notation || 'Enter V and T numbers'}</span>
                </div>
            </div>
            
            ${!isWriteoff ? `
                <div class="form-group">
                    <label>Full Notation Display</label>
                    <div id="notationPreview_${hop.hopNumber}_${entry.id}" 
                         style="font-family: monospace; padding: 10px; background: #f8f9fa; border-radius: 4px; min-height: 60px;">
                        ${entry.displayNotation || 'Complete source selection and notation to generate full display'}
                    </div>
                </div>
            ` : ''}

            <div class="form-group">
                <label>Currency</label>
                <select onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'currency', this.value)">
                    <option value="USD" ${entry.currency === 'USD' ? 'selected' : ''}>US Dollar</option>
                    <option value="BTC" ${entry.currency === 'BTC' ? 'selected' : ''}>Bitcoin</option>
                    <option value="ETH" ${entry.currency === 'ETH' ? 'selected' : ''}>Ethereum</option>
                    <option value="USDT" ${entry.currency === 'USDT' ? 'selected' : ''}>Tether</option>
                    <option value="USDC" ${entry.currency === 'USDC' ? 'selected' : ''}>USD Coin</option>
                    <option value="TRX" ${entry.currency === 'TRX' ? 'selected' : ''}>TRON</option>
                    <option value="SOL" ${entry.currency === 'SOL' ? 'selected' : ''}>Solana</option>
                    <option value="ADA" ${entry.currency === 'ADA' ? 'selected' : ''}>Cardano</option>
                    <option value="DAI" ${entry.currency === 'DAI' ? 'selected' : ''}>DAI</option>
                    <option value="BNB" ${entry.currency === 'BNB' ? 'selected' : ''}>BNB</option>
                    <option value="MATIC" ${entry.currency === 'MATIC' ? 'selected' : ''}>MATIC</option>
                    <option value="AVAX" ${entry.currency === 'AVAX' ? 'selected' : ''}>AVAX</option>
                    <option value="HYPE" ${entry.currency === 'HYPE' ? 'selected' : ''}>HYPE</option>
                    <option value="MNT" ${entry.currency === 'MNT' ? 'selected' : ''}>MNT</option>
                    <option value="CUSTOM" ${entry.currency === 'CUSTOM' ? 'selected' : ''}>Custom Currency</option>
                </select>
            </div>
            
            <div class="form-group ${entry.currency === 'CUSTOM' ? '' : 'custom-currency-input'}" 
                 id="customEntryCurrency_${hop.hopNumber}_${entry.id}">
                <label>Custom Currency Symbol</label>
                <input type="text" value="${entry.customCurrency || ''}" 
                       placeholder="e.g., DOGE, SHIB"
                       onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'customCurrency', this.value)">
            </div>
            
            ${!isWriteoff && !isColdStorage ? `
                <div class="form-group">
                    <label>To Wallet Address</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <div class="wallet-autocomplete-container" style="flex: 1;">
                            <input type="text" 
                                   id="toWallet_${hop.hopNumber}_${entry.id}"
                                   value="${entry.toWallet || ''}" 
                                   placeholder="Select existing or enter new wallet address"
                                   onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'toWallet', this.value)"
                                   oninput="handleWalletAutocomplete(this, ${entry.hopNumber}, ${entry.id})"
                                   autocomplete="off"
                                   list="walletList_${hop.hopNumber}_${entry.id}"
                                   style="width: 100%;">
                            <div id="autocomplete_${hop.hopNumber}_${entry.id}" class="wallet-autocomplete-dropdown"></div>
                        </div>
                        <datalist id="walletList_${hop.hopNumber}_${entry.id}">
                            ${(investigation.universalWalletIndex || []).map(wallet => `
                                <option value="${wallet.address}">
                                    ${wallet.permanentId} - ${wallet.address.substring(0, 20)}...
                                </option>
                            `).join('')}
                        </datalist>
                        <button type="button" class="btn btn-secondary" style="padding: 6px 12px; font-size: 12px;"
                                onclick="showWalletSelector(${hop.hopNumber}, ${entry.id})">
                            📋 Browse
                        </button>
                    </div>
                    <div style="font-size: 11px; color: #666; margin-top: 5px;">
                        Type to search existing wallets or enter a new address
                    </div>
                </div>
                <div class="form-group">
                    <label>To Wallet Classification</label>
                    <select onchange="updateHopEntryWalletType(${hop.hopNumber}, ${entry.id}, this.value)">
                        <option value="">Select classification...</option>
                        ${Object.entries(walletTypes).filter(([key]) => key !== 'red').map(([key, value]) => 
                            `<option value="${key}" ${entry.toWalletType === key ? 'selected' : ''}>${value}</option>`
                        ).join('')}
                    </select>
                </div>
                <div class="form-group">
                    <label>Transaction Hash</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <input type="text" 
                               id="txHash_${hop.hopNumber}_${entry.id}"
                               value="${entry.txHash || ''}" 
                               placeholder="Blockchain transaction hash"
                               onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'txHash', this.value)"
                               style="flex: 1;">
                        <button type="button" 
                                class="btn btn-secondary" 
                                onclick="openBlockchainLookup(${hop.hopNumber}, ${entry.id})"
                                style="background: #3498db; color: white; padding: 8px 15px; font-size: 14px;">
                            Lookup
                        </button>
                    </div>
                </div>
                <div class="form-group">
                    <label>Timestamp with Timezone</label>
                    <div class="datetime-timezone">
                        <input type="datetime-local" 
                               id="timestamp_${hop.hopNumber}_${entry.id}"
                               value="${entry.timestamp || ''}" 
                               onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'timestamp', this.value)">
                        <select onchange="onTimezoneChange('timestamp_${hop.hopNumber}_${entry.id}', 'hop', ${hop.hopNumber}, ${entry.id})">
                            ${Object.entries(timezones).map(([key, value]) => 
                                `<option value="${key}" ${entry.timezone === key ? 'selected' : ''}>${value}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
            ` : ''}
            
            ${isWriteoff ? `
                <div class="form-group">
                    <label>Write-off Category</label>
                    <select onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'category', this.value)">
                        <option value="">Select category...</option>
                        ${Object.entries(writeoffCategories).map(([key, value]) => 
                            `<option value="${key}" ${entry.category === key ? 'selected' : ''}>${value}</option>`
                        ).join('')}
                    </select>
                </div>
                <div class="form-group" style="grid-column: span 2;">
                    <label>Justification</label>
                    <textarea rows="2" placeholder="Detailed explanation for abandoning this trace path..." 
                              onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'justification', this.value)">${entry.justification || ''}</textarea>
                </div>
            ` : `
                <div class="form-group" style="grid-column: span 2;">
                    <label>Notes</label>
                    <textarea rows="2" placeholder="PIFO application, convergence notes, etc." 
                              onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'notes', this.value)">${entry.notes || ''}</textarea>
                </div>
            `}
        </div>
    `;
}


// ADD THESE FUNCTIONS TO HANDLE COMMINGLING/MULTIPLE SOURCES

// Enhanced Source Selection Handler for Multiple Sources
function handleMultipleSourceSelection(hopNumber, entryId, selectedSources) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    
    // Store multiple source threads
    entry.multipleSourceThreads = selectedSources;
    entry.isConvergence = selectedSources.length > 1;
    
    if (selectedSources.length > 0) {
        // Calculate total available amount from all selected sources
        let totalAvailable = 0;
        selectedSources.forEach(sourceId => {
            const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
            const maxAmount = getMaxAssignableAmount(sourceId, currency, entry.id, hop.hopNumber);
            totalAvailable += maxAmount;
        });
        
        // Update max amount for input
        const amountInput = document.getElementById(`assignAmount_${hopNumber}_${entryId}`);
        if (amountInput) {
            amountInput.max = totalAvailable;
            
            // Auto-fill with total available if no amount set
            if (!entry.amount || parseFloat(entry.amount) === 0) {
                entry.amount = totalAvailable.toString();
                amountInput.value = totalAvailable;
            }
        }
        
        updateMultipleSourcePreview(hopNumber, entryId);
        updateFullNotationDisplay(hopNumber, entryId);
    }
    
    saveToStorage();
}

// Update Multiple Source Preview
function renderEnhancedSourceSelection(entry) {
    const availableSourceThreads = getAvailableSourcesForHop(entry.hopNumber, null);
    
    // If only one source available, use single selection
    if (availableSourceThreads.length <= 1) {
        const sourceOptions = availableSourceThreads.map(source => 
            `<option value="${source.threadId}" ${entry.sourceThreadId === source.threadId ? 'selected' : ''}>
                ${source.displayText} - ${source.availableAmount.toLocaleString()} ${source.currency} available
            </option>`
        ).join('');
        
        return `
            <div class="form-group">
                <label>Source Thread Selection</label>
                <select id="sourceSelect_${hop.hopNumber}_${entry.id}" 
                        onchange="handleSourceSelection(${hop.hopNumber}, ${entry.id}, this.value)">
                    <option value="">Select source thread...</option>
                    ${sourceOptions}
                </select>
            </div>
        `;
    }
    
    // Multiple sources available - show checkboxes for commingling
    return `
        <div class="form-group">
            <label>Source Thread Selection (Multiple sources for commingling)</label>
            <div style="background: #f8f9fa; border: 1px solid #ddd; border-radius: 4px; padding: 15px;">
                <div style="margin-bottom: 10px; font-weight: bold;">Select one or more source threads:</div>
                ${availableSourceThreads.map(source => `
                    <label style="display: block; margin: 8px 0; cursor: pointer;">
                        <input type="checkbox" 
                               value="${source.threadId}" 
                               ${entry.multipleSourceThreads && entry.multipleSourceThreads.includes(source.threadId) ? 'checked' : ''}
                               onchange="updateMultipleSourceSelection(${hop.hopNumber}, ${entry.id})"> 
                        ${source.displayText} - ${source.availableAmount.toLocaleString()} ${source.currency} available
                    </label>
                `).join('')}
            </div>
            <div id="multipleSourcePreview_${hop.hopNumber}_${entry.id}"></div>
        </div>
    `;
}

// Update Multiple Source Selection
// REPLACE YOUR updateMultipleSourceSelection FUNCTION WITH THIS FIXED VERSION

function updateMultipleSourceSelection(hopNumber, entryId) {
    const checkboxes = document.querySelectorAll(`input[type="checkbox"][onchange*="${hopNumber}, ${entryId}"]`);
    const selectedSources = Array.from(checkboxes)
        .filter(cb => cb.checked)
        .map(cb => cb.value);
    
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    
    // Check if we were already in multiple source mode
    const wasMultipleMode = entry.multipleSourceThreads && entry.multipleSourceThreads.length > 0;
    
    // Store multiple source threads
    entry.multipleSourceThreads = selectedSources;
    entry.isConvergence = selectedSources.length > 1;
    
    // Only switch to single source mode if we weren't already in multiple mode
    // This preserves the multiple source UI even when only one thread is selected
    if (!wasMultipleMode && selectedSources.length === 1) {
        // Starting fresh with single selection - use single source mode
        entry.sourceThreadId = selectedSources[0];
        entry.multipleSourceThreads = [];
    } else if (wasMultipleMode) {
        // We were in multiple mode - stay in multiple mode even with 1 selection
        entry.sourceThreadId = '';
    } else {
        // No sources selected
        entry.sourceThreadId = '';
    }
    
    if (selectedSources.length > 0) {
        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
        
        // Initialize individual assignments for newly selected sources
        if (!entry.individualSourceAssignments) {
            entry.individualSourceAssignments = {};
        }
        
        // Add any new sources with 0 assignment
        selectedSources.forEach(sourceId => {
            if (!(sourceId in entry.individualSourceAssignments)) {
                entry.individualSourceAssignments[sourceId] = 0;
            }
        });
        
        // Remove any unselected sources
        Object.keys(entry.individualSourceAssignments).forEach(sourceId => {
            if (!selectedSources.includes(sourceId)) {
                delete entry.individualSourceAssignments[sourceId];
            }
        });
        
        // Calculate total available and assigned amounts
        let totalAvailable = 0;
        let totalAssigned = 0;
        
        selectedSources.forEach(sourceId => {
            const maxAmount = getMaxAssignableAmount(sourceId, currency, entry.id, hop.hopNumber);
            totalAvailable += maxAmount;
            totalAssigned += entry.individualSourceAssignments[sourceId] || 0;
        });
        
        console.log(`Total available from ${selectedSources.length} sources: ${totalAvailable} ${currency}`);
        console.log(`Total assigned: ${totalAssigned} ${currency}`);
        
        // Update main amount field with total assigned
        entry.amount = totalAssigned.toString();
        
        // Update max amount for input
        const amountInput = document.getElementById(`assignAmount_${hopNumber}_${entryId}`);
        if (amountInput) {
            amountInput.max = totalAvailable;
            amountInput.value = totalAssigned;
        }
        
        // AUTO-GENERATE NOTATION FROM MULTIPLE SOURCE THREADS
        autoGenerateNotationFromMultipleSources(hopNumber, entryId, selectedSources);
        
        // Show the granular control interface immediately
        updateMultipleSourcePreview(hopNumber, entryId);
        updateFullNotationDisplayMultiple(hopNumber, entryId);
    } else {
        // No sources selected - clear everything
        const amountInput = document.getElementById(`assignAmount_${hopNumber}_${entryId}`);
        if (amountInput) {
            amountInput.max = 0;
            amountInput.value = '';
        }
        entry.amount = '';
        entry.multipleSourceThreads = [];
        entry.isConvergence = false;
        entry.sourceThreadId = '';
        entry.individualSourceAssignments = {};
        
        // Clear notation fields
        clearNotationFields(hopNumber, entryId);
        
        // Clear the preview
        const previewElement = document.getElementById(`multipleSourcePreview_${hopNumber}_${entryId}`);
        if (previewElement) {
            previewElement.innerHTML = '';
        }
    }
    
    saveToStorage();
    // Don't re-render the entire hop list - this causes entries to collapse while user is working
    // Just update the preview which is sufficient for the user to continue working
    // renderHops();
}
// ALSO ADD THIS NEW FUNCTION TO PROPERLY VALIDATE MULTIPLE SOURCE ASSIGNMENTS

function validateMultipleSourceAssignment(entry) {
    if (!entry.multipleSourceThreads || entry.multipleSourceThreads.length === 0) {
        return { valid: false, error: 'No source threads selected' };
    }
    
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    const amount = parseFloat(entry.amount);
    
    if (isNaN(amount) || amount <= 0) {
        return { valid: false, error: 'Amount must be a positive number' };
    }
    
    // Calculate total available from all selected sources using REAL-TIME calculation
    let totalAvailable = 0;
    entry.multipleSourceThreads.forEach(sourceId => {
        totalAvailable += getMaxAssignableAmount(sourceId, currency);
    });
    
    if (amount > totalAvailable) {
        return { 
            valid: false, 
            error: `Amount ${amount.toLocaleString()} exceeds total available ${totalAvailable.toLocaleString()} ${currency}` 
        };
    }
    
    return { valid: true, totalAvailable: totalAvailable };
}


function updateMultipleSourcePreview(hopNumber, entryId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    const previewElement = document.getElementById(`multipleSourcePreview_${hopNumber}_${entryId}`);
    
    if (!previewElement || !entry.multipleSourceThreads || entry.multipleSourceThreads.length === 0) {
        if (previewElement) previewElement.innerHTML = '';
        return;
    }
    
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    
    // Initialize individual assignments if not exists
    if (!entry.individualSourceAssignments) {
        entry.individualSourceAssignments = {};
        entry.multipleSourceThreads.forEach(sourceId => {
            entry.individualSourceAssignments[sourceId] = 0;
        });
    }
    
    let totalAvailable = 0;
    let totalAssigned = 0;
    let sourceInputsHTML = '';
    
    entry.multipleSourceThreads.forEach(sourceId => {
        const maxAmount = getMaxAssignableAmount(sourceId, currency, entry.id, entry.hopNumber);
        const assignedAmount = entry.individualSourceAssignments[sourceId] || 0;
        const remaining = maxAmount - assignedAmount;
        
        totalAvailable += maxAmount;
        totalAssigned += assignedAmount;
        
        sourceInputsHTML += `
            <div style="display: flex; align-items: center; gap: 10px; margin: 8px 0; padding: 8px; background: white; border-radius: 4px; border: 1px solid #ddd;">
                <div style="flex: 1; font-weight: bold; color: #2c3e50;">
                    ${sourceId}
                </div>
                <div style="display: flex; align-items: center; gap: 5px;">
                    <input type="number" 
                           step="0.01" 
                           min="0" 
                           max="${maxAmount}"
                           value="${assignedAmount}"
                           style="width: 100px; padding: 4px;"
                           onchange="updateIndividualSourceAssignment(${hopNumber}, ${entryId}, '${sourceId}', this.value)"
                           placeholder="0">
                    <span style="font-size: 11px; color: #666;">/ ${maxAmount.toLocaleString()}</span>
                    <button type="button" 
                            onclick="assignMaxToIndividualSource(${hopNumber}, ${entryId}, '${sourceId}')"
                            style="padding: 2px 6px; font-size: 11px; background: #95a5a6; color: white; border: none; border-radius: 3px; cursor: pointer;">
                        Max
                    </button>
                </div>
                <div style="font-size: 11px; color: ${remaining === 0 ? '#e74c3c' : '#27ae60'};">
                    ${remaining === 0 ? 'DEPLETED' : `${remaining.toLocaleString()} left`}
                </div>
            </div>
        `;
    });
    
    // Update main amount field with total assigned
    entry.amount = totalAssigned.toString();
    const mainAmountInput = document.getElementById(`assignAmount_${hopNumber}_${entryId}`);
    if (mainAmountInput) {
        mainAmountInput.value = totalAssigned;
    }
    
    const isValid = totalAssigned <= totalAvailable && totalAssigned > 0;
    
    let previewHTML = `
        <div style="background: #f8f9fa; border: 1px solid #ddd; border-radius: 4px; padding: 15px; margin-top: 10px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <div style="font-weight: bold; color: #2c3e50;">
                    Individual Source Assignments:
                </div>
                <div style="display: flex; gap: 5px;">
                    <button type="button" 
                            onclick="distributeProportionally(${hopNumber}, ${entryId})"
                            style="padding: 4px 8px; font-size: 11px; background: #3498db; color: white; border: none; border-radius: 3px; cursor: pointer;">
                        Distribute Proportionally
                    </button>
                    <button type="button" 
                            onclick="depleteInOrder(${hopNumber}, ${entryId})"
                            style="padding: 4px 8px; font-size: 11px; background: #e67e22; color: white; border: none; border-radius: 3px; cursor: pointer;">
                        Deplete In Order
                    </button>
                    <button type="button" 
                            onclick="clearAllAssignments(${hopNumber}, ${entryId})"
                            style="padding: 4px 8px; font-size: 11px; background: #95a5a6; color: white; border: none; border-radius: 3px; cursor: pointer;">
                        Clear All
                    </button>
                </div>
            </div>
            
            ${sourceInputsHTML}
            
            <div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid #ddd;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <strong>Total Available:</strong> ${totalAvailable.toLocaleString()} ${currency}
                    </div>
                    <div style="color: ${isValid ? '#27ae60' : '#e74c3c'}; font-weight: bold;">
                        <strong>Total Assigned:</strong> ${totalAssigned.toLocaleString()} ${currency}
                        ${!isValid && totalAssigned > totalAvailable ? ' (EXCEEDS AVAILABLE!)' : ''}
                        ${totalAssigned === 0 ? ' (No assignments)' : ''}
                    </div>
                </div>
            </div>
        </div>
    `;
    
    previewElement.innerHTML = previewHTML;
}
// Enhanced Full Notation Display for Multiple Sources
function updateFullNotationDisplayMultiple(hopNumber, entryId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    const previewElement = document.getElementById(`notationPreview_${hopNumber}_${entryId}`);
    
    if (!previewElement) return;
    
    const amount = parseFloat(entry.amount);
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    
    if (entry.multipleSourceThreads && entry.multipleSourceThreads.length > 1) {
        // Multiple sources - show convergence notation
        const sourceNotations = entry.multipleSourceThreads.map(sourceId => {
            const sourceAmount = getMaxAssignableAmount(sourceId, currency);
            return `${sourceId}(${formatNumber(sourceAmount)})`;
        });
        
        const displayNotation = `${sourceNotations.join(' + ')} ${entry.notation}`;
        const summaryNotation = `${entry.notation} (${formatNumber(amount)} ${currency} from ${entry.multipleSourceThreads.length} sources)`;
        
        // Update entry with generated notations
        entry.displayNotation = displayNotation;
        entry.summaryNotation = summaryNotation;
        entry.sourceChain = entry.multipleSourceThreads.map(sourceId => ({
            sourceNotation: sourceId,
            amount: getMaxAssignableAmount(sourceId, currency),
            currency: currency,
            percentage: (getMaxAssignableAmount(sourceId, currency) / amount) * 100
        }));
        
        previewElement.innerHTML = `
            <div style="margin-bottom: 8px;"><strong>Display:</strong> ${displayNotation}</div>
            <div style="margin-bottom: 8px;"><strong>Summary:</strong> ${summaryNotation}</div>
            <div style="font-size: 11px; color: #666;">Convergence: ${entry.multipleSourceThreads.join(' + ')} ${entry.notation}</div>
        `;
    } else if (entry.sourceThreadId) {
        // Single source - use existing logic
        updateFullNotationDisplay(hopNumber, entryId);
    } else {
        previewElement.innerHTML = 'Select source(s) and complete notation to generate full display';
    }
}
// =================================
// PHASE 1: ENHANCED DATA STRUCTURES
// =================================
        // STEP 4.1: REPLACE YOUR EXISTING entryTypes OBJECT WITH THIS:

        const entryTypes = {
            'trace': 'Outgoing Transaction',
            'swap': 'DEX/Asset Conversion',
            'cold_storage': 'Still in Wallet'
        };


        // currencies already defined earlier with more complete information including decimals

        // timezones already defined earlier
        const writeoffCategories = {
            'dust': 'Dust - Below threshold',
            'dilution': 'Dilution - Too diluted to trace',
            'obfuscation': 'Obfuscation - Privacy services',
            'operational': 'Operational - Resource constraints'
        };

        // Format number with commas while preserving full decimal precision
        function formatNumber(value) {
            if (!value || isNaN(value)) return '0';
            
            const parts = value.toString().split('.');
            const integerPart = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ',');
            
            if (parts.length === 2) {
                return integerPart + '.' + parts[1];
            }
            return integerPart;
        }

        // Toggle file dropdown menu
        function toggleFileMenu() {
            const dropdown = document.getElementById('fileDropdown');
            if (dropdown) {
                dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
            }
        }

        // Close file dropdown when clicking outside - will be initialized after DOM loads

        // Security Status Display Function
        function displaySecurityStatus() {
            const protocol = window.location.protocol;
            const container = document.querySelector('.container');
            
            if (protocol === 'file:') {
                // Add warning banner for file:// protocol
                const warningBanner = document.createElement('div');
                warningBanner.style.cssText = `
                    background: #fff3cd;
                    border: 2px solid #ffc107;
                    color: #856404;
                    padding: 15px;
                    margin-bottom: 20px;
                    border-radius: 8px;
                    display: flex;
                    align-items: center;
                    gap: 10px;
                `;
                warningBanner.innerHTML = `
                    <span style="font-size: 24px;">⚠️</span>
                    <div>
                        <strong>Limited Functionality - File Protocol Detected</strong><br>
                        <small>You're running B.A.T.S. from a local file. For full functionality including custom save locations and API features, please serve this file over HTTPS. 
                        <a href="training.html#deployment" target="_blank" style="color: #856404; text-decoration: underline;">Learn more about deployment options</a></small>
                    </div>
                `;
                container.insertBefore(warningBanner, container.firstChild);
            } else if (protocol === 'https:') {
                // Add secure connection indicator
                const secureIndicator = document.createElement('div');
                secureIndicator.style.cssText = `
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    background: #d4edda;
                    border: 1px solid #c3e6cb;
                    color: #155724;
                    padding: 8px 15px;
                    border-radius: 6px;
                    font-size: 12px;
                    display: flex;
                    align-items: center;
                    gap: 5px;
                    z-index: 1000;
                    opacity: 0.9;
                `;
                secureIndicator.innerHTML = `
                    <span style="color: #28a745;">🔒</span> Secure Connection
                `;
                document.body.appendChild(secureIndicator);
                
                // Auto-hide after 5 seconds
                setTimeout(() => {
                    secureIndicator.style.transition = 'opacity 0.5s';
                    secureIndicator.style.opacity = '0';
                    setTimeout(() => secureIndicator.remove(), 500);
                }, 5000);
            }
        }

        // Make sure these functions are globally accessible
        window.switchTab = switchTab;
        window.toggleFileMenu = toggleFileMenu;
        window.openPKConverter = openPKConverter;
        window.closePKConverterModal = closePKConverterModal;
        window.openAddressFinder = openAddressFinder;
        window.closeAddressFinderModal = closeAddressFinderModal;

        // Clean up memory on page unload
        window.addEventListener('beforeunload', () => {
            // Clear undo history to free memory
            if (typeof undoHistory !== 'undefined' && undoHistory && undoHistory.length > 0) {
                undoHistory.forEach(state => {
                    if (state && state.investigation) {
                        state.investigation = null;
                    }
                });
                undoHistory.length = 0;
            }
        });

        document.addEventListener('DOMContentLoaded', function() {
    console.log('Initializing B.A.T.S. application...');

    // Display security status
    displaySecurityStatus();

    // Check if user is entering app or should see landing page
    const urlParams = new URLSearchParams(window.location.search);
    const enterApp = urlParams.get('app') === 'true';
    const hasExistingCase = investigation.caseId || (investigation.victims && investigation.victims.length > 0);

    if (enterApp || hasExistingCase) {
        // User is entering the app or has existing work
        initializeApp();
        window.appInitialized = true;

        // If entering from landing page, show app UI and welcome message
        if (enterApp && !hasExistingCase) {
            showAppUI();
            switchTab('casedetails');

            // Show intro for new users only
            if (!localStorage.getItem('bats_intro_shown')) {
                setTimeout(() => {
                    alert('Welcome to B.A.T.S. Documentation\n\n' +
                          'Step 1: Fill in your case details\n' +
                          'Step 2: Add victim information and transactions\n' +
                          'Step 3: Document fund traces using V-T-H notation\n' +
                          'Step 4: Generate your investigation report\n\n' +
                          'Remember: Use your blockchain analysis tools alongside B.A.T.S. for actual tracing.');
                    localStorage.setItem('bats_intro_shown', 'true');
                }, 500);
            }
        } else if (hasExistingCase) {
            // Show app UI for existing cases
            showAppUI();
        }
    } else {
        // Show landing page
        showLandingPage();
    }
});

function initializeApp() {
    try {
        // Enhanced structure initialization
        initializeCompleteIntegration();

        // Build thread tracking index
        buildAvailableThreadsIndex();

        // Original initialization
        loadFromStorage();
        renderAll();
        updateWorkflowSteps();
        setupConversionModalListeners();

        // Show app UI
        showAppUI();

        // Show Victims tab by default to avoid white screen
        switchTab('victims');

        // Check onboarding state on load
        setTimeout(() => {
            checkOnboardingState();
        }, 100);
        
        // Setup event listeners for case info with better error handling
        const caseIdInput = document.getElementById('caseId');
        const investigatorInput = document.getElementById('investigator');
        const caseTypeInput = document.getElementById('caseType');
        
        if (caseIdInput) {
            caseIdInput.addEventListener('change', function() {
                try {
                    investigation.caseId = this.value;
                    saveToStorage();
                } catch (error) {
                    console.error('Error saving case ID:', error);
                }
            });
        }
        if (investigatorInput) {
            investigatorInput.addEventListener('change', function() {
                try {
                    investigation.investigator = this.value;
                    saveToStorage();
                } catch (error) {
                    console.error('Error saving investigator:', error);
                }
            });
        }
        if (caseTypeInput) {
            caseTypeInput.addEventListener('change', function() {
                try {
                    investigation.caseType = this.value;
                    saveToStorage();
                } catch (error) {
                    console.error('Error saving case type:', error);
                }
            });
        }
        
        // Add case synopsis handler
        const caseSynopsisInput = document.getElementById('caseSynopsis');
        if (caseSynopsisInput) {
            caseSynopsisInput.addEventListener('change', function() {
                try {
                    investigation.caseSynopsis = this.value;
                    saveToStorage();
                } catch (error) {
                    console.error('Error saving case synopsis:', error);
                }
            });
        }
        
        // Close file dropdown when clicking outside
        document.addEventListener('click', function(event) {
            const dropdown = document.getElementById('fileDropdown');
            const fileButton = event.target.closest('button[onclick="toggleFileMenu()"]');
            
            if (dropdown && !fileButton && !dropdown.contains(event.target)) {
                dropdown.style.display = 'none';
            }
        });
        
        console.log(' B.A.T.S. application initialized successfully');

    } catch (error) {
        console.error('❌ Error initializing B.A.T.S. application:', error);
        alert('There was an error initializing the application. Please refresh the page and try again.');
    }
}
function updateFormFieldsFromInvestigation() {
    console.log('Updating form fields from investigation data...');
    
    // Update the form fields
    const caseIdField = document.getElementById('caseId');
    const investigatorField = document.getElementById('investigator');
    const caseTypeField = document.getElementById('caseType');
    const caseSynopsisField = document.getElementById('caseSynopsis');
    
    if (caseIdField) {
        caseIdField.value = investigation.caseId || '';
    }
    if (investigatorField) {
        investigatorField.value = investigation.investigator || '';
    }
    if (caseTypeField) {
        caseTypeField.value = investigation.caseType || '';
    }
    if (caseSynopsisField) {
        caseSynopsisField.value = investigation.caseSynopsis || '';
    }
    
    
    console.log('Form fields updated');
}

        function updateWorkflowSteps() {
            // Reset all steps
            document.querySelectorAll('.step-item').forEach(step => {
                step.classList.remove('completed', 'active');
            });

            // Step 1: Investigation Setup
            const step1 = document.getElementById('step1');
            if (investigation.caseId && investigation.investigator && investigation.caseType) {
                step1.classList.add('completed');
            } else {
                step1.classList.add('active');
                return;
            }

            // Step 2: Add Victims
            const step2 = document.getElementById('step2');
            if (investigation.victims.length > 0) {
                step2.classList.add('completed');
            } else {
                step2.classList.add('active');
                return;
            }

            // Step 3: Confirm Root Total
            const step3 = document.getElementById('step3');
            if (investigation.rootTotalConfirmed) {
                step3.classList.add('completed');
            } else {
                step3.classList.add('active');
                return;
            }

            // Step 4: Document Traces
            const step4 = document.getElementById('step4');
            if (investigation.hops.length > 0) {
                step4.classList.add('completed');
            }
            step4.classList.add('active');

            // Steps 5 & 6 are always available once root total is confirmed
            if (investigation.rootTotalConfirmed) {
                document.getElementById('step5').classList.add('active');
                document.getElementById('step6').classList.add('active');
            }

            // Show/hide generate root total section
            updateGenerateRootSection();
        }

        function updateGenerateRootSection() {
            const generateSection = document.getElementById('generateRootSection');
            const hasTransactions = investigation.victims.some(v => 
                v.transactions.some(t => t.amount && parseFloat(t.amount) > 0)
            );
            
            if (hasTransactions && !investigation.rootTotalConfirmed) {
                generateSection.style.display = 'block';
                
                // Check if file has been saved to show appropriate button
                if (savedFilePath) {
                    document.getElementById('saveRequiredMessage').style.display = 'none';
                    document.getElementById('generateRootBtn').style.display = 'block';
                } else {
                    document.getElementById('saveRequiredMessage').style.display = 'block';
                    document.getElementById('generateRootBtn').style.display = 'none';
                }
            } else {
                generateSection.style.display = 'none';
            }
        }

        function switchWalletIndex(indexType) {
            // Hide all wallet index content
            document.querySelectorAll('.wallet-index-content').forEach(content => {
                content.style.display = 'none';
            });
            
            // Show selected index
            document.getElementById(indexType + 'WalletIndexContent').style.display = 'block';
            
            // Render the appropriate index
            if (indexType === 'universal') {
                renderUniversalWalletIndex();
            } else if (indexType === 'red') {
                renderRedWalletIndex();
            } else if (indexType === 'purple') {
                renderPurpleWalletIndex();
            } else if (indexType === 'blue') {
                renderBlueWalletIndex();
            }
        }

        // Setup tab-specific actions
        window.tabActions = {
            'summary': () => {
                if (typeof renderSummary !== 'undefined') renderSummary();
                if (typeof updateCaseConclusionStats !== 'undefined') updateCaseConclusionStats();
            },
            'walletindexes': () => {
                if (typeof renderUniversalWalletIndex !== 'undefined') {
                    renderUniversalWalletIndex();
                    renderRedWalletIndex();
                    renderPurpleWalletIndex();
                    renderBlueWalletIndex();
                }
            },
            'victims': () => {
                if (typeof renderVictims !== 'undefined') renderVictims();
            },
            'casedetails': () => {
                if (typeof updateCaseStats !== 'undefined') updateCaseStats();
            },
            'flowdiagram': () => {
                if (investigation.hops && investigation.hops.length > 0) {
                    const controls = document.getElementById('flowDiagramControls');
                    if (controls) controls.style.display = 'block';
                } else {
                    const controls = document.getElementById('flowDiagramControls');
                    if (controls) controls.style.display = 'none';
                    const svg = document.getElementById('flowDiagramSVG');
                    if (svg) svg.innerHTML = '<text x="50%" y="50%" text-anchor="middle" fill="#999">No trace data available. Complete at least one hop to generate flow diagram.</text>';
                }
            },
            'traces': () => {
                if (typeof renderHops !== 'undefined') renderHops();
            }
        };
        
        // switchTab is already defined globally earlier

        function addVictim() {
            const victimId = investigation.victims.length + 1;
            const victim = {
                id: victimId,
                isCompleted: false,  // Initialize completion state
                name: '',  // Initialize name
                transactions: [{
                    id: 1,
                    txHash: '',  // Initialize txHash
                    amount: '',
                    currency: 'USD',
                    customCurrency: '',
                    receivingWallet: '',
                    datetime: '',
                    timezone: 'UTC',
                    notes: ''
                }]
            };
            investigation.victims.push(victim);
            renderVictims();
            saveToStorage();
            updateWorkflowSteps();
        }

        function addTransaction(victimId) {
            const victim = investigation.victims.find(v => v.id === victimId);
            const transactionId = victim.transactions.length + 1;
            victim.transactions.push({
                id: transactionId,
                txHash: '',
                amount: '',
                currency: 'USD',
                customCurrency: '',
                receivingWallet: '',
                datetime: '',
                timezone: 'UTC',
                notes: ''
            });
            renderVictims();
            saveToStorage();
            updateWorkflowSteps();
        }
        
        // Check if a transaction hash already exists across all victims
        function checkTransactionDuplicate(txHash, excludeVictimId, excludeTransactionId) {
            if (!txHash || txHash.trim() === '') return null;
            
            const normalizedHash = txHash.trim().toLowerCase();
            
            for (const victim of investigation.victims) {
                for (const transaction of victim.transactions) {
                    // Skip the current transaction being edited
                    if (victim.id === excludeVictimId && transaction.id === excludeTransactionId) {
                        continue;
                    }
                    
                    if (transaction.txHash && transaction.txHash.trim().toLowerCase() === normalizedHash) {
                        return {
                            victimId: victim.id,
                            transactionId: transaction.id,
                            victimName: victim.name || `Victim ${victim.id}`
                        };
                    }
                }
            }
            
            return null;
        }

        function sortTransactionsChronologically() {
            // Sort all transactions across all victims by datetime
            investigation.victims.forEach(victim => {
                // Sort this victim's transactions by datetime
                victim.transactions.sort((a, b) => {
                    // Handle empty dates - put them at the end
                    if (!a.datetime && !b.datetime) return 0;
                    if (!a.datetime) return 1;
                    if (!b.datetime) return -1;
                    
                    // Convert to comparable dates considering timezone
                    const dateA = new Date(a.datetime + ' ' + (a.timezone || 'UTC'));
                    const dateB = new Date(b.datetime + ' ' + (b.timezone || 'UTC'));
                    
                    return dateA - dateB;
                });
                
                // Re-assign transaction IDs based on new order
                victim.transactions.forEach((transaction, index) => {
                    transaction.id = index + 1;
                });
            });
            
            // Save the reordered data
            saveToStorage();
        }
        
        function fixVictimTransactionOrder(victimId) {
            const victim = investigation.victims.find(v => v.id === victimId);
            if (!victim) return;
            
            // Count transactions with dates
            const transactionsWithDates = victim.transactions.filter(t => t.datetime && t.datetime.trim() !== '').length;
            const totalTransactions = victim.transactions.length;
            
            if (transactionsWithDates === 0) {
                alert('No transactions have dates. Please add dates to transactions before sorting.');
                return;
            }
            
            if (transactionsWithDates < totalTransactions) {
                if (!confirm(`${totalTransactions - transactionsWithDates} transaction(s) are missing dates and will be placed at the end. Continue?`)) {
                    return;
                }
            }
            
            // Save undo state
            saveUndoState(`Fix transaction order for Victim ${victimId}`);
            
            // Sort this victim's transactions by datetime
            victim.transactions.sort((a, b) => {
                // Handle empty dates - put them at the end
                if (!a.datetime && !b.datetime) return 0;
                if (!a.datetime) return 1;
                if (!b.datetime) return -1;
                
                // Convert to UTC timestamps for accurate comparison
                const timestampA = convertToUTC(a.datetime, a.timezone || 'UTC');
                const timestampB = convertToUTC(b.datetime, b.timezone || 'UTC');
                
                return timestampA - timestampB;
            });
            
            // Re-assign transaction IDs based on new order
            victim.transactions.forEach((transaction, index) => {
                transaction.id = index + 1;
            });
            
            // If root total was confirmed, we need to rebuild indexes
            if (investigation.rootTotalConfirmed) {
                buildUniversalWalletIndex();
                buildRedWalletIndex();
                buildAvailableThreadsIndex();
            }
            
            // Re-render
            renderVictims();
            saveToStorage();
            updateWorkflowSteps();
            
            alert(` Transaction order fixed for Victim ${victimId}.\n\nTransactions have been renumbered in chronological order (T1, T2, T3, etc.).`);
        }

        function renderVictims() {
    const container = document.getElementById('victimsList');
    container.innerHTML = '';
    
    // Show/hide instructions based on victim count
    const instructionsDiv = document.getElementById('victimInstructions');
    if (instructionsDiv) {
        if (investigation.victims.length > 0) {
            instructionsDiv.style.display = 'none';
        } else {
            instructionsDiv.style.display = 'block';
        }
    }
    
    // First, sort all transactions chronologically
    sortTransactionsChronologically();

    investigation.victims.forEach(victim => {
        const victimDiv = document.createElement('div');
        victimDiv.className = 'trace-entry';
        
        // Check for chronology errors in this victim's transactions
        const chronologyError = validateTransactionChronology(victim);
        
        // Check if victim is completed (minimized)
        const isMinimized = victim.isCompleted || false;
        
        // Calculate victim total losses by currency
        const totalsByCurrency = {};
        victim.transactions.forEach(t => {
            if (parseFloat(t.amount) > 0) {
                const currency = t.currency === 'CUSTOM' ? t.customCurrency : t.currency;
                if (!totalsByCurrency[currency]) {
                    totalsByCurrency[currency] = 0;
                }
                totalsByCurrency[currency] += parseFloat(t.amount);
            }
        });

        // Format totals display
        const totalsDisplay = Object.entries(totalsByCurrency)
            .map(([currency, amount]) => `${formatNumber(amount)} ${currency}`)
            .join(' | ');

        // Count valid transactions
        const validTransactions = victim.transactions.filter(t =>
            parseFloat(t.amount) > 0 && t.receivingWallet && t.receivingWallet.trim() !== ''
        ).length;

        victimDiv.innerHTML = `
            <div class="trace-header" style="background: ${isMinimized ? '#e8f5e9' : '#fff3e0'}; border: 2px solid ${isMinimized ? '#4caf50' : '#ff9800'};">
                <h3>Victim ${victim.id} ${isMinimized ? `✓ - ${validTransactions} transaction${validTransactions !== 1 ? 's' : ''}, Total Loss: ${totalsDisplay}` : ''}</h3>
                <div>
                    ${!isMinimized ? `<button class="btn btn-success" onclick="completeVictim(${victim.id})" 
                        ${validTransactions === 0 ? 'disabled' : ''} 
                        title="${validTransactions === 0 ? 'Add at least one valid transaction first' : 'Mark this victim as complete'}">
                        ✓ Complete Victim
                    </button>` : 
                    `<button class="btn btn-secondary" onclick="reopenVictim(${victim.id})">
                        Edit
                    </button>`}
                    <button class="btn btn-danger" onclick="removeVictim(${victim.id})">Remove</button>
                </div>
            </div>
            ${!isMinimized ? `
                ${chronologyError ? `
                    <div style="background: #f8d7da; color: #721c24; padding: 15px; margin: 10px 0; border-radius: 4px; border: 1px solid #f5c6cb;">
                        <div style="display: flex; justify-content: space-between; align-items: start;">
                            <div style="flex: 1;">
                                <strong>⚠️ Chronological Order Warning:</strong><br>
                                ${chronologyError.replace(/\n/g, '<br>')}<br><br>
                                <em style="font-size: 12px;">Transactions must be numbered in chronological order for PIFO (Proceeds In First Out) compliance.</em>
                            </div>
                            <button class="btn btn-sm btn-warning" onclick="fixVictimTransactionOrder(${victim.id})" 
                                    style="background: #f39c12; color: white; white-space: nowrap; margin-left: 15px;">
                                🔧 Fix Order
                            </button>
                        </div>
                    </div>
                ` : ''}
                ${victim.transactions.map(transaction => {
                const hasAmount = parseFloat(transaction.amount) > 0;
                const hasWallet = transaction.receivingWallet && transaction.receivingWallet.trim() !== '';
                const isIncomplete = hasAmount && !hasWallet;
                
                return `
                    <div style="background: ${isIncomplete ? '#fff3cd' : 'white'}; padding: 15px; border-radius: 8px; margin-bottom: 10px; border: ${isIncomplete ? '2px solid #ffc107' : '1px solid #e8f0fe'};">
                        ${isIncomplete ? '<div style="color: #856404; font-weight: bold; margin-bottom: 10px;">⚠️ Missing receiving wallet address!</div>' : ''}
                        <div class="trace-notation">V${victim.id}-T${transaction.id}</div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 10px;">
                            <div class="form-group" style="grid-column: span 2; background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%); padding: 20px; border-radius: 8px; border: 2px solid #2196f3; margin-bottom: 15px;">
                                <label style="font-weight: bold; color: #0d47a1; font-size: 16px;">Transaction Hash (Start Here)</label>
                                <div style="display: flex; gap: 10px; align-items: center; margin-bottom: 10px;">
                                    <input type="text"
                                           id="txHash_victim_${victim.id}_${transaction.id}"
                                           value="${transaction.txHash || ''}"
                                           placeholder="Paste transaction hash to auto-fill details"
                                           onchange="updateTransaction(${victim.id}, ${transaction.id}, 'txHash', this.value)"
                                           style="flex: 1; font-size: 16px; padding: 14px; border: 2px solid #2196f3;">
                                    <button type="button" class="btn btn-sm btn-primary"
                                            onclick="lookupVictimTransaction(${victim.id}, ${transaction.id})"
                                            style="padding: 10px 20px; font-size: 16px; background: #2196f3;">
                                        🔍 Lookup
                                    </button>
                                </div>
                                <div style="display: flex; gap: 10px; align-items: center;">
                                    <label style="color: #0d47a1; margin-right: 10px;">Chain:</label>
                                    <select id="chain_victim_${victim.id}_${transaction.id}"
                                            onchange="updateTransaction(${victim.id}, ${transaction.id}, 'chain', this.value)"
                                            style="flex: 1; padding: 8px; border: 2px solid #2196f3; border-radius: 4px; background: white;">
                                        <option value="">Auto-detect</option>
                                        <option value="bitcoin">Bitcoin</option>
                                        <option value="ethereum">Ethereum</option>
                                        <option value="bsc">BNB Chain</option>
                                        <option value="polygon">Polygon</option>
                                        <option value="arbitrum">Arbitrum</option>
                                        <option value="optimism">Optimism</option>
                                        <option value="base">Base</option>
                                        <option value="avalanche">Avalanche</option>
                                        <option value="hyperevm">HyperEVM</option>
                                        <option value="linea">Linea</option>
                                        <option value="scroll">Scroll</option>
                                        <option value="mantle">Mantle</option>
                                        <option value="blast">Blast</option>
                                        <option value="zksync">zkSync</option>
                                        <option value="gnosis">Gnosis</option>
                                        <option value="tron">Tron</option>
                                        <option value="solana">Solana</option>
                                    </select>
                                </div>
                                <div style="font-size: 12px; color: #0d47a1; margin-top: 8px;">Paste the transaction hash and click Lookup to automatically fetch transaction details</div>
                            </div>
                            <div class="form-group">
                                <label>Amount</label>
                                <input type="number" 
                                       id="amount_victim_${victim.id}_${transaction.id}"
                                       step="${getCurrencyStep(transaction.currency)}" 
                                       value="${transaction.amount}" 
                                       onchange="updateTransaction(${victim.id}, ${transaction.id}, 'amount', this.value)"
                                       title="${transaction.currency} supports ${getCurrencyDecimals(transaction.currency)} decimal places">
                            </div>
                            <div class="form-group">
                                <label>Currency</label>
                                <select id="currency_victim_${victim.id}_${transaction.id}"
                                        onchange="updateTransactionCurrency(${victim.id}, ${transaction.id}, this.value)">
                                    <option value="USD" ${transaction.currency === 'USD' ? 'selected' : ''}>US Dollar</option>
                                    <option value="BTC" ${transaction.currency === 'BTC' ? 'selected' : ''}>Bitcoin</option>
                                    <option value="ETH" ${transaction.currency === 'ETH' ? 'selected' : ''}>Ethereum</option>
                                    <option value="USDT" ${transaction.currency === 'USDT' ? 'selected' : ''}>Tether</option>
                                    <option value="USDC" ${transaction.currency === 'USDC' ? 'selected' : ''}>USD Coin</option>
                                    <option value="TRX" ${transaction.currency === 'TRX' ? 'selected' : ''}>TRON</option>
                                    <option value="SOL" ${transaction.currency === 'SOL' ? 'selected' : ''}>Solana</option>
                                    <option value="ADA" ${transaction.currency === 'ADA' ? 'selected' : ''}>Cardano</option>
                                    <option value="DAI" ${transaction.currency === 'DAI' ? 'selected' : ''}>DAI</option>
                                    <option value="BNB" ${transaction.currency === 'BNB' ? 'selected' : ''}>BNB</option>
                                    <option value="MATIC" ${transaction.currency === 'MATIC' ? 'selected' : ''}>MATIC</option>
                                    <option value="AVAX" ${transaction.currency === 'AVAX' ? 'selected' : ''}>AVAX</option>
                                    <option value="HYPE" ${transaction.currency === 'HYPE' ? 'selected' : ''}>HYPE</option>
                                    <option value="MNT" ${transaction.currency === 'MNT' ? 'selected' : ''}>MNT</option>
                                    <option value="CUSTOM" ${transaction.currency === 'CUSTOM' ? 'selected' : ''}>Custom Currency</option>
                                </select>
                            </div>
                            <div class="form-group" style="grid-column: span 2;">
                                <label style="color: ${isIncomplete ? '#dc3545' : 'inherit'}; font-weight: ${isIncomplete ? 'bold' : 'normal'};">
                                    Receiving Wallet Address (RED Wallet) ${isIncomplete ? '- REQUIRED' : ''}
                                </label>
                                <input type="text" 
                                       id="receivingWallet_victim_${victim.id}_${transaction.id}"
                                       value="${transaction.receivingWallet || ''}" 
                                       placeholder="Wallet address that received victim's funds"
                                       style="border-color: ${isIncomplete ? '#dc3545' : '#e8f0fe'};"
                                       onchange="updateTransaction(${victim.id}, ${transaction.id}, 'receivingWallet', this.value)">
                            </div>
                            <div class="form-group ${transaction.currency === 'CUSTOM' ? '' : 'custom-currency-input'}" 
                                 id="customCurrency_${victim.id}_${transaction.id}">
                                <label>Custom Currency Symbol</label>
                                <input type="text" value="${transaction.customCurrency || ''}" 
                                       placeholder="e.g., DOGE, SHIB"
                                       onchange="updateTransaction(${victim.id}, ${transaction.id}, 'customCurrency', this.value)">
                            </div>
                            <div class="form-group">
                                <label>Date & Time with Timezone</label>
                                <div class="datetime-timezone">
                                    <input type="datetime-local" 
                                           id="datetime_victim_${victim.id}_${transaction.id}"
                                           value="${transaction.datetime}" 
                                           onchange="updateTransaction(${victim.id}, ${transaction.id}, 'datetime', this.value)">
                                    <select id="timezone_victim_${victim.id}_${transaction.id}"
                                            onchange="onTimezoneChange('datetime_victim_${victim.id}_${transaction.id}', 'victim', ${victim.id}, ${transaction.id})">
                                        ${Object.entries(timezones).map(([key, value]) => 
                                            `<option value="${key}" ${transaction.timezone === key ? 'selected' : ''}>${value}</option>`
                                        ).join('')}
                                    </select>
                                </div>
                            </div>
                            <div class="form-group" style="grid-column: span 2;">
                                <label>Notes</label>
                                <input type="text" value="${transaction.notes}" 
                                       placeholder="Payment description, method, etc."
                                       onchange="updateTransaction(${victim.id}, ${transaction.id}, 'notes', this.value)">
                            </div>
                        </div>
                    </div>
                `.trim();
            }).join('')}` : ''}
            ${!isMinimized ? `
                <button class="btn btn-add-transaction" onclick="addTransaction(${victim.id})">+ Add Transaction</button>
                <button class="btn btn-secondary" onclick="openBulkTransactionModal(${victim.id})">📋 Bulk Add Transactions</button>
                <div style="text-align: center; margin-top: 20px; padding-top: 20px; border-top: 2px solid #e0e0e0;">
                    <button class="btn btn-success" onclick="completeVictim(${victim.id})" 
                        ${validTransactions === 0 ? 'disabled' : ''} 
                        title="${validTransactions === 0 ? 'Add at least one valid transaction first' : 'Mark this victim as complete'}"
                        style="padding: 12px 30px; font-size: 16px;">
                        ✓ Complete Victim
                    </button>
                </div>
            ` : `
                <div style="padding: 15px; background: white; border-radius: 6px; margin-top: 10px;">
                    <h4 style="margin-bottom: 10px; color: #2c3e50;">Transaction Summary:</h4>
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr style="background: #f8f9fa;">
                                <th style="padding: 8px; text-align: left; border: 1px solid #ddd;">V-T</th>
                                <th style="padding: 8px; text-align: left; border: 1px solid #ddd;">Date</th>
                                <th style="padding: 8px; text-align: right; border: 1px solid #ddd;">Amount</th>
                                <th style="padding: 8px; text-align: left; border: 1px solid #ddd;">Asset</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${victim.transactions.filter(t => parseFloat(t.amount) > 0).map(transaction => `
                                <tr>
                                    <td style="padding: 8px; border: 1px solid #ddd;">V${victim.id}-T${transaction.id}</td>
                                    <td style="padding: 8px; border: 1px solid #ddd;">${transaction.datetime || 'N/A'}</td>
                                    <td style="padding: 8px; text-align: right; border: 1px solid #ddd;">${formatNumber(transaction.amount)}</td>
                                    <td style="padding: 8px; border: 1px solid #ddd;">${transaction.currency === 'CUSTOM' ? transaction.customCurrency : transaction.currency}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                        <tfoot>
                            <tr style="background: #e8f4f8; font-weight: bold;">
                                <td colspan="2" style="padding: 8px; border: 1px solid #ddd;">Total Loss:</td>
                                <td colspan="2" style="padding: 8px; border: 1px solid #ddd;">${totalsDisplay || '0'}</td>
                            </tr>
                        </tfoot>
                    </table>
                </div>
            `}
        `;
        container.appendChild(victimDiv);
    });
    
    // Update Add New Victim button visibility
    const addVictimSection = document.getElementById('addVictimSection');
    if (addVictimSection) {
        // Always show the Add New Victim button - no restrictions
        addVictimSection.innerHTML = `
            <button class="btn" onclick="addVictim()"
                    style="font-size: 1rem; padding: 10px 25px; background: #3498db; color: white;">
                + Add ${investigation.victims.length > 0 ? 'Another' : 'New'} Victim
            </button>
        `;
    }
    
    updateGenerateRootSection();
}

        function updateTransactionCurrency(victimId, transactionId, currency) {
            updateTransaction(victimId, transactionId, 'currency', currency);
            
            const customInput = document.getElementById(`customCurrency_${victimId}_${transactionId}`);
            if (currency === 'CUSTOM') {
                customInput.style.display = 'block';
                customInput.classList.remove('custom-currency-input');
            } else {
                customInput.style.display = 'none';
                customInput.classList.add('custom-currency-input');
            }
            
            // Update the amount input step based on new currency
            const amountInput = document.querySelector(`input[onchange*="updateTransaction(${victimId}, ${transactionId}, 'amount'"]`);
            if (amountInput) {
                amountInput.step = getCurrencyStep(currency);
                
                // Show currency info tooltip
                const decimals = getCurrencyDecimals(currency);
                amountInput.title = `${currencies[currency]?.name || currency} supports ${decimals} decimal places`;
            }
            
            // Trigger recalculation of any dependent calculations
            updateWorkflowSteps();
            saveToStorage();
            
            // Log for debugging currency issues
            console.log(`Currency updated for victim ${victimId}, transaction ${transactionId}: ${currency}`);
        }

        function generateRootTotal() {
    // Check if file has been saved
    if (!savedFilePath) {
        document.getElementById('saveRequiredMessage').style.display = 'block';
        document.getElementById('generateRootBtn').style.display = 'none';
        return;
    }
    
    // NEW VALIDATION: Check for missing wallet addresses before generating root total
    const missingWallets = [];
    investigation.victims.forEach(victim => {
        victim.transactions.forEach(transaction => {
            if (parseFloat(transaction.amount) > 0 && (!transaction.receivingWallet || transaction.receivingWallet.trim() === '')) {
                missingWallets.push(`V${victim.id}-T${transaction.id}`);
            }
        });
    });
    
    if (missingWallets.length > 0) {
        alert(`ERROR:  Cannot generate root total: Missing receiving wallet addresses for the following transactions:\n\n${missingWallets.join(', ')}\n\nPlease add receiving wallet addresses for all transactions with amounts before confirming your root total.`);
        return;
    }
    
    // Check chronological order for each victim
    const chronologyErrors = [];
    investigation.victims.forEach(victim => {
        const error = validateTransactionChronology(victim);
        if (error) {
            chronologyErrors.push(error);
        }
    });
    
    if (chronologyErrors.length > 0) {
        const shouldFix = confirm(`❌ Transaction chronology errors detected!\n\n${chronologyErrors.join('\n\n')}\n\nTransactions must be in chronological order for PIFO compliance.\n\nWould you like to automatically fix the order for all victims?\n\nClick OK to reorder all transactions chronologically.\nClick Cancel to fix manually.`);
        
        if (shouldFix) {
            // Fix order for all victims with errors
            investigation.victims.forEach(victim => {
                const error = validateTransactionChronology(victim);
                if (error) {
                    fixVictimTransactionOrder(victim.id);
                }
            });
            
            // Try to generate root total again - using longer delay to avoid race conditions
            setTimeout(() => generateRootTotal(), 500);
            return;
        } else {
            return;
        }
    }
    
    const totalsByCurrency = {};
    
    // Calculate totals by currency
    investigation.victims.forEach(victim => {
        victim.transactions.forEach(transaction => {
            if (parseFloat(transaction.amount) > 0) {
                const currency = transaction.currency === 'CUSTOM' ? transaction.customCurrency : transaction.currency;
                if (!totalsByCurrency[currency]) {
                    totalsByCurrency[currency] = 0;
                }
                totalsByCurrency[currency] += parseFloat(transaction.amount);
            }
        });
    });
    
    if (Object.keys(totalsByCurrency).length === 0) {
        alert('Please add at least one victim transaction with an amount before generating root total.');
        return;
    }

    // Display totals by currency
    let totalDisplay = '';
    Object.entries(totalsByCurrency).forEach(([currency, amount]) => {
        totalDisplay += `<div style="font-size: 1.8rem; font-weight: bold; color: #27ae60; margin: 10px 0;">${amount.toLocaleString()} ${currency}</div>`;
    });
    
    document.getElementById('totalRootAmount').innerHTML = totalDisplay;
    
    // Add visual progress bars for root total
    let progressBars = '<div style="background: white; padding: 20px; border-radius: 8px; margin: 15px 0; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">';
    progressBars += '<h4 style="margin-bottom: 15px; color: #2c3e50;">📊 Investigation Progress Overview</h4>';
    progressBars += '<p style="color: #666; margin-bottom: 15px; font-size: 14px;">These bars will track your progress as you trace funds through the investigation.</p>';
    
    Object.entries(totalsByCurrency).forEach(([currency, total]) => {
        progressBars += `
            <div style="margin-bottom: 20px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <strong style="font-size: 16px;">${currency}</strong>
                    <span style="font-size: 14px; color: #666;">
                        ${total.toLocaleString()} total
                    </span>
                </div>
                
                <!-- Progress Bar Preview -->
                <div style="position: relative; height: 35px; background: #f5f5f5; border-radius: 20px; overflow: hidden; box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);">
                    <!-- Starting state - all red (unaccounted) -->
                    <div style="position: absolute; left: 0; top: 0; height: 100%; width: 100%; background: #e74c3c;"
                         title="All funds currently unaccounted">
                    </div>
                    
                    <!-- Label -->
                    <div style="position: absolute; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; pointer-events: none;">
                        <span style="color: white; font-size: 12px; font-weight: bold; text-shadow: 1px 1px 2px rgba(0,0,0,0.3);">
                            100% Unaccounted
                        </span>
                    </div>
                </div>
                
                <!-- Legend Preview -->
                <div style="display: flex; gap: 20px; margin-top: 10px; font-size: 12px; flex-wrap: wrap;">
                    <span style="display: flex; align-items: center; gap: 5px;">
                        <span style="width: 14px; height: 14px; background: #27ae60; border-radius: 3px;"></span>
                        Will show traced funds
                    </span>
                    <span style="display: flex; align-items: center; gap: 5px;">
                        <span style="width: 14px; height: 14px; background: #9b59b6; border-radius: 3px;"></span>
                        Will show exchange/VASP
                    </span>
                    <span style="display: flex; align-items: center; gap: 5px;">
                        <span style="width: 14px; height: 14px; background: #3498db; border-radius: 3px;"></span>
                        Will show cold storage
                    </span>
                    <span style="display: flex; align-items: center; gap: 5px;">
                        <span style="width: 14px; height: 14px; background: #95a5a6; border-radius: 3px;"></span>
                        Will show write-offs
                    </span>
                </div>
            </div>
        `;
    });
    
    progressBars += '</div>';
    
    let breakdown = progressBars;
    breakdown += '<div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 15px 0; border: 1px solid #ddd;">';
    breakdown += '<h4 style="margin-bottom: 15px; color: #2c3e50;">📋 Transaction Breakdown by Currency:</h4>';
    
    investigation.victims.forEach(victim => {
        breakdown += `<div style="margin-bottom: 15px; padding: 10px; background: white; border-radius: 6px; border-left: 4px solid #3498db;">`;
        breakdown += `<div style="font-weight: bold; color: #2c3e50; margin-bottom: 8px;">👤 Victim ${victim.id}:</div>`;
        victim.transactions.forEach(transaction => {
            if (parseFloat(transaction.amount) > 0) {
                const currency = transaction.currency === 'CUSTOM' ? transaction.customCurrency : transaction.currency;
                const timeDisplay = transaction.datetime ? 
                    `${transaction.datetime} ${transaction.timezone}` : 
                    'No timestamp';
                breakdown += `<div style="margin-left: 20px; margin-bottom: 5px; color: #34495e;">`;
                breakdown += `<strong>V${victim.id}-T${transaction.id}:</strong> ${parseFloat(transaction.amount).toLocaleString()} ${currency}`;
                breakdown += `<br><small style="color: #7f8c8d;">VASP: ${transaction.receivingWallet}</small>`;
                breakdown += `<br><small style="color: #7f8c8d;">⏰ ${timeDisplay}</small>`;
                if (transaction.notes) {
                    breakdown += `<br><small style="color: #7f8c8d;">📝 ${transaction.notes}</small>`;
                }
                breakdown += `</div>`;
            }
        });
        breakdown += `</div>`;
    });
    breakdown += '</div>';
    
    document.getElementById('rootTotalBreakdown').innerHTML = breakdown;
    showModal('rootTotalModal');
}

        function confirmAndProceed() {
            try {
                console.log('Starting confirmAndProceed...');
                
                investigation.rootTotalConfirmed = true;
                
                // Store confirmed root totals by currency
                investigation.confirmedRootTotalsByCurrency = {};
                investigation.victims.forEach(victim => {
                    victim.transactions.forEach(transaction => {
                        if (parseFloat(transaction.amount) > 0) {
                            const currency = transaction.currency === 'CUSTOM' ? transaction.customCurrency : transaction.currency;
                            if (!investigation.confirmedRootTotalsByCurrency[currency]) {
                                investigation.confirmedRootTotalsByCurrency[currency] = 0;
                            }
                            investigation.confirmedRootTotalsByCurrency[currency] += parseFloat(transaction.amount);
                        }
                    });
                });
                
                console.log('Root totals by currency:', investigation.confirmedRootTotalsByCurrency);
                
                // Keep legacy confirmedRootTotal for backward compatibility (sum of all)
                investigation.confirmedRootTotal = Object.values(investigation.confirmedRootTotalsByCurrency).reduce((sum, amount) => sum + amount, 0);
                
                // Initialize currentART with the confirmed root totals
                investigation.currentART = {...investigation.confirmedRootTotalsByCurrency};
                
                console.log('Total root amount:', investigation.confirmedRootTotal);
                console.log('Current ART:', investigation.currentART);
                
                // Build Universal Wallet Index and Red Wallet Index from victim transactions
                console.log('Building wallet indexes...');
                buildUniversalWalletIndex();
                buildRedWalletIndex();
                
                // Close modal first
                console.log('Closing modal...');
                closeModal();
                
                // Update various statuses
                console.log('Updating statuses...');
                updateValidationStatus();
                updateWorkflowSteps();
                updateGenerateRootSection();
                saveToStorage();
                
                // Auto-save investigation
                console.log('Auto-saving investigation...');
                saveInvestigation();
            
            // Switch to traces tab
            try {
                switchTab('traces');
                
                // Force re-render hops to show ready state
                renderHops();
                
                // Show success message with clear next steps
                setTimeout(() => {
                    alert('✅ Root Total Confirmed!\n\n' +
                          'Your investigation baseline has been established.\n\n' +
                          '🎯 NEXT STEP:\n' +
                          'You will now be taken to the Trace Documentation tab.\n' +
                          'Click "Create Hop 1" to start tracking where the funds went from the RED wallets.\n\n' +
                          'Hop 1 = First movement of funds AFTER leaving the RED wallets');
                }, 100);
            } catch (error) {
                console.error('Error switching to traces tab:', error);
                alert('Root total confirmed, but there was an error switching tabs. Please manually click on "Trace Documentation" to continue.');
            }
            
            } catch (error) {
                console.error('Error in confirmAndProceed:', error);
                alert(`An error occurred while confirming the root total:\n\n${error.message}\n\nPlease check the console for more details.`);
                
                // Try to save what we can
                try {
                    investigation.rootTotalConfirmed = true;
                    saveToStorage();
                } catch (saveError) {
                    console.error('Error saving after error:', saveError);
                }
            }
        }

        function buildRedWalletIndex() {
            investigation.redWalletIndex = [];

            // Ensure universal index is up to date first
            if (!investigation.universalWalletIndex || investigation.universalWalletIndex.length === 0) {
                buildUniversalWalletIndex();
            }

            investigation.victims.forEach(victim => {
                victim.transactions.forEach(transaction => {
                    const amount = parseAmount(transaction.amount);
                    if (amount > 0 && transaction.receivingWallet) {
                        const currency = transaction.currency === 'CUSTOM' ? transaction.customCurrency : transaction.currency;
                        const walletAddress = transaction.receivingWallet.trim();

                        // Find corresponding wallet ID from universal index
                        let walletId = '';
                        const universalEntry = investigation.universalWalletIndex.find(w => w.address === walletAddress);
                        if (universalEntry) {
                            walletId = universalEntry.permanentId;
                        } else {
                            // If not found, rebuild universal index and try again
                            console.warn(`Wallet ${walletAddress} not found in universal index, rebuilding...`);
                            buildUniversalWalletIndex();
                            const retryEntry = investigation.universalWalletIndex.find(w => w.address === walletAddress);
                            if (retryEntry) {
                                walletId = retryEntry.permanentId;
                            }
                        }

                        const redEntry = {
                            id: investigation.redWalletIndex.length + 1,
                            vtNotation: `V${victim.id}-T${transaction.id}`,
                            walletId: walletId,
                            walletAddress: walletAddress,
                            depositDate: transaction.datetime,
                            timezone: transaction.timezone,
                            amount: amount,
                            currency: currency,
                            notes: transaction.notes || '',
                            investigativeNotes: '' // For additional investigative findings
                        };

                        investigation.redWalletIndex.push(redEntry);
                    }
                });
            });
        }

        // REPLACE the existing renderRedWalletIndex() function with this:

function renderPurpleWalletIndex() {
    const container = document.getElementById('purpleWalletIndexList');
    
    // Filter only purple wallets from the universal index
    const purpleWallets = (investigation.universalWalletIndex || []).filter(wallet => 
        wallet.permanentType === 'purple'
    );
    
    if (purpleWallets.length === 0) {
        container.innerHTML = `
            <div class="no-traces-message">
                <h3>No Exchange Wallets Identified</h3>
                <p>No PURPLE (exchange) wallets have been identified yet. These are typically identified during trace documentation when funds reach known exchanges.</p>
            </div>
        `;
        return;
    }
    
    let tableHTML = `
        <table style="width: 100%; border-collapse: collapse;">
            <thead>
                <tr style="background: #f8f9fa;">
                    <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Exchange ID</th>
                    <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Exchange Name</th>
                    <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Wallet Address</th>
                    <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">First Seen</th>
                    <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Total Received</th>
                    <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Notes</th>
                </tr>
            </thead>
            <tbody>
    `;
    
    purpleWallets.forEach(wallet => {
        // Calculate total received by this wallet from hop entries
        const receivedAmounts = {};
        investigation.hops.forEach(hop => {
            hop.entries.forEach(entry => {
                if (entry.toWallet === wallet.address && entry.amount) {
                    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                    if (!receivedAmounts[currency]) {
                        receivedAmounts[currency] = 0;
                    }
                    receivedAmounts[currency] += parseFloat(entry.amount);
                }
            });
        });
        
        const totalDisplay = Object.entries(receivedAmounts)
            .map(([currency, amount]) => `${amount.toLocaleString()} ${currency}`)
            .join(', ') || 'No deposits tracked';
        
        tableHTML += `
            <tr>
                <td style="border: 1px solid #ddd; padding: 12px;">
                    <div class="wallet-display purple" style="margin: 0;">${wallet.permanentId}</div>
                </td>
                <td style="border: 1px solid #ddd; padding: 12px;">
                    <input type="text" value="${wallet.exchangeName || ''}" 
                           placeholder="Enter exchange name..."
                           style="width: 100%; padding: 4px; border: 1px solid #ddd; border-radius: 3px;"
                           onchange="updateWalletExchangeName('${wallet.address}', this.value)">
                </td>
                <td style="border: 1px solid #ddd; padding: 12px; font-family: monospace; font-size: 11px;">${wallet.address}</td>
                <td style="border: 1px solid #ddd; padding: 12px;">${wallet.firstSeenHop || 'Unknown'}</td>
                <td style="border: 1px solid #ddd; padding: 12px;">${totalDisplay}</td>
                <td style="border: 1px solid #ddd; padding: 12px;">
                    <textarea placeholder="Legal service notes, subpoena info, etc." 
                              style="width: 100%; min-height: 60px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;"
                              onchange="updateWalletNotes('${wallet.address}', this.value)">${wallet.notes || ''}</textarea>
                </td>
            </tr>
        `;
    });
    
    tableHTML += `
            </tbody>
        </table>
    `;
    
    container.innerHTML = tableHTML;
}

function renderBlueWalletIndex() {
    const container = document.getElementById('blueWalletIndexList');
    
    // Filter only blue wallets from the universal index
    const blueWallets = (investigation.universalWalletIndex || []).filter(wallet => 
        wallet.permanentType === 'blue'
    );
    
    if (blueWallets.length === 0) {
        container.innerHTML = `
            <div class="no-traces-message">
                <h3>No Cold Storage Wallets Identified</h3>
                <p>No BLUE (cold storage) wallets have been identified yet. These are identified when funds remain stationary at the end of a hop.</p>
            </div>
        `;
        return;
    }
    
    let tableHTML = `
        <table style="width: 100%; border-collapse: collapse;">
            <thead>
                <tr style="background: #f8f9fa;">
                    <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Wallet ID</th>
                    <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Wallet Address</th>
                    <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Amount Held</th>
                    <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Last Activity</th>
                    <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Status</th>
                    <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Monitoring Notes</th>
                </tr>
            </thead>
            <tbody>
    `;
    
    blueWallets.forEach(wallet => {
        // Find cold storage entries for this wallet
        const coldStorageAmounts = {};
        let lastActivity = '';
        
        investigation.hops.forEach(hop => {
            hop.entries.forEach(entry => {
                if (entry.entryType === 'cold_storage' && entry.toWallet === wallet.address && entry.amount) {
                    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                    if (!coldStorageAmounts[currency]) {
                        coldStorageAmounts[currency] = 0;
                    }
                    coldStorageAmounts[currency] += parseFloat(entry.amount);
                    
                    if (entry.timestamp) {
                        lastActivity = `${entry.timestamp} ${entry.timezone || 'UTC'}`;
                    }
                }
            });
        });
        
        const amountDisplay = Object.entries(coldStorageAmounts)
            .map(([currency, amount]) => `${amount.toLocaleString()} ${currency}`)
            .join(', ') || 'No amount recorded';
        
        tableHTML += `
            <tr>
                <td style="border: 1px solid #ddd; padding: 12px;">
                    <div class="wallet-display blue" style="margin: 0;">${wallet.permanentId}</div>
                </td>
                <td style="border: 1px solid #ddd; padding: 12px; font-family: monospace; font-size: 11px;">${wallet.address}</td>
                <td style="border: 1px solid #ddd; padding: 12px; font-weight: bold;">${amountDisplay}</td>
                <td style="border: 1px solid #ddd; padding: 12px;">${lastActivity || 'Unknown'}</td>
                <td style="border: 1px solid #ddd; padding: 12px;">
                    <select onchange="updateWalletStatus('${wallet.address}', this.value)"
                            style="width: 100%; padding: 4px; border: 1px solid #ddd; border-radius: 3px;">
                        <option value="monitoring" ${wallet.status === 'monitoring' ? 'selected' : ''}>🔍 Monitoring</option>
                        <option value="moved" ${wallet.status === 'moved' ? 'selected' : ''}>➡️ Funds Moved</option>
                        <option value="seized" ${wallet.status === 'seized' ? 'selected' : ''}>🔒 Seized</option>
                        <option value="abandoned" ${wallet.status === 'abandoned' ? 'selected' : ''}>❌ Abandoned</option>
                    </select>
                </td>
                <td style="border: 1px solid #ddd; padding: 12px;">
                    <textarea placeholder="Movement alerts, monitoring status, etc." 
                              style="width: 100%; min-height: 60px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;"
                              onchange="updateWalletNotes('${wallet.address}', this.value)">${wallet.notes || ''}</textarea>
                </td>
            </tr>
        `;
    });
    
    tableHTML += `
            </tbody>
        </table>
    `;
    
    container.innerHTML = tableHTML;
}

function renderRedWalletIndex() {
    const container = document.getElementById('redWalletIndexList');
    
    if (investigation.redWalletIndex.length === 0) {
        container.innerHTML = `
            <div class="no-traces-message">
                <h3>Red Wallet Index Not Available</h3>
                <p>${!investigation.rootTotalConfirmed ? 
                    'Please complete victim setup to generate the Red Wallet Index. Note: Full functionality requires confirming the root total.' : 
                    'No victim transactions found. Please add victim transactions first.'}</p>
                <button class="btn btn-confirm" onclick="switchTab('victims'); document.querySelector('[onclick=\\"switchTab(\\'victims\\')\\"]').click();">← Back to Victims & Transactions</button>
            </div>
        `;
        return;
    }
    
    // Group red wallet entries by victim
    const entriesByVictim = {};
    investigation.redWalletIndex.forEach(entry => {
        const victimMatch = entry.vtNotation.match(/^V(\d+)/);
        if (victimMatch) {
            const victimId = victimMatch[1];
            if (!entriesByVictim[victimId]) {
                entriesByVictim[victimId] = [];
            }
            entriesByVictim[victimId].push(entry);
        }
    });
    
    let tablesHTML = '';
    
    // Create a table for each victim
    Object.entries(entriesByVictim).forEach(([victimId, entries]) => {
        // Calculate totals for this victim
        const totalsByCurrency = {};
        entries.forEach(entry => {
            if (!totalsByCurrency[entry.currency]) {
                totalsByCurrency[entry.currency] = 0;
            }
            totalsByCurrency[entry.currency] += entry.amount;
        });
        
        const totalsDisplay = Object.entries(totalsByCurrency)
            .map(([currency, amount]) => `${amount.toLocaleString()} ${currency}`)
            .join(' | ');
        
        tablesHTML += `
            <div style="background: white; border-radius: 8px; padding: 20px; margin-bottom: 30px; box-shadow: 0 2px 10px rgba(0,0,0,0.08);">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 2px solid #e8f0fe;">
                    <div>
                        <h3 style="margin: 0; color: #2c3e50; font-size: 1.5rem;">👤 Victim ${victimId} - Red Wallet Deposits</h3>
                        <div style="margin-top: 8px; color: #666; font-size: 14px;">
                            <strong>Total Deposits:</strong> ${totalsDisplay} | <strong>Transactions:</strong> ${entries.length}
                        </div>
                    </div>
                    <button class="btn btn-success" onclick="exportVictimTableToExcel(${victimId})" style="background: #27ae60;">
                        📊 Export Victim ${victimId} to Excel
                    </button>
                </div>
                
                <table id="victimTable_${victimId}" style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr style="background: #f8f9fa;">
                            <th style="border: 1px solid #ddd; padding: 12px; text-align: left; font-weight: bold;">V-T Notation</th>
                            <th style="border: 1px solid #ddd; padding: 12px; text-align: left; font-weight: bold;">Wallet ID</th>
                            <th style="border: 1px solid #ddd; padding: 12px; text-align: left; font-weight: bold;">Deposit Date</th>
                            <th style="border: 1px solid #ddd; padding: 12px; text-align: left; font-weight: bold;">Amount</th>
                            <th style="border: 1px solid #ddd; padding: 12px; text-align: left; font-weight: bold;">Currency</th>
                            <th style="border: 1px solid #ddd; padding: 12px; text-align: left; font-weight: bold;">Wallet Address</th>
                            <th style="border: 1px solid #ddd; padding: 12px; text-align: left; font-weight: bold;">Notes</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${entries.map(entry => {
                            const dateDisplay = entry.depositDate ? 
                                formatDateTimeForReport(entry.depositDate, entry.timezone) : 
                                'Not specified';
                            
                            return `
                                <tr>
                                    <td style="border: 1px solid #ddd; padding: 12px; font-weight: bold; color: #e74c3c;">${entry.vtNotation}</td>
                                    <td style="border: 1px solid #ddd; padding: 12px;">
                                        <div class="wallet-display red" style="margin: 0;">${entry.walletId || 'Not assigned'}</div>
                                    </td>
                                    <td style="border: 1px solid #ddd; padding: 12px; font-size: 12px;">${dateDisplay}</td>
                                    <td style="border: 1px solid #ddd; padding: 12px; font-weight: bold;">${entry.amount.toLocaleString()}</td>
                                    <td style="border: 1px solid #ddd; padding: 12px;">${entry.currency}</td>
                                    <td style="border: 1px solid #ddd; padding: 12px; font-family: monospace; font-size: 11px; word-break: break-all; max-width: 200px;">${entry.walletAddress}</td>
                                    <td style="border: 1px solid #ddd; padding: 12px;">
                                        <div style="margin-bottom: 8px; font-size: 12px; color: #666;">
                                            <strong>Transaction Notes:</strong> ${entry.notes || 'None'}
                                        </div>
                                        <textarea placeholder="Add investigative notes..." 
                                                  style="width: 100%; min-height: 60px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;"
                                                  onchange="updateRedWalletIndexNotes(${entry.id}, this.value)">${entry.investigativeNotes || ''}</textarea>
                                    </td>
                                </tr>
                            `;
                        }).join('')}
                    </tbody>
                </table>
            </div>
        `;
    });
    
    // Add export all button at the top
    const headerHTML = `
        <div style="background: #e8f4f8; border: 2px solid #3498db; border-radius: 8px; padding: 20px; margin-bottom: 20px; text-align: center;">
            <h4 style="color: #2c3e50; margin-bottom: 15px;">📋 Red Wallet Index - Organized by Victim</h4>
            <p style="color: #2c3e50; margin-bottom: 15px;">Each victim's deposits are shown in separate tables below. Export individual victim data or all data using the buttons.</p>
            <button class="btn btn-success" onclick="exportAllVictimTablesToExcel()" style="background: #27ae60; margin-right: 10px;">
                📊 Export All Victims to Excel
            </button>
            <button class="btn" onclick="exportRedWalletIndexCSV()" style="background: #3498db;">
                Export Summary CSV
            </button>
        </div>
    `;
    
    container.innerHTML = headerHTML + tablesHTML;
}

// Helper functions for wallet updates
function updateWalletExchangeName(address, exchangeName) {
    const wallet = investigation.universalWalletIndex.find(w => w.address === address);
    if (wallet) {
        wallet.exchangeName = exchangeName;
        saveToStorage();
    }
}

function updateWalletStatus(address, status) {
    const wallet = investigation.universalWalletIndex.find(w => w.address === address);
    if (wallet) {
        wallet.status = status;
        saveToStorage();
    }
}

// Export wallet index function
function exportWalletIndex(indexType) {
    let wallets = [];
    let filename = '';
    let headers = '';
    
    if (indexType === 'universal') {
        wallets = investigation.universalWalletIndex || [];
        filename = `Universal_Wallet_Index_${investigation.caseId}_${new Date().toISOString().split('T')[0]}.csv`;
        headers = 'Wallet ID,Type,Address,First Seen,Notes\n';
    } else if (indexType === 'red') {
        // Export red wallet index data
        exportRedWalletIndexCSV();
        return;
    } else if (indexType === 'purple') {
        wallets = (investigation.universalWalletIndex || []).filter(w => w.permanentType === 'purple');
        filename = `Purple_Exchange_Wallets_${investigation.caseId}_${new Date().toISOString().split('T')[0]}.csv`;
        headers = 'Exchange ID,Exchange Name,Address,First Seen,Total Received,Notes\n';
    } else if (indexType === 'blue') {
        wallets = (investigation.universalWalletIndex || []).filter(w => w.permanentType === 'blue');
        filename = `Blue_Cold_Storage_Wallets_${investigation.caseId}_${new Date().toISOString().split('T')[0]}.csv`;
        headers = 'Wallet ID,Address,Amount Held,Status,Notes\n';
    }
    
    if (wallets.length === 0) {
        alert('No wallets found in this index.');
        return;
    }
    
    let csvContent = headers;
    
    wallets.forEach(wallet => {
        if (indexType === 'universal') {
            csvContent += `${escapeCSVCell(wallet.permanentId)},${escapeCSVCell(wallet.permanentType)},${escapeCSVCell(wallet.address)},${escapeCSVCell(wallet.firstSeenHop || 'Unknown')},${escapeCSVCell(wallet.notes || '')}\n`;
        } else if (indexType === 'purple') {
            // Calculate total received
            const receivedAmounts = {};
            investigation.hops.forEach(hop => {
                hop.entries.forEach(entry => {
                    if (entry.toWallet === wallet.address && entry.amount) {
                        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                        if (!receivedAmounts[currency]) {
                            receivedAmounts[currency] = 0;
                        }
                        receivedAmounts[currency] += parseFloat(entry.amount);
                    }
                });
            });
            const totalDisplay = Object.entries(receivedAmounts)
                .map(([currency, amount]) => `${amount.toLocaleString()} ${currency}`)
                .join('; ') || 'None';
            
            csvContent += `${escapeCSVCell(wallet.permanentId)},${escapeCSVCell(wallet.exchangeName || '')},${escapeCSVCell(wallet.address)},${escapeCSVCell(wallet.firstSeenHop || 'Unknown')},${escapeCSVCell(totalDisplay)},${escapeCSVCell(wallet.notes || '')}\n`;
        } else if (indexType === 'blue') {
            // Calculate cold storage amounts
            const coldStorageAmounts = {};
            investigation.hops.forEach(hop => {
                hop.entries.forEach(entry => {
                    if (entry.entryType === 'cold_storage' && entry.toWallet === wallet.address && entry.amount) {
                        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                        if (!coldStorageAmounts[currency]) {
                            coldStorageAmounts[currency] = 0;
                        }
                        coldStorageAmounts[currency] += parseFloat(entry.amount);
                    }
                });
            });
            const amountDisplay = Object.entries(coldStorageAmounts)
                .map(([currency, amount]) => `${amount.toLocaleString()} ${currency}`)
                .join('; ') || 'None';
            
            csvContent += `${escapeCSVCell(wallet.permanentId)},${escapeCSVCell(wallet.address)},${escapeCSVCell(amountDisplay)},${escapeCSVCell(wallet.status || 'monitoring')},${escapeCSVCell(wallet.notes || '')}\n`;
        }
    });
    
    // Download the file
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

// ADD these new functions for Excel export functionality:

function exportVictimTableToExcel(victimId) {
    // Get entries for this specific victim
    const victimEntries = investigation.redWalletIndex.filter(entry => 
        entry.vtNotation.startsWith(`V${victimId}-`)
    );
    
    if (victimEntries.length === 0) {
        alert(`No data found for Victim ${victimId}`);
        return;
    }
    
    // Create CSV content
    let csvContent = 'V-T Notation,Wallet ID,Deposit Date,Amount,Currency,Wallet Address,Transaction Notes,Investigative Notes\n';
    
    victimEntries.forEach(entry => {
        const dateDisplay = entry.depositDate ? formatDateTimeForReport(entry.depositDate, entry.timezone) : 'Not specified';
        const walletId = entry.walletId || 'Not assigned';
        const transactionNotes = (entry.notes || '').replace(/"/g, '""');
        const investigativeNotes = (entry.investigativeNotes || '').replace(/"/g, '""');
        
        csvContent += `"${entry.vtNotation}","${walletId}","${dateDisplay}","${entry.amount}","${entry.currency}","${entry.walletAddress}","${transactionNotes}","${investigativeNotes}"\n`;
    });
    
    // Calculate totals for the filename
    const totalsByCurrency = {};
    victimEntries.forEach(entry => {
        if (!totalsByCurrency[entry.currency]) {
            totalsByCurrency[entry.currency] = 0;
        }
        totalsByCurrency[entry.currency] += entry.amount;
    });
    
    const totalsText = Object.entries(totalsByCurrency)
        .map(([currency, amount]) => `${amount.toLocaleString()}${currency}`)
        .join('_');
    
    const filename = `Victim_${victimId}_Red_Wallets_${totalsText}_${investigation.caseId || 'Case'}_${new Date().toISOString().slice(0,10)}.csv`;
    downloadFile(csvContent, filename, 'text/csv');
}
// ADD this function to your JavaScript section:

function exportUniversalWalletIndex() {
    if (!investigation.universalWalletIndex || investigation.universalWalletIndex.length === 0) {
        alert('No universal wallet data to export');
        return;
    }
    
    // Create CSV content with comprehensive wallet data
    let csvContent = 'Wallet ID,Permanent Classification,Current Status,Wallet Address,First Seen,Total Amount,Currencies,Status History,Exposure Chain Summary,Notes\n';
    
    // Sort wallets by type then by ID (same as display)
    const sortedWallets = [...investigation.universalWalletIndex].sort((a, b) => {
        if (a.permanentType !== b.permanentType) {
            const typeOrder = ['red', 'pink', 'yellow', 'orange', 'brown', 'black', 'blue', 'purple', 'gray', 'green'];
            return typeOrder.indexOf(a.permanentType) - typeOrder.indexOf(b.permanentType);
        }
        return a.permanentId.localeCompare(b.permanentId);
    });
    
    sortedWallets.forEach(wallet => {
        // Format currencies as "BTC: 1.5, USD: 5000"
        const currenciesText = Object.entries(wallet.currencies || {})
            .map(([currency, amount]) => `${currency}: ${amount.toLocaleString()}`)
            .join('; ');
        
        // Format status history
        const statusHistory = (wallet.statusHistory || []).join(' ');
        
        // Format exposure chain summary
        const exposureChainSummary = (wallet.exposureChain || [])
            .map(exp => `${exp.notation}(${exp.amount.toLocaleString()} ${exp.currency})`)
            .join('; ');
        
        // Clean and escape text fields
        const walletId = wallet.permanentId || wallet.id || '';
        const permanentClassification = walletTypes[wallet.permanentType] || wallet.permanentType || '';
        const currentStatus = wallet.currentStatus !== wallet.permanentType ? 
            `${walletTypes[wallet.currentStatus] || wallet.currentStatus} (Currently)` : 
            permanentClassification;
        const address = wallet.address || '';
        const firstSeen = wallet.firstSeen ? 
            (wallet.firstSeenTimezone ? formatDateTimeForReport(wallet.firstSeen, wallet.firstSeenTimezone) : wallet.firstSeen + ' UTC') : '';
        const totalAmount = wallet.totalAmount ? wallet.totalAmount.toLocaleString() : '0';
        const notes = (wallet.notes || '').replace(/"/g, '""').replace(/\n/g, ' ');
        
        csvContent += `"${walletId}","${permanentClassification}","${currentStatus}","${address}","${firstSeen}","${totalAmount}","${currenciesText}","${statusHistory}","${exposureChainSummary}","${notes}"\n`;
    });
    
    const filename = `Universal_Wallet_Index_${investigation.caseId || 'Case'}_${new Date().toISOString().slice(0,10)}.csv`;
    downloadFile(csvContent, filename, 'text/csv');
}

function exportAllVictimTablesToExcel() {
    if (investigation.redWalletIndex.length === 0) {
        alert('No red wallet data to export');
        return;
    }
    
    // Create comprehensive CSV with victim grouping
    let csvContent = 'Victim ID,V-T Notation,Wallet ID,Deposit Date,Amount,Currency,Wallet Address,Transaction Notes,Investigative Notes\n';
    
    // Group by victim and add victim ID column
    const entriesByVictim = {};
    investigation.redWalletIndex.forEach(entry => {
        const victimMatch = entry.vtNotation.match(/^V(\d+)/);
        if (victimMatch) {
            const victimId = victimMatch[1];
            if (!entriesByVictim[victimId]) {
                entriesByVictim[victimId] = [];
            }
            entriesByVictim[victimId].push(entry);
        }
    });
    
    Object.entries(entriesByVictim).forEach(([victimId, entries]) => {
        entries.forEach(entry => {
            const dateDisplay = entry.depositDate ? formatDateTimeForReport(entry.depositDate, entry.timezone) : 'Not specified';
            const walletId = entry.walletId || 'Not assigned';
            const transactionNotes = (entry.notes || '').replace(/"/g, '""');
            const investigativeNotes = (entry.investigativeNotes || '').replace(/"/g, '""');
            
            csvContent += `"${victimId}","${entry.vtNotation}","${walletId}","${dateDisplay}","${entry.amount}","${entry.currency}","${entry.walletAddress}","${transactionNotes}","${investigativeNotes}"\n`;
        });
    });
    
    const filename = `All_Victims_Red_Wallets_${investigation.caseId || 'Case'}_${new Date().toISOString().slice(0,10)}.csv`;
    downloadFile(csvContent, filename, 'text/csv');
}

function exportRedWalletIndexCSV() {
    // Create summary CSV (original format)
    let csvContent = 'V-T Notation,Wallet ID,Deposit Date,Amount,Currency,Wallet Address,Transaction Notes,Investigative Notes\n';
    
    investigation.redWalletIndex.forEach(entry => {
        const dateDisplay = entry.depositDate ? formatDateTimeForReport(entry.depositDate, entry.timezone) : 'Not specified';
        const walletId = entry.walletId || 'Not assigned';
        const transactionNotes = (entry.notes || '').replace(/"/g, '""');
        const investigativeNotes = (entry.investigativeNotes || '').replace(/"/g, '""');
        
        csvContent += `"${entry.vtNotation}","${walletId}","${dateDisplay}","${entry.amount}","${entry.currency}","${entry.walletAddress}","${transactionNotes}","${investigativeNotes}"\n`;
    });
    
    const filename = `Red_Wallet_Index_Summary_${investigation.caseId || 'Case'}_${new Date().toISOString().slice(0,10)}.csv`;
    downloadFile(csvContent, filename, 'text/csv');
}
        function updateRedWalletIndexNotes(entryId, notes) {
            const entry = investigation.redWalletIndex.find(e => e.id === entryId);
            if (entry) {
                entry.investigativeNotes = notes;
                saveToStorage();
            }
        }

        function buildUniversalWalletIndex() {
            investigation.universalWalletIndex = [];
            const walletMap = new Map();
            const colorCounters = {
                red: 1, pink: 1, yellow: 1, orange: 1, brown: 1,
                black: 1, blue: 1, purple: 1, gray: 1, green: 1
            };
            
            // Start with RED wallets from victim transactions
            investigation.victims.forEach(victim => {
                victim.transactions.forEach(transaction => {
                    if (parseFloat(transaction.amount) > 0 && transaction.receivingWallet) {
                        const address = transaction.receivingWallet.trim();
                        
                        if (!walletMap.has(address)) {
                            const walletEntry = {
                                id: `RED ${colorCounters.red}`,
                                permanentId: `RED ${colorCounters.red}`,
                                address: address,
                                permanentType: 'red',
                                currentStatus: 'red',
                                totalAmount: 0,
                                currencies: {},
                                exposureChain: [],
                                firstSeen: `V${victim.id}-T${transaction.id}`,
                                statusHistory: ['red'],
                                isDestination: false,
                                isSource: true,
                                notes: ''
                            };
                            walletMap.set(address, walletEntry);
                            colorCounters.red++;
                        }
                        
                        const wallet = walletMap.get(address);
                        const currency = transaction.currency === 'CUSTOM' ? transaction.customCurrency : transaction.currency;
                        const amount = parseFloat(transaction.amount);
                        
                        if (!wallet.currencies[currency]) {
                            wallet.currencies[currency] = 0;
                        }
                        wallet.currencies[currency] += amount;
                        wallet.totalAmount += amount;
                        
                        // Add exposure chain
                        wallet.exposureChain.push({
                            notation: `V${victim.id}-T${transaction.id}`,
                            amount: amount,
                            currency: currency,
                            type: 'victim_payment'
                        });
                    }
                });
            });
            
            // Process hop entries to build complete wallet index
            investigation.hops.forEach(hop => {
                hop.entries.forEach(entry => {
                    if (entry.entryType === 'trace' && entry.toWallet && parseFloat(entry.amount) > 0) {
                        const address = entry.toWallet.trim();
                        const walletType = entry.toWalletType || 'black';
                        
                        if (!walletMap.has(address)) {
                            // New wallet - BLUE wallets get temporary classification, others get permanent
                            const permanentType = walletType === 'blue' ? 'temporary' : walletType;
                            const walletId = walletType === 'blue' ? 
                                'BLUE (Temporary)' : 
                                `${permanentType.toUpperCase()} ${colorCounters[permanentType]}`;
                            
                            const walletEntry = {
                                id: walletId,
                                permanentId: walletType === 'blue' ? 'BLUE (Temporary)' : `${permanentType.toUpperCase()} ${colorCounters[permanentType]}`,
                                address: address,
                                permanentType: permanentType,
                                currentStatus: walletType,
                                totalAmount: 0,
                                currencies: {},
                                exposureChain: [],
                                firstSeen: entry.notation,
                                statusHistory: [walletType],
                                isDestination: true,
                                isSource: false,
                                notes: ''
                            };
                            walletMap.set(address, walletEntry);
                            
                            // Only increment counter for permanent types
                            if (walletType !== 'blue') {
                                colorCounters[permanentType]++;
                            }
                        } else {
                            // Existing wallet - check if we need to update permanent classification
                            const wallet = walletMap.get(address);
                            
                            // Check if wallet classification should be updated
                            if (wallet.permanentType !== walletType) {
                                // Check if this is an allowed progression
                                if (canChangeWalletClassification(wallet.permanentType, walletType)) {
                                    // For automatic classifications during hop building, skip manual auth
                                    const oldType = wallet.permanentType;
                                    
                                    // Record the automatic change
                                    if (!wallet.classificationHistory) {
                                        wallet.classificationHistory = [];
                                    }
                                    
                                    wallet.classificationHistory.push({
                                        timestamp: new Date().toISOString(),
                                        fromType: oldType,
                                        toType: walletType,
                                        justification: `Automatic classification: ${walletType === 'yellow' ? 'Multiple traces converged at this wallet' : walletType === 'brown' ? 'Asset conversion detected' : 'Behavioral pattern detected'}`,
                                        investigator: investigation.investigator || 'System'
                                    });
                                    
                                    // Update the classification
                                    wallet.permanentType = walletType;
                                    wallet.permanentId = `${walletType.toUpperCase()} ${colorCounters[walletType]}`;
                                    colorCounters[walletType]++;
                                    
                                    // Add to status history
                                    if (!wallet.statusHistory.includes(`Auto-reclassified from ${oldType} to ${walletType}`)) {
                                        wallet.statusHistory.push(`Auto-reclassified from ${oldType} to ${walletType}`);
                                    }
                                }
                            }
                            // Always update current status
                            if (wallet.currentStatus !== walletType) {
                                wallet.currentStatus = walletType;
                                if (!wallet.statusHistory.includes(walletType)) {
                                    wallet.statusHistory.push(walletType);
                                }
                            }
                        }
                        
                        const wallet = walletMap.get(address);
                        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                        const amount = parseFloat(entry.amount);
                        
                        if (!wallet.currencies[currency]) {
                            wallet.currencies[currency] = 0;
                        }
                        wallet.currencies[currency] += amount;
                        wallet.totalAmount += amount;
                        
                        // Add exposure chain
                        wallet.exposureChain.push({
                            notation: entry.notation,
                            amount: amount,
                            currency: currency,
                            type: 'trace_movement',
                            hopNumber: entry.hopNumber
                        });
                        
                        wallet.isDestination = true;
                    }
                });
            });
            
            // Convert map to array
            investigation.universalWalletIndex = Array.from(walletMap.values());
        }

        function renderUniversalWalletIndex() {
            const container = document.getElementById('universalWalletIndexList');
            
            if (!investigation.universalWalletIndex || investigation.universalWalletIndex.length === 0) {
                container.innerHTML = `
                    <div class="no-traces-message">
                        <h3>Universal Wallet Index Empty</h3>
                        <p>The wallet index will be populated as you add victim transactions and trace hops. You can also manually add wallet entries for reference.</p>
                    </div>
                `;
                return;
            }
            
            // Add export button header
            const headerHTML = `
                <div style="background: #e8f4f8; border: 2px solid #3498db; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <h4 style="color: #2c3e50; margin-bottom: 10px;">📋 Universal Wallet Index</h4>
                            <p style="color: #2c3e50; margin: 0;">Complete catalog of all wallets with permanent classifications and investigative notes.</p>
                        </div>
                        <button class="btn btn-success" onclick="exportUniversalWalletIndex()" style="background: #27ae60;">
                            📊 Export to Excel
                        </button>
                    </div>
                </div>
            `;
            
            let tableHTML = `
                <div style="background: white; border-radius: 8px; padding: 20px; box-shadow: 0 2px 10px rgba(0,0,0,0.08);">
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr style="background: #f8f9fa;">
                                <th style="border: 1px solid #ddd; padding: 12px; text-align: left; font-weight: bold;">Wallet ID</th>
                                <th style="border: 1px solid #ddd; padding: 12px; text-align: left; font-weight: bold;">Classification</th>
                                <th style="border: 1px solid #ddd; padding: 12px; text-align: left; font-weight: bold;">Wallet Address</th>
                                <th style="border: 1px solid #ddd; padding: 12px; text-align: left; font-weight: bold;">First Seen</th>
                                <th style="border: 1px solid #ddd; padding: 12px; text-align: left; font-weight: bold;">Notes</th>
                                <th style="border: 1px solid #ddd; padding: 12px; text-align: left; font-weight: bold;">Actions</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            // Sort by wallet type then by ID
            const sortedWallets = [...investigation.universalWalletIndex].sort((a, b) => {
                if (a.permanentType !== b.permanentType) {
                    const typeOrder = ['red', 'pink', 'yellow', 'orange', 'brown', 'black', 'blue', 'purple', 'gray', 'green'];
                    return typeOrder.indexOf(a.permanentType) - typeOrder.indexOf(b.permanentType);
                }
                return a.permanentId.localeCompare(b.permanentId);
            });
            
            sortedWallets.forEach(wallet => {
                const statusIndicator = wallet.currentStatus !== wallet.permanentType ? 
                    ` <span style="background: ${getWalletColor(wallet.currentStatus)}; color: white; padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 8px;">CURRENTLY ${wallet.currentStatus.toUpperCase()}</span>` : '';
                
                tableHTML += `
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 12px;">
                            <div class="wallet-display ${wallet.permanentType}" style="margin: 0;">
                                ${wallet.permanentId}${statusIndicator}
                            </div>
                        </td>
                        <td style="border: 1px solid #ddd; padding: 12px;">
                            ${walletTypes[wallet.permanentType] || wallet.permanentType.toUpperCase()}
                        </td>
                        <td style="border: 1px solid #ddd; padding: 12px; font-family: monospace; font-size: 11px; word-break: break-all; max-width: 250px;">
                            ${wallet.address}
                        </td>
                        <td style="border: 1px solid #ddd; padding: 12px; font-size: 12px;">
                            ${wallet.firstSeen}
                        </td>
                        <td style="border: 1px solid #ddd; padding: 12px;">
                            <textarea placeholder="Add notes about this wallet..." 
                                      style="width: 100%; min-height: 60px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;"
                                      onchange="updateUniversalWalletNotes('${wallet.address}', this.value)">${wallet.notes}</textarea>
                        </td>
                        <td style="border: 1px solid #ddd; padding: 12px; text-align: center;">
                            <button class="btn btn-danger" style="padding: 6px 12px; font-size: 12px;" 
                                    onclick="removeWalletFromIndex('${wallet.address}')">Remove</button>
                        </td>
                    </tr>
                `;
            });
            
            tableHTML += `
                        </tbody>
                    </table>
                </div>
            `;
            
            container.innerHTML = headerHTML + tableHTML;
        }

        function updateUniversalWalletNotes(address, notes) {
            const wallet = investigation.universalWalletIndex.find(w => w.address === address);
            if (wallet) {
                wallet.notes = notes;
                saveToStorage();
            }
        }

        function removeWalletFromIndex(address) {
            if (confirm('Are you sure you want to remove this wallet from the index? This will not affect trace data.')) {
                investigation.universalWalletIndex = investigation.universalWalletIndex.filter(w => w.address !== address);
                renderUniversalWalletIndex();
                saveToStorage();
            }
        }

        function addManualWallet() {
            const address = prompt('Enter wallet address:');
            if (!address || !address.trim()) return;
            
            const walletType = prompt('Enter wallet classification (red, black, blue, etc.):');
            if (!walletType || !walletTypes[walletType.toLowerCase()]) {
                alert('Invalid wallet type. Please use: red, pink, yellow, orange, brown, black, blue, purple, gray, green');
                return;
            }
            
            const type = walletType.toLowerCase();
            
            // Check if wallet already exists
            if (investigation.universalWalletIndex.find(w => w.address === address.trim())) {
                alert('This wallet address already exists in the index.');
                return;
            }
            
            // Find next available ID for this type
            const existingIds = investigation.universalWalletIndex
                .filter(w => w.permanentType === type)
                .map(w => parseInt(w.permanentId.split(' ')[1]) || 0);
            const nextId = existingIds.length > 0 ? Math.max(...existingIds) + 1 : 1;
            
            const walletEntry = {
                id: `${type.toUpperCase()} ${nextId}`,
                permanentId: `${type.toUpperCase()} ${nextId}`,
                address: address.trim(),
                permanentType: type,
                currentStatus: type,
                totalAmount: 0,
                currencies: {},
                exposureChain: [],
                firstSeen: 'Manual Entry',
                statusHistory: [type],
                isDestination: false,
                isSource: false,
                notes: ''
            };
            
            investigation.universalWalletIndex.push(walletEntry);
            renderUniversalWalletIndex();
            saveToStorage();
        }

        function getCurrentART() {
            // Calculate ART by currency for the NEXT hop
            const artByCurrency = {};
            
            // If no hops exist, start with root totals
            if (investigation.hops.length === 0) {
                investigation.victims.forEach(victim => {
                    victim.transactions.forEach(transaction => {
                        if (parseFloat(transaction.amount) > 0) {
                            const currency = transaction.currency === 'CUSTOM' ? transaction.customCurrency : transaction.currency;
                            if (!artByCurrency[currency]) {
                                artByCurrency[currency] = 0;
                            }
                            artByCurrency[currency] += parseFloat(transaction.amount);
                        }
                    });
                });
            } else {
                // Get the last hop
                const lastHop = investigation.hops[investigation.hops.length - 1];
                
                // Start with the last hop's starting ART
                const lastHopStartingART = lastHop.artAtStartByCurrency || {};
                Object.entries(lastHopStartingART).forEach(([currency, amount]) => {
                    artByCurrency[currency] = amount;
                });
                
                // Add any new currencies from traces in the last hop
                lastHop.entries.forEach(entry => {
                    if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0) {
                        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                        if (!artByCurrency.hasOwnProperty(currency)) {
                            artByCurrency[currency] = 0;
                        }
                    }
                });
                
                // For each currency, calculate what remains for the next hop
                Object.keys(artByCurrency).forEach(currency => {
                    let tracedAmount = 0;
                    let writeoffAmount = 0;

                    lastHop.entries.forEach(entry => {
                        const entryCurrency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                        if (entryCurrency === currency && parseFloat(entry.amount) > 0) {
                            // Trace and cold storage entries reduce ART for next hop
                            if (['trace', 'cold_storage', 'vasp_arrival'].includes(entry.entryType)) {
                                tracedAmount += parseFloat(entry.amount);
                            }
                            // Write-offs permanently reduce the ART (as requested: "reduce the art at the close of the hop")
                            else if (entry.entryType === 'writeoff') {
                                writeoffAmount += parseFloat(entry.amount);
                                tracedAmount += parseFloat(entry.amount); // Also count as traced
                            }
                        }
                    });
                    
                    // What's left for the next hop
                    artByCurrency[currency] = (artByCurrency[currency] || 0) - tracedAmount;
                    
                    // Remove currencies with zero or negative amounts
                    if (artByCurrency[currency] <= 0) {
                        delete artByCurrency[currency];
                    }
                });
                
                // Add amounts from trace outputs that continue to next hop
                lastHop.entries.forEach(entry => {
                    if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0) {
                        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                        if (!artByCurrency[currency]) {
                            artByCurrency[currency] = 0;
                        }
                        artByCurrency[currency] += parseFloat(entry.amount);
                    }
                });
            }
            
            return artByCurrency;
        }

        function getAvailableSourceWallets(hopNumber) {
            if (!investigation.universalWalletIndex) {
                buildUniversalWalletIndex();
            }
            
            if (hopNumber === 1) {
                // First hop: only RED wallets
                return investigation.universalWalletIndex.filter(wallet => wallet.permanentType === 'red');
            } else {
                // Subsequent hops: wallets that were destinations in previous hops
                const previousHopNumber = hopNumber - 1;
                const availableWallets = [];
                
                investigation.hops.forEach(hop => {
                    if (hop.hopNumber === previousHopNumber) {
                        hop.entries.forEach(entry => {
                            if (entry.entryType === 'trace' && entry.toWallet) {
                                const wallet = investigation.universalWalletIndex.find(w => w.address === entry.toWallet);
                                if (wallet && !availableWallets.find(w => w.address === wallet.address)) {
                                    availableWallets.push({
                                        ...wallet,
                                        lastAmount: entry.amount,
                                        lastCurrency: entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency,
                                        lastNotation: entry.notation
                                    });
                                }
                            }
                        });
                    }
                });
                
                return availableWallets;
            }
        }

        function closeModal() {
            hideModal('rootTotalModal');
        }
        
        // Generic modal show/hide functions for centered display
        function showModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.classList.add('show');
            }
        }
        
        function hideModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.classList.remove('show');
            }
        }
        
        // Helper to create a modal with proper centered styling
        function createCenteredModal(modalId, content) {
            // Remove existing modal if present
            const existingModal = document.getElementById(modalId);
            if (existingModal) {
                existingModal.remove();
            }
            
            // Create modal with show class for centered display
            let modalHTML = content;
            
            // Replace all variations of modal display styles
            modalHTML = modalHTML.replace(
                /<div id="[^"]*" class="modal" style="display:\s*block[^"]*">/g,
                function(match) {
                    const idMatch = match.match(/id="([^"]*)"/);
                    const modalIdFromMatch = idMatch ? idMatch[1] : modalId;
                    return `<div id="${modalIdFromMatch}" class="modal show">`;
                }
            );
            
            // Add to body
            document.body.insertAdjacentHTML('beforeend', modalHTML);
        }

        function calculateRootTotal() {
            // This should return totals by currency, not a single sum
            const totalsByCurrency = {};
            investigation.victims.forEach(v => {
                v.transactions.forEach(t => {
                    const amount = parseAmount(t.amount);
                    if (amount > 0) {
                        const currency = t.currency === 'CUSTOM' ? t.customCurrency : t.currency;
                        if (!totalsByCurrency[currency]) {
                            totalsByCurrency[currency] = 0;
                        }
                        // Use safe addition for currency amounts
                        totalsByCurrency[currency] = addCurrencyAmounts(
                            totalsByCurrency[currency],
                            amount,
                            currency
                        );
                    }
                });
            });
            return totalsByCurrency;
        }
        
        // Custom centered alert function
        function showAlert(message, type = 'info') {
            const alertId = 'customAlert_' + Date.now();
            const iconMap = {
                'success': '✅',
                'error': '❌',
                'warning': '⚠️',
                'info': 'ℹ️'
            };
            
            const alertHTML = `
                <div id="${alertId}" class="modal show">
                    <div class="modal-content" style="max-width: 500px;">
                        <div style="text-align: center; padding: 20px;">
                            <div style="font-size: 48px; margin-bottom: 20px;">${iconMap[type] || iconMap.info}</div>
                            <div style="white-space: pre-wrap; line-height: 1.6; color: #2c3e50;">${message}</div>
                            <button class="btn btn-confirm" onclick="document.getElementById('${alertId}').remove()" 
                                    style="margin-top: 20px; padding: 10px 30px;">
                                OK
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', alertHTML);
            
            // Focus the OK button
            setTimeout(() => {
                const okBtn = document.querySelector(`#${alertId} button`);
                if (okBtn) okBtn.focus();
            }, 100);
        }

        function getNextHopNumber() {
            if (investigation.hops.length === 0) {
                return 1;
            }
            
            const maxHop = Math.max(...investigation.hops.map(h => h.hopNumber || 0));
            return maxHop + 1;
        }


// ADD THIS FUNCTION RIGHT AFTER getNextHopNumber():
function addNewHop() {
    console.log(' Adding new hop...');

    if (!investigation.rootTotalConfirmed) {
        alert('Please confirm your root total before adding hops.');
        return;
    }

    // Check if there are any active threads to trace
    const availableThreads = getAvailableSourcesForHop(getNextHopNumber(), null);
    const activeThreads = availableThreads.filter(t => t.availableAmount > 0.01); // Ignore tiny remainders

    if (activeThreads.length === 0) {
        // Check if all funds went to terminal wallets
        const lastHop = investigation.hops[investigation.hops.length - 1];
        if (lastHop) {
            const terminalEntries = lastHop.entries.filter(e => e.isTerminalWallet || e.toWalletType === 'purple' || e.toWalletType === 'gray');
            if (terminalEntries.length > 0) {
                alert('All funds have reached terminal wallets. The investigation is complete.\n\nNo new hop can be created as there are no active threads to trace.');

                // Show completion section
                document.getElementById('completeInvestigationSection').style.display = 'block';
                document.getElementById('addHopBtn').style.display = 'none';
                return;
            }
        }

        alert('No available threads to trace. Please check your previous hop entries.');
        return;
    }
    
    // Validate previous hops are complete (with option to proceed)
    for (let hop of investigation.hops) {
        const validation = typeof validateHopCompletionByCurrency === 'function' ? 
            validateHopCompletionByCurrency(hop.hopNumber) : 
            validateHopCompletion(hop.hopNumber);
            
        if (!validation.valid && validation.errors && validation.errors.length > 0) {
            const shouldProceed = confirm(
                `Hop ${hop.hopNumber} has validation errors:\n${validation.errors.join('\n')}\n\nDo you want to proceed anyway? This may cause mathematical inconsistencies.`
            );
            if (!shouldProceed) {
                return;
            }
        }
    }
    
    const hopNumber = getNextHopNumber();
    const currentART = getCurrentART();
    
    // Create new hop with proper structure
    const hop = {
        hopNumber: hopNumber,
        entries: [],
        artAtStartByCurrency: currentART,
        artAtStart: Object.values(currentART).reduce((sum, amount) => sum + amount, 0), // Legacy support
        completed: false
    };
    
    console.log(`Creating hop ${hopNumber} with starting ART:`, currentART);
    
    investigation.hops.push(hop);
    
    // Rebuild thread index after adding hop
    buildAvailableThreadsIndex();
    
    renderHops();
    saveToStorage();
    updateWorkflowSteps();
    
    console.log(` Hop ${hopNumber} created successfully`);
}

// ADD this export function to your JavaScript section:

        // Track collapse state
        window.hopCollapseState = window.hopCollapseState || {};
        window.entryCollapseState = window.entryCollapseState || {};
        
        // Toggle hop collapse state
        function toggleHopCollapse(hopNumber) {
            window.hopCollapseState[hopNumber] = !window.hopCollapseState[hopNumber];
            const content = document.getElementById(`hopContent_${hopNumber}`);
            const arrow = event.currentTarget.querySelector('span');

            if (window.hopCollapseState[hopNumber]) {
                content.style.display = 'none';
                arrow.style.transform = 'rotate(0deg)';
            } else {
                content.style.display = 'block';
                arrow.style.transform = 'rotate(90deg)';
            }
        }
        
        // Toggle entry collapse state
        function toggleEntryCollapse(entryId) {
            window.entryCollapseState[entryId] = !window.entryCollapseState[entryId];
            const content = document.getElementById(`entryContent_${entryId}`);
            const summary = document.getElementById(`entrySummary_${entryId}`);
            
            if (window.entryCollapseState[entryId]) {
                content.style.display = 'none';
                summary.style.display = 'block';
            } else {
                content.style.display = 'block';
                summary.style.display = 'none';
            }
        }
        
        // Log entry and collapse
        function logAndCollapseEntry(hopNumber, entryId) {
            // Find the entry
            const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
            const entry = hop.entries.find(e => e.id === entryId);
            
            console.log('Log entry debug:', {
                hopNumber, entryId,
                sourceThreadId: entry.sourceThreadId,
                multipleSourceThreads: entry.multipleSourceThreads,
                notation: entry.notation,
                victimNumbers: entry.victimNumbers,
                transactionNumbers: entry.transactionNumbers,
                amount: entry.amount,
                currency: entry.currency
            });
            
            // Validate entry has required data
            if (!entry.amount || parseFloat(entry.amount) <= 0) {
                alert('Please enter an amount before logging the entry.');
                return;
            }
            
            // Try to auto-generate notation if missing but source is selected
            if (!entry.notation || entry.notation.trim() === '') {
                if (entry.sourceThreadId) {
                    console.log('🔧 Attempting to auto-generate notation from single source:', entry.sourceThreadId);
                    autoGenerateNotationFromSource(hopNumber, entryId, entry.sourceThreadId);
                } else if (entry.multipleSourceThreads && entry.multipleSourceThreads.length > 0) {
                    console.log('🔧 Attempting to auto-generate notation from multiple sources:', entry.multipleSourceThreads);
                    autoGenerateNotationFromMultipleSources(hopNumber, entryId, entry.multipleSourceThreads);
                }
            }
            
            if (!entry.notation || entry.notation.trim() === '') {
                alert('Please enter a notation before logging the entry.\n\nIf you have selected a source thread, the notation should auto-fill. Try manually entering the victim and transaction numbers.');
                return;
            }
            
            // Save undo state before logging
            saveUndoState(`Log entry ${entry.notation} in Hop ${hop.hopNumber}`);
            
            // Save to storage
            saveToStorage();
            
            // Set entry as collapsed
            const entryKey = `${hopNumber}_${entryId}`;
            window.entryCollapseState[entryKey] = true;
            
            // Update UI to show collapsed state
            const content = document.getElementById(`entryContent_${entryKey}`);
            const summary = document.getElementById(`entrySummary_${entryKey}`);
            
            if (content && summary) {
                content.style.display = 'none';
                summary.style.display = 'block';
            }
            
            // Update the hop to refresh ART calculations
            updateInvestigationCompletionStatus();
            
            // Show success message
            const amount = parseFloat(entry.amount);
            const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
            alert(` Entry logged successfully!\n\n${entry.notation}: ${amount.toLocaleString()} ${currency}`);
        }
        
        // Render collapsible hop entry
        function renderCollapsibleHopEntry(entry, entryIndex, hop) {
            // Initialize collapse state - start expanded for new entries
            const entryKey = `${hop.hopNumber}_${entry.id}`;
            if (window.entryCollapseState[entryKey] === undefined) {
                window.entryCollapseState[entryKey] = false; // Start expanded
            }
            const isCollapsed = window.entryCollapseState[entryKey];

            // Get entry type info
            const entryTypeLabel = entryTypes[entry.entryType] || entry.entryType;
            const amount = parseFloat(entry.amount) || 0;
            const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;

            // Get hop number and ART amount
            const hopNumber = hop.hopNumber;
            
            // Get the ART amount for this currency at this hop
            let artAmount = 0;
            let displayCurrency = currency;

            // For swap entries, show both input and output
            if (entry.entryType === 'swap' && entry.swapDetails) {
                // For swaps, show input amount and currency
                displayCurrency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                if (hop && hop.artAtStartByCurrency && displayCurrency) {
                    artAmount = hop.artAtStartByCurrency[displayCurrency] || 0;
                }
            } else {
                // For regular entries, get ART for the entry's currency
                if (hop && hop.artAtStartByCurrency && currency) {
                    artAmount = hop.artAtStartByCurrency[currency] || 0;
                }
            }
            
            // Calculate thread number within hop (sequential numbering for entries with notation)
            let threadNumber = null;
            if (entry.notation && parseFloat(entry.amount) > 0) {
                const hopEntriesWithNotation = hop.entries.filter(e => e.notation && parseFloat(e.amount) > 0);
                threadNumber = hopEntriesWithNotation.findIndex(e => e.id === entry.id) + 1;
            }
            
            // Get source thread information
            let sourceThreadsInfo = '';
            if (entry.sourceThreadId) {
                // Single source thread
                const sourceMatch = entry.sourceThreadId.match(/^(V\d+-T\d+)-H(\d+)$/);
                if (sourceMatch) {
                    const [, vtPath, sourceHopNumber] = sourceMatch;
                    sourceThreadsInfo = `from ${vtPath} (H${sourceHopNumber})`;
                }
            } else if (entry.multipleSourceThreads && entry.multipleSourceThreads.length > 0) {
                // Multiple source threads
                const sourceThreads = entry.multipleSourceThreads.map(threadId => {
                    const sourceMatch = threadId.match(/^(V\d+-T\d+)-H(\d+)$/);
                    if (sourceMatch) {
                        const [, vtPath, sourceHopNumber] = sourceMatch;
                        return `${vtPath} (H${sourceHopNumber})`;
                    }
                    return threadId;
                });
                sourceThreadsInfo = `from ${sourceThreads.join(', ')}`;
            }
            
            // Entry background color based on type - thematically consistent
            let entryBgColor = '#f0f7ff'; // Very light blue for regular trace entries
            let entryBorderColor = '#b8daff'; // Soft blue border
            if (entry.entryType === 'writeoff') {
                entryBgColor = '#f5f5f5'; // Light gray for writeoffs (abandoned like gray wallets)
                entryBorderColor = '#9e9e9e'; // Gray border
            } else if (entry.entryType === 'cold_storage' || entry.toWalletType === 'blue') {
                entryBgColor = '#e3f2fd'; // Light blue for cold storage
                entryBorderColor = '#3498db';
            } else if (entry.toWalletType === 'purple') {
                entryBgColor = '#f3e6ff'; // Light purple for exchange deposits
                entryBorderColor = '#9b59b6';
            }
            
            return `
                <div id="entry_${hop.hopNumber}_${entry.id}" style="background: ${entryBgColor}; border: 2px solid ${entryBorderColor}; border-radius: 8px; margin-bottom: 10px; overflow: hidden;">
                    <div style="padding: ${isCollapsed ? '8px' : '15px'};">
                        <!-- Collapsed state header -->
                        <div id="entrySummary_${entryKey}" style="display: ${isCollapsed ? 'block' : 'none'}; background: rgba(255,255,255,0.7); padding: 6px 10px; border-radius: 6px;">
                            <div style="cursor: pointer;" onclick="toggleEntryCollapse('${entryKey}')">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <div style="display: flex; align-items: center; gap: 10px;">
                                            <span style="transform: rotate(0deg); transition: transform 0.3s; display: inline-block; font-size: 16px;">▶</span>
                                            <span style="font-weight: bold; color: #2c3e50;">
                                                Hop ${hopNumber} Entry ${entry.id}${threadNumber ? ` (Thread ${threadNumber})` : ''}
                                            </span>
                                            <span style="color: #7f8c8d; font-size: 12px;">
                                                ${entryTypeLabel}
                                            </span>
                                            ${entry.isBridge ? `
                                                <span style="background: #8b4513; color: white; padding: 2px 6px; border-radius: 4px; font-size: 11px;">
                                                    🌉 BRIDGE
                                                </span>
                                            ` : (entry.toWalletType === 'purple' || entry.toWalletType === 'PURPLE') && !entry.bridgeOutputLogged ? `
                                                <span style="background: #9b59b6; color: white; padding: 2px 6px; border-radius: 4px; font-size: 11px;">
                                                    TERMINAL${entry.exchangeAttribution?.name ? `: ${entry.exchangeAttribution.name}` : ''}
                                                </span>
                                            ` : ''}
                                        </div>
                                        ${sourceThreadsInfo ? `
                                            <div style="margin-left: 26px; margin-top: 4px;">
                                                <span style="color: #666; font-size: 11px; font-style: italic;">
                                                    ${sourceThreadsInfo}
                                                </span>
                                            </div>
                                        ` : ''}
                                    </div>
                                    <div style="text-align: right;">
                                        ${amount > 0 ? (
                                            entry.entryType === 'swap' && entry.swapDetails ? `
                                                <span style="font-weight: bold; color: #27ae60;">
                                                    ${amount.toLocaleString()} ${displayCurrency} → ${parseFloat(entry.outputAmount || 0).toLocaleString()} ${entry.outputCurrency || ''}
                                                </span>
                                            ` : `
                                                <span style="font-weight: bold; color: #27ae60;">
                                                    ${amount.toLocaleString()} ${currency} / ${artAmount.toLocaleString()} ${currency}
                                                </span>
                                            `
                                        ) : `
                                            <span style="color: #e74c3c; font-size: 12px;">
                                                Not logged
                                            </span>
                                        `}
                                    </div>
                                </div>
                            </div>
                            <!-- Action buttons in collapsed view -->
                            <div style="display: flex; gap: 10px; margin-top: 10px; justify-content: flex-start;">
                                ${(entry.toWalletType === 'purple' || entry.toWalletType === 'PURPLE') && entry.entryType === 'trace' && !entry.bridgeOutputLogged && !entry.isBridge ? `
                                    <button class="btn btn-sm" style="background: #27ae60; color: white; border: 1px solid #229954;"
                                            onclick="event.stopPropagation(); logBridgeOutput(${hop.hopNumber}, ${entry.id})"
                                            title="Log the output transaction from this terminal wallet (CEX or Bridge)">
                                        🌉 Log Bridge/Swap
                                    </button>
                                ` : ''}
                                <button class="btn btn-sm btn-danger" onclick="event.stopPropagation(); removeHopEntry(${hop.hopNumber}, ${entry.id})">
                                    🗑️ Delete
                                </button>
                            </div>
                        </div>
                        
                        <!-- Expanded state -->
                        <div id="entryContent_${entryKey}" style="display: ${isCollapsed ? 'none' : 'block'};">
                            <!-- Expanded header - clickable to collapse -->
                            <div style="cursor: pointer; margin-bottom: 10px; background: rgba(255,255,255,0.7); padding: 10px; border-radius: 6px;" onclick="toggleEntryCollapse('${entryKey}')">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <div style="display: flex; align-items: center; gap: 10px;">
                                            <span style="transform: rotate(90deg); transition: transform 0.3s; display: inline-block; font-size: 16px;">▶</span>
                                            <span style="font-weight: bold; color: #2c3e50;">
                                                Hop ${hopNumber} Entry ${entry.id}${threadNumber ? ` (Thread ${threadNumber})` : ''}
                                            </span>
                                            <span style="color: #7f8c8d; font-size: 12px;">
                                                ${entryTypeLabel}
                                            </span>
                                            ${entry.isBridge ? `
                                                <span style="background: #8b4513; color: white; padding: 2px 6px; border-radius: 4px; font-size: 11px;">
                                                    🌉 BRIDGE
                                                </span>
                                            ` : (entry.toWalletType === 'purple' || entry.toWalletType === 'PURPLE') && !entry.bridgeOutputLogged ? `
                                                <span style="background: #9b59b6; color: white; padding: 2px 6px; border-radius: 4px; font-size: 11px;">
                                                    TERMINAL${entry.exchangeAttribution?.name ? `: ${entry.exchangeAttribution.name}` : ''}
                                                </span>
                                            ` : ''}
                                            <span style="color: #666; font-size: 11px;">
                                                (Click to collapse)
                                            </span>
                                        </div>
                                        ${sourceThreadsInfo ? `
                                            <div style="margin-left: 26px; margin-top: 4px;">
                                                <span style="color: #666; font-size: 11px; font-style: italic;">
                                                    ${sourceThreadsInfo}
                                                </span>
                                            </div>
                                        ` : ''}
                                    </div>
                                    <div style="text-align: right;">
                                        ${amount > 0 ? (
                                            entry.entryType === 'swap' && entry.swapDetails ? `
                                                <span style="font-weight: bold; color: #27ae60;">
                                                    ${amount.toLocaleString()} ${displayCurrency} → ${parseFloat(entry.outputAmount || 0).toLocaleString()} ${entry.outputCurrency || ''}
                                                </span>
                                            ` : `
                                                <span style="font-weight: bold; color: #27ae60;">
                                                    ${amount.toLocaleString()} ${currency} / ART
                                                </span>
                                            `
                                        ) : `
                                            <span style="color: #e74c3c; font-size: 12px;">
                                                Not logged yet
                                            </span>
                                        `}
                                    </div>
                                </div>
                            </div>
                            <!-- Entry form content - not clickable -->
                            <div style="background: #f8f8f8; padding: 15px; border-radius: 6px; cursor: default;" onclick="event.stopPropagation();">
                                ${renderHopEntry(entry, hop)}
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }
        
        // Pagination variables
        let currentHopPage = 1;
        let hopsPerPage = 20;
        
        // Dashboard Functions
        function updateDashboard() {
            // Update victim count
            document.getElementById('dashStatVictims').textContent = investigation.victims.length;
            
            // Update hop count
            document.getElementById('dashStatHops').textContent = investigation.hops.length;
            
            // Update thread and terminal wallet counts
            const threadStatus = checkAllThreadsTerminated();
            document.getElementById('dashStatThreads').textContent = threadStatus.activeThreads.length;
            document.getElementById('dashStatTerminal').textContent = threadStatus.activeThreads.filter(t => 
                ['gray', 'purple', 'blue'].includes(t.toWalletType)
            ).length;
            
            // Update ART progress bars
            updateARTProgressBars();
            
            // Update thread status bar
            updateThreadStatusBar(threadStatus);
            
            // Update hop jump menu
            updateHopJumpMenu();
        }
        
        function updateThreadStatusBar(threadStatus) {
            const container = document.getElementById('threadStatusBar');
            if (!container) return;
            
            container.innerHTML = '';
            
            if (!investigation.rootTotalConfirmed) {
                container.innerHTML = '<p style="color: #7f8c8d;">Confirm root total to see thread status</p>';
                return;
            }
            
            if (!threadStatus || threadStatus.activeThreads.length === 0) {
                container.innerHTML = '<p style="color: #7f8c8d;">No active threads yet</p>';
                return;
            }
            
            // Group threads by currency
            const threadsByCurrency = {};
            threadStatus.activeThreads.forEach(thread => {
                if (!threadsByCurrency[thread.currency]) {
                    threadsByCurrency[thread.currency] = [];
                }
                threadsByCurrency[thread.currency].push(thread);
            });
            
            // Create a visual bar for each currency
            Object.entries(threadsByCurrency).forEach(([currency, threads]) => {
                const barContainer = document.createElement('div');
                barContainer.style.cssText = 'margin-bottom: 15px;';
                
                // Currency label
                const label = document.createElement('div');
                label.style.cssText = 'font-weight: bold; margin-bottom: 5px; color: #2c3e50;';
                label.textContent = `${currency} Threads (${threads.length})`;
                barContainer.appendChild(label);
                
                // Thread bar
                const barBg = document.createElement('div');
                barBg.style.cssText = 'background: #e0e0e0; border-radius: 8px; height: 30px; position: relative; overflow: hidden;';
                
                // Calculate total amount for this currency
                const totalAmount = threads.reduce((sum, t) => sum + t.amount, 0);
                
                // Add segments for each thread
                let currentPosition = 0;
                threads.forEach((thread, index) => {
                    const percentage = (thread.amount / totalAmount) * 100;
                    const segment = document.createElement('div');
                    
                    // Use wallet color for terminal wallets, green for active threads
                    const isTerminal = ['purple', 'blue', 'gray'].includes(thread.toWalletType);
                    const segmentColor = isTerminal ? getWalletColor(thread.toWalletType) : '#27ae60';
                    
                    segment.style.cssText = `
                        position: absolute;
                        left: ${currentPosition}%;
                        width: ${percentage}%;
                        height: 100%;
                        background: ${segmentColor};
                        border-right: 1px solid white;
                        cursor: pointer;
                        transition: opacity 0.2s;
                    `;
                    
                    // Add hover effect and tooltip
                    segment.title = `${thread.path}: ${thread.amount.toLocaleString()} ${currency}\nTo: ${thread.toWallet}\nType: ${walletTypes[thread.toWalletType] || thread.toWalletType}`;
                    segment.onmouseover = () => { segment.style.opacity = '0.8'; };
                    segment.onmouseout = () => { segment.style.opacity = '1'; };
                    
                    barBg.appendChild(segment);
                    currentPosition += percentage;
                });
                
                barContainer.appendChild(barBg);
                
                // Legend for this currency
                const legend = document.createElement('div');
                legend.style.cssText = 'margin-top: 5px; font-size: 12px; color: #666;';
                
                const terminalCount = threads.filter(t => ['purple', 'blue', 'gray'].includes(t.toWalletType)).length;
                const activeCount = threads.length - terminalCount;
                
                const legendItems = [];
                if (activeCount > 0) {
                    legendItems.push(`<span style="color: #27ae60;">● ${activeCount} Active</span>`);
                }
                
                // Count by terminal type
                const purpleCount = threads.filter(t => t.toWalletType === 'purple').length;
                const blueCount = threads.filter(t => t.toWalletType === 'blue').length;
                const grayCount = threads.filter(t => t.toWalletType === 'gray').length;
                
                if (purpleCount > 0) {
                    legendItems.push(`<span style="color: #9b59b6;">● ${purpleCount} Exchange</span>`);
                }
                if (blueCount > 0) {
                    legendItems.push(`<span style="color: #3498db;">● ${blueCount} Cold Storage</span>`);
                }
                if (grayCount > 0) {
                    legendItems.push(`<span style="color: #95a5a6;">● ${grayCount} Obfuscated</span>`);
                }
                
                legend.innerHTML = legendItems.join(' | ');
                barContainer.appendChild(legend);
                
                container.appendChild(barContainer);
            });
        }
        
        function updateARTProgressBars() {
            const container = document.getElementById('artProgressBars');
            container.innerHTML = '';

            if (!investigation.rootTotalConfirmed) {
                container.innerHTML = '<p style="color: #7f8c8d;">Confirm root total to see ART progress</p>';
                return;
            }

            // Get ALL available currencies from threads (includes converted currencies)
            const allCurrencies = {};

            // Start with root total from victim transactions
            const rootTotal = investigation.victims.reduce((acc, victim) => {
                victim.transactions.forEach(t => {
                    const currency = t.currency === 'CUSTOM' ? t.customCurrency : t.currency;
                    const amount = parseFloat(t.amount) || 0;
                    if (currency && amount > 0) {
                        acc[currency] = (acc[currency] || 0) + amount;
                    }
                });
                return acc;
            }, {});

            // Add currencies from available threads (includes swap/bridge outputs)
            if (investigation.availableThreads) {
                for (const currency in investigation.availableThreads) {
                    if (!allCurrencies[currency]) {
                        allCurrencies[currency] = { total: 0, available: 0, isConverted: !rootTotal[currency] };
                    }

                    // Sum up total amounts in this currency
                    for (const threadKey in investigation.availableThreads[currency]) {
                        const thread = investigation.availableThreads[currency][threadKey];
                        allCurrencies[currency].total += thread.totalAmount || 0;
                        allCurrencies[currency].available += thread.availableAmount || 0;
                    }
                }
            }

            // Merge root totals into allCurrencies
            for (const currency in rootTotal) {
                if (!allCurrencies[currency]) {
                    allCurrencies[currency] = { total: 0, available: 0, isConverted: false };
                }
                allCurrencies[currency].rootAmount = rootTotal[currency];
            }

            // Get current ART by currency
            const currentART = getCurrentART();

            // Create progress bars for each currency
            Object.entries(allCurrencies).forEach(([currency, data]) => {
                // For root currencies, show traditional progress
                if (data.rootAmount) {
                    const total = data.rootAmount;
                    const current = currentART[currency] || 0;
                    const traced = total - current;
                    const percentage = total > 0 ? (traced / total * 100).toFixed(1) : 0;

                    const progressBar = `
                        <div class="progress-bar-container">
                            <div class="progress-bar-label">
                                <span><strong>${currency}</strong></span>
                                <span>${traced.toLocaleString()} / ${total.toLocaleString()} (${percentage}%)</span>
                            </div>
                            <div class="progress-bar-bg">
                                <div class="progress-bar-fill" style="width: ${percentage}%"></div>
                            </div>
                        </div>
                    `;
                    container.innerHTML += progressBar;
                } else if (data.total > 0) {
                    // For converted currencies (from swaps/bridges), show what needs to be traced
                    const total = data.total;
                    const traced = total - data.available;
                    const percentage = total > 0 ? (traced / total * 100).toFixed(1) : 0;

                    const progressBar = `
                        <div class="progress-bar-container">
                            <div class="progress-bar-label">
                                <span><strong>${currency}</strong> <em style="color: #8b4513; font-size: 0.9em;">(converted)</em></span>
                                <span>${traced.toLocaleString()} / ${total.toLocaleString()} (${percentage}%)</span>
                            </div>
                            <div class="progress-bar-bg" style="background: #fff8f4;">
                                <div class="progress-bar-fill" style="width: ${percentage}%; background: #8b4513;"></div>
                            </div>
                        </div>
                    `;
                    container.innerHTML += progressBar;
                }
            });

            // If no currencies to display
            if (Object.keys(allCurrencies).length === 0) {
                container.innerHTML = '<p style="color: #7f8c8d;">No ART data to display</p>';
            }
        }
        
        function updateHopJumpMenu() {
            const menu = document.getElementById('hopJumpMenu');
            menu.innerHTML = '<option value="">Jump to Hop...</option>';
            
            investigation.hops.forEach(hop => {
                const option = document.createElement('option');
                option.value = hop.hopNumber;
                option.textContent = `Hop ${hop.hopNumber}${hop.completed ? ' ✓' : ''}`;
                menu.appendChild(option);
            });
        }
        
        function toggleDashboard() {
            const content = document.getElementById('dashboardContent');
            const button = document.getElementById('dashboardToggle');
            
            if (content.style.display === 'none') {
                content.style.display = 'block';
                button.textContent = 'Hide Dashboard';
            } else {
                content.style.display = 'none';
                button.textContent = 'Show Dashboard';
            }
        }
        
        function jumpToHop(hopNumber) {
            if (!hopNumber) return;
            
            const hopElement = document.querySelector(`[data-hop-id="${hopNumber}"]`);
            if (hopElement) {
                hopElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                // Flash the hop for visibility
                hopElement.style.transition = 'background-color 0.3s';
                hopElement.style.backgroundColor = '#fff3cd';
                setTimeout(() => {
                    hopElement.style.backgroundColor = '';
                }, 1000);
            }
        }
        
        let searchTimeout;
        function globalSearchDebounce() {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(globalSearch, 300);
        }
        
        function globalSearch() {
            const query = document.getElementById('globalSearch').value.toLowerCase();
            if (!query) {
                // Clear highlights
                document.querySelectorAll('.search-highlight').forEach(el => {
                    el.classList.remove('search-highlight');
                });
                return;
            }
            
            // Search in hops and entries
            let found = false;
            investigation.hops.forEach(hop => {
                hop.entries.forEach(entry => {
                    const searchableText = [
                        entry.toWallet,
                        entry.fromWallet,
                        entry.txHash,
                        entry.amount,
                        entry.notation
                    ].filter(Boolean).join(' ').toLowerCase();
                    
                    if (searchableText.includes(query)) {
                        found = true;
                        // Highlight the entry
                        const entryElement = document.querySelector(`[data-entry-id="${hop.hopNumber}-${entry.id}"]`);
                        if (entryElement) {
                            entryElement.classList.add('search-highlight');
                            if (!found) {
                                entryElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            }
                        }
                    }
                });
            });
        }
        
        function showThreadFilter() {
            // This will be implemented with the visualization tools
            alert('Thread filter coming soon! This will allow you to filter the view to specific V-T threads.');
        }
        
        function showAnalysisTools() {
            const modalHTML = `
                <div id="analysisModal" class="modal" style="display: block;">
                    <div class="modal-content" style="max-width: 800px;">
                        <div class="modal-header">
                            <h2>📊 Investigation Analysis Tools</h2>
                            <button class="close-btn" onclick="closeAnalysisModal()">×</button>
                        </div>
                        
                        <div style="padding: 20px;">
                            <div class="nav-tabs">
                                <button class="nav-tab active" onclick="switchAnalysisTab('wallet-frequency')">Wallet Frequency</button>
                                <button class="nav-tab" onclick="switchAnalysisTab('pattern-detection')">Pattern Detection</button>
                                <button class="nav-tab" onclick="switchAnalysisTab('terminal-summary')">Terminal Summary</button>
                            </div>
                            
                            <div id="wallet-frequency-tab" class="analysis-tab-content active">
                                <h3>Wallet Frequency Analysis</h3>
                                <div id="walletFrequencyContent"></div>
                            </div>
                            
                            <div id="pattern-detection-tab" class="analysis-tab-content" style="display: none;">
                                <h3>Transaction Pattern Detection</h3>
                                <div id="patternDetectionContent"></div>
                            </div>
                            
                            <div id="terminal-summary-tab" class="analysis-tab-content" style="display: none;">
                                <h3>Terminal Wallet Summary</h3>
                                <div id="terminalSummaryContent"></div>
                            </div>
                        </div>
                        
                        <div class="modal-footer" style="text-align: center; padding: 20px; border-top: 1px solid #eee;">
                            <button class="btn btn-secondary" onclick="closeAnalysisModal()" style="padding: 10px 30px;">
                                Close Analysis
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            createCenteredModal('analysisModal', modalHTML);
            analyzeInvestigation();
        }
        
        function closeAnalysisModal() {
            const modal = document.getElementById('analysisModal');
            if (modal) modal.remove();
        }
        
        function switchAnalysisTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.analysis-tab-content').forEach(tab => {
                tab.style.display = 'none';
            });
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected tab
            document.getElementById(`${tabName}-tab`).style.display = 'block';
            event.target.classList.add('active');
        }
        
        function analyzeInvestigation() {
            // Wallet Frequency Analysis
            const walletFrequency = {};
            investigation.hops.forEach(hop => {
                hop.entries.forEach(entry => {
                    if (entry.toWallet) {
                        walletFrequency[entry.toWallet] = (walletFrequency[entry.toWallet] || 0) + 1;
                    }
                });
            });
            
            const frequentWallets = Object.entries(walletFrequency)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);
            
            let walletFreqHTML = '<table style="width: 100%; border-collapse: collapse;">';
            walletFreqHTML += '<tr><th style="text-align: left; padding: 10px; border-bottom: 2px solid #ddd;">Wallet Address</th>';
            walletFreqHTML += '<th style="text-align: right; padding: 10px; border-bottom: 2px solid #ddd;">Appearances</th></tr>';
            
            frequentWallets.forEach(([wallet, count]) => {
                walletFreqHTML += `<tr>
                    <td style="padding: 8px; border-bottom: 1px solid #eee; font-family: monospace; font-size: 12px;">
                        ${wallet.substring(0, 20)}...
                    </td>
                    <td style="padding: 8px; border-bottom: 1px solid #eee; text-align: right;">
                        ${count}
                    </td>
                </tr>`;
            });
            walletFreqHTML += '</table>';
            
            document.getElementById('walletFrequencyContent').innerHTML = walletFreqHTML;
            
            // Pattern Detection
            const patterns = detectPatterns();
            let patternHTML = '<div style="margin-top: 20px;">';
            patterns.forEach(pattern => {
                patternHTML += `<div style="background: #f8f9fa; border-left: 4px solid #3498db; padding: 15px; margin-bottom: 10px;">
                    <strong>${pattern.type}</strong>: ${pattern.description}
                </div>`;
            });
            patternHTML += '</div>';
            
            document.getElementById('patternDetectionContent').innerHTML = patternHTML;
            
            // Enhanced Terminal Summary with exchange details
            const terminalWallets = getTerminalWallets();
            let terminalHTML = '<div style="margin-top: 20px;">';

            // Add export button for terminal wallet report
            terminalHTML += `
                <div style="margin-bottom: 20px;">
                    <button class="btn btn-primary" onclick="exportTerminalWalletReport()" style="margin-right: 10px;">
                        📊 Export Terminal Wallet Report
                    </button>
                    <button class="btn btn-secondary" onclick="copyTerminalWalletReport()">
                        📋 Copy Report to Clipboard
                    </button>
                </div>
            `;

            Object.entries(terminalWallets).forEach(([type, wallets]) => {
                if (wallets.length === 0) return;

                terminalHTML += `<h4>${type} Wallets (${wallets.length})</h4>`;

                if (type === 'Purple (Exchange)' && wallets.length > 0) {
                    // Enhanced display for exchange wallets
                    terminalHTML += '<div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin-bottom: 20px;">';
                    terminalHTML += '<table style="width: 100%; border-collapse: collapse;">';
                    terminalHTML += `
                        <thead>
                            <tr style="border-bottom: 2px solid #dee2e6;">
                                <th style="padding: 10px; text-align: left;">Exchange</th>
                                <th style="padding: 10px; text-align: left;">Amount</th>
                                <th style="padding: 10px; text-align: left;">Wallet</th>
                                <th style="padding: 10px; text-align: left;">Timestamp</th>
                                <th style="padding: 10px; text-align: left;">Hop</th>
                                <th style="padding: 10px; text-align: left;">Source</th>
                            </tr>
                        </thead>
                        <tbody>
                    `;

                    wallets.forEach(w => {
                        terminalHTML += `
                            <tr style="border-bottom: 1px solid #dee2e6;">
                                <td style="padding: 10px;">
                                    <strong style="color: #9b59b6;">${w.exchangeName || 'Unknown'}</strong>
                                </td>
                                <td style="padding: 10px;">
                                    ${w.amount.toLocaleString()} ${w.currency}
                                </td>
                                <td style="padding: 10px; font-family: monospace; font-size: 11px;">
                                    ${w.wallet.substring(0, 15)}...${w.wallet.substring(w.wallet.length - 10)}
                                </td>
                                <td style="padding: 10px; font-size: 12px;">
                                    ${w.timestamp ? new Date(w.timestamp).toLocaleString() : 'N/A'}
                                </td>
                                <td style="padding: 10px;">
                                    ${w.hopNumber ? `Hop ${w.hopNumber}` : 'N/A'}
                                </td>
                                <td style="padding: 10px; font-size: 11px;">
                                    ${w.detectionSource || 'Manual'}
                                </td>
                            </tr>
                        `;
                    });

                    terminalHTML += '</tbody></table></div>';

                    // Summary statistics
                    const totalByExchange = {};
                    wallets.forEach(w => {
                        const key = `${w.exchangeName || 'Unknown'}_${w.currency}`;
                        if (!totalByExchange[key]) {
                            totalByExchange[key] = {
                                exchange: w.exchangeName || 'Unknown',
                                currency: w.currency,
                                total: 0,
                                count: 0
                            };
                        }
                        totalByExchange[key].total += w.amount;
                        totalByExchange[key].count++;
                    });

                    terminalHTML += '<div style="background: #e1bee7; padding: 15px; border-radius: 8px; margin-bottom: 20px;">';
                    terminalHTML += '<h5>📊 Exchange Summary:</h5>';
                    Object.values(totalByExchange).forEach(summary => {
                        terminalHTML += `
                            <div style="margin: 10px 0;">
                                <strong>${summary.exchange}:</strong>
                                ${summary.total.toLocaleString()} ${summary.currency}
                                (${summary.count} transaction${summary.count > 1 ? 's' : ''})
                            </div>
                        `;
                    });
                    terminalHTML += '</div>';

                } else {
                    // Standard display for other terminal types
                    terminalHTML += '<ul>';
                    wallets.forEach(w => {
                        terminalHTML += `<li style="margin-bottom: 5px;">
                            <strong>${w.wallet}</strong>: ${w.amount.toLocaleString()} ${w.currency}
                        </li>`;
                    });
                    terminalHTML += '</ul>';
                }
            });
            terminalHTML += '</div>';

            document.getElementById('terminalSummaryContent').innerHTML = terminalHTML;
        }
        
        // Export terminal wallet report
        function exportTerminalWalletReport() {
            const terminals = getTerminalWallets();
            const exchangeWallets = terminals['Purple (Exchange)'] || [];

            if (exchangeWallets.length === 0) {
                alert('No terminal wallet arrivals to export.');
                return;
            }

            // Prepare CSV data
            const csvData = [];
            csvData.push({
                'Date/Time (UTC)': 'Date/Time (UTC)',
                'Exchange': 'Exchange',
                'Amount': 'Amount',
                'Currency': 'Currency',
                'Receiving Wallet': 'Receiving Wallet',
                'Sending Wallet': 'Sending Wallet',
                'Transaction Hash': 'Transaction Hash',
                'Hop Number': 'Hop Number',
                'Detection Source': 'Detection Source',
                'Case ID': 'Case ID',
                'Investigator': 'Investigator'
            });

            exchangeWallets.forEach(wallet => {
                csvData.push({
                    'Date/Time (UTC)': wallet.timestamp ? formatDateTimeForReport(wallet.timestamp, 'UTC') : 'N/A',
                    'Exchange': wallet.exchangeName || 'Unknown Exchange',
                    'Amount': wallet.amount.toLocaleString(),
                    'Currency': wallet.currency,
                    'Receiving Wallet': wallet.wallet,
                    'Sending Wallet': wallet.fromWallet || 'N/A',
                    'Transaction Hash': wallet.txHash || 'N/A',
                    'Hop Number': wallet.hopNumber ? `Hop ${wallet.hopNumber}` : 'N/A',
                    'Detection Source': wallet.detectionSource || 'Manual',
                    'Case ID': investigation.caseId,
                    'Investigator': investigation.investigator
                });
            });

            // Generate filename with timestamp
            const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, 19);
            const filename = `Terminal_Wallet_Report_${investigation.caseId}_${timestamp}.csv`;

            exportToCSV(csvData, filename);
            showNotification(`Terminal wallet report exported as ${filename}`, 'success');
        }

        // Copy terminal wallet report to clipboard
        function copyTerminalWalletReport() {
            const terminals = getTerminalWallets();
            const exchangeWallets = terminals['Purple (Exchange)'] || [];

            if (exchangeWallets.length === 0) {
                alert('No terminal wallet arrivals to copy.');
                return;
            }

            let report = '=== TERMINAL WALLET ARRIVAL REPORT ===\n\n';
            report += `Case ID: ${investigation.caseId}\n`;
            report += `Investigator: ${investigation.investigator}\n`;
            report += `Report Generated: ${new Date().toISOString()}\n\n`;

            // Group by exchange
            const byExchange = {};
            exchangeWallets.forEach(wallet => {
                const exchange = wallet.exchangeName || 'Unknown Exchange';
                if (!byExchange[exchange]) {
                    byExchange[exchange] = [];
                }
                byExchange[exchange].push(wallet);
            });

            // Generate report for each exchange
            Object.entries(byExchange).forEach(([exchange, wallets]) => {
                report += `\n=== ${exchange.toUpperCase()} ===\n`;
                report += `Total Arrivals: ${wallets.length}\n\n`;

                wallets.forEach((wallet, index) => {
                    report += `${index + 1}. ${wallet.amount.toLocaleString()} ${wallet.currency}\n`;
                    report += `   Date/Time: ${wallet.timestamp ? new Date(wallet.timestamp).toLocaleString() : 'N/A'}\n`;
                    report += `   Receiving Wallet: ${wallet.wallet}\n`;
                    if (wallet.fromWallet) {
                        report += `   Sending Wallet: ${wallet.fromWallet}\n`;
                    }
                    if (wallet.txHash) {
                        report += `   Transaction Hash: ${wallet.txHash}\n`;
                    }
                    report += `   Hop: ${wallet.hopNumber ? wallet.hopNumber : 'N/A'}\n`;
                    report += `   Detection: ${wallet.detectionSource || 'Manual'}\n\n`;
                });
            });

            // Summary
            report += '\n=== SUMMARY ===\n';
            const totals = {};
            exchangeWallets.forEach(wallet => {
                const key = `${wallet.currency}_${wallet.exchangeName || 'Unknown'}`;
                if (!totals[key]) {
                    totals[key] = {
                        currency: wallet.currency,
                        exchange: wallet.exchangeName || 'Unknown',
                        amount: 0,
                        count: 0
                    };
                }
                totals[key].amount += wallet.amount;
                totals[key].count++;
            });

            Object.values(totals).forEach(total => {
                report += `${total.exchange}: ${total.amount.toLocaleString()} ${total.currency} (${total.count} transaction${total.count > 1 ? 's' : ''})\n`;
            });

            report += '\n=== LEGAL PROCESS REQUIREMENTS ===\n';
            report += 'The following exchanges have been identified as receiving stolen funds:\n\n';

            const uniqueExchanges = [...new Set(exchangeWallets.map(w => w.exchangeName || 'Unknown'))];
            uniqueExchanges.forEach(exchange => {
                report += `• ${exchange}\n`;
            });

            report += '\nLegal process (subpoenas, court orders, or international cooperation) may be required to:\n';
            report += '• Identify account holders at these exchanges\n';
            report += '• Freeze or recover funds\n';
            report += '• Obtain transaction records and KYC information\n';

            // Copy to clipboard
            navigator.clipboard.writeText(report).then(() => {
                showNotification('Terminal wallet report copied to clipboard', 'success');
            }).catch(err => {
                console.error('Failed to copy report:', err);
                alert('Failed to copy to clipboard. Please try exporting instead.');
            });
        }

        function detectPatterns() {
            const patterns = [];
            
            // Check for round amounts
            let roundAmounts = 0;
            investigation.hops.forEach(hop => {
                hop.entries.forEach(entry => {
                    const amount = parseFloat(entry.amount);
                    if (amount > 0 && amount % 100 === 0) {
                        roundAmounts++;
                    }
                });
            });
            
            if (roundAmounts > 5) {
                patterns.push({
                    type: 'Round Number Preference',
                    description: `${roundAmounts} transactions use round numbers (multiples of 100)`
                });
            }
            
            // Check for time patterns
            const timePatterns = {};
            investigation.victims.forEach(victim => {
                victim.transactions.forEach(t => {
                    if (t.datetime) {
                        const hour = new Date(t.datetime).getHours();
                        timePatterns[hour] = (timePatterns[hour] || 0) + 1;
                    }
                });
            });
            
            const peakHour = Object.entries(timePatterns).sort((a, b) => b[1] - a[1])[0];
            if (peakHour) {
                patterns.push({
                    type: 'Time Pattern',
                    description: `Peak activity at ${peakHour[0]}:00 hours (${peakHour[1]} transactions)`
                });
            }
            
            return patterns;
        }
        
        function getTerminalWallets() {
            const terminals = {
                'Purple (Exchange)': [],
                'Gray (Obfuscated)': [],
                'Blue (Cold Storage)': []
            };

            // First check terminal wallet index for detailed exchange info
            if (investigation.terminalWalletIndex && investigation.terminalWalletIndex.length > 0) {
                investigation.terminalWalletIndex.forEach(record => {
                    terminals['Purple (Exchange)'].push({
                        wallet: record.toWallet,
                        amount: record.amount,
                        currency: record.currency,
                        exchangeName: record.exchangeName,
                        timestamp: record.timestamp,
                        txHash: record.txHash,
                        fromWallet: record.fromWallet,
                        hopNumber: record.hopNumber,
                        detectionSource: record.detectionSource
                    });
                });
            }

            // Also check thread status for other terminal types
            const threadStatus = checkAllThreadsTerminated();
            threadStatus.activeThreads.forEach(thread => {
                if (thread.toWalletType === 'purple' &&
                    !terminals['Purple (Exchange)'].some(t => t.wallet === thread.toWallet && t.amount === thread.amount)) {
                    // Only add if not already in index
                    terminals['Purple (Exchange)'].push({
                        wallet: thread.toWallet,
                        amount: thread.amount,
                        currency: thread.currency,
                        exchangeName: 'Unknown Exchange',
                        hopNumber: thread.hopNumber
                    });
                } else if (thread.toWalletType === 'gray') {
                    terminals['Gray (Obfuscated)'].push({
                        wallet: thread.toWallet,
                        amount: thread.amount,
                        currency: thread.currency
                    });
                } else if (thread.toWalletType === 'blue') {
                    terminals['Blue (Cold Storage)'].push({
                        wallet: thread.toWallet,
                        amount: thread.amount,
                        currency: thread.currency
                    });
                }
            });
            
            return terminals;
        }
        
        // Export/Import Functions
        function exportInvestigation() {
            const exportData = {
                version: '1.0',
                exportDate: new Date().toISOString(),
                investigation: investigation
            };
            
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `BATS_Investigation_${investigation.caseId || 'export'}_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            alert(' Investigation exported successfully!');
        }
        
        function importInvestigation(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importData = JSON.parse(e.target.result);
                    
                    if (!importData.investigation) {
                        throw new Error('Invalid file format');
                    }
                    
                    if (confirm('⚠️ This will replace your current investigation. Are you sure you want to import?')) {
                        investigation = importData.investigation;
                        
                        // Reset pagination
                        currentHopPage = 1;
                        
                        // Clear collapse states
                        window.hopCollapseState = {};
                        window.entryCollapseState = {};
                        
                        // Save and re-render
                        saveToStorage();
                        location.reload(); // Reload to ensure all UI is properly initialized
                    }
                } catch (error) {
                    alert('ERROR:  Error importing file: ' + error.message);
                }
            };
            
            reader.readAsText(file);
        }
        
        // Export to CSV for specific data
        // Safe CSV cell escaping to prevent injection attacks
        function escapeCSVCell(value) {
            if (value === null || value === undefined) {
                return '';
            }

            const strValue = String(value);

            // Check for CSV injection patterns
            const injectionChars = ['=', '+', '-', '@', '\t', '\r'];
            const needsEscape = injectionChars.some(char => strValue.startsWith(char));

            // If starts with injection character, prefix with single quote
            let escaped = needsEscape ? "'" + strValue : strValue;

            // Handle quotes and commas
            if (escaped.includes('"') || escaped.includes(',') || escaped.includes('\n')) {
                // Escape quotes by doubling them
                escaped = escaped.replace(/"/g, '""');
                // Wrap in quotes
                escaped = `"${escaped}"`;
            }

            return escaped;
        }

        function exportToCSV(data, filename) {
            let csv = '';

            // Add headers
            const headers = Object.keys(data[0]);
            csv += headers.map(h => escapeCSVCell(h)).join(',') + '\n';

            // Add data
            data.forEach(row => {
                csv += headers.map(header => {
                    const value = row[header];
                    return escapeCSVCell(value);
                }).join(',') + '\n';
            });

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);

            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        // Pagination functions
        function changeHopPage(direction) {
            const totalPages = Math.ceil(investigation.hops.length / hopsPerPage);
            currentHopPage += direction;
            
            if (currentHopPage < 1) currentHopPage = 1;
            if (currentHopPage > totalPages) currentHopPage = totalPages;
            
            renderHops();
        }
        
        function updateHopsPerPage() {
            const select = document.getElementById('hopsPerPage');
            hopsPerPage = select.value === 'all' ? 'all' : parseInt(select.value);
            currentHopPage = 1; // Reset to first page
            renderHops();
        }

        function validateHopTransactionHashes(hop) {
            // Check for duplicate transaction hashes within the hop
            const txHashes = new Map();
            const duplicates = [];

            hop.entries.forEach(entry => {
                if (entry.txHash && entry.entryType !== 'writeoff') {
                    const hashLower = entry.txHash.toLowerCase();
                    if (txHashes.has(hashLower)) {
                        // Found duplicate
                        const existingEntry = txHashes.get(hashLower);
                        if (!duplicates.some(d => d.hash.toLowerCase() === hashLower)) {
                            duplicates.push({
                                hash: entry.txHash,
                                entries: [existingEntry.id, entry.id],
                                notations: [existingEntry.notation || 'Entry ' + existingEntry.id, entry.notation || 'Entry ' + entry.id]
                            });
                        }
                    } else {
                        txHashes.set(hashLower, entry);
                    }
                }
            });

            return duplicates;
        }

        function renderHops() {
            // Initialize collapse state tracking
            window.hopCollapseState = window.hopCollapseState || {};
            window.entryCollapseState = window.entryCollapseState || {};

            // Update dashboard
            updateDashboard();

            const container = document.getElementById('hopsList');
            container.innerHTML = '';

            if (!investigation.rootTotalConfirmed) {
                container.innerHTML = `
                    <div class="no-traces-message">
                        <h3>Root Total Confirmation Required</h3>
                        <p>Please return to the "Victims & Transactions" tab and confirm your root total before documenting trace hops.</p>
                        <button class="btn btn-confirm" onclick="switchTab('victims'); document.querySelector('[onclick=\\"switchTab(\\'victims\\')\\"]').click();">← Back to Victims & Transactions</button>
                    </div>
                `;
                return;
            }

            if (investigation.hops.length === 0) {
                const currentART = getCurrentART();
                const artDisplay = Object.entries(currentART).map(([currency, amount]) => 
                    `${amount.toLocaleString()} ${currency}`
                ).join(' | ');
                
                container.innerHTML = `
                    <div class="no-traces-message" style="background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%); border: 3px solid #4caf50; padding: 40px; max-width: 900px; margin: 0 auto;">
                        <h2 style="color: #2e7d32; margin-bottom: 30px; font-size: 2rem;">🚀 Ready to Start Tracing Your Funds!</h2>
                        
                        <div style="background: white; border-radius: 12px; padding: 30px; margin-bottom: 30px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
                            <h3 style="color: #1565c0; margin-bottom: 20px;">📋 What is Hop 1?</h3>
                            <p style="font-size: 1.1rem; line-height: 1.6; color: #424242; margin-bottom: 20px;">
                                <strong>Hop 1 documents where the stolen funds went IMMEDIATELY after leaving the RED wallets.</strong>
                            </p>
                            <div style="background: #f5f5f5; padding: 20px; border-radius: 8px; margin-bottom: 20px;">
                                <p style="margin: 0 0 15px 0; font-weight: bold; color: #1976d2;">You will need:</p>
                                <ul style="margin: 0; padding-left: 25px; color: #424242; line-height: 1.8;">
                                    <li>Transaction hash from each RED wallet showing outgoing funds</li>
                                    <li>Destination wallet addresses where funds were sent</li>
                                    <li>Amount and date/time of each transfer</li>
                                </ul>
                            </div>
                            <div style="background: #fff3e0; padding: 15px; border-radius: 8px; border-left: 4px solid #ff9800;">
                                <p style="margin: 0; color: #e65100;">
                                    <strong>💡 Example:</strong> If victim's funds went from RED wallet → Exchange wallet, that's your first Hop 1 entry
                                </p>
                            </div>
                        </div>
                        
                        <div class="art-display" style="background: white; padding: 20px; border-radius: 8px; margin-bottom: 30px; font-size: 1.15rem; font-weight: bold; border: 2px solid #4caf50;">
                            <div style="color: #1b5e20; margin-bottom: 5px;">Funds Available to Trace:</div>
                            <div style="color: #2e7d32; font-size: 1.3rem;">${artDisplay}</div>
                        </div>
                        
                        <button class="btn btn-confirm" onclick="addNewHop()" style="padding: 20px 50px; font-size: 1.3rem; background: #4caf50; animation: pulse 2s infinite; border: none; border-radius: 8px; cursor: pointer; box-shadow: 0 4px 15px rgba(76,175,80,0.3);">
                            ➕ Create Hop 1 - Start Tracing
                        </button>
                        
                        <div style="margin-top: 20px; padding-top: 20px; border-top: 2px solid rgba(255,255,255,0.3);">
                            <p style="color: #1b5e20; font-size: 0.95rem; margin: 0;">
                                <strong>Need help?</strong> Each hop represents one "jump" in the blockchain. Start with Hop 1 to track where funds went from the RED wallets.
                            </p>
                        </div>
                    </div>
                `;
                return;
            }

            // Pagination logic
            const totalHops = investigation.hops.length;
            const showPagination = totalHops > 10 && hopsPerPage !== 'all';
            document.getElementById('paginationControls').style.display = showPagination ? 'block' : 'none';
            
            let hopsToShow = investigation.hops;
            if (showPagination) {
                const startIndex = (currentHopPage - 1) * hopsPerPage;
                const endIndex = startIndex + hopsPerPage;
                hopsToShow = investigation.hops.slice(startIndex, endIndex);
                
                // Update pagination info
                const totalPages = Math.ceil(totalHops / hopsPerPage);
                document.getElementById('pageInfo').textContent = `Page ${currentHopPage} of ${totalPages} (${totalHops} total hops)`;
                document.getElementById('prevPageBtn').disabled = currentHopPage === 1;
                document.getElementById('nextPageBtn').disabled = currentHopPage === totalPages;
            }
            
            hopsToShow.forEach((hop, hopIndex) => {
                // Get the real hop index for alternating colors
                const realHopIndex = investigation.hops.indexOf(hop);
                const hopDiv = document.createElement('div');
                hopDiv.className = 'hop-container';
                hopDiv.setAttribute('data-hop-id', hop.hopNumber);
                
                // Calculate what's been accounted for in this hop
                // Use the thread database as the source of truth for amounts
                const availableThreads = getAvailableSourcesForHop(hop.hopNumber + 1, null);

                // Group available threads by currency for display
                const availableByCurrency = {};
                availableThreads.forEach(thread => {
                    if (!availableByCurrency[thread.currency]) {
                        availableByCurrency[thread.currency] = 0;
                    }
                    availableByCurrency[thread.currency] += thread.availableAmount;
                });

                // For "Total Accounted", show what's been traced in each entry
                // DO NOT count swaps - they are currency conversions, not traces
                const entryTotalsByCurrency = {};
                hop.entries.forEach(entry => {
                    if (parseFloat(entry.amount) > 0) {
                        // Skip swaps - they don't "account" for funds, they convert them
                        // Only count actual traces, writeoffs, cold storage
                        if (['trace', 'writeoff', 'cold_storage', 'vasp_arrival'].includes(entry.entryType)) {
                            const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                            if (!entryTotalsByCurrency[currency]) {
                                entryTotalsByCurrency[currency] = 0;
                            }
                            entryTotalsByCurrency[currency] += parseFloat(entry.amount);
                        }
                    }
                });
                
                // Check if hop is complete (all currencies balance)
                const artAtStart = hop.artAtStartByCurrency || {};

                // If artAtStartByCurrency is empty but we have a legacy artAtStart number, calculate it
                if (Object.keys(artAtStart).length === 0 && hop.artAtStart) {
                    // For legacy support - assume USD if only a number is stored
                    artAtStart['USD'] = hop.artAtStart;
                }

                let isComplete = hop.completed || false;
                let remainingDisplay = [];

                // Calculate remaining based on available threads, not just starting ART
                // This properly accounts for swaps that change currency
                // Use already fetched availableThreads from line 9836
                const remainingByCurrency = {};

                // Sum up remaining amounts by currency from available threads
                availableThreads.forEach(thread => {
                    if (thread.availableAmount > 0) {
                        if (!remainingByCurrency[thread.currency]) {
                            remainingByCurrency[thread.currency] = 0;
                        }
                        remainingByCurrency[thread.currency] += thread.availableAmount;
                    }
                });

                // Build display of remaining amounts
                Object.entries(remainingByCurrency).forEach(([currency, amount]) => {
                    if (amount >= 0.01) {
                        remainingDisplay.push(`${amount.toLocaleString()} ${currency}`);
                    }
                });

                // If no remaining threads, check if we had starting ART that wasn't traced
                if (remainingDisplay.length === 0 && Object.keys(artAtStart).length > 0) {
                    // Check for untraced amounts in original currencies
                    Object.entries(artAtStart).forEach(([currency, startAmount]) => {
                        const tracedAmount = entryTotalsByCurrency[currency] || 0;
                        const remaining = startAmount - tracedAmount;
                        if (Math.abs(remaining) >= 0.01) {
                            // Only show if not converted by swap
                            const hasSwapToOtherCurrency = hop.entries.some(e =>
                                e.entryType === 'swap' && e.currency === currency
                            );
                            if (!hasSwapToOtherCurrency) {
                                remainingDisplay.push(`${remaining.toLocaleString()} ${currency}`);
                            }
                        }
                    });
                }
                
                const artStartDisplay = typeof artAtStart === 'object' ? 
                    Object.entries(artAtStart).map(([currency, amount]) => `${amount.toLocaleString()} ${currency}`).join(' | ') :
                    `${artAtStart.toLocaleString()}`;
                
                // Initialize collapse state - completed hops start collapsed
                // Auto-collapse old hops for performance and clarity
                if (window.hopCollapseState[hop.hopNumber] === undefined) {
                    // When loading a saved investigation, collapse completed hops
                    // to reduce clutter and help users focus on current work
                    const isCurrentHop = !hop.completed && hop.entries && hop.entries.length > 0;
                    const isLastHop = hopIndex === investigation.hops.length - 1;
                    
                    // Collapse if: completed, or old hop (not in last 3), unless it's the current working hop
                    window.hopCollapseState[hop.hopNumber] = isComplete && !isCurrentHop && !isLastHop;
                }
                const isCollapsed = window.hopCollapseState[hop.hopNumber];
                
                // Different background colors for alternating hops
                const hopBgColor = realHopIndex % 2 === 0 ? '#f0f4f8' : '#e8ecf0';
                
                // Count entry summary
                const tracesCount = hop.entries.filter(e => e.entryType === 'trace').length;
                const writeoffsCount = hop.entries.filter(e => e.entryType === 'writeoff').length;
                const totalAccountedDisplay = Object.entries(entryTotalsByCurrency)
                    .map(([curr, amt]) => `${amt.toLocaleString()} ${curr}`)
                    .join(' | ');

                // Check for duplicate transaction hashes
                const duplicateHashes = validateHopTransactionHashes(hop);
                const hasDuplicates = duplicateHashes.length > 0;

                hopDiv.innerHTML = `
                    <div class="hop-container" data-hop-id="${hop.hopNumber}" style="background: ${hopBgColor}; border-radius: 12px; margin-bottom: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.08); overflow: hidden;">
                        <div class="hop-header" style="background: ${isComplete ? '#27ae60' : hasDuplicates ? '#d32f2f' : '#e67e22'}; color: white; padding: ${isCollapsed ? '12px 20px' : '20px'}; cursor: pointer;"
                             onclick="toggleHopCollapse(${hop.hopNumber})">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div style="display: flex; align-items: center; gap: 15px;">
                                    <span style="font-size: 24px; transform: rotate(${isCollapsed ? '0' : '90'}deg); transition: transform 0.3s;">
                                        ▶
                                    </span>
                                    <div>
                                        <h2 style="margin: 0; font-size: 1.5rem;">🎯 Hop ${hop.hopNumber}</h2>
                                        <div style="font-size: 14px; opacity: 0.9; margin-top: 5px;">
                                            ${isCollapsed ? `${tracesCount} traces, ${writeoffsCount} writeoffs | Total: ${totalAccountedDisplay || '0'}` : `ART at Hop Start: ${artStartDisplay}`}
                                        </div>
                                        ${hasDuplicates ? `
                                            <div style="background: rgba(255,255,255,0.2); padding: 8px 12px; border-radius: 6px; margin-top: 10px; border: 2px solid #fff;">
                                                <strong>⚠️ DUPLICATE TRANSACTION HASH DETECTED!</strong><br>
                                                ${duplicateHashes.map(dup =>
                                                    `<div style="margin-top: 5px; font-size: 12px;">
                                                        • TX ${dup.hash.substring(0, 10)}... used in: ${dup.notations.join(' & ')}
                                                    </div>`
                                                ).join('')}
                                                <div style="margin-top: 8px; font-size: 11px; font-style: italic;">
                                                    Multiple threads in the same transaction must be logged in a single entry
                                                </div>
                                            </div>
                                        ` : ''}
                                    </div>
                                </div>
                                <div style="text-align: right;">
                                    <div style="font-weight: bold; font-size: 16px;">
                                        ${hop.needsValidation ? 'Needs Validation' : isComplete ? '✅ Complete' : `⚠️ In Progress`}
                                    </div>
                                    ${hop.needsValidation ? `
                                        <div style="font-size: 12px; color: #e74c3c; margin-top: 5px;">
                                            Upstream changes detected
                                        </div>
                                    ` : ''}
                                    ${!isCollapsed && remainingDisplay.length > 0 && !isComplete ? 
                                        `<div style="font-size: 12px; opacity: 0.9; margin-top: 5px;">Remaining: ${remainingDisplay.join(' | ')}</div>` : ''
                                    }
                                    ${isComplete ? `
                                        <button class="btn btn-sm" onclick="reopenHop(${hop.hopNumber})" 
                                                style="margin-top: 8px; background: #3498db; padding: 6px 12px; font-size: 12px;">
                                            ✏️ Edit Hop
                                        </button>
                                    ` : ''}
                                    ${hop.needsValidation ? `
                                        <button class="btn btn-sm" onclick="validateAndUpdateHop(${hop.hopNumber})" 
                                                style="margin-top: 8px; background: #e74c3c; padding: 6px 12px; font-size: 12px;">
                                            Validate & Update
                                        </button>
                                    ` : ''}
                                </div>
                            </div>
                        </div>
                        
                        <div id="hopContent_${hop.hopNumber}" style="display: ${isCollapsed ? 'none' : 'block'}; padding: 20px;">
                            ${!isCollapsed ? `
                                <div style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 15px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                                        <div>
                                            <strong>ART at Hop Start:</strong><br>
                                            <span style="color: #2c3e50; font-size: 18px;">${artStartDisplay}</span>
                                        </div>
                                        <div>
                                            <strong>Current Available ART:</strong><br>
                                            <span style="color: #3498db; font-size: 18px;">${(() => {
                                                // Calculate current ART (accounts for writeoffs)
                                                const currentART = {};

                                                // Start with hop's starting ART
                                                Object.entries(artAtStart).forEach(([currency, amount]) => {
                                                    if (typeof amount === 'number') {
                                                        currentART[currency] = amount;
                                                    }
                                                });

                                                // Subtract writeoffs from current hop
                                                hop.entries.forEach(entry => {
                                                    if (entry.entryType === 'writeoff' && parseFloat(entry.amount) > 0) {
                                                        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                                                        if (currentART[currency]) {
                                                            currentART[currency] = roundAmount(currentART[currency] - parseFloat(entry.amount));
                                                        }
                                                    }
                                                });

                                                // Format for display
                                                const currentARTDisplay = Object.entries(currentART)
                                                    .filter(([currency, amount]) => amount > 0)
                                                    .map(([currency, amount]) => `${amount.toLocaleString()} ${currency}`)
                                                    .join(' | ');

                                                return currentARTDisplay || '0';
                                            })()}</span>
                                        </div>
                                        <div>
                                            <strong>Total Accounted:</strong><br>
                                            <span style="color: #27ae60; font-size: 18px;">${totalAccountedDisplay || '0'}</span>
                                        </div>
                                        ${remainingDisplay.length > 0 && !isComplete ? `
                                            <div>
                                                <strong>Remaining:</strong><br>
                                                <span style="color: #e67e22; font-size: 18px;">${remainingDisplay.join(' | ')}</span>
                                            </div>
                                        ` : ''}
                                    </div>
                                    
                                    <!-- Visual ART Progress Bars -->
                                    <div style="margin-top: 20px;">
                                        ${renderARTProgressBars(hop)}
                                    </div>
                                </div>
                            ` : ''}
                            
                            <div id="hopEntries_${hop.hopNumber}">
                                ${(hop.entries || []).map((entry, entryIndex) => renderCollapsibleHopEntry(entry, entryIndex, hop)).join('')}
                            </div>
                            
                            ${(!isComplete || (hop.entries && hop.entries.length > 0)) ? `
                                <div style="margin-top: 15px; padding: 20px; background: white; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                                    ${(() => {
                                        // First check if this hop has any entries at all
                                        const hasEntries = hop.entries && hop.entries.length > 0;

                                        // Get available threads for the CURRENT hop to see what needs to be traced
                                        const currentHopThreads = getAvailableSourcesForHop(hop.hopNumber, null);

                                        // Add total amount information to each thread
                                        // We'll keep ALL threads to check if they're rounding remainders
                                        const allThreadsInCurrentHop = currentHopThreads.filter(t => t.availableAmount > 0.000001).map(thread => {
                                            // Find the original thread to get total amount
                                            let totalAmount = thread.availableAmount;

                                            // Search in the threads database for the total
                                            for (const currency in investigation.availableThreads) {
                                                for (const threadKey in investigation.availableThreads[currency]) {
                                                    const dbThread = investigation.availableThreads[currency][threadKey];
                                                    if ((dbThread.notation === thread.threadId || dbThread.internalId === thread.internalId) && currency === thread.currency) {
                                                        totalAmount = dbThread.totalAmount || totalAmount;
                                                        break;
                                                    }
                                                }
                                            }

                                            return {
                                                ...thread,
                                                totalAmount: totalAmount
                                            };
                                        });

                                        // Separate actual unallocated threads from rounding remainders
                                        const unallocatedInCurrentHop = allThreadsInCurrentHop.filter(thread => {
                                            const remaining = thread.availableAmount;
                                            const original = thread.totalAmount || thread.availableAmount;
                                            const assigned = original - remaining;
                                            const percentAssigned = original > 0 ? (assigned / original) * 100 : 0;
                                            // Consider it a rounding remainder if >99% assigned and remainder is <1% of original
                                            const isRoundingRemainder = percentAssigned >= 99 && remaining < (original * 0.01);
                                            return !isRoundingRemainder && remaining > 0.01; // Only show actual unallocated amounts
                                        });

                                        // Check if ALL remaining amounts are just rounding remainders
                                        const onlyRoundingRemainders = allThreadsInCurrentHop.length > 0 && unallocatedInCurrentHop.length === 0;

                                        // Get available threads for the NEXT hop (created by this hop's entries)
                                        const nextHopNumber = hop.hopNumber + 1;
                                        const nextHopThreads = getAvailableSourcesForHop(nextHopNumber, null);
                                        const availableForNextHop = nextHopThreads.filter(t => t.availableAmount > 0);

                                        // Check if any threads are from swaps in the current hop
                                        const hasSwapOutputs = availableForNextHop.some(t => t.sourceType === 'swap_output' && t.hopLevel === hop.hopNumber);

                                        // Show threads available for CURRENT hop that still need assignment
                                        // BUT NOT if they're all just rounding remainders
                                        if (unallocatedInCurrentHop.length > 0 || (onlyRoundingRemainders && allThreadsInCurrentHop.length > 0)) {
                                            return `
                                                <div style="background: #fff3e0; border-left: 4px solid #ff9800; padding: 15px; margin-bottom: 20px; border-radius: 4px;">
                                                    <h4 style="margin: 0 0 10px 0; color: #e65100;">${onlyRoundingRemainders ? '✅ Hop Complete (Rounding Remainders Only)' : '📋 Available Threads for Hop ' + hop.hopNumber + ':'}</h4>
                                                    <div style="display: grid; gap: 8px;">
                                                        ${(onlyRoundingRemainders ? allThreadsInCurrentHop : unallocatedInCurrentHop).map(thread => {
                                                            // Show the remaining amount for this thread
                                                            const remaining = thread.availableAmount;
                                                            const original = thread.totalAmount || thread.availableAmount;
                                                            const assigned = original - remaining;
                                                            let percentAssigned = original > 0 ? Math.round((assigned / original) * 100) : 0;
                                                            const isRoundingRemainder = percentAssigned >= 99 && remaining < (original * 0.01);

                                                            return `
                                                                <div style="padding: 8px; background: ${isRoundingRemainder ? '#fff3e0' : 'white'}; border-radius: 4px;">
                                                                    <div style="display: flex; justify-content: space-between; align-items: center;">
                                                                        <span style="font-weight: bold; color: #2c3e50;">
                                                                            ${thread.threadId}
                                                                            ${isRoundingRemainder ? '<span style="color: #ff6b6b; font-size: 10px; margin-left: 5px;">(rounding)</span>' : ''}
                                                                        </span>
                                                                        <span style="color: ${isRoundingRemainder ? '#ff6b6b' : '#e67e22'}; font-weight: 600;">
                                                                            ${remaining.toLocaleString()} ${thread.currency}
                                                                        </span>
                                                                    </div>
                                                                    ${assigned > 0 ? `
                                                                        <div style="margin-top: 5px;">
                                                                            <div style="background: #f0f0f0; height: 6px; border-radius: 3px; overflow: hidden;">
                                                                                <div style="background: ${isRoundingRemainder ? '#4caf50' : '#ff9800'}; height: 100%; width: ${percentAssigned}%;"></div>
                                                                            </div>
                                                                            <small style="color: #999; font-size: 11px;">
                                                                                ${percentAssigned}% assigned
                                                                                ${isRoundingRemainder ? '(~' + ((remaining/original * 100).toFixed(2)) + '% remainder)' : ''}
                                                                            </small>
                                                                        </div>
                                                                    ` : ''}
                                                                </div>
                                                            `;
                                                        }).join('')}
                                                    </div>
                                                    <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #ffcc80;">
                                                        ${(() => {
                                                            // Check if all remaining threads are rounding remainders
                                                            const allRounding = unallocatedInCurrentHop.every(thread => {
                                                                const remaining = thread.availableAmount;
                                                                const original = thread.totalAmount || thread.availableAmount;
                                                                const assigned = original - remaining;
                                                                const percentAssigned = original > 0 ? Math.round((assigned / original) * 100) : 0;
                                                                return percentAssigned >= 99 && remaining < (original * 0.01);
                                                            });

                                                            if (allRounding && unallocatedInCurrentHop.length > 0) {
                                                                const totalRounding = unallocatedInCurrentHop.reduce((sum, t) => sum + t.availableAmount, 0);
                                                                const currency = unallocatedInCurrentHop[0].currency;
                                                                return `
                                                                    <div style="background: #e8f5e9; padding: 10px; border-radius: 4px; margin-bottom: 10px;">
                                                                        <div style="display: flex; justify-content: space-between; align-items: center;">
                                                                            <div>
                                                                                <strong style="color: #2e7d32;">✅ Hop Complete (Rounding Remainders Only)</strong>
                                                                                <div style="margin-top: 5px; font-size: 12px; color: #1b5e20;">
                                                                                    Total rounding remainder: ${totalRounding.toFixed(6)} ${currency}
                                                                                    <br>From ${unallocatedInCurrentHop.length} threads (< 1% each)
                                                                                </div>
                                                                            </div>
                                                                            <button onclick="writeOffAllRoundingRemainders(${hop.hopNumber})"
                                                                                    class="btn btn-warning"
                                                                                    style="font-size: 12px; padding: 5px 10px;">
                                                                                📝 Write Off All Rounding
                                                                            </button>
                                                                        </div>
                                                                    </div>
                                                                `;
                                                            } else if (unallocatedInCurrentHop.length > 0) {
                                                                return '<small style="color: #bf6000;">💡 Continue adding entries to trace these funds</small>';
                                                            } else {
                                                                return '<small style="color: #4caf50;">✅ All threads fully allocated</small>';
                                                            }
                                                        })()}
                                                    </div>
                                                </div>
                                            `;
                                        }
                                        // All threads fully traced - ready to finalize
                                        else {
                                            // Check if we actually have entries and they're all accounted for
                                            const allAccountedFor = hasEntries &&
                                                                   unallocatedInCurrentHop.length === 0 &&
                                                                   availableForNextHop.length === 0;

                                            if (allAccountedFor) {
                                                return `
                                                    <div style="background: #d4edda; border-left: 4px solid #27ae60; padding: 15px; margin-bottom: 20px; border-radius: 4px;">
                                                        <h4 style="margin: 0; color: #1e7e34;">✅ All threads fully traced!</h4>
                                                        <p style="margin: 10px 0 0 0; color: #155724;">All source funds have been accounted for. You can finalize this hop.</p>
                                                    </div>
                                                `;
                                            } else if (!hasEntries) {
                                                // No entries yet but also no available threads (shouldn't normally happen)
                                                return `
                                                    <div style="background: #f8d7da; border-left: 4px solid #dc3545; padding: 15px; margin-bottom: 20px; border-radius: 4px;">
                                                        <h4 style="margin: 0; color: #721c24;">⚠️ No threads available</h4>
                                                        <p style="margin: 10px 0 0 0; color: #721c24;">Check that previous hops have been completed correctly.</p>
                                                    </div>
                                                `;
                                            } else {
                                                // Has entries but threads still need allocation
                                                return `
                                                    <div style="background: #fff3e0; border-left: 4px solid #ff9800; padding: 15px; margin-bottom: 20px; border-radius: 4px;">
                                                        <h4 style="margin: 0; color: #e65100;">⚠️ Threads need allocation</h4>
                                                        <p style="margin: 10px 0 0 0; color: #856404;">Continue adding entries to account for all funds.</p>
                                                    </div>
                                                `;
                                            }
                                        }
                                    })()}

                                    ${!hop.completed ? `
                                        <h4 style="margin-bottom: 15px; color: #2c3e50;">Next Action:</h4>
                                        <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                                            <button class="btn btn-primary" onclick="showAddEntryWizard(${hop.hopNumber})"
                                                    style="padding: 12px 24px; background: #3498db; color: white; font-size: 16px;">
                                                + Add Entry
                                            </button>
                                            <button class="btn btn-secondary" onclick="viewAvailableThreads(${hop.hopNumber})"
                                                    style="padding: 12px 24px; font-size: 16px;">
                                                📊 View Available Threads
                                            </button>
                                            <button class="btn btn-confirm" onclick="finalizeHop(${hop.hopNumber})"
                                                    style="margin-left: auto; background: #27ae60; padding: 10px 30px;">
                                                Finalize Hop ${hop.hopNumber}
                                            </button>
                                        </div>
                                    ` : `
                                        <div style="background: #d4edda; border: 2px solid #27ae60; border-radius: 8px; padding: 20px; margin-top: 20px;">
                                            <h4 style="margin: 0 0 10px 0; color: #1e7e34;">✅ Hop ${hop.hopNumber} Completed</h4>
                                            <p style="margin: 0 0 15px 0; color: #155724;">This hop has been finalized. To make changes, you must reopen it for editing.</p>
                                            <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                                                <button class="btn btn-warning" onclick="reopenHopForEditing(${hop.hopNumber})"
                                                        style="padding: 10px 20px; background: #ff9800; color: white;">
                                                    🔓 Reopen for Editing
                                                </button>
                                                <button class="btn btn-secondary" onclick="viewAvailableThreads(${hop.hopNumber})"
                                                        style="padding: 10px 20px;">
                                                    📊 View Thread Summary
                                                </button>
                                            </div>
                                        </div>
                                    `}
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
                container.appendChild(hopDiv);
            });
            
            // Update add hop button and complete investigation section visibility
            updateInvestigationCompletionStatus();
        }

// Get starting ART for a specific hop
function getStartingARTForHop(hopNumber) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    if (!hop) return {};
    
    // Use the stored ART at start for this hop
    return hop.artAtStartByCurrency || {};
}

// Render visual ART progress bars
function renderARTProgressBars(hop) {
    // Get ART data for this hop
    const hopIndex = investigation.hops.findIndex(h => h.hopNumber === hop.hopNumber);
    const startingART = getStartingARTForHop(hop.hopNumber);

    // Calculate amounts by category for each currency
    const breakdown = {};

    // Initialize with starting ART
    Object.entries(startingART).forEach(([currency, amount]) => {
        if (amount > 0) {
            breakdown[currency] = {
                total: amount,
                traced: 0,
                writeoff: 0,
                coldStorage: 0,
                vasp: 0,
                swapped: 0,
                remaining: amount
            };
        }
    });

    // Process entries
    if (hop.entries) {
        hop.entries.forEach(entry => {
            const amount = parseFloat(entry.amount) || 0;

            if (entry.entryType === 'swap' && entry.swapDetails) {
                // Handle swap entries
                const inputCurrency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                const outputCurrency = entry.outputCurrency;
                const outputAmount = parseFloat(entry.outputAmount) || 0;

                // Mark input currency as swapped
                if (breakdown[inputCurrency]) {
                    breakdown[inputCurrency].swapped += amount;
                    breakdown[inputCurrency].remaining -= amount;
                }

                // Add output currency if it doesn't exist
                if (!breakdown[outputCurrency]) {
                    breakdown[outputCurrency] = {
                        total: 0,
                        traced: 0,
                        writeoff: 0,
                        coldStorage: 0,
                        vasp: 0,
                        swapped: 0,
                        remaining: 0,
                        isSwapOutput: true
                    };
                }

                // Add the swapped amount to the new currency
                breakdown[outputCurrency].total += outputAmount;
                breakdown[outputCurrency].remaining += outputAmount;

            } else if (amount > 0 && entry.currency) {
                const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;

                if (!breakdown[currency]) {
                    breakdown[currency] = {
                        total: 0,
                        traced: 0,
                        writeoff: 0,
                        coldStorage: 0,
                        vasp: 0,
                        swapped: 0,
                        remaining: 0
                    };
                }

                switch (entry.entryType) {
                    case 'trace':
                        // Check if this is a bridge with output
                        if (entry.isBridge && entry.bridgeDetails) {
                            // Mark input currency as bridged
                            breakdown[currency].swapped += amount; // Treat bridges like swaps
                            breakdown[currency].remaining -= amount;

                            // Add output currency
                            const outputCurrency = entry.bridgeDetails.destinationAsset;
                            const outputAmount = entry.bridgeDetails.destinationAmount || 0;

                            if (outputCurrency && outputAmount > 0) {
                                if (!breakdown[outputCurrency]) {
                                    breakdown[outputCurrency] = {
                                        total: 0,
                                        traced: 0,
                                        writeoff: 0,
                                        coldStorage: 0,
                                        vasp: 0,
                                        swapped: 0,
                                        remaining: 0,
                                        isBridgeOutput: true
                                    };
                                }
                                breakdown[outputCurrency].total += outputAmount;
                                breakdown[outputCurrency].remaining += outputAmount;
                            }
                        }
                        // Check if this trace goes to a VASP/exchange (purple wallet) without bridge
                        else if ((entry.toWalletType === 'purple' || entry.isTerminalWallet) && !entry.isBridge) {
                            breakdown[currency].vasp += amount;
                            breakdown[currency].remaining -= amount;
                        } else if (!entry.isBridge) {
                            breakdown[currency].traced += amount;
                            breakdown[currency].remaining -= amount;
                        }
                        break;
                    case 'writeoff':
                        breakdown[currency].writeoff += amount;
                        breakdown[currency].remaining -= amount;
                        break;
                    case 'cold_storage':
                        breakdown[currency].coldStorage += amount;
                        breakdown[currency].remaining -= amount;
                        break;
                }
            }
        });
    }
    
    // Generate progress bars
    let html = '';

    Object.entries(breakdown).forEach(([currency, data]) => {
        const total = data.total;
        if (total <= 0) return;

        // Calculate percentages
        const tracedPct = (data.traced / total) * 100;
        const writeoffPct = (data.writeoff / total) * 100;
        const coldStoragePct = (data.coldStorage / total) * 100;
        const vaspPct = (data.vasp / total) * 100;
        const swappedPct = (data.swapped / total) * 100;
        const remainingPct = Math.max(0, (data.remaining / total) * 100);
        
        html += `
            <div style="margin-bottom: 15px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                    <strong>${currency} ${data.isSwapOutput ? '(from swap)' : data.isBridgeOutput ? '(from bridge)' : ''}</strong>
                    <span style="font-size: 12px; color: #666;">
                        ${data.total.toLocaleString()} total
                        ${data.swapped > 0 ? ` (${data.swapped.toLocaleString()} converted to other currency)` : ''}
                    </span>
                </div>
                
                <!-- Progress Bar -->
                <div style="position: relative; height: 30px; background: #f5f5f5; border-radius: 15px; overflow: hidden; box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);">
                    <!-- Traced (Green) -->
                    ${tracedPct > 0 ? `
                        <div style="position: absolute; left: 0; top: 0; height: 100%; width: ${tracedPct}%; background: #27ae60; transition: width 0.3s ease;"
                             title="Traced: ${data.traced.toLocaleString()} ${currency} (${tracedPct.toFixed(1)}%)">
                        </div>
                    ` : ''}
                    
                    <!-- VASP/Exchange (Purple) -->
                    ${vaspPct > 0 ? `
                        <div style="position: absolute; left: ${tracedPct}%; top: 0; height: 100%; width: ${vaspPct}%; background: #9b59b6; transition: all 0.3s ease;"
                             title="Sent to Exchange/VASP: ${data.vasp.toLocaleString()} ${currency} (${vaspPct.toFixed(1)}%)">
                        </div>
                    ` : ''}

                    <!-- Swapped (Brown) -->
                    ${swappedPct > 0 ? `
                        <div style="position: absolute; left: ${tracedPct + vaspPct}%; top: 0; height: 100%; width: ${swappedPct}%; background: #8B4513; transition: all 0.3s ease;"
                             title="Swapped to another currency: ${data.swapped.toLocaleString()} ${currency} (${swappedPct.toFixed(1)}%)">
                        </div>
                    ` : ''}
                    
                    <!-- Write-off (Gray) -->
                    ${writeoffPct > 0 ? `
                        <div style="position: absolute; left: ${tracedPct + vaspPct + swappedPct}%; top: 0; height: 100%; width: ${writeoffPct}%; background: #95a5a6; transition: all 0.3s ease;"
                             title="Written off: ${data.writeoff.toLocaleString()} ${currency} (${writeoffPct.toFixed(1)}%)">
                        </div>
                    ` : ''}

                    <!-- Cold Storage (Blue) -->
                    ${coldStoragePct > 0 ? `
                        <div style="position: absolute; left: ${tracedPct + vaspPct + swappedPct + writeoffPct}%; top: 0; height: 100%; width: ${coldStoragePct}%; background: #3498db; transition: all 0.3s ease;"
                             title="Cold Storage: ${data.coldStorage.toLocaleString()} ${currency} (${coldStoragePct.toFixed(1)}%)">
                        </div>
                    ` : ''}

                    <!-- Remaining (Red) -->
                    ${remainingPct > 0.1 ? `
                        <div style="position: absolute; left: ${tracedPct + vaspPct + swappedPct + writeoffPct + coldStoragePct}%; top: 0; height: 100%; width: ${remainingPct}%; background: #e74c3c; transition: all 0.3s ease;"
                             title="Remaining to account: ${data.remaining.toLocaleString()} ${currency} (${remainingPct.toFixed(1)}%)">
                        </div>
                    ` : ''}
                    
                    <!-- Percentage labels -->
                    <div style="position: absolute; width: 100%; height: 100%; display: flex; align-items: center; padding: 0 10px; pointer-events: none;">
                        ${tracedPct > 15 ? `
                            <span style="color: white; font-size: 11px; font-weight: bold; text-shadow: 1px 1px 2px rgba(0,0,0,0.3);">
                                ${tracedPct.toFixed(0)}%
                            </span>
                        ` : ''}
                    </div>
                </div>
                
                <!-- Legend -->
                <div style="display: flex; gap: 15px; margin-top: 8px; font-size: 11px; flex-wrap: wrap;">
                    ${data.traced > 0 ? `
                        <span style="display: flex; align-items: center; gap: 5px;">
                            <span style="width: 12px; height: 12px; background: #27ae60; border-radius: 2px;"></span>
                            Traced: ${data.traced.toLocaleString()}
                        </span>
                    ` : ''}
                    ${data.vasp > 0 ? `
                        <span style="display: flex; align-items: center; gap: 5px;">
                            <span style="width: 12px; height: 12px; background: #9b59b6; border-radius: 2px;"></span>
                            Exchange/VASP: ${data.vasp.toLocaleString()}
                        </span>
                    ` : ''}
                    ${data.swapped > 0 ? `
                        <span style="display: flex; align-items: center; gap: 5px;">
                            <span style="width: 12px; height: 12px; background: #8B4513; border-radius: 2px;"></span>
                            Swapped: ${data.swapped.toLocaleString()}
                        </span>
                    ` : ''}
                    ${data.writeoff > 0 ? `
                        <span style="display: flex; align-items: center; gap: 5px;">
                            <span style="width: 12px; height: 12px; background: #95a5a6; border-radius: 2px;"></span>
                            Written off: ${data.writeoff.toLocaleString()}
                        </span>
                    ` : ''}
                    ${data.coldStorage > 0 ? `
                        <span style="display: flex; align-items: center; gap: 5px;">
                            <span style="width: 12px; height: 12px; background: #3498db; border-radius: 2px;"></span>
                            Cold Storage: ${data.coldStorage.toLocaleString()}
                        </span>
                    ` : ''}
                    ${data.remaining > 0 ? `
                        <span style="display: flex; align-items: center; gap: 5px;">
                            <span style="width: 12px; height: 12px; background: #e74c3c; border-radius: 2px;"></span>
                            Remaining: ${data.remaining.toLocaleString()}
                        </span>
                    ` : ''}
                </div>
            </div>
        `;
    });
    
    return html || '<div style="text-align: center; color: #999;">No ART data to display</div>';
}

// Show modal for ART completion options
function showARTCompletionModal(hop, validation) {
    const modalHTML = `
        <div id="artCompletionModal" class="modal" style="display: block;">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>⚠️ Complete ART Balance for Hop ${hop.hopNumber}</h2>
                    <p>All ART must be accounted for before starting the next hop</p>
                </div>
                
                <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 20px; margin: 20px 0;">
                    <h4 style="color: #856404; margin-bottom: 15px;">Unaccounted Amounts:</h4>
                    ${Object.entries(validation.remainingByCurrency).map(([currency, amount]) => 
                        amount > 0 ? `
                            <div style="margin-bottom: 15px; padding: 15px; background: white; border-radius: 6px; border-left: 4px solid #ffc107;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                    <strong>${currency}: ${amount.toLocaleString()} remaining</strong>
                                </div>
                                <div style="display: flex; gap: 10px;">
                                    <button class="btn btn-danger" onclick="createMaxWriteoff(${hop.hopNumber}, '${currency}', ${amount})">
                                        📝 Write Off All ${amount.toLocaleString()} ${currency}
                                    </button>
                                    <button class="btn" style="background: #3498db;" onclick="createColdStorage(${hop.hopNumber}, '${currency}', ${amount})">
                                        Mark as Cold Storage
                                    </button>
                                </div>
                                <div style="margin-top: 10px; font-size: 12px; color: #666;">
                                    Or manually add trace/write-off entries to account for this amount
                                </div>
                            </div>
                        ` : ''
                    ).join('')}
                </div>
                
                <div style="text-align: center; margin-top: 25px;">
                    <button class="btn btn-secondary" onclick="closeARTCompletionModal()">
                        Cancel - Return to Fix Hop ${hop.hopNumber}
                    </button>
                </div>
            </div>
        </div>
    `;
    
    // Create centered modal
    createCenteredModal('artCompletionModal', modalHTML);
}

// Create maximum write-off entry to balance ART
function createMaxWriteoff(hopNumber, currency, amount) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    if (!hop) return;
    
    const writeoffEntry = {
        id: hop.entries.length + 1,
        hopNumber: hopNumber,
        hopNumber: hop.hopNumber,
        entryType: 'writeoff',
        notation: '',
        amount: amount.toString(),
        currency: currency,
        customCurrency: currency === 'CUSTOM' ? currency : '',
        category: 'operational',
        justification: `ART balancing write-off: ${amount.toLocaleString()} ${currency} to complete hop accounting`,
        // Enhanced fields
        sourceChain: [],
        displayNotation: '',
        summaryNotation: '',
        victimNumbers: '',
        transactionNumbers: '',
        availableSourceAmount: 0,
        sourceThreadId: '',
        sourceThreadData: null,
        assignmentPercentage: 0,
        generatedNotation: '',
        isConvergence: false,
        convergenceData: null,
        fromWallet: '',
        fromWalletType: '',
        fromWalletId: '',
        toWallet: '',
        toWalletType: '',
        toWalletId: '',
        txHash: '',
        timestamp: '',
        timezone: 'UTC',
        notes: `Auto-generated to balance ART for hop completion`
    };
    
    hop.entries.push(writeoffEntry);
    
    // Sort entries chronologically
    sortHopEntriesChronologically(hop);
    
    closeARTCompletionModal();
    renderHops();
    saveToStorage();
    
    alert(` Write-off created for ${amount.toLocaleString()} ${currency}. Hop ${hop.hopNumber} is now balanced.`);
}

// Create cold storage entry to account for funds
function createColdStorage(hopNumber, currency, amount) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    if (!hop) return;
    
    // Find the most recent trace entry with the same currency to get wallet info
    let sourceWallet = '';
    let sourceWalletType = '';
    
    for (let i = hop.entries.length - 1; i >= 0; i--) {
        const entry = hop.entries[i];
        const entryCurrency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
        if (entry.entryType === 'trace' && entryCurrency === currency && entry.toWallet) {
            sourceWallet = entry.toWallet;
            sourceWalletType = entry.toWalletType || 'black';
            break;
        }
    }
    
    const coldStorageEntry = {
        id: hop.entries.length + 1,
        hopNumber: hopNumber,
        hopNumber: hop.hopNumber,
        entryType: 'cold_storage',
        notation: '',
        amount: amount.toString(),
        currency: currency,
        customCurrency: currency === 'CUSTOM' ? currency : '',
        category: '',
        justification: '',
        // Enhanced fields
        sourceChain: [],
        displayNotation: '',
        summaryNotation: '',
        victimNumbers: '',
        transactionNumbers: '',
        availableSourceAmount: 0,
        sourceThreadId: '',
        sourceThreadData: null,
        assignmentPercentage: 0,
        generatedNotation: '',
        isConvergence: false,
        convergenceData: null,
        fromWallet: sourceWallet,
        fromWalletType: sourceWalletType,
        fromWalletId: '',
        toWallet: sourceWallet, // Same wallet, marking as cold storage
        toWalletType: 'blue', // BLUE = Cold Storage
        toWalletId: '',
        txHash: '',
        timestamp: '',
        timezone: 'UTC',
        notes: `Auto-generated cold storage classification: ${amount.toLocaleString()} ${currency} remains in this wallet`
    };
    
    hop.entries.push(coldStorageEntry);
    
    // Sort entries chronologically
    sortHopEntriesChronologically(hop);
    
    closeARTCompletionModal();
    renderHops();
    saveToStorage();
    
    alert(`Cold storage entry created for ${amount.toLocaleString()} ${currency}. Funds marked as BLUE (cold storage) in current wallet.`);
}

// Close ART completion modal
function closeARTCompletionModal() {
    const modal = document.getElementById('artCompletionModal');
    if (modal) {
        modal.remove();
    }
}
// Main function to finalize a hop with all validation and options
// Analyze which wallets have untraced balances
function analyzeUntracedBalances(hop) {
    const walletBalances = {};
    
    // Calculate incoming amounts to each wallet in this hop
    hop.entries.forEach(entry => {
        if (entry.entryType === 'trace' && entry.toWallet && parseFloat(entry.amount) > 0) {
            const wallet = entry.toWallet;
            const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
            const key = `${wallet}|${currency}`;
            
            if (!walletBalances[key]) {
                walletBalances[key] = {
                    wallet: wallet,
                    walletType: entry.toWalletType,
                    currency: currency,
                    incoming: 0,
                    outgoing: 0,
                    balance: 0
                };
            }
            walletBalances[key].incoming += parseFloat(entry.amount);
        }
    });
    
    // Check if these wallets have outgoing transactions in the next hop
    const nextHopNumber = hop.hopNumber + 1;
    const nextHop = investigation.hops.find(h => h.hopNumber === nextHopNumber);
    
    if (nextHop) {
        nextHop.entries.forEach(entry => {
            if (entry.sourceThreadId) {
                // Parse the source thread to find the originating wallet
                const sourceMatch = entry.sourceThreadId.match(/H(\d+)$/);
                if (sourceMatch && parseInt(sourceMatch[1]) === hop.hopNumber) {
                    // This entry sources from the current hop
                    // Find which wallet it came from by checking the current hop's entries
                    hop.entries.forEach(hopEntry => {
                        if (hopEntry.notation === entry.sourceThreadId.replace(/-H\d+$/, '') && hopEntry.toWallet) {
                            const wallet = hopEntry.toWallet;
                            const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                            const key = `${wallet}|${currency}`;
                            
                            if (walletBalances[key]) {
                                walletBalances[key].outgoing += parseFloat(entry.amount);
                            }
                        }
                    });
                }
            }
        });
    }
    
    // Calculate final balances and identify wallets with remaining funds
    const walletsWithFunds = [];
    Object.values(walletBalances).forEach(wb => {
        wb.balance = wb.incoming - wb.outgoing;
        if (wb.balance > 0.01) {  // Only consider significant balances
            walletsWithFunds.push({
                wallet: wb.wallet,
                walletType: wb.walletType,
                currency: wb.currency,
                remainingBalance: wb.balance,
                suggestColdStorage: wb.walletType !== 'blue' && wb.walletType !== 'purple' && wb.walletType !== 'gray'
            });
        }
    });
    
    return walletsWithFunds;
}

// New function to show comprehensive hop finalization summary
function showHopFinalizationSummary(hop, remainingByCurrency, walletsWithRemainingFunds) {
    // Check for unallocated bridge/swap outputs FIRST
    const availableThreadsForNextHop = getAvailableSourcesForHop(hop.hopNumber + 1, null);
    const unallocatedBridgeOutputs = [];
    const unallocatedSwapOutputs = [];

    availableThreadsForNextHop.forEach(thread => {
        // Check if this is a same-hop conversion output that needs allocation
        if (thread.hopLevel === hop.hopNumber && thread.availableAmount > 0) {
            if (thread.sourceType === 'bridge_output') {
                unallocatedBridgeOutputs.push(thread);
            } else if (thread.sourceType === 'swap_output') {
                unallocatedSwapOutputs.push(thread);
            }
        }
    });

    // If there are unallocated bridge/swap outputs, show warning and prevent finalization
    if (unallocatedBridgeOutputs.length > 0 || unallocatedSwapOutputs.length > 0) {
        const modalHTML = `
            <div id="hopFinalizationModal" class="modal" style="display: block;">
                <div class="modal-content" style="max-width: 800px;">
                    <div class="modal-header" style="background: #f8d7da; border-bottom: 2px solid #f5c6cb;">
                        <h2>❌ Cannot Finalize Hop ${hop.hopNumber}</h2>
                        <p style="color: #721c24;">Unallocated bridge/swap outputs must be traced first</p>
                    </div>

                    <div style="padding: 20px;">
                        ${unallocatedBridgeOutputs.length > 0 ? `
                            <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                                <h3 style="margin-top: 0; color: #856404;">🌉 Unallocated Bridge Outputs (${unallocatedBridgeOutputs.length})</h3>
                                <p>These bridge outputs were created when you logged bridge destinations. They must be allocated before finalizing:</p>
                                <ul style="margin: 10px 0;">
                                    ${unallocatedBridgeOutputs.map(thread => `
                                        <li><strong>${thread.threadId}</strong>: ${thread.availableAmount.toLocaleString()} ${thread.currency}
                                            <small>(from ${thread.sourceWallet ? thread.sourceWallet.substring(0, 16) + '...' : 'bridge'})</small></li>
                                    `).join('')}
                                </ul>
                            </div>
                        ` : ''}

                        ${unallocatedSwapOutputs.length > 0 ? `
                            <div style="background: #e3f2fd; border: 2px solid #2196f3; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                                <h3 style="margin-top: 0; color: #0d47a1;">🔄 Unallocated Swap Outputs (${unallocatedSwapOutputs.length})</h3>
                                <p>These swap outputs need to be traced:</p>
                                <ul style="margin: 10px 0;">
                                    ${unallocatedSwapOutputs.map(thread => `
                                        <li><strong>${thread.threadId}</strong>: ${thread.availableAmount.toLocaleString()} ${thread.currency}</li>
                                    `).join('')}
                                </ul>
                            </div>
                        ` : ''}

                        <div style="background: #d4edda; border: 2px solid #c3e6cb; border-radius: 8px; padding: 15px;">
                            <h4 style="margin-top: 0; color: #155724;">What to do:</h4>
                            <ol style="margin: 10px 0; padding-left: 20px;">
                                <li>Click "Add Entry" to create trace entries for each unallocated output</li>
                                <li>Select the bridge/swap output threads as sources</li>
                                <li>Enter the transaction details for where these funds went</li>
                                <li>Once all outputs are allocated, you can finalize the hop</li>
                            </ol>
                        </div>

                        <div style="margin-top: 20px; text-align: center;">
                            <button class="btn btn-primary" onclick="closeFinalizationModal(); scrollToHop(${hop.hopNumber});">
                                Return to Hop ${hop.hopNumber}
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        `;

        document.body.insertAdjacentHTML('beforeend', modalHTML);
        return; // Don't show the normal finalization modal
    }

    // Calculate threads created in this hop
    const threadsCreated = [];
    let allThreadsTerminal = true;
    hop.entries.forEach(entry => {
        if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0 && entry.notation) {
            const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
            // Check if terminal - wallet type is stored as lowercase
            // Note: Bridge outputs are NOT terminal even though they were converted from purple wallets
            const isTerminal = (entry.toWalletType === 'purple' || entry.toWalletType === 'PURPLE' || entry.isTerminal === true) && !entry.isBridge;
            if (!isTerminal) {
                allThreadsTerminal = false;
            }
            threadsCreated.push({
                notation: entry.notation,
                amount: parseFloat(entry.amount),
                currency: currency,
                toWallet: entry.toWallet,
                toWalletType: entry.toWalletType,
                isTerminal: isTerminal,
                isBridge: entry.isBridge
            });
        }
    });
    
    // Calculate balance status
    const isBalanced = Object.keys(remainingByCurrency).length === 0;
    const balanceStatusHTML = isBalanced ? `
        <div style="background: #d4edda; border: 2px solid #27ae60; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
            <h3 style="color: #155724; margin-top: 0;">✅ Hop is Balanced!</h3>
            <p style="color: #155724; margin-bottom: 0;">All Adjusted Root Total (ART) has been accounted for. You can proceed to the next hop.</p>
        </div>
    ` : `
        <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
            <h3 style="color: #856404; margin-top: 0;">⚠️ Hop Has Unaccounted Amounts</h3>
            <p style="color: #856404;">The following amounts need to be accounted for before proceeding:</p>
            <ul style="margin-bottom: 0;">
                ${Object.entries(remainingByCurrency).map(([currency, amount]) => 
                    `<li><strong>${amount.toLocaleString()} ${currency}</strong> remaining</li>`
                ).join('')}
            </ul>
        </div>
    `;
    
    // Thread summary
    const threadSummaryHTML = threadsCreated.length > 0 ? `
        <div style="background: #e3f2fd; border: 2px solid #2196f3; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
            <h3 style="color: #0d47a1; margin-top: 0;">Threads Created in Hop ${hop.hopNumber}</h3>
            <p style="color: #0d47a1; margin-bottom: 15px;">${allThreadsTerminal ? 'All threads have reached terminal wallets:' : `These threads will be available for tracing in Hop ${hop.hopNumber + 1}:`}</p>
            <div style="max-height: 200px; overflow-y: auto;">
                ${threadsCreated.map(thread => `
                    <div style="background: white; padding: 10px; margin-bottom: 10px; border-radius: 4px; border-left: 4px solid #2196f3;">
                        <strong>${thread.notation}</strong> - ${thread.amount.toLocaleString()} ${thread.currency}
                        <br><span style="font-size: 12px; color: #666;">To: ${thread.toWallet.substring(0, 16)}... (${thread.isTerminal ? '🟪 TERMINAL - ' : ''}${walletTypes[thread.toWalletType] || thread.toWalletType})</span>
                    </div>
                `).join('')}
            </div>
        </div>
    ` : '';
    
    const modalHTML = `
        <div id="hopFinalizationModal" class="modal" style="display: block;">
            <div class="modal-content" style="max-width: 800px; max-height: 90vh; overflow-y: auto;">
                <div class="modal-header">
                    <h2>Finalize Hop ${hop.hopNumber}</h2>
                    <p>Review hop summary and balance any remaining amounts</p>
                </div>
                
                ${balanceStatusHTML}
                ${threadSummaryHTML}
                
                ${!isBalanced ? `
                    <div style="margin-bottom: 20px;">
                        <h3>Balance Remaining Amounts</h3>
                        <p style="color: #666; margin-bottom: 15px;">Choose how to account for the remaining amounts. These options close out funds without creating new threads:</p>
                        
                        ${Object.entries(remainingByCurrency).map(([currency, amount]) => `
                            <div style="background: white; border: 2px solid #ddd; border-radius: 8px; padding: 20px; margin-bottom: 15px;">
                                <h4 style="margin-top: 0;">${amount.toLocaleString()} ${currency} Remaining</h4>
                                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">
                                    <button class="btn btn-warning" onclick="writeOffAmount(${hop.hopNumber}, '${currency}', ${amount})">
                                        ❌ Write Off
                                    </button>
                                    <button class="btn btn-primary" onclick="markAsColdStorage(${hop.hopNumber}, '${currency}', ${amount})">
                                        ❄️ Cold Storage
                                    </button>
                                    <button class="btn btn-success" onclick="markAsVASPArrival(${hop.hopNumber}, '${currency}', ${amount})">
                                        VASP Arrival
                                    </button>
                                    <button class="btn btn-secondary" onclick="assignPartialAmount(${hop.hopNumber}, '${currency}', ${amount})">
                                        ✂️ Split Amount
                                    </button>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                ` : ''}
                
                <div style="margin-top: 30px; padding-top: 20px; border-top: 2px solid #e0e0e0; text-align: center;">
                    ${isBalanced ? `
                        <button class="btn btn-success btn-large" onclick="proceedWithHopFinalization(investigation.hops.find(h => h.hopNumber === ${hop.hopNumber}))">
                            ${allThreadsTerminal ? '🎯 Complete Trace' : `✅ Complete Hop ${hop.hopNumber}`}
                        </button>
                    ` : `
                        <p style="color: #666; margin-bottom: 10px;">Balance all remaining amounts to proceed</p>
                        <button class="btn btn-secondary" onclick="closeFinalizationModal()">
                            Cancel
                        </button>
                    `}
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHTML);
}

function closeFinalizationModal() {
    const modal = document.getElementById('hopFinalizationModal');
    if (modal) modal.remove();
}

function viewAvailableThreads(hopNumber) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    if (!hop) return;
    
    console.log('Viewing available threads for hop:', hop.hopNumber);
    console.log('Current hop entries:', hop.entries);
    
    const availableThreads = getAvailableSourcesForHop(hop.hopNumber, null);
    console.log('Available threads returned:', availableThreads);
    
    const modalHTML = `
        <div id="availableThreadsModal" class="modal" style="display: block; z-index: 9999;">
            <div class="modal-content" style="max-width: 800px; max-height: 90vh; overflow-y: auto;">
                <div class="modal-header">
                    <h2>📊 Available Threads for Hop ${hop.hopNumber}</h2>
                    <span class="close" onclick="document.getElementById('availableThreadsModal').remove()">&times;</span>
                </div>
                <div style="padding: 20px;">
                    ${availableThreads.length === 0 ? `
                        <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 20px; text-align: center;">
                            <p style="margin: 0; color: #856404;">No available threads for this hop.</p>
                            <small>Threads become available from previous hop entries that have been traced.</small>
                        </div>
                    ` : `
                        <div style="background: #e8f4f8; border: 1px solid #3498db; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                            <p style="margin: 0; color: #2c3e50;">
                                <strong>Available threads:</strong> These are the funds you can trace in this hop.
                                Each thread represents a transaction output from a previous hop that hasn't been fully assigned yet.
                            </p>
                        </div>
                        <table style="width: 100%; border-collapse: collapse;">
                            <thead>
                                <tr style="background: #f8f9fa; border-bottom: 2px solid #dee2e6;">
                                    <th style="padding: 12px; text-align: left;">Thread ID</th>
                                    <th style="padding: 12px; text-align: left;">Source</th>
                                    <th style="padding: 12px; text-align: left;">Date/Time</th>
                                    <th style="padding: 12px; text-align: right;">Available Amount</th>
                                    <th style="padding: 12px; text-align: left;">Currency</th>
                                    <th style="padding: 12px; text-align: left;">Status</th>
                                </tr>
                            </thead>
                            <tbody>
                                ${availableThreads.map(thread => {
                                    const isFullyAssigned = thread.availableAmount === 0;
                                    return `
                                        <tr style="border-bottom: 1px solid #dee2e6;">
                                            <td style="padding: 10px; font-family: monospace;">${thread.threadId}</td>
                                            <td style="padding: 10px;">${thread.displayText}</td>
                                            <td style="padding: 10px; font-size: 13px;">
                                                ${thread.datetime ? 
                                                    formatDateTimeForReport(thread.datetime, thread.timezone) : 
                                                    '<span style="color: #999;">Not specified</span>'
                                                }
                                            </td>
                                            <td style="padding: 10px; text-align: right; font-weight: bold; color: ${isFullyAssigned ? '#dc3545' : '#28a745'};">
                                                ${thread.availableAmount.toLocaleString()}
                                            </td>
                                            <td style="padding: 10px;">${thread.currency}</td>
                                            <td style="padding: 10px;">
                                                ${isFullyAssigned ? 
                                                    '<span style="color: #dc3545;">✗ Fully Assigned</span>' : 
                                                    '<span style="color: #28a745;">✓ Available</span>'
                                                }
                                            </td>
                                        </tr>
                                    `;
                                }).join('')}
                            </tbody>
                        </table>
                        <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                            <h4 style="margin-bottom: 10px;">Summary by Currency:</h4>
                            ${Object.entries(availableThreads.reduce((acc, thread) => {
                                if (!acc[thread.currency]) acc[thread.currency] = 0;
                                acc[thread.currency] += thread.availableAmount;
                                return acc;
                            }, {})).map(([currency, total]) => `
                                <div style="margin: 5px 0;">
                                    <strong>${currency}:</strong> ${total.toLocaleString()} available
                                </div>
                            `).join('')}
                        </div>
                    `}
                    <div style="margin-top: 20px; text-align: center;">
                        <button class="btn btn-primary" onclick="document.getElementById('availableThreadsModal').remove()">Close</button>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHTML);
}

// Reopen a completed hop for editing
function reopenHopForEditing(hopNumber) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    if (!hop) {
        alert('Hop not found');
        return;
    }

    // Check if there are dependent hops
    const hasSubsequentHops = investigation.hops.some(h => h.hopNumber > hopNumber);

    if (hasSubsequentHops) {
        const confirmReopen = confirm(
            `⚠️ WARNING: Reopening Hop ${hopNumber} for Editing\n\n` +
            `This hop has subsequent hops that depend on it.\n\n` +
            `Reopening this hop may affect:\n` +
            `• Thread allocations in later hops\n` +
            `• Fund flow continuity\n` +
            `• Investigation integrity\n\n` +
            `Are you sure you want to reopen Hop ${hopNumber}?\n\n` +
            `Note: You may need to review and update subsequent hops after making changes.`
        );

        if (!confirmReopen) {
            return;
        }
    }

    // Save undo state
    saveUndoState(`Reopen Hop ${hopNumber} for editing`);

    // Mark hop as not completed
    hop.completed = false;
    hop.isCollapsed = false;
    window.hopCollapseState[hop.hopNumber] = false;

    // Log the action
    console.log(`Reopened Hop ${hopNumber} for editing`);

    // Re-render the hops
    renderHops();

    // Show success notification
    showNotification(`🔓 Hop ${hopNumber} has been reopened for editing`, 'info');

    // Scroll to the reopened hop
    setTimeout(() => {
        const hopElement = document.querySelector(`[data-hop="${hopNumber}"]`);
        if (hopElement) {
            hopElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
    }, 100);
}

function finalizeHop(hopNumber) {
    console.log(`🎯 Attempting to finalize Hop ${hopNumber}`);

    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    if (!hop) {
        console.error(`Hop ${hopNumber} not found in investigation`);
        alert('Hop not found');
        return;
    }

    console.log(`Found hop:`, hop);

    // Check if hop is already completed
    if (hop.completed) {
        console.log(`Hop ${hopNumber} is already completed`);
        alert(`Hop ${hopNumber} has already been completed`);
        return;
    }

    // CRITICAL: Check if hop has any entries at all
    if (!hop.entries || hop.entries.length === 0) {
        console.error(`Hop ${hopNumber} has no entries - cannot finalize empty hop`);
        alert(`Cannot finalize Hop ${hopNumber} - no entries added yet!\n\nPlease add at least one trace, swap, or write-off entry before finalizing.`);
        return;
    }

    // Check if hop has any meaningful entries (not just empty placeholders)
    const hasValidEntries = hop.entries.some(entry =>
        entry.amount && parseFloat(entry.amount) > 0 &&
        ['trace', 'swap', 'writeoff', 'cold_storage'].includes(entry.entryType)
    );

    if (!hasValidEntries) {
        console.error(`Hop ${hopNumber} has no valid entries with amounts`);
        alert(`Cannot finalize Hop ${hopNumber} - no valid entries!\n\nEntries must have amounts greater than 0.`);
        return;
    }

    // USE the validateHopCompletion function which properly handles swaps!
    const validation = validateHopCompletion(hopNumber);
    console.log(`Hop ${hopNumber} validation result:`, validation);

    // Check for validation errors
    if (validation.errors && validation.errors.length > 0) {
        console.error(`Hop ${hopNumber} has validation errors:`, validation.errors);
        alert(`Cannot finalize hop - validation errors:\n${validation.errors.join('\n')}`);
        return;
    }

    // Use the remaining amounts from validation (which already accounts for swaps)
    const remainingByCurrency = validation.remainingByCurrency || {};

    // Check if hop is truly balanced (no remaining unallocated threads)
    const totalRemaining = Object.values(remainingByCurrency).reduce((sum, amt) => sum + Math.abs(amt), 0);
    const isBalanced = totalRemaining < 0.01;

    console.log(`Finalizing Hop ${hopNumber}: Total remaining = ${totalRemaining}, Is balanced = ${isBalanced}`);
    console.log(`Remaining by currency:`, remainingByCurrency);

    if (isBalanced) {
        // Skip finalization modal if already balanced - go straight to completion
        console.log(`✅ Hop ${hopNumber} is balanced - proceeding to completion`);
        completeHopAndProceed(hop);
    } else {
        // Show finalization only if there are unbalanced amounts
        console.log(`⚠️ Hop ${hopNumber} has unbalanced amounts - showing finalization options`);
        const walletsWithRemainingFunds = analyzeUntracedBalances(hop);
        showHopFinalizationSummary(hop, remainingByCurrency, walletsWithRemainingFunds);
    }
}

// Proceed with hop finalization after all amounts are accounted for
function proceedWithHopFinalization(hop) {
    // Close the finalization modal first
    closeFinalizationModal();

    // Streamlined: Skip intermediate modals and go straight to completion
    completeHopAndProceed(hop);
}

// Streamlined hop completion - single action instead of multiple modals
function completeHopAndProceed(hop) {
    // Mark hop as completed
    hop.completed = true;
    hop.isCollapsed = true;
    window.hopCollapseState[hop.hopNumber] = true;

    // Calculate threads and ART for next hop
    const threadsCreated = [];
    let allThreadsTerminal = true;
    hop.entries.forEach(entry => {
        if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0 && entry.notation) {
            const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;

            // Check if this is a terminal wallet - note that wallet type is stored as lowercase
            const isTerminal = entry.toWalletType === 'purple' || entry.toWalletType === 'PURPLE' || entry.isTerminal === true;

            threadsCreated.push({
                notation: entry.notation,
                amount: parseFloat(entry.amount),
                currency: currency,
                toWallet: entry.toWallet,
                toWalletType: entry.toWalletType,
                isTerminal: isTerminal
            });

            // Track if any non-terminal threads exist
            if (!isTerminal) {
                allThreadsTerminal = false;
            }
        }
    });

    // Calculate ART for next hop (accounting for write-offs and terminal wallets)
    // Only count non-terminal threads for next hop ART
    const nextHopART = {};

    // Build ART from non-terminal threads only
    threadsCreated.forEach(thread => {
        if (!thread.isTerminal) {
            if (!nextHopART[thread.currency]) {
                nextHopART[thread.currency] = 0;
            }
            nextHopART[thread.currency] += thread.amount;
        }
    });

    const hasActiveThreads = Object.values(nextHopART).some(amount => amount > 0);

    // Don't create next hop if all threads reached terminal wallets
    const shouldCreateNextHop = hasActiveThreads && !allThreadsTerminal;

    // Create next hop only if there are non-terminal active threads
    if (shouldCreateNextHop) {
        const nextHopNumber = hop.hopNumber + 1;
        const existingNextHop = investigation.hops.find(h => h.hopNumber === nextHopNumber);

        if (!existingNextHop) {
            const nextHop = {
                hopNumber: nextHopNumber,
                entries: [],
                artAtStartByCurrency: nextHopART,
                artAtStart: Object.values(nextHopART).reduce((sum, amount) => sum + amount, 0),
                completed: false
            };
            investigation.hops.push(nextHop);
        }
    }

    // Save and update UI
    saveToStorage();
    renderHops();
    updateWorkflowSteps();
    updateValidationStatus();

    // Auto-save the investigation after hop completion
    autoSaveAfterHopCompletion(hop.hopNumber);

    // Check if investigation is complete
    updateInvestigationCompletionStatus();

    // Determine what to show based on state
    if (allThreadsTerminal && threadsCreated.length > 0) {
        // Trace is complete - show proper completion ceremony
        showTraceCompletionCeremony(hop, threadsCreated);
    } else if (shouldCreateNextHop) {
        // Show streamlined next hop notification
        const nextHopSummary = Object.entries(nextHopART)
            .map(([currency, amount]) => `${amount.toLocaleString()} ${currency}`)
            .join(', ');

        showNotification(
            `<strong>✅ Hop ${hop.hopNumber} Complete</strong><br>
            <small>Hop ${hop.hopNumber + 1} ready with: ${nextHopSummary}</small>`,
            'success',
            4000
        );

        // Auto-scroll to next hop
        setTimeout(() => {
            const nextHopElement = document.getElementById(`hop_${hop.hopNumber + 1}`);
            if (nextHopElement) {
                nextHopElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            }
        }, 100);
    } else {
        // All funds accounted but not terminal - show completion
        showNotification(
            `<strong>✅ Hop ${hop.hopNumber} Complete</strong><br>
            <small>All funds accounted for</small>`,
            'success',
            4000
        );
    }
}

// Auto-save investigation after hop completion
async function autoSaveAfterHopCompletion(hopNumber) {
    try {
        // Add hop completion metadata
        if (!investigation.hopCompletions) {
            investigation.hopCompletions = {};
        }
        investigation.hopCompletions[`hop${hopNumber}`] = new Date().toISOString();
        investigation.lastModified = new Date().toISOString();
        investigation.lastCompletedHop = hopNumber;

        // Build thread index before saving
        buildAvailableThreadsIndex();

        // Prepare the data
        const dataStr = JSON.stringify(investigation, null, 2);

        // Try to save to existing file handle if available
        if (fileHandle && isFileSystemAvailable) {
            try {
                const writable = await fileHandle.createWritable();
                await writable.write(dataStr);
                await writable.close();

                // Show subtle notification
                showNotification(`✅ Auto-saved after Hop ${hopNumber} completion`, 'success', 3000);
                console.log(`Auto-save successful after Hop ${hopNumber} completion`);
                return;
            } catch (error) {
                console.error('Auto-save to file handle failed:', error);
                // Fall through to download method
            }
        }

        // If no file handle or not saved yet, use standard save
        if (!investigation.hasBeenSaved && investigation.caseId) {
            // For first save after hop completion, trigger download
            const filename = `${investigation.caseId}_hop${hopNumber}_${new Date().toISOString().slice(0,10)}.bats`;
            downloadFile(dataStr, filename, 'application/json');

            investigation.hasBeenSaved = true;
            showNotification(`📥 Investigation saved as ${filename}`, 'info', 5000);
        } else if (investigation.caseId) {
            // For subsequent saves, just notify that auto-save would occur
            console.log(`Auto-save ready for Hop ${hopNumber} - use Ctrl+S or Save button to persist`);
            showNotification(`💾 Hop ${hopNumber} complete - Remember to save your progress`, 'info', 3000);
        }
    } catch (error) {
        console.error('Auto-save error:', error);
        showNotification('⚠️ Auto-save failed - Please save manually', 'error', 5000);
    }
}

// Show comprehensive trace completion ceremony
function showTraceCompletionCeremony(hop, threadsCreated) {
    // Mark hop as completed first
    hop.completed = true;
    hop.isCollapsed = true;
    window.hopCollapseState[hop.hopNumber] = true;

    // Calculate trace statistics
    const totalVictims = investigation.victims.length;
    const totalHops = investigation.hops.length;
    const totalTransactions = investigation.victims.reduce((sum, v) => sum + v.transactions.length, 0);

    // Calculate terminal arrivals
    const terminalsByExchange = {};
    let totalAmountsByExchange = {};

    threadsCreated.forEach(thread => {
        if (thread.isTerminal) {
            // Get exchange name from wallet attribution or use generic
            const exchangeName = thread.exchangeName || 'Exchange';
            if (!terminalsByExchange[exchangeName]) {
                terminalsByExchange[exchangeName] = [];
                totalAmountsByExchange[exchangeName] = {};
            }
            terminalsByExchange[exchangeName].push(thread);

            if (!totalAmountsByExchange[exchangeName][thread.currency]) {
                totalAmountsByExchange[exchangeName][thread.currency] = 0;
            }
            totalAmountsByExchange[exchangeName][thread.currency] += thread.amount;
        }
    });

    // Create completion modal
    const modal = document.createElement('div');
    modal.id = 'traceCompletionModal';
    modal.className = 'modal';
    modal.style.cssText = `
        display: flex;
        align-items: center;
        justify-content: center;
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.8);
        z-index: 10001;
    `;

    const content = document.createElement('div');
    content.style.cssText = `
        background: white;
        border-radius: 16px;
        padding: 40px;
        max-width: 700px;
        width: 90%;
        max-height: 85vh;
        overflow-y: auto;
        box-shadow: 0 20px 60px rgba(0,0,0,0.3);
    `;

    // Generate trace timestamp
    const completionTime = new Date().toLocaleString();
    const traceDuration = investigation.created ?
        Math.round((Date.now() - new Date(investigation.created).getTime()) / 60000) : 0;

    content.innerHTML = `
        <div style="text-align: center; margin-bottom: 30px;">
            <div style="font-size: 72px; margin-bottom: 20px;">🎯</div>
            <h1 style="color: #27ae60; margin: 0 0 10px 0; font-size: 2.5rem;">Trace Complete!</h1>
            <p style="color: #666; font-size: 18px;">All source threads have been traced to terminal wallets</p>
        </div>

        <div style="background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%);
                    border-radius: 12px; padding: 25px; margin-bottom: 25px;">
            <h3 style="color: #2e7d32; margin: 0 0 15px 0;">📊 Trace Summary</h3>
            <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;">
                <div>
                    <strong>Case ID:</strong> ${investigation.caseId || 'Untitled'}
                </div>
                <div>
                    <strong>Completion Time:</strong> ${completionTime}
                </div>
                <div>
                    <strong>Total Victims:</strong> ${totalVictims}
                </div>
                <div>
                    <strong>Total Hops:</strong> ${totalHops}
                </div>
                <div>
                    <strong>Transactions Traced:</strong> ${totalTransactions}
                </div>
                <div>
                    <strong>Duration:</strong> ${traceDuration} minutes
                </div>
            </div>
        </div>

        <div style="background: #f3e5ff; border-radius: 12px; padding: 25px; margin-bottom: 25px;">
            <h3 style="color: #6a1b9a; margin: 0 0 15px 0;">🏦 Terminal Wallet Arrivals</h3>
            ${Object.entries(terminalsByExchange).map(([exchange, threads]) => `
                <div style="background: white; border-radius: 8px; padding: 15px; margin-bottom: 10px;">
                    <h4 style="color: #333; margin: 0 0 10px 0;">${exchange}</h4>
                    ${Object.entries(totalAmountsByExchange[exchange]).map(([currency, amount]) =>
                        `<div style="font-size: 18px; color: #666;">
                            ${amount.toLocaleString()} ${currency}
                        </div>`
                    ).join('')}
                    <div style="font-size: 14px; color: #999; margin-top: 5px;">
                        ${threads.length} arrival${threads.length > 1 ? 's' : ''}
                    </div>
                </div>
            `).join('')}
        </div>

        <div style="background: #fff3cd; border-radius: 12px; padding: 25px; margin-bottom: 25px;">
            <h3 style="color: #856404; margin: 0 0 15px 0;">📝 Important Note</h3>
            <p style="color: #856404; margin: 0; line-height: 1.6;">
                Your trace is complete, but your investigation continues. You must now:
            </p>
            <ul style="color: #856404; margin: 10px 0 0 20px;">
                <li>Save your investigation file for evidence preservation</li>
                <li>Generate analysis reports for legal teams</li>
                <li>Export terminal wallet report for exchange coordination</li>
                <li>Create visualizations for court presentation</li>
            </ul>
        </div>

        <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
            <button class="btn btn-success btn-large" onclick="saveInvestigationAfterCompletion()"
                    style="padding: 12px 30px; font-size: 18px;">
                💾 Save Investigation File
            </button>
            <button class="btn btn-primary" onclick="closeTraceCompletionAndGoToAnalysis()"
                    style="padding: 12px 30px; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); border: none; color: white; font-weight: bold;">
                🌐 View Investigation Graph
            </button>
            <button class="btn btn-secondary" onclick="closeTraceCompletionModal()">
                Continue Reviewing
            </button>
        </div>
    `;

    modal.appendChild(content);
    document.body.appendChild(modal);

    // Update investigation status
    saveToStorage();
    renderHops();
    updateWorkflowSteps();
    updateValidationStatus();
    updateInvestigationCompletionStatus();

    // Add to terminal wallet index
    threadsCreated.forEach(thread => {
        if (thread.isTerminal) {
            const terminalEntry = {
                timestamp: new Date().toISOString(),
                hopNumber: hop.hopNumber,
                notation: thread.notation,
                amount: thread.amount,
                currency: thread.currency,
                toWallet: thread.toWallet,
                exchangeName: thread.exchangeName || 'Unknown Exchange',
                detectionSource: 'trace_completion'
            };

            if (!investigation.terminalWalletIndex) {
                investigation.terminalWalletIndex = [];
            }
            investigation.terminalWalletIndex.push(terminalEntry);
        }
    });
}

// Helper functions for trace completion
function saveInvestigationAfterCompletion() {
    closeTraceCompletionModal();
    // Trigger save with a note about completion
    investigation.traceCompletedAt = new Date().toISOString();
    investigation.traceComplete = true;
    saveInvestigation();

    // Show confirmation
    showNotification('Investigation saved with trace completion status', 'success', 5000);
}

function closeTraceCompletionAndGoToAnalysis() {
    closeTraceCompletionModal();
    // Navigate to flow diagram visualization instead of analysis tab
    switchTab('flowdiagram');
    // Initialize the visualization after a short delay
    setTimeout(() => {
        initializeGraphVisualization();
    }, 100);
}

function closeTraceCompletionModal() {
    const modal = document.getElementById('traceCompletionModal');
    if (modal) {
        modal.remove();
    }
}

// Show thread review for the next hop
function showThreadReviewForNextHop(completedHop) {
    // Calculate threads created in this hop
    const threadsCreated = [];
    completedHop.entries.forEach(entry => {
        if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0 && entry.notation) {
            const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
            threadsCreated.push({
                notation: entry.notation,
                amount: parseFloat(entry.amount),
                currency: currency,
                toWallet: entry.toWallet,
                toWalletType: entry.toWalletType,
                fromWallet: entry.fromWallet
            });
        }
    });
    
    // Calculate starting ART for next hop
    const nextHopART = {};
    threadsCreated.forEach(thread => {
        if (thread.toWalletType !== 'purple') { // Exclude VASP arrivals
            if (!nextHopART[thread.currency]) {
                nextHopART[thread.currency] = 0;
            }
            nextHopART[thread.currency] += thread.amount;
        }
    });
    
    const totalActiveAmount = Object.values(nextHopART).reduce((sum, amount) => sum + amount, 0);
    
    const modalHTML = `
        <div id="threadReviewModal" class="modal" style="display: block;">
            <div class="modal-content" style="max-width: 900px; max-height: 90vh; overflow-y: auto;">
                <div class="modal-header">
                    <h2>🧵 Review Source Threads for Hop ${completedHop.hopNumber + 1}</h2>
                    <p>These are the threads created from Hop ${completedHop.hopNumber} that will be available for tracing</p>
                </div>
                
                <div style="padding: 20px;">
                    ${threadsCreated.length === 0 ? `
                        <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 20px; text-align: center;">
                            <h3 style="color: #856404; margin: 0;">No threads created in this hop</h3>
                            <p style="margin: 10px 0 0 0;">All funds were written off or sent to exchanges (PURPLE wallets)</p>
                        </div>
                    ` : `
                        <div style="background: #e3f2fd; border: 1px solid #2196f3; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                            <h3 style="margin-top: 0; color: #0d47a1;">📊 Thread Summary</h3>
                            <div style="display: grid; gap: 15px;">
                                ${threadsCreated.map((thread, index) => `
                                    <div style="background: white; padding: 15px; border-radius: 8px; border-left: 4px solid ${thread.toWalletType === 'purple' ? '#8e24aa' : '#2196f3'};">
                                        <div style="display: flex; justify-content: space-between; align-items: start;">
                                            <div>
                                                <h4 style="margin: 0 0 5px 0; color: #2c3e50;">${thread.notation}</h4>
                                                <div style="color: #666; font-size: 14px;">
                                                    <div>Amount: <strong>${thread.amount.toLocaleString()} ${thread.currency}</strong></div>
                                                    <div>From: ${thread.fromWallet.substring(0, 16)}...</div>
                                                    <div>To: ${thread.toWallet.substring(0, 16)}... <span>(${walletTypes[thread.toWalletType] || thread.toWalletType})</span></div>
                                                </div>
                                            </div>
                                            <div style="text-align: right;">
                                                ${thread.toWalletType === 'purple' ? 
                                                    '<span style="color: #8e24aa; font-weight: bold;">VASP ARRIVAL</span>' : 
                                                    '<span style="color: #28a745;">✓ Active Thread</span>'
                                                }
                                            </div>
                                        </div>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                        
                        ${totalActiveAmount > 0 ? `
                            <div style="background: #d4edda; border: 2px solid #27ae60; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
                                <h3 style="color: #155724; margin-top: 0;">Adjusted Root Total (ART) for Hop ${completedHop.hopNumber + 1}</h3>
                                <div style="display: grid; gap: 10px;">
                                    ${Object.entries(nextHopART).map(([currency, amount]) => `
                                        <div style="font-size: 18px;">
                                            <strong>${currency}:</strong> ${amount.toLocaleString()}
                                        </div>
                                    `).join('')}
                                </div>
                            </div>
                        ` : ''}
                    `}
                    
                    <div style="margin-top: 30px; text-align: center; padding-top: 20px; border-top: 2px solid #e0e0e0;">
                        ${totalActiveAmount > 0 ? `
                            <button class="btn btn-success btn-large" onclick="proceedToNextHop(${completedHop.id})">
                                Continue to Hop ${completedHop.hopNumber + 1} →
                            </button>
                            <button class="btn btn-primary" onclick="saveInvestigationFile()" style="margin-left: 10px;">
                                💾 Save Progress
                            </button>
                        ` : `
                            <button class="btn btn-primary btn-large" onclick="completeInvestigation(${completedHop.id})">
                                Complete Investigation
                            </button>
                            <button class="btn btn-primary" onclick="saveInvestigationFile()" style="margin-left: 10px;">
                                💾 Save Progress
                            </button>
                        `}
                        <button class="btn btn-secondary" onclick="document.getElementById('threadReviewModal').remove()" style="margin-left: 10px;">
                            Review Later
                        </button>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHTML);
}

// Update the progress indicator bar
function updateProgressIndicator() {
    const status = analyzeCaseStatus();
    const indicator = document.getElementById('progressIndicator');
    const bar = document.getElementById('progressBar');
    const percentage = document.getElementById('progressPercentage');
    const statusText = document.getElementById('progressStatus');
    
    if (!indicator) return;
    
    // Show the indicator
    indicator.style.display = 'block';
    
    // Calculate progress percentage
    let progress = 0;
    let progressSteps = 0;
    const totalSteps = 5; // Setup, Victims, Root Total, Hops, Analysis
    
    if (investigation.caseId || investigation.investigatorName) progressSteps += 0.5;
    if (status.victimsComplete) progressSteps += 1;
    if (status.rootTotalConfirmed) progressSteps += 0.5;
    
    // Calculate hop progress
    if (status.hops.length > 0) {
        const completeHops = status.hops.filter(h => h.status === 'complete').length;
        const inProgressHops = status.hops.filter(h => h.status === 'in-progress' || h.status === 'current').length;
        progressSteps += completeHops + (inProgressHops * 0.5);
    }
    
    if (status.analysisReady) progressSteps += 1;
    
    // Cap at 100%
    progress = Math.min(100, Math.round((progressSteps / totalSteps) * 100));
    
    // Update UI
    bar.style.width = progress + '%';
    percentage.textContent = progress + '%';
    
    // Update status text
    if (status.currentPhase === 'complete') {
        statusText.textContent = '✅ Investigation complete - Ready for analysis';
        bar.style.background = '#27ae60';
    } else if (status.currentHopId) {
        const currentHop = status.hops.find(h => h.hopNumber === status.currentHopId);
        if (currentHop) {
            statusText.innerHTML = `🔄 Currently on <strong>Hop ${currentHop.number}</strong> - ${currentHop.entryCount} entries${currentHop.remainingART ? ` • Remaining: ${currentHop.remainingART}` : ''}`;
        }
        bar.style.background = '#3498db';
    } else if (!status.victimsComplete) {
        statusText.textContent = '📝 Add victim transactions to begin';
        bar.style.background = '#f39c12';
    } else if (!status.rootTotalConfirmed) {
        statusText.textContent = '⏳ Confirm root total to proceed';
        bar.style.background = '#f39c12';
    } else {
        statusText.textContent = status.summary;
        bar.style.background = '#3498db';
    }
}

// Show case status dashboard after loading investigation
function showCaseStatusDashboard() {
    // Analyze the investigation status
    const status = analyzeCaseStatus();

    // Update the progress indicator
    updateProgressIndicator();

    // Create dashboard modal
    const dashboard = document.createElement('div');
    dashboard.id = 'caseStatusDashboard';
    dashboard.style.cssText = `
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background: rgba(0, 0, 0, 0.7);
        z-index: 10000;
        display: flex;
        align-items: center;
        justify-content: center;
        animation: fadeIn 0.3s ease;
    `;

    const content = document.createElement('div');
    content.style.cssText = `
        background: white;
        border-radius: 12px;
        padding: 30px;
        max-width: 800px;
        width: 90%;
        max-height: 85vh;
        overflow-y: auto;
        box-shadow: 0 10px 40px rgba(0,0,0,0.3);
    `;

    // Get detailed status info
    const availableThreads = getAvailableSourcesForHop(
        status.currentHopId || (investigation.hops.length + 1),
        null
    );
    const hasAvailableThreads = availableThreads && availableThreads.length > 0;

    // Calculate terminal wallet summary
    let terminalSummary = '';
    if (investigation.terminalWalletIndex && investigation.terminalWalletIndex.length > 0) {
        const terminalsByExchange = {};
        investigation.terminalWalletIndex.forEach(terminal => {
            const exchange = terminal.exchangeName || 'Unknown Exchange';
            if (!terminalsByExchange[exchange]) {
                terminalsByExchange[exchange] = [];
            }
            terminalsByExchange[exchange].push(terminal);
        });

        terminalSummary = `
            <div style="margin-top: 15px; padding: 10px; background: #f3e5ff; border-radius: 6px;">
                <strong>🏦 Terminal Wallets Reached:</strong>
                ${Object.entries(terminalsByExchange).map(([exchange, terminals]) =>
                    `<div style="margin-top: 5px;">• ${exchange}: ${terminals.length} arrival(s)</div>`
                ).join('')}
            </div>
        `;
    }

    // Build status HTML
    let statusHTML = `
        <h2 style="margin: 0 0 20px 0; color: #2c3e50; border-bottom: 2px solid #e8f0fe; padding-bottom: 15px;">
            📊 Investigation Loaded: ${investigation.caseId || 'Untitled'}
        </h2>

        <div style="background: ${status.currentPhase === 'complete' ?
                'linear-gradient(135deg, #d4edda 0%, #c3e6cb 100%)' :
                'linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%)'};
                    border-radius: 8px; padding: 20px; margin-bottom: 20px;">
            <h3 style="margin: 0 0 10px 0; color: ${status.currentPhase === 'complete' ? '#155724' : '#0d47a1'};">
                ${status.currentPhase === 'complete' ?
                    '✅ Investigation Complete - All Funds Traced to Terminal Wallets' :
                    `📍 Current Position: ${status.whereYouAre}`}
            </h3>
            <div style="color: #2c3e50; line-height: 1.6;">
                ${status.summary}
                ${terminalSummary}
            </div>
            ${hasAvailableThreads && !status.currentPhase === 'complete' ? `
                <div style="margin-top: 15px; padding: 10px; background: #fff3cd; border-radius: 6px;">
                    <strong>💰 Available to Trace:</strong>
                    ${availableThreads.map(thread =>
                        `<div style="margin-top: 5px;">• ${thread.displayText}: ${thread.availableAmount.toLocaleString()} ${thread.currency}</div>`
                    ).slice(0, 3).join('')}
                    ${availableThreads.length > 3 ? `<div style="margin-top: 5px;">... and ${availableThreads.length - 3} more threads</div>` : ''}
                </div>
            ` : ''}
        </div>
    `;
    
    // Progress sections
    statusHTML += '<div style="margin: 20px 0;">';
    
    // Setup & Victims
    statusHTML += `
        <div style="margin-bottom: 15px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid ${status.victimsComplete ? '#27ae60' : '#ffc107'};">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <div>
                    <strong>${status.victimsComplete ? '✅' : '⏳'} Victims & Root Total</strong>
                    <div style="color: #666; font-size: 14px; margin-top: 5px;">
                        ${status.victimCount} victim${status.victimCount !== 1 ? 's' : ''} • 
                        ${status.transactionCount} transaction${status.transactionCount !== 1 ? 's' : ''} • 
                        Root Total: ${status.rootTotal}
                    </div>
                </div>
                ${!status.victimsComplete ? 
                    '<button class="btn btn-primary btn-small" onclick="closeCaseStatusDashboard(); focusOnVictims()">Add Victims</button>' : 
                    '<span style="color: #27ae60; font-weight: bold;">Complete</span>'
                }
            </div>
        </div>
    `;
    
    // Hops
    status.hops.forEach(hop => {
        const hopStatus = hop.status;
        const statusColor = hopStatus === 'complete' ? '#27ae60' : hopStatus === 'in-progress' ? '#3498db' : '#999';
        const statusIcon = hopStatus === 'complete' ? '✅' : hopStatus === 'in-progress' ? '🔄' : '⏳';
        
        statusHTML += `
            <div style="margin-bottom: 15px; padding: 15px; background: ${hopStatus === 'current' ? '#fff3cd' : '#f8f9fa'}; 
                        border-radius: 8px; border-left: 4px solid ${statusColor};
                        ${hopStatus === 'current' ? 'border: 2px solid #ffc107;' : ''}">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <strong>${statusIcon} Hop ${hop.number}</strong>
                        ${hopStatus === 'current' ? '<span style="color: #856404; margin-left: 10px;">← You were here</span>' : ''}
                        <div style="color: #666; font-size: 14px; margin-top: 5px;">
                            ${hop.entryCount} entr${hop.entryCount !== 1 ? 'ies' : 'y'} • 
                            ${hop.amountTraced} traced
                            ${hop.remainingART ? ` • Remaining: ${hop.remainingART}` : ''}
                        </div>
                    </div>
                    ${hopStatus === 'current' || hopStatus === 'in-progress' ? 
                        `<button class="btn btn-primary btn-small" onclick="closeCaseStatusDashboard(); focusOnHop(${hop.hopNumber})">
                            ${hopStatus === 'current' ? 'Continue Here' : 'Go to Hop'}
                        </button>` : 
                        hopStatus === 'complete' ? 
                            '<span style="color: #27ae60; font-weight: bold;">Complete</span>' :
                            '<span style="color: #999;">Not Started</span>'
                    }
                </div>
            </div>
        `;
    });
    
    // Analysis
    if (status.showAnalysis) {
        statusHTML += `
            <div style="margin-bottom: 15px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid ${status.analysisReady ? '#27ae60' : '#999'};">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <strong>${status.analysisReady ? '✅' : '⏳'} Analysis & Reports</strong>
                        <div style="color: #666; font-size: 14px; margin-top: 5px;">
                            ${status.analysisReady ? 'Ready to generate reports' : 'Complete hops first'}
                        </div>
                    </div>
                    ${status.analysisReady ? 
                        '<button class="btn btn-success btn-small" onclick="closeCaseStatusDashboard(); focusOnAnalysis()">View Analysis</button>' : 
                        '<span style="color: #999;">Not Ready</span>'
                    }
                </div>
            </div>
        `;
    }
    
    statusHTML += '</div>';
    
    // Action buttons
    statusHTML += `
        <div style="margin-top: 30px; padding-top: 20px; border-top: 2px solid #e8f0fe;">
            <div style="background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%);
                        border-radius: 8px; padding: 20px; margin-bottom: 20px;">
                <h4 style="margin: 0 0 10px 0; color: #856404;">
                    📝 What to do next:
                </h4>
                <p style="margin: 0 0 15px 0; color: #856404; font-size: 16px; line-height: 1.5;">
                    ${status.whatToDoNext}
                </p>
                <div style="text-align: center;">
                    ${status.currentHopId ?
                        `<button class="btn btn-success btn-large" onclick="closeCaseStatusDashboard(); focusOnHop(${status.currentHopId})"
                                 style="padding: 12px 30px; font-size: 18px;">
                            🎯 Continue Working on Hop ${status.currentHopId}
                        </button>` :
                        status.nextAction ?
                            `<button class="btn btn-success btn-large" onclick="closeCaseStatusDashboard(); ${status.nextAction}"
                                     style="padding: 12px 30px; font-size: 18px;">
                                🚀 ${status.whatToDoNext}
                            </button>` :
                            ''
                    }
                </div>
            </div>
            <div style="text-align: center;">
                <button class="btn btn-secondary" onclick="closeCaseStatusDashboard()" style="padding: 10px 20px;">
                    👁️ View Full Investigation
                </button>
                ${status.currentPhase === 'complete' ? `
                    <button class="btn btn-primary" onclick="closeCaseStatusDashboard(); switchTab('analysis')"
                            style="margin-left: 10px; padding: 10px 20px;">
                        📊 Go to Analysis
                    </button>
                ` : ''}
            </div>
        </div>
    `;
    
    content.innerHTML = statusHTML;
    dashboard.appendChild(content);
    document.body.appendChild(dashboard);
    
    // Add click-outside to close
    dashboard.addEventListener('click', (e) => {
        if (e.target === dashboard) {
            closeCaseStatusDashboard();
        }
    });
}

// Analyze case status to determine current state
function analyzeCaseStatus() {
    const status = {
        currentPhase: 'setup',
        whereYouAre: '',
        victimsComplete: false,
        rootTotalConfirmed: false,
        victimCount: 0,
        transactionCount: 0,
        rootTotal: '$0',
        hops: [],
        currentHopId: null,
        showAnalysis: false,
        analysisReady: false,
        nextAction: null,
        summary: '',
        whatToDoNext: ''
    };
    
    // Check victims
    if (investigation.victims && investigation.victims.length > 0) {
        status.victimCount = investigation.victims.length;
        status.transactionCount = investigation.victims.reduce((sum, v) => sum + (v.transactions?.length || 0), 0);
        
        // Calculate root total
        let rootTotal = 0;
        const currencies = {};
        investigation.victims.forEach(victim => {
            victim.transactions?.forEach(tx => {
                if (tx.amount) {
                    const currency = tx.currency === 'CUSTOM' ? tx.customCurrency : tx.currency;
                    if (!currencies[currency]) currencies[currency] = 0;
                    currencies[currency] += parseFloat(tx.amount);
                    rootTotal += parseFloat(tx.amount);
                }
            });
        });
        
        // Format root total
        if (Object.keys(currencies).length === 1) {
            const curr = Object.keys(currencies)[0];
            status.rootTotal = `${currencies[curr].toLocaleString()} ${curr}`;
        } else {
            status.rootTotal = Object.entries(currencies)
                .map(([curr, amt]) => `${amt.toLocaleString()} ${curr}`)
                .join(' + ');
        }
        
        status.victimsComplete = status.transactionCount > 0;
        status.rootTotalConfirmed = investigation.rootTotalConfirmed || false;
    }
    
    // Check hops
    let lastCompleteHop = null;
    let firstIncompleteHop = null;
    
    if (investigation.hops && investigation.hops.length > 0) {
        investigation.hops.forEach(hop => {
            const hopInfo = {
                id: hop.hopNumber,
                number: hop.hopNumber,
                entryCount: hop.entries?.length || 0,
                status: 'not-started',
                amountTraced: '0',
                remainingART: null
            };
            
            // Calculate hop amounts
            const hopCurrencies = {};
            hop.entries?.forEach(entry => {
                if (entry.amount) {
                    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                    if (!hopCurrencies[currency]) hopCurrencies[currency] = 0;
                    hopCurrencies[currency] += parseFloat(entry.amount);
                }
            });
            
            if (Object.keys(hopCurrencies).length > 0) {
                hopInfo.amountTraced = Object.entries(hopCurrencies)
                    .map(([curr, amt]) => `${amt.toLocaleString()} ${curr}`)
                    .join(' + ');
            }
            
            // Determine hop status
            if (hop.completed) {
                hopInfo.status = 'complete';
                lastCompleteHop = hop;
            } else if (hopInfo.entryCount > 0) {
                hopInfo.status = 'in-progress';
                if (!firstIncompleteHop) {
                    firstIncompleteHop = hop;
                    hopInfo.status = 'current';
                    status.currentHopId = hop.hopNumber;
                    
                    // Calculate remaining ART
                    const validation = validateHopCompletion(hop.hopNumber);
                    if (validation.remainingByCurrency) {
                        const remaining = Object.entries(validation.remainingByCurrency)
                            .filter(([_, amt]) => amt > 0)
                            .map(([curr, amt]) => `${amt.toLocaleString()} ${curr}`)
                            .join(' + ');
                        if (remaining) {
                            hopInfo.remainingART = remaining;
                        }
                    }
                }
            }
            
            status.hops.push(hopInfo);
        });
    }
    
    // Determine current phase and next action with detailed summary
    if (!status.victimsComplete) {
        status.currentPhase = 'victims';
        status.whereYouAre = 'Setup Phase - No Victims Added';
        status.nextAction = 'focusOnVictims()';
        status.summary = 'Your investigation needs victim transactions to begin. Add victims and their blockchain transactions to start tracing.';
        status.whatToDoNext = 'Add victim wallet addresses and transaction hashes';
    } else if (!status.rootTotalConfirmed) {
        status.currentPhase = 'root-total';
        status.whereYouAre = `Victims Added (${status.victimCount} victims, ${status.transactionCount} transactions)`;
        status.nextAction = 'confirmRootTotal()';
        status.summary = `You have entered ${status.transactionCount} transaction(s) totaling ${status.rootTotal}. Confirm the root total to begin tracing these funds.`;
        status.whatToDoNext = 'Confirm root total and generate initial threads';
    } else if (firstIncompleteHop) {
        status.currentPhase = 'hops';
        status.whereYouAre = `Working on Hop ${firstIncompleteHop.hopNumber}`;
        const validation = validateHopCompletion(firstIncompleteHop.hopNumber);
        if (validation.remainingByCurrency && Object.keys(validation.remainingByCurrency).length > 0) {
            const remainingAmounts = Object.entries(validation.remainingByCurrency)
                .filter(([_, amt]) => amt > 0)
                .map(([curr, amt]) => `${amt.toLocaleString()} ${curr}`)
                .join(', ');
            status.summary = `Hop ${firstIncompleteHop.hopNumber} is in progress with ${firstIncompleteHop.entryCount} entries recorded. You have ${remainingAmounts} remaining to trace.`;
            status.whatToDoNext = `Continue adding transactions to Hop ${firstIncompleteHop.hopNumber}`;
        } else {
            status.summary = `Hop ${firstIncompleteHop.hopNumber} has ${firstIncompleteHop.entryCount} entries. Complete this hop to proceed.`;
            status.whatToDoNext = `Complete Hop ${firstIncompleteHop.hopNumber}`;
        }
    } else if (lastCompleteHop) {
        // Check if there are any active threads
        const nextHopNumber = lastCompleteHop.hopNumber + 1;
        const availableThreads = getAvailableSourcesForHop(nextHopNumber, null);
        const hasActiveThreads = availableThreads && availableThreads.length > 0;

        if (hasActiveThreads) {
            status.currentPhase = 'hops';
            status.whereYouAre = `Completed Hop ${lastCompleteHop.hopNumber}`;
            status.nextAction = `addNewHop()`;
            const threadSummary = availableThreads.slice(0, 3)
                .map(t => `${t.availableAmount.toLocaleString()} ${t.currency}`)
                .join(', ');
            status.summary = `You've completed ${investigation.hops.length} hop(s). There are ${availableThreads.length} active thread(s) with ${threadSummary}${availableThreads.length > 3 ? '...' : ''} ready to trace in Hop ${nextHopNumber}.`;
            status.whatToDoNext = `Start Hop ${nextHopNumber} to continue tracing`;
        } else {
            status.currentPhase = 'complete';
            status.whereYouAre = 'Investigation Complete';
            status.showAnalysis = true;
            status.analysisReady = true;
            const terminalCount = investigation.terminalWalletIndex ? investigation.terminalWalletIndex.length : 0;
            status.summary = `All funds have been successfully traced through ${investigation.hops.length} hops. ${terminalCount} terminal wallet arrival(s) documented. Your investigation is complete and ready for reporting.`;
            status.whatToDoNext = 'Generate reports and visualizations';
        }
    } else {
        status.currentPhase = 'hops';
        status.whereYouAre = 'Ready to Start Tracing';
        status.nextAction = 'startHop1()';
        status.summary = `Root total confirmed: ${status.rootTotal}. Begin tracing these funds from the ${status.victimCount} victim wallet(s).`;
        status.whatToDoNext = 'Start Hop 1 to begin tracing victim funds';
    }
    
    return status;
}

// Check if there are active threads from a hop
function checkForActiveThreads(hop) {
    if (!hop || !hop.entries) return false;
    
    let hasActive = false;
    hop.entries.forEach(entry => {
        if (entry.entryType === 'trace' && 
            entry.toWalletType !== 'purple' && 
            entry.toWalletType !== 'blue' &&
            parseFloat(entry.amount) > 0) {
            hasActive = true;
        }
    });
    
    return hasActive;
}

// Close the case status dashboard
function closeCaseStatusDashboard() {
    const dashboard = document.getElementById('caseStatusDashboard');
    if (dashboard) {
        dashboard.remove();
    }
}

// Focus functions for different sections
function focusOnVictims() {
    switchTab('victims');
    setTimeout(() => {
        const firstInput = document.querySelector('#victimsContent input');
        if (firstInput) firstInput.focus();
    }, 100);
}

function focusOnHop(hopNumber) {
    switchTab('hops');
    setTimeout(() => {
        const hopElement = document.querySelector(`#hop_${hopNumber}`);
        if (hopElement) {
            hopElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            // Highlight the hop
            hopElement.style.border = '3px solid #ffc107';
            hopElement.style.boxShadow = '0 0 20px rgba(255, 193, 7, 0.3)';
            setTimeout(() => {
                hopElement.style.border = '';
                hopElement.style.boxShadow = '';
            }, 3000);
        }
    }, 100);
}

// Alias for focusOnHop for consistency
function scrollToHop(hopNumber) {
    focusOnHop(hopNumber);
}

function focusOnAnalysis() {
    document.getElementById('analysisTab').click();
}

function startHop1() {
    if (!investigation.hops || investigation.hops.length === 0) {
        investigation.hops = [{
            hopNumber: 1,
            entries: [],
            completed: false
        }];
        saveToStorage();
        renderHops();
    }
    document.getElementById('hopsTab').click();
}

function createNextHop(previousHopId) {
    const prevHop = investigation.hops.find(h => h.hopNumber === previousHopId);
    if (prevHop) {
        proceedToNextHop(previousHopId);
    }
}

// Check if a hop is fully accounted for and notify user
function showRemainingThreadsSummary(hop) {
    // Get available threads for the NEXT hop (what's available after this hop's entries)
    const nextHopNumber = hop.hopNumber + 1;
    const availableThreads = getAvailableSourcesForHop(nextHopNumber, null);

    // Filter for threads with remaining amounts
    const remainingThreads = availableThreads.filter(t => t.availableAmount > 0);

    if (remainingThreads.length > 0) {
        // Build summary of what's left to trace
        const totalsByCurrency = {};
        remainingThreads.forEach(thread => {
            if (!totalsByCurrency[thread.currency]) {
                totalsByCurrency[thread.currency] = 0;
            }
            totalsByCurrency[thread.currency] += thread.availableAmount;
        });

        // Show concise notification in corner instead of modal
        let summaryHTML = `<strong>✅ Entry created</strong><br>`;
        summaryHTML += `<small>${remainingThreads.length} thread${remainingThreads.length > 1 ? 's' : ''} remaining to trace</small>`;

        showNotification(summaryHTML, 'success', 4000);

        // Quick feedback without extra delays
        const addButton = document.querySelector(`button[onclick*="addHopEntry(${hop.hopNumber}"]`);
        if (addButton) {
            addButton.style.animation = 'pulse 2s ease-in-out 3';
        }
    } else {
        // All threads consumed - hop is complete
        // The completion modal will handle this notification
        hop.lastEntryCompleted = true;
    }

    // Update investigation completion status to check if we're done
    updateInvestigationCompletionStatus();
}

function checkHopCompletionStatus(hop) {
    if (!hop || hop.completed) return;

    const validation = validateHopCompletion(hop.hopNumber);

    // NEW APPROACH: Check if there are any available threads remaining
    // This properly handles swaps where the currency changes
    // IMPORTANT: We need to check threads for NEXT hop (hop + 1)
    // BUT also check same-hop conversion outputs (bridges/swaps) that haven't been allocated yet
    const nextHopThreads = getAvailableSourcesForHop(hop.hopNumber + 1, null);

    // Also check for unallocated same-hop conversion outputs
    // These are bridge/swap outputs created in the current hop that need to be traced
    const allAvailableThreads = [];

    // Add all threads that would be available for the next hop
    nextHopThreads.forEach(thread => {
        // Check if this is a same-hop conversion output from the CURRENT hop
        // These need to be allocated before the hop can be finalized
        if ((thread.sourceType === 'bridge_output' || thread.sourceType === 'swap_output') &&
            thread.hopLevel === hop.hopNumber) {
            console.log(`Found unallocated ${thread.sourceType} in current hop: ${thread.threadId} - ${thread.availableAmount} ${thread.currency}`);
        }
        allAvailableThreads.push(thread);
    });

    // Calculate total available across all currencies
    let totalAvailable = 0;
    const availableByCurrency = {};
    allAvailableThreads.forEach(thread => {
        if (thread.availableAmount > 0) {
            totalAvailable += thread.availableAmount;
            if (!availableByCurrency[thread.currency]) {
                availableByCurrency[thread.currency] = 0;
            }
            availableByCurrency[thread.currency] += thread.availableAmount;
        }
    });

    // Hop is fully accounted if no threads remain available
    const fullyAccounted = totalAvailable < 0.01; // Allow small rounding differences

    console.log(`Hop ${hop.hopNumber} completion check: ${totalAvailable} remaining across all currencies`, availableByCurrency);
    
    // Show notification if fully accounted
    if (fullyAccounted && hop.entries.length > 0) {
        // Check if we've already notified (to avoid spam)
        if (!hop.completionNotified) {
            hop.completionNotified = true;
            
            // Show notification immediately for better UX
            {
                // Show success notification with action prompt
                const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: #d4edda;
                border: 2px solid #27ae60;
                border-radius: 12px;
                padding: 30px;
                z-index: 10000;
                box-shadow: 0 10px 40px rgba(0,0,0,0.2);
                max-width: 500px;
                text-align: center;
            `;
            
            // Check if all threads reached terminal wallets
            let allThreadsTerminal = true;
            let hasAnyTraceEntries = false;
            hop.entries.forEach(entry => {
                if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0) {
                    hasAnyTraceEntries = true;
                    // Check if terminal - wallet type is stored as lowercase
                    const isTerminal = entry.toWalletType === 'purple' || entry.toWalletType === 'PURPLE' || entry.isTerminal === true;
                    if (!isTerminal) {
                        allThreadsTerminal = false;
                    }
                }
            });

            // Only consider all terminal if we actually have trace entries
            const traceComplete = hasAnyTraceEntries && allThreadsTerminal;

            const buttonText = traceComplete ?
                '🎯 Complete Trace' :
                `Close Hop ${hop.hopNumber} & Continue`;

            const subText = traceComplete ?
                'All funds have reached terminal wallets. Your trace is complete!' :
                'All source threads have been accounted for in this hop.';

            notification.innerHTML = `
                <h2 style="color: #155724; margin: 0 0 15px 0;">✅ Ready to ${traceComplete ? 'Complete Trace' : 'Continue'}</h2>
                <p style="color: #155724; margin: 0 0 20px 0;">
                    ${subText}
                </p>
                <div style="display: flex; gap: 10px; justify-content: center; flex-wrap: wrap;">
                    <button class="btn btn-success" onclick="closeHopAndProceed(${hop.hopNumber}, this.parentElement.parentElement)" style="padding: 12px 24px; font-size: 16px;">
                        ${buttonText}
                    </button>
                    ${!traceComplete ? `
                        <button class="btn btn-secondary" onclick="this.parentElement.parentElement.remove()" style="padding: 12px 24px;">
                            <small>Continue Adding Entries</small>
                        </button>
                    ` : ''}
                    <button class="btn btn-light" onclick="finalizeHop(${hop.hopNumber}); this.parentElement.parentElement.remove()" style="padding: 12px 24px;">
                        <small>📊 Review Details</small>
                    </button>
                </div>
            `;
            
            document.body.appendChild(notification);
            
                // Don't auto-remove - let user decide when to proceed
            } // No delay - show immediately
        }
    } else {
        // Reset notification flag if no longer fully accounted
        hop.completionNotified = false;
    }
}

// Close hop and proceed to next
function closeHopAndProceed(hopNumber, notificationElement) {
    if (notificationElement) {
        notificationElement.remove();
    }

    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    if (!hop) return;

    // Streamlined: Use the consolidated completion function
    completeHopAndProceed(hop);
}

// Update hop progress indicator
function updateHopProgressIndicator(hop) {
    // Get available threads for this hop
    const availableThreads = getAvailableSourcesForHop(hop.hopNumber + 1, null);
    const totalRemaining = availableThreads.reduce((sum, t) => sum + (t.availableAmount || 0), 0);

    // Calculate progress percentage
    const startingART = hop.artAtStartByCurrency || {};
    const totalStarting = Object.values(startingART).reduce((sum, amt) => sum + amt, 0);
    const progress = totalStarting > 0 ? ((totalStarting - totalRemaining) / totalStarting) * 100 : 0;

    // Update hop header with progress
    const hopHeader = document.querySelector(`#hop_${hop.hopNumber} .hop-header`);
    if (hopHeader) {
        let progressBar = hopHeader.querySelector('.hop-progress-bar');
        if (!progressBar) {
            // Create progress bar if it doesn't exist
            progressBar = document.createElement('div');
            progressBar.className = 'hop-progress-bar';
            progressBar.style.cssText = `
                position: absolute;
                bottom: 0;
                left: 0;
                height: 3px;
                background: linear-gradient(90deg, #4CAF50 0%, #45a049 100%);
                transition: width 0.5s ease;
                border-radius: 0 0 0 8px;
            `;
            hopHeader.style.position = 'relative';
            hopHeader.appendChild(progressBar);
        }
        progressBar.style.width = `${progress}%`;

        // Add completion checkmark if fully accounted
        if (progress >= 99.99) {
            let checkmark = hopHeader.querySelector('.hop-complete-check');
            if (!checkmark) {
                checkmark = document.createElement('span');
                checkmark.className = 'hop-complete-check';
                checkmark.innerHTML = ' ✓';
                checkmark.style.cssText = 'color: #4CAF50; font-weight: bold;';
                const hopTitle = hopHeader.querySelector('h3');
                if (hopTitle && !hopTitle.innerHTML.includes('✓')) {
                    hopTitle.appendChild(checkmark);
                }
            }
        }
    }
}

// Check if hop has unaccounted threads
function checkForUnaccountedThreads(hop) {
    // Check if there are threads that haven't been fully allocated
    const threads = getAvailableSourcesForHop(hop.hopNumber, null);
    for (const thread of threads) {
        if (thread.availableAmount > 0.01) { // Small threshold to avoid rounding issues
            return true;
        }
    }
    return false;
}

// Proceed to next hop without modal
function proceedToNextHopFromObject(hop) {
    // Mark hop as completed
    hop.isCollapsed = true;

    // Create next hop if it doesn't exist
    const nextHopNumber = hop.hopNumber + 1;
    const existingNextHop = investigation.hops.find(h => h.hopNumber === nextHopNumber);

    if (!existingNextHop) {
        createNewHop();
    }

    // Save and update UI
    saveToStorage();
    renderHops();

    // Scroll to next hop
    setTimeout(() => {
        const nextHopElement = document.getElementById(`hop_${nextHopNumber}`);
        if (nextHopElement) {
            nextHopElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
    }, 100);
}

// Show thread review modal before proceeding to next hop
function showThreadReviewModal(hop) {
    // Calculate the ART for the next hop (accounting for write-offs)
    const nextHopART = getCurrentART();
    const hasWriteoffs = hop.entries.some(e => e.entryType === 'writeoff' && parseFloat(e.amount) > 0);

    // Get all untraced threads from this hop
    const untracedThreads = [];
    hop.entries.forEach(entry => {
        if (entry.type === 'trace' && !entry.writeOff) {
            const threadId = `V${entry.sourceThreads[0].victimId}-T${entry.sourceThreads[0].transactionId}-H${hop.hopNumber}`;
            untracedThreads.push({
                id: threadId,
                amount: entry.outputAmount,
                currency: entry.outputCurrency || entry.sourceThreads[0].currency,
                wallet: entry.toWallet
            });
        }
    });

    if (untracedThreads.length === 0) {
        // No threads to trace, proceed directly
        proceedToNextHop(hop.hopNumber);
        return;
    }

    const modalHTML = `
        <div id="threadReviewModal" class="modal" style="display: block; z-index: 10000;">
            <div class="modal-content" style="max-width: 700px;">
                <div class="modal-header" style="background: linear-gradient(135deg, #4CAF50 0%, #45a049 100%);">
                    <h2 style="color: white;">📊 Thread Review - Hop ${hop.hopNumber}</h2>
                </div>
                <div style="padding: 20px;">
                    <div class="alert alert-info">
                        <strong>✅ Hop ${hop.hopNumber} Complete!</strong><br>
                        The following threads are ready to be traced in Hop ${hop.hopNumber + 1}:
                    </div>

                    ${hasWriteoffs ? `
                        <div class="alert alert-warning" style="background: #fff3cd; border: 1px solid #ffc107; padding: 12px; border-radius: 8px; margin-bottom: 15px;">
                            <strong>⚠️ Write-offs Applied</strong><br>
                            The Adjusted Root Total (ART) has been reduced by write-offs in this hop.
                        </div>
                    ` : ''}

                    <div style="background: #f5f5f5; border-radius: 8px; padding: 15px; margin: 20px 0;">
                        <h4>Threads to Trace:</h4>
                        ${untracedThreads.map(thread => `
                            <div style="background: white; padding: 10px; margin: 10px 0; border-radius: 4px; border-left: 4px solid #4CAF50;">
                                <strong>${thread.id}</strong><br>
                                Amount: ${formatAmount(thread.amount, thread.currency)}<br>
                                Wallet: ${thread.wallet}
                            </div>
                        `).join('')}
                    </div>

                    <div style="background: #d4edda; border: 2px solid #27ae60; border-radius: 8px; padding: 15px; margin: 20px 0;">
                        <h4>Adjusted Root Total for Hop ${hop.hopNumber + 1}:</h4>
                        ${Object.entries(nextHopART).filter(([currency, amount]) => amount > 0).map(([currency, amount]) =>
                            `<div style="font-size: 16px; margin: 5px 0;">${currency}: ${amount.toLocaleString()}</div>`
                        ).join('')}
                        ${hasWriteoffs ? '<small style="color: #856404;">*ART reduced due to write-offs</small>' : ''}
                    </div>

                    <div style="text-align: center; margin-top: 20px;">
                        <button onclick="proceedToNextHop('${hop.hopNumber}')" class="btn btn-primary" style="padding: 10px 30px;">
                            Continue to Hop ${hop.hopNumber + 1} →
                        </button>
                    </div>
                </div>
            </div>
        </div>
    `;

    createCenteredModal('threadReviewModal', modalHTML);
}

// Proceed to next hop after thread review
function proceedToNextHop(hopNumber) {
    const modal = document.getElementById('threadReviewModal');
    if (modal) modal.remove();

    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    if (!hop) return;

    // Mark current hop as completed
    hop.completed = true;

    // Auto-collapse the completed hop
    window.hopCollapseState[hop.hopNumber] = true;

    // Calculate the ART for the next hop (after write-offs in current hop)
    const nextHopART = getCurrentART();

    // Create the next hop with proper ART tracking
    const nextHopNumber = hop.hopNumber + 1;
    const nextHop = {
        hopNumber: nextHopNumber,
        entries: [],
        artAtStartByCurrency: nextHopART,
        artAtStart: Object.values(nextHopART).reduce((sum, amount) => sum + amount, 0), // Legacy support
        completed: false
    };

    investigation.hops.push(nextHop);
    
    // Save and render
    saveToStorage();
    renderHops();
    
    // Scroll to the new hop
    setTimeout(() => {
        const newHopElement = document.querySelector(`#hop_${nextHop.hopNumber}`);
        if (newHopElement) {
            newHopElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
    }, 100);
    
    // Show success notification
    showNotification(`✅ Hop ${hop.hopNumber} completed! Starting Hop ${nextHopNumber}`, 'success');
}

// Keep the old function for backward compatibility but redirect to simpler flow
function proceedToWalletClassification(hopNumber) {
    proceedToNextHop(hopNumber);
}

// Complete the hop and create the next one
function completeHopAndCreateNext(hop) {
    hop.completed = true;

    // Auto-collapse the completed hop
    window.hopCollapseState[hop.hopNumber] = true;

    // Calculate ART for next hop (after accounting for write-offs in the current hop)
    const nextHopART = getCurrentART();
    const hasWriteoffs = hop.entries.some(e => e.entryType === 'writeoff' && parseFloat(e.amount) > 0);

    // Create the next hop with proper ART accounting
    const nextHopNumber = hop.hopNumber + 1;
    const nextHop = {
        hopNumber: nextHopNumber,
        entries: [],
        artAtStartByCurrency: nextHopART,
        artAtStart: Object.values(nextHopART).reduce((sum, amount) => sum + amount, 0), // Legacy support
        completed: false
    };

    investigation.hops.push(nextHop);

    // If there were write-offs, notify the user
    if (hasWriteoffs) {
        const writeoffTotal = {};
        hop.entries.forEach(entry => {
            if (entry.entryType === 'writeoff' && parseFloat(entry.amount) > 0) {
                const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                writeoffTotal[currency] = (writeoffTotal[currency] || 0) + parseFloat(entry.amount);
            }
        });

        let writeoffMessage = 'Write-offs applied:\n';
        Object.entries(writeoffTotal).forEach(([currency, amount]) => {
            writeoffMessage += `- ${amount.toLocaleString()} ${currency}\n`;
        });
        writeoffMessage += '\nThe ART has been reduced for Hop ' + nextHopNumber;

        console.log(writeoffMessage); // Log for debugging
    }

    saveToStorage();
    renderHops();
    updateInvestigationCompletionStatus();

    // Trigger autosave after hop completion
    if (isFileSystemAvailable) {
        autosaveInvestigation();
    }

    // Ensure we stay on the traces tab to see the new hop
    if (typeof switchTab === 'function') {
        switchTab('traces');
    }
}

// Complete investigation when no threads remain
function completeInvestigation(hopNumber) {
    const modal = document.getElementById('threadReviewModal');
    if (modal) modal.remove();
    
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    if (!hop) return;
    
    hop.completed = true;
    window.hopCollapseState[hop.hopNumber] = true;
    
    saveToStorage();
    renderHops();
    updateInvestigationCompletionStatus();
    
    if (isFileSystemAvailable) {
        autosaveInvestigation();
    }
    
    alert('🎉 Investigation complete! All funds have been traced.');
}

// Analyze wallet behaviors for classification suggestions
function analyzeWalletBehaviors(hop) {
    const suggestions = [];
    const walletAnalysis = {};
    
    // Analyze each wallet in the hop
    hop.entries.forEach(entry => {
        if (entry.entryType === 'trace' && entry.toWallet) {
            const wallet = entry.toWallet;
            if (!walletAnalysis[wallet]) {
                walletAnalysis[wallet] = {
                    incomingCount: 0,
                    outgoingCount: 0,
                    currencies: new Set(),
                    totalAmount: 0,
                    currentType: entry.toWalletType || 'black'
                };
            }
            walletAnalysis[wallet].incomingCount++;
            walletAnalysis[wallet].currencies.add(entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency);
            walletAnalysis[wallet].totalAmount += parseFloat(entry.amount);
        }
    });
    
    // Check previous hops for outgoing transactions
    investigation.hops.forEach(h => {
        if (h.id !== hop.hopNumber) {
            h.entries.forEach(entry => {
                if (entry.entryType === 'trace' && entry.fromWallet && walletAnalysis[entry.fromWallet]) {
                    walletAnalysis[entry.fromWallet].outgoingCount++;
                }
            });
        }
    });
    
    // Generate suggestions based on behavior
    Object.entries(walletAnalysis).forEach(([wallet, analysis]) => {
        // Yellow wallet: Multiple incoming transactions (convergence)
        if (analysis.incomingCount >= 2 && analysis.currentType !== 'yellow') {
            suggestions.push({
                wallet: wallet,
                suggestedType: 'yellow',
                reason: `Convergence detected: ${analysis.incomingCount} incoming transactions`,
                currentType: analysis.currentType
            });
        }
        
        // Brown wallet: Multiple currencies (conversion)
        if (analysis.currencies.size > 1 && analysis.currentType !== 'brown') {
            suggestions.push({
                wallet: wallet,
                suggestedType: 'brown',
                reason: `Conversion detected: handles ${analysis.currencies.size} different currencies`,
                currentType: analysis.currentType
            });
        }
        
        // Blue wallet logic removed - will be handled at hop finalization
        // when we can properly identify wallets with untraced remaining balances
    });
    
    return suggestions;
}

// Show wallet classification suggestions
function showWalletClassificationSuggestions(hop, suggestions) {
    const modalHTML = `
        <div id="walletSuggestionsModal" class="modal" style="display: block;">
            <div class="modal-content" style="max-width: 800px;">
                <div class="modal-header">
                    <h2>🔍 Wallet Classification Suggestions</h2>
                    <p>Based on transaction patterns, we suggest updating these wallet classifications:</p>
                </div>
                
                <div style="margin: 20px 0;">
                    ${suggestions.map((suggestion, index) => `
                        <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid ${getWalletColor(suggestion.suggestedType)};">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <strong style="font-family: monospace;">${suggestion.wallet.substring(0, 20)}...</strong><br>
                                    <span style="color: #666;">Current: ${walletTypes[suggestion.currentType] || suggestion.currentType}</span><br>
                                    <span style="color: ${getWalletColor(suggestion.suggestedType)};">Suggested: ${walletTypes[suggestion.suggestedType]}</span><br>
                                    <small style="color: #666;">${suggestion.reason}</small>
                                </div>
                                <div>
                                    <button class="btn btn-confirm" onclick="acceptWalletSuggestion('${suggestion.wallet}', '${suggestion.suggestedType}', ${index})">
                                        ✅ Accept
                                    </button>
                                    <button class="btn btn-secondary" onclick="declineWalletSuggestion(${index})">
                                        ❌ Decline
                                    </button>
                                </div>
                            </div>
                        </div>
                    `).join('')}
                </div>
                
                <div style="text-align: center;">
                    <button class="btn btn-confirm" onclick="completeWalletSuggestions(${hop.hopNumber})">
                        Continue to Complete Hop ${hop.hopNumber}
                    </button>
                </div>
            </div>
        </div>
    `;
    
    createCenteredModal('walletSuggestionsModal', modalHTML);
}

// Accept wallet classification suggestion
function acceptWalletSuggestion(walletAddress, newType, suggestionIndex) {
    // Use the new authorization system
    const success = updateWalletClassificationWithAuth(walletAddress, newType, false);
    
    if (success) {
        // Hide this suggestion
        const suggestionDiv = document.querySelectorAll('#walletSuggestionsModal .modal-content > div')[1].children[suggestionIndex];
        suggestionDiv.style.display = 'none';
    }
    
    saveToStorage();
}

// Decline wallet classification suggestion
function declineWalletSuggestion(suggestionIndex) {
    const suggestionDiv = document.querySelectorAll('#walletSuggestionsModal .modal-content > div')[1].children[suggestionIndex];
    suggestionDiv.style.display = 'none';
}

// Complete wallet suggestions and finalize hop
function completeWalletSuggestions(hopNumber) {
    const modal = document.getElementById('walletSuggestionsModal');
    if (modal) modal.remove();
    
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    if (hop) {
        completeHopAndCreateNext(hop);
    }
}

// Open Smart Allocation Modal
function openSmartAllocationModal(hopNumber, entryId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    
    if (!hop || !entry) {
        alert('Error: Could not find hop or entry');
        return;
    }
    
    // Store current context
    window.smartAllocationContext = {
        hopNumber: hopNumber,
        entryId: entryId,
        hop: hop,
        entry: entry
    };
    
    // Get available currencies from sources
    const availableSourcesAll = getAvailableSourcesForHop(hop.hopNumber, null);
    const availableCurrencies = [...new Set(availableSourcesAll.map(s => s.currency))];
    
    // Populate currency dropdown
    const currencySelect = document.getElementById('smartAllocationTargetCurrency');
    currencySelect.innerHTML = '<option value="">Select currency...</option>' + 
        availableCurrencies.map(curr => {
            const currencyName = currencies[curr]?.name || curr;
            return `<option value="${curr}">${currencyName}</option>`;
        }).join('');
    
    // Clear previous state
    document.getElementById('smartAllocationTargetAmount').value = '';
    document.getElementById('smartAllocationAvailableSources').style.display = 'none';
    document.getElementById('smartAllocationPreview').style.display = 'none';
    document.getElementById('smartAllocationError').style.display = 'none';
    document.getElementById('confirmSmartAllocation').style.display = 'none';
    
    // Show modal
    showModal('smartAllocationModal');
    
    // Add event listeners
    document.getElementById('smartAllocationTargetAmount').addEventListener('input', updateSmartAllocationPreview);
    document.getElementById('smartAllocationTargetCurrency').addEventListener('change', function() {
        // Update step value when currency changes
        const currency = this.value;
        const amountInput = document.getElementById('smartAllocationTargetAmount');
        if (currency && amountInput) {
            amountInput.step = getCurrencyStep(currency);
        }
        updateSmartAllocationPreview();
    });
}

// Close Smart Allocation Modal
function closeSmartAllocationModal() {
    hideModal('smartAllocationModal');
    window.smartAllocationContext = null;
}

// Update Smart Allocation Preview
function updateSmartAllocationPreview() {
    const targetAmount = parseFloat(document.getElementById('smartAllocationTargetAmount').value);
    const targetCurrency = document.getElementById('smartAllocationTargetCurrency').value;
    
    if (!targetAmount || !targetCurrency || targetAmount <= 0) {
        document.getElementById('smartAllocationAvailableSources').style.display = 'none';
        document.getElementById('smartAllocationPreview').style.display = 'none';
        document.getElementById('smartAllocationError').style.display = 'none';
        document.getElementById('confirmSmartAllocation').style.display = 'none';
        return;
    }
    
    const context = window.smartAllocationContext;
    if (!context) return;
    
    // Get available sources for this currency
    const availableSources = getAvailableSourcesForHop(context.hop.hopNumber, targetCurrency);
    
    // Show available sources
    const sourcesListDiv = document.getElementById('availableSourcesList');
    sourcesListDiv.innerHTML = availableSources.map(source => `
        <div style="padding: 10px; margin-bottom: 5px; background: #f8f9fa; border-radius: 6px; border-left: 4px solid #3498db;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <strong>${source.threadId}</strong>
                <span style="color: #27ae60; font-weight: bold;">${source.availableAmount.toLocaleString()} ${source.currency}</span>
            </div>
            <div style="font-size: 11px; color: #666; margin-top: 3px;">
                ${source.sourceType === 'victim_transaction' ? 'Victim Transaction (RED Wallet)' : 'Previous Hop Output'}
            </div>
        </div>
    `).join('');
    document.getElementById('smartAllocationAvailableSources').style.display = 'block';
    
    // Calculate allocation
    const allocation = calculateSmartAllocation(availableSources, targetAmount);
    
    if (allocation.error) {
        document.getElementById('smartAllocationError').innerHTML = `⚠️ ${allocation.error}`;
        document.getElementById('smartAllocationError').style.display = 'block';
        document.getElementById('smartAllocationPreview').style.display = 'none';
        document.getElementById('confirmSmartAllocation').style.display = 'none';
    } else {
        document.getElementById('smartAllocationError').style.display = 'none';
        
        // Show allocation preview
        const previewContent = document.getElementById('allocationPreviewContent');
        previewContent.innerHTML = `
            <div style="background: #f8f9fa; border: 1px solid #ddd; border-radius: 6px; padding: 15px;">
                ${allocation.allocations.map(alloc => `
                    <div style="margin-bottom: 10px; padding: 10px; background: white; border-radius: 4px; border-left: 4px solid ${alloc.fullyUsed ? '#e74c3c' : '#27ae60'};">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <strong>${alloc.threadId}</strong>
                            <span style="color: ${alloc.fullyUsed ? '#e74c3c' : '#27ae60'};">
                                Use ${alloc.amountToUse.toLocaleString()} of ${alloc.availableAmount.toLocaleString()} ${targetCurrency}
                            </span>
                        </div>
                        ${alloc.fullyUsed ? 
                            '<div style="font-size: 11px; color: #e74c3c; margin-top: 3px;">✓ Fully depleted</div>' : 
                            `<div style="font-size: 11px; color: #666; margin-top: 3px;">${alloc.remaining.toLocaleString()} ${targetCurrency} will remain</div>`
                        }
                    </div>
                `).join('')}
                
                <div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid #ddd;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <strong>Total Allocated:</strong>
                        <span style="color: #27ae60; font-size: 18px; font-weight: bold;">
                            ${allocation.totalAllocated.toLocaleString()} ${targetCurrency}
                        </span>
                    </div>
                    ${allocation.totalAllocated < targetAmount ? 
                        `<div style="color: #e74c3c; font-size: 12px; margin-top: 5px;">
                            ⚠️ Only ${allocation.totalAllocated.toLocaleString()} of ${targetAmount.toLocaleString()} ${targetCurrency} available
                        </div>` : ''
                    }
                </div>
            </div>
        `;
        
        document.getElementById('smartAllocationPreview').style.display = 'block';
        document.getElementById('confirmSmartAllocation').style.display = 'inline-block';
        
        // Store allocation for confirmation
        window.smartAllocationContext.allocation = allocation;
        window.smartAllocationContext.targetCurrency = targetCurrency;
    }
}

// Calculate Smart Allocation
function calculateSmartAllocation(sources, targetAmount) {
    let remainingAmount = targetAmount;
    const allocations = [];
    let totalAllocated = 0;
    
    for (const source of sources) {
        if (remainingAmount <= 0) break;
        
        const amountToUse = Math.min(source.availableAmount, remainingAmount);
        allocations.push({
            threadId: source.threadId,
            availableAmount: source.availableAmount,
            amountToUse: amountToUse,
            remaining: source.availableAmount - amountToUse,
            fullyUsed: amountToUse === source.availableAmount
        });
        
        totalAllocated += amountToUse;
        remainingAmount -= amountToUse;
    }
    
    if (totalAllocated < targetAmount) {
        const totalAvailable = sources.reduce((sum, s) => sum + s.availableAmount, 0);
        if (totalAvailable < targetAmount) {
            return {
                error: `Insufficient funds. Only ${totalAvailable.toLocaleString()} available, but ${targetAmount.toLocaleString()} requested.`,
                totalAvailable: totalAvailable
            };
        }
    }
    
    return {
        allocations: allocations,
        totalAllocated: totalAllocated,
        success: true
    };
}

// Confirm and Apply Smart Allocation
function confirmSmartAllocation() {
    const context = window.smartAllocationContext;
    if (!context || !context.allocation) return;
    
    const entry = context.entry;
    const allocation = context.allocation;
    const targetCurrency = context.targetCurrency;
    
    // Set up multiple source threads
    entry.multipleSourceThreads = allocation.allocations.map(a => a.threadId);
    entry.individualSourceAssignments = {};
    allocation.allocations.forEach(alloc => {
        entry.individualSourceAssignments[alloc.threadId] = alloc.amountToUse;
    });
    
    // Set total amount and currency, preserving full precision
    entry.amount = formatCurrencyAmount(allocation.totalAllocated, targetCurrency, true);
    entry.currency = targetCurrency;
    
    // Mark as convergence if multiple sources and apply Sequential Hop Rule
    if (allocation.allocations.length > 1) {
        entry.isConvergence = true;
        
        // Apply Sequential Hop Rule: find the highest hop number among converging paths
        let maxSourceHopNumber = 0;
        allocation.allocations.forEach(alloc => {
            const threadMatch = alloc.threadId.match(/-H(\d+)$/);
            if (threadMatch) {
                const sourceHopNumber = parseInt(threadMatch[1]);
                maxSourceHopNumber = Math.max(maxSourceHopNumber, sourceHopNumber);
            }
        });
        
        // The convergence output should be at maxHop + 1
        if (investigation.tracingMethod === 'PIFO') {
            // For PIFO, we track the highest hop number and add 1
            entry.hopNumber = maxSourceHopNumber + 1;
            
            // Show notification about Sequential Hop Rule application
            showNotification(
                `Sequential Hop Rule applied: Convergence of ${allocation.allocations.length} sources at hop ${entry.hopNumber}`,
                'info'
            );
        }
        
        entry.convergenceData = {
            sourceCount: allocation.allocations.length,
            sources: allocation.allocations,
            maxSourceHop: maxSourceHopNumber,
            sequentialHopRuleApplied: true
        };
    }
    
    // Close modal
    closeSmartAllocationModal();
    
    // Re-render the hop entries
    renderHops();
    saveToStorage();
    
    alert(` Smart allocation applied: ${allocation.totalAllocated.toLocaleString()} ${targetCurrency} allocated across ${allocation.allocations.length} source(s)`);
}

// Original smart allocation function (keep for compatibility)
function smartAllocateAmount(hopNumber, entryId) {
    // Redirect to the new modal-based approach
    openSmartAllocationModal(hopNumber, entryId);
}

// Clear all allocations
function clearAllAllocations(hopNumber, entryId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    
    entry.multipleSourceThreads = [];
    entry.individualSourceAssignments = {};
    entry.sourceThreadId = '';
    entry.amount = '';
    
    const previewDiv = document.getElementById(`smartAllocationPreview_${hopNumber}_${entryId}`);
    if (previewDiv) {
        previewDiv.innerHTML = '';
    }
    
    const targetAmountInput = document.getElementById(`targetAmount_${hopNumber}_${entryId}`);
    if (targetAmountInput) {
        targetAmountInput.value = '';
    }
    
    renderHops();
    saveToStorage();
}

// Get wallet color based on type
function getWalletColor(walletType) {
    const colorMap = {
        'red': '#e74c3c',
        'pink': '#e91e63',
        'yellow': '#f1c40f',
        'orange': '#ff9800',
        'brown': '#795548',
        'black': '#2c3e50',
        'blue': '#3498db',
        'purple': '#9b59b6',
        'gray': '#95a5a6',
        'green': '#27ae60'
    };
    return colorMap[walletType] || '#95a5a6';
}

// Define criminal hierarchy for wallet classifications
const walletHierarchy = {
    'green': 1,   // Victim-owned (legitimate)
    'gray': 2,    // Obfuscated (write-off)
    'black': 3,   // Default intermediary
    'orange': 4,  // Bitcoin change (technical)
    'brown': 4,   // Asset conversion (technical)
    'blue': 5,    // Cold storage
    'yellow': 6,  // Hub (convergence)
    'pink': 7,    // Deception/Dividend
    'purple': 8,  // Exchange (terminal)
    'red': 9      // Victim-facing (highest exposure)
};

// Check if wallet classification change is allowed (only up the hierarchy)
function canChangeWalletClassification(currentType, newType) {
    const currentLevel = walletHierarchy[currentType] || 0;
    const newLevel = walletHierarchy[newType] || 0;
    return newLevel > currentLevel;
}

// Update wallet classification with authorization
function updateWalletClassificationWithAuth(walletAddress, newType, skipAuth = false) {
    const wallet = investigation.universalWalletIndex.find(w => w.address === walletAddress);
    if (!wallet) {
        alert('Wallet not found in index');
        return false;
    }
    
    const oldType = wallet.permanentType;
    
    // Check if change is allowed
    if (!canChangeWalletClassification(oldType, newType)) {
        alert(`Cannot change wallet classification from ${oldType.toUpperCase()} to ${newType.toUpperCase()}. Wallets can only progress UP the criminal hierarchy.`);
        return false;
    }
    
    // Get authorization unless skipped (for automatic updates)
    let justification = '';
    if (!skipAuth) {
        justification = prompt(
            `Changing wallet classification from ${walletTypes[oldType]} to ${walletTypes[newType]}.\n\n` +
            `This is a significant change that will affect all entries using this wallet.\n\n` +
            `Please provide justification for this classification change:`
        );
        
        if (!justification || justification.trim() === '') {
            alert('Classification change cancelled - justification required.');
            return false;
        }
    } else {
        justification = 'Automatic classification based on observed behavior';
    }
    
    // Record the change
    if (!wallet.classificationHistory) {
        wallet.classificationHistory = [];
    }
    
    wallet.classificationHistory.push({
        timestamp: new Date().toISOString(),
        fromType: oldType,
        toType: newType,
        justification: justification,
        investigator: investigation.investigator || 'Unknown'
    });
    
    // Update the wallet
    wallet.permanentType = newType;
    wallet.currentStatus = newType;
    
    // Update wallet ID if needed
    const colorCounters = {};
    investigation.universalWalletIndex.forEach(w => {
        const type = w.permanentType;
        if (!colorCounters[type]) colorCounters[type] = 0;
        const match = w.permanentId.match(/\d+$/);
        if (match) {
            colorCounters[type] = Math.max(colorCounters[type], parseInt(match[0]));
        }
    });
    
    if (!colorCounters[newType]) colorCounters[newType] = 0;
    wallet.permanentId = `${newType.toUpperCase()} ${colorCounters[newType] + 1}`;
    
    // Add to status history
    if (!wallet.statusHistory) wallet.statusHistory = [];
    wallet.statusHistory.push(`Reclassified from ${oldType} to ${newType}: ${justification}`);
    
    // Update all entries retroactively
    updateWalletClassificationRetroactively(walletAddress, newType);
    
    // Save and refresh
    saveToStorage();
    buildUniversalWalletIndex();
    renderHops();
    
    showNotification(
        `Wallet reclassified from ${oldType.toUpperCase()} to ${newType.toUpperCase()}.\n` +
        `Justification: ${justification}`,
        'success'
    );
    
    return true;
}

// Update wallet classification retroactively across all entries
function updateWalletClassificationRetroactively(walletAddress, newType) {
    // Update all hop entries with this wallet
    investigation.hops.forEach(hop => {
        hop.entries.forEach(entry => {
            if (entry.toWallet === walletAddress) {
                entry.toWalletType = newType;
                if (entry.toWalletId) {
                    // Update wallet ID if it exists
                    const wallet = investigation.universalWalletIndex.find(w => w.address === walletAddress);
                    if (wallet) {
                        entry.toWalletId = wallet.permanentId;
                    }
                }
            }
            if (entry.fromWallet === walletAddress) {
                entry.fromWalletType = newType;
                if (entry.fromWalletId) {
                    const wallet = investigation.universalWalletIndex.find(w => w.address === walletAddress);
                    if (wallet) {
                        entry.fromWalletId = wallet.permanentId;
                    }
                }
            }
        });
    });
    
    // Rebuild UWI to ensure consistency
    buildUniversalWalletIndex();
}

// Complete current hop and start the next one
function completeCurrentHopAndStartNext() {
    const lastHop = investigation.hops[investigation.hops.length - 1];
    if (!lastHop) {
        alert('No hop found to complete');
        return;
    }
    
    // Mark the hop as completed
    lastHop.completed = true;
    
    // Save the state
    saveToStorage();
    
    // Add a new hop
    addNewHop();
    
    // Update the display
    renderHops();
    updateInvestigationCompletionStatus();
    
    console.log(` Completed Hop ${lastHop.hopNumber} and started Hop ${lastHop.hopNumber + 1}`);
}

// Show modal for hop finalization options
function showHopFinalizationModal(hop, remainingByCurrency, walletsWithRemainingFunds = []) {
    // Generate wallet suggestions HTML
    let walletSuggestionsHTML = '';
    if (walletsWithRemainingFunds.length > 0) {
        const walletsByCurrency = {};
        walletsWithRemainingFunds.forEach(w => {
            if (!walletsByCurrency[w.currency]) {
                walletsByCurrency[w.currency] = [];
            }
            walletsByCurrency[w.currency].push(w);
        });
        
        walletSuggestionsHTML = `
            <div style="background: #e8f4f8; border: 2px solid #3498db; border-radius: 8px; padding: 20px; margin: 20px 0;">
                <h4 style="color: #2c3e50; margin-bottom: 15px;">💡 Wallets with Remaining Balances:</h4>
                <p style="margin-bottom: 15px; color: #34495e;">These wallets have funds that are not being traced forward. Consider marking them as cold storage:</p>
                ${Object.entries(walletsByCurrency).map(([currency, wallets]) => `
                    <div style="margin-bottom: 15px;">
                        <strong>${currency}:</strong>
                        ${wallets.map(w => `
                            <div style="margin: 10px 0; padding: 10px; background: white; border-radius: 4px; border-left: 3px solid ${w.suggestColdStorage ? '#3498db' : '#95a5a6'};">
                                <div style="font-family: monospace; font-size: 12px; color: #7f8c8d;">
                                    ${w.wallet.substring(0, 20)}...
                                </div>
                                <div style="margin-top: 5px;">
                                    <strong>${w.remainingBalance.toLocaleString()} ${w.currency}</strong> remaining
                                    ${w.suggestColdStorage ? 
                                        `<span style="color: #3498db; margin-left: 10px;">Suggest: Mark as Cold Storage</span>` : 
                                        `<span style="color: #95a5a6; margin-left: 10px;">Already classified as ${w.walletType.toUpperCase()}</span>`
                                    }
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `).join('')}
            </div>
        `;
    }
    
    const modalHTML = `
        <div id="hopFinalizationModal" class="modal" style="display: block;">
            <div class="modal-content" style="max-width: 700px;">
                <div class="modal-header">
                    <h2>Finalize Hop ${hop.hopNumber}</h2>
                    <p>Choose how to account for remaining amounts before proceeding to the next hop</p>
                </div>
                
                ${walletSuggestionsHTML}
                
                <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 20px; margin: 20px 0;">
                    <h4 style="color: #856404; margin-bottom: 15px;">Unaccounted Amounts:</h4>
                    ${Object.entries(remainingByCurrency).map(([currency, amount]) => `
                        <div style="margin-bottom: 20px; padding: 15px; background: white; border-radius: 6px; border-left: 4px solid #ffc107;">
                            <div style="font-size: 18px; font-weight: bold; margin-bottom: 15px;">
                                ${currency}: ${amount.toLocaleString()} remaining
                            </div>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                                <button class="btn btn-danger" onclick="createAutoWriteoff(${hop.hopNumber}, '${currency}', ${amount})" style="padding: 15px;">
                                    📝 Automatic Write-off
                                    <div style="font-size: 12px; margin-top: 5px; font-weight: normal;">Mark as unrecoverable</div>
                                </button>
                                <button class="btn" style="background: #3498db; padding: 15px;" onclick="markAsColdStorage(${hop.hopNumber}, '${currency}', ${amount})">
                                    Cold Storage
                                    <div style="font-size: 12px; margin-top: 5px; font-weight: normal;">Funds remain in current wallet</div>
                                </button>
                                <button class="btn" style="background: #9b59b6; padding: 15px;" onclick="markAsVASPArrival(${hop.hopNumber}, '${currency}', ${amount})">
                                    VASP Arrival
                                    <div style="font-size: 12px; margin-top: 5px; font-weight: normal;">Funds arrived at exchange/service</div>
                                </button>
                                <button class="btn btn-secondary" style="padding: 15px;" onclick="assignPartialAmount(${hop.hopNumber}, '${currency}', ${amount})">
                                    ✂️ Partial Assignment
                                    <div style="font-size: 12px; margin-top: 5px; font-weight: normal;">Split amount across options</div>
                                </button>
                            </div>
                        </div>
                    `).join('')}
                </div>
                
                <div style="text-align: center; margin-top: 25px;">
                    <button class="btn btn-secondary" onclick="closeHopFinalizationModal()">
                        Cancel - Continue Editing Hop ${hop.hopNumber}
                    </button>
                </div>
            </div>
        </div>
    `;
    
    // Remove existing modal if present
    const existingModal = document.getElementById('hopFinalizationModal');
    if (existingModal) {
        existingModal.remove();
    }
    
    // Create centered modal
    createCenteredModal('hopFinalizationModal', modalHTML);
}

// Close hop finalization modal
function closeHopFinalizationModal() {
    const modal = document.getElementById('hopFinalizationModal');
    if (modal) {
        modal.remove();
    }
}

// Create automatic writeoff for remaining amount
function createAutoWriteoff(hopNumber, currency, amount) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    if (!hop) return;
    
    const writeoffEntry = {
        id: hop.entries.length + 1,
        hopNumber: hopNumber,
        hopNumber: hop.hopNumber,
        entryType: 'writeoff',
        notation: `H${hop.hopNumber}-WO`,
        amount: amount.toString(),
        currency: currency,
        customCurrency: currency === 'CUSTOM' ? currency : '',
        category: 'operational',
        justification: `Automatic write-off during hop finalization: ${amount.toLocaleString()} ${currency} unaccounted for`,
        // Default fields
        sourceChain: [],
        displayNotation: '',
        summaryNotation: '',
        victimNumbers: '',
        transactionNumbers: '',
        availableSourceAmount: 0,
        sourceThreadId: '',
        sourceThreadData: null,
        assignmentPercentage: 0,
        generatedNotation: '',
        isConvergence: false,
        convergenceData: null,
        fromWallet: '',
        fromWalletType: '',
        fromWalletId: '',
        toWallet: '',
        toWalletType: '',
        toWalletId: '',
        txHash: '',
        timestamp: new Date().toISOString(),
        timezone: 'UTC',
        notes: `Auto-generated during hop ${hop.hopNumber} finalization`
    };
    
    hop.entries.push(writeoffEntry);
    
    // Sort entries chronologically
    sortHopEntriesChronologically(hop);
    
    closeHopFinalizationModal();
    renderHops();
    saveToStorage();
    
    // Close the modal and re-run finalization to refresh the view
    closeFinalizationModal();
    
    // Re-run finalization to show updated state
    setTimeout(() => {
        finalizeHop(hopNumber);
    }, 100);
}

// Mark funds as cold storage
function markAsColdStorage(hopNumber, currency, amount) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    if (!hop) return;
    
    // Find the most recent wallet that handled this currency
    let lastWallet = '';
    let lastWalletType = 'black';
    
    for (let i = hop.entries.length - 1; i >= 0; i--) {
        const entry = hop.entries[i];
        const entryCurrency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
        if (entry.entryType === 'trace' && entryCurrency === currency && entry.toWallet) {
            lastWallet = entry.toWallet;
            lastWalletType = entry.toWalletType || 'black';
            break;
        }
    }
    
    const coldStorageEntry = {
        id: hop.entries.length + 1,
        hopNumber: hopNumber,
        hopNumber: hop.hopNumber,
        entryType: 'trace',
        notation: `H${hop.hopNumber}-CS`,
        amount: amount.toString(),
        currency: currency,
        customCurrency: currency === 'CUSTOM' ? currency : '',
        category: '',
        justification: '',
        // Enhanced fields
        sourceChain: [],
        displayNotation: '',
        summaryNotation: '',
        victimNumbers: '',
        transactionNumbers: '',
        availableSourceAmount: 0,
        sourceThreadId: '',
        sourceThreadData: null,
        assignmentPercentage: 0,
        generatedNotation: '',
        isConvergence: false,
        convergenceData: null,
        fromWallet: lastWallet,
        fromWalletType: lastWalletType,
        fromWalletId: '',
        toWallet: lastWallet,
        toWalletType: 'blue', // BLUE = Cold Storage
        toWalletId: '',
        txHash: '',
        timestamp: new Date().toISOString(),
        timezone: 'UTC',
        notes: `Cold storage: ${amount.toLocaleString()} ${currency} remains in wallet for future movement`
    };
    
    hop.entries.push(coldStorageEntry);
    
    // Sort entries chronologically
    sortHopEntriesChronologically(hop);
    
    // Update wallet classification in UWI
    let walletReclassified = false;
    if (investigation.universalWalletIndex && lastWallet) {
        const walletEntry = investigation.universalWalletIndex.find(w => w.address === lastWallet);
        if (walletEntry && walletEntry.currentStatus !== 'blue') {
            const previousType = walletEntry.currentStatus || 'unknown';
            walletEntry.currentStatus = 'blue';
            walletEntry.statusHistory = walletEntry.statusHistory || [];
            walletEntry.statusHistory.push(`Cold Storage (Hop ${hop.hopNumber})`);
            walletReclassified = true;
            
            // Show notification about wallet reclassification
            setTimeout(() => {
                alert(`Wallet Classification Updated\n\nWallet ${lastWallet.substring(0, 20)}... has been reclassified from ${previousType.toUpperCase()} to BLUE (Cold Storage) based on the remaining balance of ${amount.toLocaleString()} ${currency}.`);
            }, 100);
        }
    }
    
    closeHopFinalizationModal();
    renderHops();
    saveToStorage();
    
    // Close the modal and re-run finalization to refresh the view
    closeFinalizationModal();
    
    // Re-run finalization to show updated state
    setTimeout(() => {
        finalizeHop(hopNumber);
    }, 100);
}


// Mark funds as arriving at VASP
function markAsVASPArrival(hopNumber, currency, amount) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    if (!hop) return;
    
    // Prompt for VASP details
    const vaspName = prompt('Enter VASP/Exchange name:', 'Exchange');
    if (!vaspName) return;
    
    const vaspEntry = {
        id: hop.entries.length + 1,
        hopNumber: hopNumber,
        hopNumber: hop.hopNumber,
        entryType: 'trace',
        notation: `H${hop.hopNumber}-VASP`,
        amount: amount.toString(),
        currency: currency,
        customCurrency: currency === 'CUSTOM' ? currency : '',
        category: '',
        justification: '',
        // Enhanced fields
        sourceChain: [],
        displayNotation: '',
        summaryNotation: '',
        victimNumbers: '',
        transactionNumbers: '',
        availableSourceAmount: 0,
        sourceThreadId: '',
        sourceThreadData: null,
        assignmentPercentage: 0,
        generatedNotation: '',
        isConvergence: false,
        convergenceData: null,
        fromWallet: '',
        fromWalletType: 'black',
        fromWalletId: '',
        toWallet: vaspName,
        toWalletType: 'purple', // PURPLE = VASP
        toWalletId: '',
        txHash: '',
        timestamp: new Date().toISOString(),
        timezone: 'UTC',
        notes: `Funds arrived at VASP: ${vaspName} - ${amount.toLocaleString()} ${currency} (Fully traced)`
    };
    
    hop.entries.push(vaspEntry);
    
    // Sort entries chronologically
    sortHopEntriesChronologically(hop);
    
    // Create a new hop entry for the purple wallet to terminal exchange
    // This ensures the funds continue to be traced to their final destination
    const nextHopNumber = hop.hopNumber + 1;
    let nextHop = investigation.hops.find(h => h.hopNumber === nextHopNumber);
    
    if (!nextHop) {
        // Create the next hop if it doesn't exist
        nextHop = {
            id: investigation.hops.length + 1,
            hopNumber: nextHopNumber,
            entries: [],
            isCollapsed: false
        };
        investigation.hops.push(nextHop);
    }
    
    // Create the terminal exchange entry in the next hop
    const terminalEntry = {
        id: nextHop.entries.length + 1,
        hopNumber: nextHop.hopNumber,
        hopNumber: nextHop.hopNumber,
        entryType: 'trace',
        notation: `H${nextHop.hopNumber}-TERMINAL`,
        amount: amount.toString(),
        currency: currency,
        customCurrency: currency === 'CUSTOM' ? currency : '',
        category: '',
        justification: `Funds from ${vaspName} to terminal exchange wallet`,
        // Source from the VASP entry
        sourceChain: [{
            sourceNotation: vaspEntry.notation,
            amount: amount,
            currency: currency
        }],
        sourceThreadId: vaspEntry.notation,
        fromWallet: vaspName,
        fromWalletType: 'purple',
        toWallet: 'Terminal Exchange Wallet',
        toWalletType: 'purple',
        notes: `Terminal destination for ${amount.toLocaleString()} ${currency} from ${vaspName}`,
        timestamp: new Date().toISOString(),
        timezone: 'UTC'
    };
    
    nextHop.entries.push(terminalEntry);
    
    closeHopFinalizationModal();
    renderHops();
    saveToStorage();
    
    // Close the modal and re-run finalization to refresh the view
    closeFinalizationModal();
    
    // Re-run finalization to show updated state
    setTimeout(() => {
        finalizeHop(hopNumber);
    }, 100);
}

// Handle partial amount assignment
function assignPartialAmount(hopNumber, currency, totalAmount) {
    const modalHTML = `
        <div id="partialAssignmentModal" class="modal" style="display: block;">
            <div class="modal-content" style="max-width: 600px;">
                <div class="modal-header">
                    <h2>✂️ Partial Amount Assignment</h2>
                    <p>Split ${totalAmount.toLocaleString()} ${currency} across different options</p>
                </div>
                
                <div style="margin: 20px 0;">
                    <div style="margin-bottom: 20px;">
                        <label>Write-off Amount:</label>
                        <input type="number" id="partialWriteoff" step="0.01" min="0" max="${totalAmount}" 
                               value="0" onchange="updatePartialTotal(${totalAmount})">
                    </div>
                    <div style="margin-bottom: 20px;">
                        <label>Cold Storage Amount:</label>
                        <input type="number" id="partialColdStorage" step="0.01" min="0" max="${totalAmount}" 
                               value="0" onchange="updatePartialTotal(${totalAmount})">
                    </div>
                    <div style="margin-bottom: 20px;">
                        <label>VASP Arrival Amount:</label>
                        <input type="number" id="partialVASP" step="0.01" min="0" max="${totalAmount}" 
                               value="0" onchange="updatePartialTotal(${totalAmount})">
                    </div>
                    <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 6px;">
                        <strong>Total Assigned:</strong> <span id="partialTotal">0</span> / ${totalAmount.toLocaleString()} ${currency}
                        <div id="partialValidation" style="margin-top: 10px; color: #e74c3c;"></div>
                    </div>
                </div>
                
                <div style="text-align: center;">
                    <button class="btn btn-confirm" onclick="applyPartialAssignments(${hopNumber}, '${currency}', ${totalAmount})">
                        Apply Assignments
                    </button>
                    <button class="btn btn-secondary" onclick="closePartialAssignmentModal()">
                        Cancel
                    </button>
                </div>
            </div>
        </div>
    `;
    
    createCenteredModal('partialAssignmentModal', modalHTML);
}

// Update partial assignment total
function updatePartialTotal(totalAmount) {
    const writeoff = parseFloat(document.getElementById('partialWriteoff').value) || 0;
    const coldStorage = parseFloat(document.getElementById('partialColdStorage').value) || 0;
    const vasp = parseFloat(document.getElementById('partialVASP').value) || 0;
    
    const total = writeoff + coldStorage + vasp;
    document.getElementById('partialTotal').textContent = total.toLocaleString();
    
    const validation = document.getElementById('partialValidation');
    if (Math.abs(total - totalAmount) < 0.01) {
        validation.textContent = '✅ Amounts balance correctly';
        validation.style.color = '#27ae60';
    } else if (total > totalAmount) {
        validation.textContent = '❌ Total exceeds available amount';
        validation.style.color = '#e74c3c';
    } else {
        validation.textContent = `⚠️ ${(totalAmount - total).toLocaleString()} still unassigned`;
        validation.style.color = '#f39c12';
    }
}

// Apply partial assignments
function applyPartialAssignments(hopNumber, currency, totalAmount) {
    const writeoff = parseFloat(document.getElementById('partialWriteoff').value) || 0;
    const coldStorage = parseFloat(document.getElementById('partialColdStorage').value) || 0;
    const vasp = parseFloat(document.getElementById('partialVASP').value) || 0;
    
    const total = writeoff + coldStorage + vasp;
    if (Math.abs(total - totalAmount) >= 0.01) {
        alert('Assigned amounts must equal the total remaining amount');
        return;
    }
    
    closePartialAssignmentModal();
    closeHopFinalizationModal();
    
    // Apply each assignment
    if (writeoff > 0) {
        createAutoWriteoff(hopNumber, currency, writeoff);
    }
    if (coldStorage > 0) {
        markAsColdStorage(hopNumber, currency, coldStorage);
    }
    if (vasp > 0) {
        markAsVASPArrival(hopNumber, currency, vasp);
    }
}

// Close partial assignment modal
function closePartialAssignmentModal() {
    const modal = document.getElementById('partialAssignmentModal');
    if (modal) {
        modal.remove();
    }
}

// Confirm hop completion and start next (duplicate removed - using new flow above)
function confirmHopAndProceed(completedHop) {
    // Show confirmation modal
    const nextHopART = {};
    
    // Calculate starting ART for next hop from trace outputs
    completedHop.entries.forEach(entry => {
        if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0 && entry.toWalletType !== 'purple') {
            const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
            if (!nextHopART[currency]) {
                nextHopART[currency] = 0;
            }
            nextHopART[currency] += parseFloat(entry.amount);
        }
    });
    
    const totalActiveAmount = Object.values(nextHopART).reduce((sum, amount) => sum + amount, 0);
    
    const confirmHTML = `
        <div id="hopConfirmModal" class="modal" style="display: block;">
            <div class="modal-content">
                <div class="modal-header">
                    <h2>✅ Confirm Hop ${completedHop.hopNumber} Completion</h2>
                </div>
                
                <div style="margin: 20px 0;">
                    <p><strong>Hop ${completedHop.hopNumber} Summary:</strong></p>
                    <ul>
                        <li>Total Entries: ${completedHop.entries.length}</li>
                        <li>Traces: ${completedHop.entries.filter(e => e.entryType === 'trace').length}</li>
                        <li>Write-offs: ${completedHop.entries.filter(e => e.entryType === 'writeoff').length}</li>
                    </ul>
                    
                    ${totalActiveAmount > 0 ? `
                        <div style="margin-top: 20px; padding: 15px; background: #d4edda; border: 2px solid #27ae60; border-radius: 8px;">
                            <p><strong>Starting ART for Hop ${completedHop.hopNumber + 1}:</strong></p>
                            ${Object.entries(nextHopART).map(([currency, amount]) => 
                                `<div>${currency}: ${amount.toLocaleString()}</div>`
                            ).join('')}
                        </div>
                    ` : `
                        <div style="margin-top: 20px; padding: 15px; background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px;">
                            <p><strong>No active threads remaining - Investigation complete!</strong></p>
                        </div>
                    `}
                </div>
                
                <div style="text-align: center;">
                    <button class="btn btn-confirm" onclick="confirmHopCompletion(${completedHop.id})">
                        ${totalActiveAmount > 0 ? `Confirm & Start Hop ${completedHop.hopNumber + 1}` : 'Complete Investigation'}
                    </button>
                    <button class="btn btn-secondary" onclick="closeHopConfirmModal()">
                        Cancel
                    </button>
                </div>
            </div>
        </div>
    `;
    
    createCenteredModal('hopConfirmModal', confirmHTML);
}

// Confirm hop completion
function confirmHopCompletion(hopNumber) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    if (!hop) return;
    
    closeHopConfirmModal();
    
    // Create next hop if there are active threads
    createNextHopFromCurrent(hop);
}

// Close hop confirmation modal
function closeHopConfirmModal() {
    const modal = document.getElementById('hopConfirmModal');
    if (modal) {
        modal.remove();
    }
}

function validateHopCompletion(hopNumber) {
            const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
            if (!hop) return { valid: false, errors: ['Hop not found'] };

            const errors = [];
            const warnings = [];

            // Get starting ART by currency for this hop
            const startingART = hop.artAtStartByCurrency || {};

            // Track which currencies have been swapped out
            const swappedOutCurrencies = new Set();
            const swappedInAmounts = {};

            // First pass: identify swaps
            hop.entries.forEach(entry => {
                if (entry.entryType === 'swap' && entry.swapDetails) {
                    // Mark the source currency as swapped out
                    swappedOutCurrencies.add(entry.currency);

                    // Track the swapped-in amount
                    const toCurrency = entry.swapDetails.toCurrency;
                    if (!swappedInAmounts[toCurrency]) {
                        swappedInAmounts[toCurrency] = 0;
                    }
                    swappedInAmounts[toCurrency] += parseFloat(entry.swapDetails.toAmount || 0);
                }
            });

            // Calculate totals by currency from all entries in this hop
            const entryTotalsByCurrency = {};
            hop.entries.forEach(entry => {
                if (parseFloat(entry.amount) > 0) {
                    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                    if (!entryTotalsByCurrency[currency]) {
                        entryTotalsByCurrency[currency] = 0;
                    }
                    // Include all entry types that account for funds
                    if (['trace', 'writeoff', 'cold_storage', 'vasp_arrival'].includes(entry.entryType)) {
                        entryTotalsByCurrency[currency] += parseFloat(entry.amount);
                    }
                    // Swap entries account for the SOURCE currency only
                    // The OUTPUT must still be traced!
                    if (entry.entryType === 'swap') {
                        entryTotalsByCurrency[currency] += parseFloat(entry.amount);
                        // Note: The output currency will be available as a thread for the next hop
                    }
                }
            });
            
            // Validate each currency balances
            Object.entries(startingART).forEach(([currency, startAmount]) => {
                const tracedAmount = entryTotalsByCurrency[currency] || 0;
                const difference = Math.abs(startAmount - tracedAmount);

                // Skip validation for currencies that were fully swapped
                if (swappedOutCurrencies.has(currency)) {
                    // For swapped currencies, the entire amount should be accounted for
                    if (difference >= 0.01 && tracedAmount < startAmount) {
                        warnings.push(`${currency}: ${(startAmount - tracedAmount).toLocaleString()} was not swapped (only ${tracedAmount.toLocaleString()} of ${startAmount.toLocaleString()} converted)`);
                    }
                } else if (difference >= 0.01) {
                    if (tracedAmount > startAmount) {
                        errors.push(`${currency}: Traced ${tracedAmount.toLocaleString()} exceeds ART ${startAmount.toLocaleString()}`);
                    } else {
                        warnings.push(`${currency}: Missing ${(startAmount - tracedAmount).toLocaleString()} (${tracedAmount.toLocaleString()} of ${startAmount.toLocaleString()} traced)`);
                    }
                }
            });
            
            // Check for source thread over-assignment
            const sourceThreadUsage = {};
            hop.entries.forEach(entry => {
                if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0) {
                    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                    
                    if (entry.sourceThreadId) {
                        if (!sourceThreadUsage[currency]) sourceThreadUsage[currency] = {};
                        if (!sourceThreadUsage[currency][entry.sourceThreadId]) {
                            sourceThreadUsage[currency][entry.sourceThreadId] = 0;
                        }
                        sourceThreadUsage[currency][entry.sourceThreadId] += parseFloat(entry.amount);
                    }
                    
                    if (entry.individualSourceAssignments) {
                        Object.entries(entry.individualSourceAssignments).forEach(([sourceId, amount]) => {
                            if (!sourceThreadUsage[currency]) sourceThreadUsage[currency] = {};
                            if (!sourceThreadUsage[currency][sourceId]) {
                                sourceThreadUsage[currency][sourceId] = 0;
                            }
                            sourceThreadUsage[currency][sourceId] += parseFloat(amount);
                        });
                    }
                }
            });
            
            // Validate source thread assignments don't exceed availability
            Object.entries(sourceThreadUsage).forEach(([currency, threads]) => {
                Object.entries(threads).forEach(([threadId, usedAmount]) => {
                    if (investigation.availableThreads[currency] && investigation.availableThreads[currency][threadId]) {
                        const totalAvailable = investigation.availableThreads[currency][threadId].totalAmount;
                        if (usedAmount > totalAvailable + 0.01) {
                            errors.push(`${threadId}: Assigned ${usedAmount.toLocaleString()} exceeds available ${totalAvailable.toLocaleString()} ${currency}`);
                        }
                    }
                });
            });
            
            // CRITICAL FIX: Distinguish between untraced funds and funds traced to next hop
            // Funds traced to non-terminal wallets create threads for the next hop - that's EXPECTED
            // Only funds that haven't been traced AT ALL in this hop are "remaining/unaccounted"
            const remainingByCurrency = {};

            // Compare what was available at START of this hop vs what was actually used
            Object.entries(startingART).forEach(([currency, startAmount]) => {
                const tracedAmount = entryTotalsByCurrency[currency] || 0;
                const unaccounted = startAmount - tracedAmount;

                // Only consider it "remaining" if we haven't traced it at all
                if (unaccounted > 0.01) {
                    // Check if this currency was swapped
                    if (swappedOutCurrencies.has(currency)) {
                        // For swapped currencies, we expect the full amount to be in the swap entry
                        if (tracedAmount < startAmount - 0.01) {
                            remainingByCurrency[currency] = unaccounted;
                        }
                    } else {
                        // For non-swapped currencies, any untraced amount is truly remaining
                        remainingByCurrency[currency] = unaccounted;
                    }
                }
            });

            // Special case: Check for swap outputs created IN THIS HOP that haven't been traced
            hop.entries.forEach(entry => {
                if (entry.entryType === 'swap' && entry.swapDetails) {
                    const outputCurrency = entry.swapDetails.toCurrency;
                    const outputAmount = parseFloat(entry.swapDetails.toAmount || 0);

                    // Check if this swap output has been traced in this same hop
                    const tracedSwapOutput = hop.entries.filter(e =>
                        e.entryType === 'trace' &&
                        e.currency === outputCurrency &&
                        parseFloat(e.amount) > 0 &&
                        e.id !== entry.id  // Don't count the swap itself
                    ).reduce((sum, e) => sum + parseFloat(e.amount), 0);

                    if (tracedSwapOutput < outputAmount - 0.01) {
                        // Swap output exists but hasn't been traced yet in this hop
                        // This IS remaining because swaps in the same hop should be traced
                        if (!remainingByCurrency[outputCurrency]) {
                            remainingByCurrency[outputCurrency] = 0;
                        }
                        remainingByCurrency[outputCurrency] += (outputAmount - tracedSwapOutput);
                        console.log(`⚠️ Swap output not traced: ${outputAmount - tracedSwapOutput} ${outputCurrency} from swap`);
                    }
                }
            });

            console.log(`Hop ${hopNumber} validation - truly unaccounted amounts:`, remainingByCurrency);
            console.log(`Hop ${hopNumber} is balanced: ${Object.keys(remainingByCurrency).length === 0}`);

            // Add swapped-in currencies to the available threads for next hop
            Object.entries(swappedInAmounts).forEach(([currency, amount]) => {
                // The swapped-in currency becomes available for the next hop
                // This is handled by buildAvailableThreadsIndex after the swap
            });
            
            return {
                valid: errors.length === 0,
                errors: errors,
                warnings: warnings,
                balanceStatus: entryTotalsByCurrency,
                remainingByCurrency: remainingByCurrency
            };
        }

function updateInvestigationCompletionStatus() {
    const addHopBtn = document.getElementById('addHopBtn');
    const completeSection = document.getElementById('completeInvestigationSection');
    const visualizationSection = document.getElementById('visualizationPromptSection');

    if (!addHopBtn || !completeSection) return;

    // Hide both sections by default
    if (visualizationSection) {
        visualizationSection.style.display = 'none';
    }
    completeSection.style.display = 'none';

    // Check if we have victims entered
    if (!investigation.victims || investigation.victims.length === 0) {
        // No victims yet - hide everything
        addHopBtn.style.display = 'none';
        return;
    }

    // Check if all victims have root totals (are completed)
    const allVictimsComplete = investigation.victims.every(victim =>
        victim.rootTotals && Object.keys(victim.rootTotals).length > 0
    );

    if (!allVictimsComplete) {
        // Victims not complete - hide everything
        addHopBtn.style.display = 'none';
        return;
    }

    if (investigation.hops.length === 0) {
        // Victims complete, no hops yet - show add hop button
        addHopBtn.style.display = 'inline-block';
        return;
    }
    
    let allHopsComplete = true;
    let lastHopComplete = false;
    let totalValidationErrors = 0;
    
    // Check all hops for completion and validation
    investigation.hops.forEach((hop, index) => {
        const isLastHop = index === investigation.hops.length - 1;
        const validation = validateHopCompletion(hop.hopNumber);
        
        if (validation.errors && validation.errors.length > 0) {
            totalValidationErrors += validation.errors.length;
        }
        
        if (!hop.completed) {
            allHopsComplete = false;
        } else if (isLastHop) {
            lastHopComplete = true;
        }
    });
    
    // Check if all threads have reached terminal wallets
    const threadStatus = checkAllThreadsTerminated();

    // Calculate next hop ART from available threads
    const lastHop = investigation.hops[investigation.hops.length - 1];
    let nextHopART = {};
    let hasActiveThreads = false;

    // Get available threads for the next hop
    if (lastHop) {
        const nextHopNumber = lastHop.hopNumber + 1;
        const availableThreads = getAvailableSourcesForHop(nextHopNumber, null);

        // Check if any threads are available for tracing
        availableThreads.forEach(thread => {
            if (thread.availableAmount > 0) {
                const currency = thread.currency;
                if (!nextHopART[currency]) {
                    nextHopART[currency] = 0;
                }
                nextHopART[currency] += thread.availableAmount;
                hasActiveThreads = true;
            }
        });
    }
    
    // Show different buttons based on state
    // Only show complete if we have traced funds AND all threads are terminated
    const hasTracedFunds = investigation.hops.some(hop =>
        hop.entries && hop.entries.some(e => e.entryType === 'trace' && e.amount > 0)
    );

    if (!hasActiveThreads && investigation.hops.length > 0 && hasTracedFunds && threadStatus.allTerminated) {
        // All threads reached terminal wallets - investigation is truly complete
        addHopBtn.style.display = 'none';
        completeSection.style.display = 'block';
        if (visualizationSection) {
            visualizationSection.style.display = 'block';
        }
        updateFinalThreadSummary();
    } else if (threadStatus.allTerminated && allHopsComplete && totalValidationErrors === 0 && hasTracedFunds) {
        // All threads at terminal wallets
        addHopBtn.style.display = 'none';
        completeSection.style.display = 'block';
        if (visualizationSection) {
            visualizationSection.style.display = 'block';
        }
        updateFinalThreadSummary();
    } else if (lastHopComplete && hasActiveThreads) {
        // Last hop complete with active threads - show what will be traced
        const artSummary = Object.entries(nextHopART)
            .map(([currency, amount]) => `${amount.toLocaleString()} ${currency}`)
            .join(' + ');
        
        addHopBtn.innerHTML = `📝 Start Hop ${lastHop.hopNumber + 1} (${artSummary} available)`;
        addHopBtn.style.display = 'inline-block';
        addHopBtn.onclick = function() { 
            addNewHop();
        };
        completeSection.style.display = 'none';
    } else if (lastHopComplete && !hasActiveThreads && hasTracedFunds && threadStatus.allTerminated) {
        // No active threads AND all threads terminated - investigation is complete
        addHopBtn.style.display = 'none';

        // Show completion section
        completeSection.style.display = 'block';
        if (visualizationSection) {
            visualizationSection.style.display = 'block';
        }
        updateFinalThreadSummary();
    } else if (!lastHopComplete && investigation.hops.length > 0) {
        // Current hop not complete
        const currentHop = investigation.hops[investigation.hops.length - 1];
        addHopBtn.innerHTML = `⏸️ Complete Hop ${currentHop.hopNumber} First`;
        addHopBtn.style.display = 'inline-block';
        addHopBtn.disabled = true;
        addHopBtn.style.opacity = '0.6';
        addHopBtn.onclick = null;
        completeSection.style.display = 'none';
    } else {
        // Initial state or validation errors
        addHopBtn.innerHTML = `📝 Start First Hop`;
        addHopBtn.style.display = totalValidationErrors === 0 ? 'inline-block' : 'none';
        addHopBtn.disabled = false;
        addHopBtn.style.opacity = '1';
        addHopBtn.onclick = function() { addNewHop(); };
        completeSection.style.display = 'none';
        
        // Show validation status in console for debugging
        if (totalValidationErrors > 0) {
            console.log(`⚠️ Investigation has ${totalValidationErrors} validation errors across hops`);
        }
    }
}

        function showWalletClassificationModal(suggestions, hopNumber, onComplete) {
            const modalHTML = `
                <div id="walletClassificationModal" class="modal" style="display: block;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h2>Wallet Classification Review - Hop ${hopNumber}</h2>
                            <p>Based on observed behaviors, these wallets may need reclassification:</p>
                        </div>
                        
                        <div style="max-height: 400px; overflow-y: auto;">
                            ${suggestions.map((suggestion, index) => `
                                <div style="background: #f8f9fa; border: 2px solid #3498db; border-radius: 8px; padding: 20px; margin: 15px 0;">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                                        <div>
                                            <strong>Wallet:</strong> <span style="font-family: monospace; font-size: 12px;">${suggestion.walletAddress.substring(0, 20)}...</span>
                                        </div>
                                        <div>
                                            <strong>Amount:</strong> ${suggestion.totalAmount.toLocaleString()} ${suggestion.currencies.join('/')}
                                        </div>
                                    </div>
                                    
                                    <div style="margin-bottom: 15px;">
                                        <strong>Behavior Analysis:</strong> ${suggestion.reason}
                                    </div>
                                    
                                    <div style="margin-bottom: 15px;">
                                        <strong>Source Threads:</strong> ${suggestion.sourceThreads.join(', ')}
                                    </div>
                                    
                                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; align-items: center;">
                                        <div>
                                            <strong>Current:</strong><br>
                                            <span class="wallet-display ${suggestion.currentType}" style="margin: 0; display: inline-block;">
                                                ${walletTypes[suggestion.currentType] || suggestion.currentType.toUpperCase()}
                                            </span>
                                        </div>
                                        <div style="text-align: center;">
                                            <strong>→ Suggested:</strong><br>
                                            <span class="wallet-display ${suggestion.suggestedType}" style="margin: 0; display: inline-block;">
                                                ${walletTypes[suggestion.suggestedType] || suggestion.suggestedType.toUpperCase()}
                                            </span>
                                        </div>
                                        <div style="text-align: center;">
                                            <label style="cursor: pointer;">
                                                <input type="checkbox" id="approve_${index}" checked style="margin-right: 8px;">
                                                <strong>Apply Change</strong>
                                            </label>
                                        </div>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                        
                        <div style="text-align: center; margin-top: 25px;">
                            <button class="btn btn-confirm" onclick="applyWalletClassificationChanges(${JSON.stringify(suggestions).replace(/"/g, '&quot;')}, ${hopNumber}, arguments.callee.onComplete)">
                                ✅ Apply Selected Changes & Continue
                            </button>
                            <button class="btn btn-secondary" onclick="closeWalletClassificationModal(); arguments.callee.onComplete();">
                                Skip Classification Review
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            // Store callback for later use
            modalHTML.onComplete = onComplete;
            
            // Remove existing modal if present
            const existingModal = document.getElementById('walletClassificationModal');
            if (existingModal) {
                existingModal.remove();
            }
            
            // Create centered modal
            createCenteredModal('walletClassificationModal', modalHTML);
            
            // Store the callback on the window for access
            window.walletClassificationCallback = onComplete;
        }

        function applyWalletClassificationChanges(suggestions, hopNumber, onComplete) {
            console.log('Applying wallet classification changes...');
            
            let changesApplied = 0;
            let walletUpdates = [];
            
            suggestions.forEach((suggestion, index) => {
                const checkbox = document.getElementById(`approve_${index}`);
                if (checkbox && checkbox.checked) {
                    walletUpdates.push({
                        address: suggestion.walletAddress,
                        newType: suggestion.suggestedType,
                        oldType: suggestion.currentType,
                        reason: suggestion.reason
                    });
                    
                    // Update all entries for this wallet address retroactively
                    investigation.hops.forEach(hop => {
                        hop.entries.forEach(entry => {
                            // Update toWallet references
                            if (entry.toWallet && entry.toWallet.trim() === suggestion.walletAddress) {
                                entry.toWalletType = suggestion.suggestedType;
                                changesApplied++;
                            }
                            // Also update fromWallet references
                            if (entry.fromWallet && entry.fromWallet.trim() === suggestion.walletAddress) {
                                entry.fromWalletType = suggestion.suggestedType;
                                changesApplied++;
                            }
                        });
                    });
                    
                    // Update Red Wallet Index if needed
                    if (investigation.redWalletIndex) {
                        investigation.redWalletIndex.forEach(redEntry => {
                            if (redEntry.walletAddress === suggestion.walletAddress) {
                                // Update the wallet ID to reflect new classification
                                const walletIndex = investigation.universalWalletIndex.find(w => w.address === suggestion.walletAddress);
                                if (walletIndex) {
                                    redEntry.walletId = walletIndex.permanentId;
                                }
                            }
                        });
                    }
                }
            });
            
            if (changesApplied > 0) {
                // Rebuild Universal Wallet Index with updated classifications
                buildUniversalWalletIndex();
                buildRedWalletIndex();
                
                // Apply permanent UWI updates
                applyPermanentUWIUpdates(walletUpdates);
                
                alert(` Applied ${changesApplied} wallet classification changes retroactively!\n\nUpdated wallets:\n${walletUpdates.map(u => `• ${u.address.substring(0, 20)}... ${u.newType.toUpperCase()}`).join('\n')}`);
                saveToStorage();
                
                // Re-render all affected components
                renderHops();
                renderRedWalletIndex();
                renderUniversalWalletIndex();
            }
            
            closeWalletClassificationModal();
            
            // Call the completion callback
            if (window.walletClassificationCallback) {
                window.walletClassificationCallback();
                window.walletClassificationCallback = null;
            }
        }
        
        // Apply permanent updates to UWI
        function applyPermanentUWIUpdates(walletUpdates) {
            walletUpdates.forEach(update => {
                const walletEntry = investigation.universalWalletIndex.find(w => w.address === update.address);
                if (walletEntry) {
                    // Add audit trail entry
                    if (!walletEntry.auditTrail) {
                        walletEntry.auditTrail = [];
                    }
                    walletEntry.auditTrail.push({
                        timestamp: new Date().toISOString(),
                        action: 'Classification Update',
                        from: update.oldType,
                        to: update.newType,
                        reason: update.reason,
                        investigator: investigation.investigator || 'Unknown'
                    });
                    
                    // Update notes with classification reason
                    if (walletEntry.notes) {
                        walletEntry.notes += `\n[${new Date().toLocaleDateString()}] ${update.reason}`;
                    } else {
                        walletEntry.notes = `[${new Date().toLocaleDateString()}] ${update.reason}`;
                    }
                }
            });
        }

        function closeWalletClassificationModal() {
            const modal = document.getElementById('walletClassificationModal');
            if (modal) {
                modal.remove();
            }
        }
        
        // Show wallet selector modal
        function showWalletSelector(hopNumber, entryId) {
            const sortedWallets = [...(investigation.universalWalletIndex || [])].sort((a, b) => {
                if (a.permanentType !== b.permanentType) {
                    const typeOrder = ['red', 'pink', 'yellow', 'orange', 'brown', 'black', 'blue', 'purple', 'gray', 'green'];
                    return typeOrder.indexOf(a.permanentType) - typeOrder.indexOf(b.permanentType);
                }
                return a.permanentId.localeCompare(b.permanentId);
            });
            
            const modalHTML = `
                <div id="walletSelectorModal" class="modal" style="display: block;">
                    <div class="modal-content" style="max-width: 800px;">
                        <div class="modal-header">
                            <h2>📋 Select Wallet</h2>
                            <p>Choose an existing wallet from the Universal Wallet Index</p>
                        </div>
                        
                        <div style="margin-bottom: 20px;">
                            <input type="text" 
                                   id="walletSearchInput" 
                                   placeholder="Search by wallet address or ID..."
                                   onkeyup="filterWalletList()"
                                   style="width: 100%; padding: 10px; border: 2px solid #e8f0fe; border-radius: 6px;">
                        </div>
                        
                        <div style="max-height: 400px; overflow-y: auto;">
                            <table style="width: 100%; border-collapse: collapse;">
                                <thead>
                                    <tr style="background: #f8f9fa; position: sticky; top: 0;">
                                        <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Wallet ID</th>
                                        <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Type</th>
                                        <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Address</th>
                                        <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Action</th>
                                    </tr>
                                </thead>
                                <tbody id="walletListBody">
                                    ${sortedWallets.map(wallet => `
                                        <tr class="wallet-row" data-address="${wallet.address.toLowerCase()}" data-id="${wallet.permanentId.toLowerCase()}">
                                            <td style="border: 1px solid #ddd; padding: 12px;">
                                                <div class="wallet-display ${wallet.permanentType}" style="margin: 0;">
                                                    ${wallet.permanentId}
                                                </div>
                                            </td>
                                            <td style="border: 1px solid #ddd; padding: 12px;">
                                                ${walletTypes[wallet.permanentType] || wallet.permanentType}
                                            </td>
                                            <td style="border: 1px solid #ddd; padding: 12px; font-family: monospace; font-size: 11px;">
                                                ${wallet.address}
                                            </td>
                                            <td style="border: 1px solid #ddd; padding: 12px; text-align: center;">
                                                <button class="btn btn-confirm" style="padding: 6px 12px;"
                                                        onclick="selectWallet(${hopNumber}, ${entryId}, '${wallet.address}', '${wallet.permanentType}')">
                                                    Select
                                                </button>
                                            </td>
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                        </div>
                        
                        <div style="text-align: center; margin-top: 25px;">
                            <button class="btn btn-secondary" onclick="closeWalletSelectorModal()">
                                Cancel
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            // Remove existing modal if present
            const existingModal = document.getElementById('walletSelectorModal');
            if (existingModal) {
                existingModal.remove();
            }
            
            // Create centered modal
            createCenteredModal('walletSelectorModal', modalHTML);
        }
        
        // Filter wallet list in modal
        function filterWalletList() {
            const searchInput = document.getElementById('walletSearchInput');
            const filter = searchInput.value.toLowerCase();
            const rows = document.querySelectorAll('#walletListBody .wallet-row');
            
            rows.forEach(row => {
                const address = row.getAttribute('data-address');
                const id = row.getAttribute('data-id');
                
                if (address.includes(filter) || id.includes(filter)) {
                    row.style.display = '';
                } else {
                    row.style.display = 'none';
                }
            });
        }
        
        // Select wallet from modal
        function selectWallet(hopNumber, entryId, address, walletType) {
            // Update the entry
            const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
            const entry = hop.entries.find(e => e.id === entryId);
            
            if (entry) {
                entry.toWallet = address;
                entry.toWalletType = walletType;
            }
            
            // Update the input field
            const input = document.getElementById(`toWallet_${hopNumber}_${entryId}`);
            if (input) {
                input.value = address;
            }
            
            // Update the wallet type dropdown
            const typeSelect = document.querySelector(`select[onchange="updateHopEntryWalletType(${hopNumber}, ${entryId}, this.value)"]`);
            if (typeSelect) {
                typeSelect.value = walletType;
            }
            
            // Close modal and save
            closeWalletSelectorModal();
            saveToStorage();
            
            // Re-render to update UI
            renderHops();
        }
        
        // Close wallet selector modal
        function closeWalletSelectorModal() {
            const modal = document.getElementById('walletSelectorModal');
            if (modal) {
                modal.remove();
            }
        }

        function analyzeWalletBehaviors(hop) {
            console.log(` Analyzing wallet behaviors for hop ${hop.hopNumber}...`);
            
            const suggestions = [];
            const walletBehaviors = {};
            
            // Analyze each entry to track wallet behaviors
            hop.entries.forEach(entry => {
                if (entry.entryType === 'trace' && entry.toWallet && parseFloat(entry.amount) > 0) {
                    const walletAddress = entry.toWallet.trim();
                    
                    if (!walletBehaviors[walletAddress]) {
                        walletBehaviors[walletAddress] = {
                            address: walletAddress,
                            currentClassification: entry.toWalletType,
                            sourceThreads: [],
                            totalAmount: 0,
                            currencies: new Set()
                        };
                    }
                    
                    const behavior = walletBehaviors[walletAddress];
                    const sourceThread = entry.sourceThreadId || 'Multiple Sources';
                    
                    if (!behavior.sourceThreads.includes(sourceThread)) {
                        behavior.sourceThreads.push(sourceThread);
                    }
                    
                    behavior.totalAmount += parseFloat(entry.amount);
                    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                    behavior.currencies.add(currency);
                }
            });
            
            // Analyze behaviors and suggest reclassifications
            Object.values(walletBehaviors).forEach(behavior => {
                const sourceCount = behavior.sourceThreads.length;
                const currencyCount = behavior.currencies.size;
                let suggestedType = behavior.currentClassification;
                let reason = '';
                
                // Multiple source threads = convergence behavior
                if (sourceCount > 1) {
                    if (behavior.currentClassification !== 'yellow') {
                        suggestedType = 'yellow';
                        reason = `Received funds from ${sourceCount} different source threads, indicating convergence/hub behavior`;
                    }
                }
                
                // Multiple currencies = conversion behavior
                if (currencyCount > 1) {
                    if (behavior.currentClassification !== 'brown') {
                        suggestedType = 'brown';
                        reason = `Handled ${currencyCount} different currencies, indicating asset conversion behavior`;
                    }
                }
                
                // Cold storage detection moved to hop finalization
                // BLUE wallet classification is now only suggested when:
                // 1. User is finalizing a hop with remaining balances
                // 2. User explicitly creates cold storage entries
                // This prevents false positives during active tracing
                
                // Add suggestion if classification should change
                if (suggestedType !== behavior.currentClassification) {
                    suggestions.push({
                        walletAddress: behavior.address,
                        currentType: behavior.currentClassification,
                        suggestedType: suggestedType,
                        reason: reason,
                        sourceThreads: behavior.sourceThreads,
                        totalAmount: behavior.totalAmount,
                        currencies: Array.from(behavior.currencies)
                    });
                }
            });
            
            console.log(` Found ${suggestions.length} wallet classification suggestions:`, suggestions);
            return suggestions;
        }

        function completeCurrentHopAndStartNext() {
            console.log(' Completing current hop and starting next...');
            
            const currentHop = investigation.hops[investigation.hops.length - 1];
            const validation = validateHopCompletion(currentHop.id);
            
            if (!validation.valid) {
                alert(`Cannot complete hop ${currentHop.hopNumber}. Please fix validation errors first:\n${validation.errors.join('\n')}`);
                return;
            }
            
            // Mark current hop as completed
            currentHop.completed = true;
            
            // Analyze wallet behaviors for classification suggestions
            const classificationSuggestions = analyzeWalletBehaviors(currentHop);
            
            if (classificationSuggestions.length > 0) {
                showWalletClassificationModal(classificationSuggestions, currentHop.hopNumber, () => {
                    // After classification review, create next hop
                    createNextHopFromCurrent(currentHop);
                });
            } else {
                // No classification changes needed, proceed directly
                createNextHopFromCurrent(currentHop);
            }
        }

        function createNextHopFromCurrent(completedHop) {
            console.log(`Creating hop ${completedHop.hopNumber + 1} from completed hop ${completedHop.hopNumber}`);
            
            // Calculate starting ART for next hop based on trace outputs from current hop
            const nextHopART = {};
            
            completedHop.entries.forEach(entry => {
                if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0) {
                    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                    if (!nextHopART[currency]) {
                        nextHopART[currency] = 0;
                    }
                    nextHopART[currency] += parseFloat(entry.amount);
                }
            });
            
            // Only create next hop if there are active threads to trace
            const totalActiveAmount = Object.values(nextHopART).reduce((sum, amount) => sum + amount, 0);
            
            if (totalActiveAmount > 0) {
                const nextHop = {
                    hopNumber: completedHop.hopNumber + 1,
                    entries: [],
                    artAtStartByCurrency: nextHopART,
                    artAtStart: totalActiveAmount, // Legacy support
                    completed: false
                };
                
                investigation.hops.push(nextHop);
                
                // Rebuild thread index
                if (typeof buildAvailableThreadsIndex === 'function') {
                    buildAvailableThreadsIndex();
                }
                
                // Update Universal Wallet Index with any new wallets
                buildUniversalWalletIndex();
                
                renderHops();
                saveToStorage();
                updateWorkflowSteps();
                
                alert(` Hop ${completedHop.hopNumber} completed! \n🎯 Hop ${nextHop.hopNumber} ready with starting ART: ${Object.entries(nextHopART).map(([currency, amount]) => `${amount.toLocaleString()} ${currency}`).join(', ')}`);
                
                console.log(` Hop ${nextHop.hopNumber} created successfully with ART:`, nextHopART);
            } else {
                // No trace outputs from this hop - check if investigation is complete
                saveToStorage();
                renderHops();
                updateInvestigationCompletionStatus();
                
                // The completion status function will handle showing the appropriate message
                console.log(`Hop ${completedHop.hopNumber} completed with no trace outputs.`);
            }
        }
        
// Check if a wallet type is a terminal wallet (where traces should end)
function isTerminalWalletType(walletType) {
    // Terminal wallets: GRAY (obfuscated), PURPLE (exchange deposit), BLUE (cold storage - temporary terminal)
    return ['gray', 'purple', 'blue'].includes(walletType);
}

// Check if all active threads have reached terminal wallets
function checkAllThreadsTerminated() {
    const activeThreads = [];
    const nonTerminalThreads = [];
    const unallocatedThreads = [];

    // CRITICAL FIX: First check for any unallocated threads in availableThreads
    // This includes swap outputs that haven't been traced yet
    buildAvailableThreadsIndex(); // Ensure index is up to date

    // Check all available threads for any unallocated amounts
    Object.entries(investigation.availableThreads || {}).forEach(([currency, threads]) => {
        Object.entries(threads).forEach(([threadId, thread]) => {
            const availableAmount = getMaxAssignableAmount(thread.internalId || threadId, currency);

            if (availableAmount > 0.01) {
                // This thread has unallocated funds!
                unallocatedThreads.push({
                    threadId: thread.notation || threadId,
                    internalId: thread.internalId || threadId,
                    amount: availableAmount,
                    currency: currency,
                    sourceType: thread.sourceType,
                    isSwapOutput: thread.sourceType === 'swap_output'
                });

                // These are NOT terminated - they need to be traced
                nonTerminalThreads.push({
                    path: thread.notation || threadId,
                    amount: availableAmount,
                    currency: currency,
                    toWalletType: 'unallocated',
                    toWallet: 'NOT_TRACED_YET',
                    walletTypeDisplay: 'Unallocated Funds'
                });
            }
        });
    });

    // Now check traced threads for their terminal status
    const threadPaths = {};

    investigation.hops.forEach(hop => {
        hop.entries.forEach(entry => {
            if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0) {
                let threadPath = null;

                // Try to extract thread path from notation
                if (entry.notation) {
                    const pathMatch = entry.notation.match(/^(V\d+-T\d+)/);
                    if (pathMatch) {
                        threadPath = pathMatch[1];
                    }
                }

                // If no valid notation, create a unique identifier based on source
                if (!threadPath) {
                    // Use sourceThreadId or create a generic identifier
                    if (entry.sourceThreadId) {
                        threadPath = entry.sourceThreadId;
                    } else if (entry.victimNumbers && entry.transactionNumbers) {
                        threadPath = `V${entry.victimNumbers}-T${entry.transactionNumbers}`;
                    } else {
                        // Create a unique identifier for this entry
                        threadPath = `H${hop.hopNumber}-E${entry.id}`;
                    }
                }

                // Store the most recent (highest hop number) entry for each thread
                if (!threadPaths[threadPath] || hop.hopNumber > threadPaths[threadPath].hopNumber) {
                    threadPaths[threadPath] = {
                        hopNumber: hop.hopNumber,
                        entry: entry,
                        amount: parseFloat(entry.amount),
                        currency: entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency,
                        toWalletType: entry.toWalletType || 'black',
                        toWallet: entry.toWallet,
                        path: threadPath
                    };
                }
            }
        });
    });

    // Check each traced thread's terminal status
    Object.entries(threadPaths).forEach(([threadPath, threadData]) => {
        activeThreads.push({
            path: threadPath,
            ...threadData
        });

        if (!isTerminalWalletType(threadData.toWalletType)) {
            // Only add to nonTerminalThreads if not already there as unallocated
            const isAlreadyUnallocated = nonTerminalThreads.some(t => t.path === threadPath);
            if (!isAlreadyUnallocated) {
                nonTerminalThreads.push({
                    path: threadPath,
                    ...threadData,
                    walletTypeDisplay: walletTypes[threadData.toWalletType] || threadData.toWalletType
                });
            }
        }
    });

    console.log('Thread termination check:', {
        unallocatedThreads: unallocatedThreads,
        activeThreads: activeThreads,
        nonTerminalThreads: nonTerminalThreads
    });

    // Investigation is only complete if:
    // 1. No unallocated threads (including swap outputs)
    // 2. All traced threads reached terminal wallets
    const allTerminated = unallocatedThreads.length === 0 && nonTerminalThreads.length === 0;

    return {
        allTerminated: allTerminated,
        activeThreads: activeThreads,
        nonTerminalThreads: nonTerminalThreads,
        unallocatedThreads: unallocatedThreads,
        totalActiveAmount: activeThreads.reduce((sum, thread) => sum + thread.amount, 0),
        hasUnallocatedFunds: unallocatedThreads.length > 0
    };
}
        function updateFinalThreadSummary() {
            const summaryContainer = document.getElementById('finalThreadSummary');
            const threadStatus = checkAllThreadsTerminated();
            
            let summaryHTML = '<h4 style="margin-bottom: 15px; color: #2c3e50;">🎯 Investigation Complete - All Threads at Terminal Wallets</h4>';
            
            if (threadStatus.activeThreads.length > 0) {
                // Group threads by currency and terminal status
                const threadsByCurrency = {};
                
                threadStatus.activeThreads.forEach(thread => {
                    if (!threadsByCurrency[thread.currency]) {
                        threadsByCurrency[thread.currency] = {
                            total: 0,
                            threads: []
                        };
                    }
                    threadsByCurrency[thread.currency].total += thread.amount;
                    threadsByCurrency[thread.currency].threads.push(thread);
                });
                
                Object.entries(threadsByCurrency).forEach(([currency, data]) => {
                    summaryHTML += `
                        <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                            <div style="font-weight: bold; margin-bottom: 10px;">
                                ${currency}: ${data.total.toLocaleString()} Total
                            </div>
                            <div style="font-size: 14px;">
                    `;
                    
                    data.threads.forEach(thread => {
                        const walletTypeColor = getWalletColor(thread.toWalletType);
                        const isTerminal = isTerminalWalletType(thread.toWalletType);
                        const icon = isTerminal ? '✅' : '⚠️';
                        
                        summaryHTML += `
                            <div style="margin: 5px 0; padding: 8px; background: white; border-radius: 4px; border-left: 4px solid ${walletTypeColor};">
                                ${icon} <strong>${thread.path}</strong>: ${thread.amount.toLocaleString()} ${currency} 
                                <span style="color: ${walletTypeColor}; font-weight: bold;">
                                    ${walletTypes[thread.toWalletType] || thread.toWalletType}
                                </span>
                                ${thread.toWalletType === 'blue' ? '<small style="color: #666;"> (Cold Storage - Temporary Terminal)</small>' : ''}
                            </div>
                        `;
                    });
                    
                    summaryHTML += `
                            </div>
                        </div>
                    `;
                });
                
                // Add terminal wallet legend
                summaryHTML += `
                    <div style="margin-top: 20px; padding: 15px; background: #e8f5e8; border: 2px solid #27ae60; border-radius: 8px;">
                        <h5 style="color: #27ae60; margin-bottom: 10px;">Terminal Wallet Types:</h5>
                        <div style="font-size: 13px; color: #2c3e50;">
                            <div style="margin: 5px 0;">
                                <span style="background: ${getWalletColor('purple')}; color: white; padding: 2px 8px; border-radius: 4px;">PURPLE</span>
                                - Exchange/VASP Deposit (Final Destination)
                            </div>
                            <div style="margin: 5px 0;">
                                <span style="background: ${getWalletColor('gray')}; color: white; padding: 2px 8px; border-radius: 4px;">GRAY</span>
                                - Obfuscated/Mixed (Cannot trace further)
                            </div>
                            <div style="margin: 5px 0;">
                                <span style="background: ${getWalletColor('blue')}; color: white; padding: 2px 8px; border-radius: 4px;">BLUE</span>
                                - Cold Storage (Temporary - May move later)
                            </div>
                        </div>
                    </div>
                `;
            } else {
                summaryHTML += '<p style="color: #666; text-align: center;">No active threads found.</p>';
            }
            
            summaryContainer.innerHTML = summaryHTML;
        }

        function getCurrentThreadValues() {
            const threadsByCurrency = {};
            
            // Group entries by currency and V-T path
            const tracePathsByCurrency = {};
            
            investigation.hops.forEach(hop => {
                hop.entries.forEach(entry => {
                    if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0 && entry.notation) {
                        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                        
                        const pathMatch = entry.notation.match(/^(V\d+-T\d+)/);
                        if (pathMatch) {
                            const vtPath = pathMatch[1];
                            
                            if (!tracePathsByCurrency[currency]) {
                                tracePathsByCurrency[currency] = {};
                            }
                            if (!tracePathsByCurrency[currency][vtPath]) {
                                tracePathsByCurrency[currency][vtPath] = [];
                            }
                            
                            tracePathsByCurrency[currency][vtPath].push({
                                hopNumber: entry.hopNumber,
                                amount: parseFloat(entry.amount),
                                notation: entry.notation,
                                toWalletType: entry.toWalletType
                            });
                        }
                    }
                });
            });
            
            // For each currency, get current thread values and terminal types
            Object.entries(tracePathsByCurrency).forEach(([currency, paths]) => {
                threadsByCurrency[currency] = {
                    totalAmount: 0,
                    paths: [],
                    terminalTypes: new Set()
                };
                
                Object.entries(paths).forEach(([vtPath, entries]) => {
                    entries.sort((a, b) => b.hopNumber - a.hopNumber);
                    const currentEntry = entries[0];
                    
                    threadsByCurrency[currency].totalAmount += currentEntry.amount;
                    threadsByCurrency[currency].paths.push({
                        path: vtPath,
                        amount: currentEntry.amount,
                        notation: currentEntry.notation
                    });
                    
                    if (currentEntry.toWalletType) {
                        threadsByCurrency[currency].terminalTypes.add(walletTypes[currentEntry.toWalletType] || currentEntry.toWalletType);
                    }
                });
                
                threadsByCurrency[currency].terminalTypes = Array.from(threadsByCurrency[currency].terminalTypes);
            });
            
            return threadsByCurrency;
        }
        
        // =================================
        // PART 4: CORE THREAD TRACKING FUNCTIONS
        // Add these functions to your existing JavaScript
        // =================================

// DUPLICATE FUNCTION - Using the one at line 1572 instead
/*function buildAvailableThreadsIndex() {
    console.log('Building available threads index...');
    console.log('Victims:', investigation.victims);
    
    investigation.availableThreads = {};
    
    // Start with ALL victim transactions
    investigation.victims.forEach(victim => {
        console.log(`Processing victim ${victim.id} with ${victim.transactions.length} transactions`);
        
        victim.transactions.forEach(transaction => {
            console.log(`Transaction ${transaction.id}:`, transaction);
            console.log(`Amount: "${transaction.amount}" (parsed: ${parseFloat(transaction.amount)})`);
            console.log(`Receiving Wallet: "${transaction.receivingWallet}" (length: ${transaction.receivingWallet ? transaction.receivingWallet.length : 'undefined'})`);
            
            const amountCheck = parseFloat(transaction.amount) > 0;
            const walletCheck = transaction.receivingWallet && transaction.receivingWallet.trim() !== '';
            
            console.log(`Amount check: ${amountCheck}, Wallet check: ${walletCheck}`);
            
            if (amountCheck && walletCheck) {
                const currency = transaction.currency === 'CUSTOM' ? 
                    transaction.customCurrency : transaction.currency;
                const threadId = `V${victim.id}-T${transaction.id}`;
                
                if (!investigation.availableThreads[currency]) {
                    investigation.availableThreads[currency] = {};
                }
                
                investigation.availableThreads[currency][threadId] = {
                    totalAmount: roundAmount(parseFloat(transaction.amount)),
                    availableAmount: roundAmount(parseFloat(transaction.amount)),
                    currency: currency
                };
                
                console.log(` Added thread ${threadId} with ${transaction.amount} ${currency}`);
            } else {
                console.log(` Skipped transaction ${transaction.id}: Amount check: ${amountCheck}, Wallet check: ${walletCheck}`);
            }
        });
    });
    
    // Add threads from hop outputs
    investigation.hops.forEach(hop => {
        hop.entries.forEach(entry => {
            if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0 && entry.notation) {
                const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                // Thread ID is the notation itself (already contains hop number)
                const threadId = entry.notation;
                
                if (!investigation.availableThreads[currency]) {
                    investigation.availableThreads[currency] = {};
                }
                
                // Only add if it doesn't already exist (to preserve any existing data)
                if (!investigation.availableThreads[currency][threadId]) {
                    investigation.availableThreads[currency][threadId] = {
                        totalAmount: parseFloat(entry.amount),
                        availableAmount: parseFloat(entry.amount),
                        currency: currency,
                        sourceType: 'hop_output',
                        hopLevel: entry.hopNumber,
                        fromWallet: entry.toWallet
                    };
                    
                    console.log(` Added hop output thread ${threadId} with ${entry.amount} ${currency} from hop ${entry.hopNumber}`);
                }
            }
        });
    });
    
    console.log(' Final available threads:', investigation.availableThreads);
}*/

// DUPLICATE FUNCTION - Using the one at line 1619 instead
/*function updateThreadAvailabilityFromHop(entry) {
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    const amount = parseFloat(entry.amount);
    
    if (!investigation.availableThreads[currency]) {
        investigation.availableThreads[currency] = {};
    }
    
    // Create new thread entry for this hop output
    const newThreadId = entry.notation;
    investigation.availableThreads[currency][newThreadId] = {
        totalAmount: amount,
        availableAmount: amount,
        assignments: [],
        sourceWallet: entry.toWallet,
        sourceType: 'hop_output',
        hopLevel: entry.hopNumber,
        createdAt: entry.timestamp || new Date().toISOString(),
        isActive: true,
        parentThreads: entry.sourceThreadId ? [entry.sourceThreadId] : [],
        childThreads: [],
        currency: currency
    };
    
    // Reduce availability from source thread if specified
    if (entry.sourceThreadId && investigation.availableThreads[currency][entry.sourceThreadId]) {
        const sourceThread = investigation.availableThreads[currency][entry.sourceThreadId];
        sourceThread.availableAmount -= amount;
        sourceThread.assignments.push({
            assignedTo: newThreadId,
            amount: amount,
            timestamp: new Date().toISOString(),
            isActive: true
        });
        
        // Add child reference
        if (!sourceThread.childThreads.includes(newThreadId)) {
            sourceThread.childThreads.push(newThreadId);
        }
    }
}*/

// DUPLICATE FUNCTION - Using the one at line 1663 instead
/*function getAvailableSourcesForHop(hopNumber, targetCurrency) {
    console.log(` Getting available sources for Hop ${hopNumber}, Currency filter: ${targetCurrency || 'ALL'}`);
    
    buildAvailableThreadsIndex(); // Refresh the index
    
    console.log('Available threads after build:', investigation.availableThreads);
    
    const availableSources = [];
    
    if (hopNumber === 1) {
        // First hop: ALL victim transactions (RED wallets) from ALL victims, ALL currencies
        console.log(`📋 Checking ${investigation.victims.length} victims for available transactions`);
        
        investigation.victims.forEach(victim => {
            victim.transactions.forEach(transaction => {
                console.log(`Checking V${victim.id}-T${transaction.id}: Amount=${transaction.amount}, Wallet=${transaction.receivingWallet}, Currency=${transaction.currency}`);
                
                if (parseFloat(transaction.amount) > 0 && transaction.receivingWallet && transaction.receivingWallet.trim() !== '') {
                    const currency = transaction.currency === 'CUSTOM' ? transaction.customCurrency : transaction.currency;
                    
                    console.log(`Transaction currency: ${currency}, Target filter: ${targetCurrency || 'NONE'}`);
                    
                    // Only filter by currency if targetCurrency is specified
                    if (!targetCurrency || currency === targetCurrency) {
                        const threadId = `V${victim.id}-T${transaction.id}`;
                        
                        // Use the REAL-TIME availability calculation
                        const currentAvailable = getMaxAssignableAmount(threadId, currency);
                        
                        console.log(`Thread ${threadId}: Available ${currentAvailable} ${currency} from real-time calculation`);
                        
                        if (currentAvailable > 0) {
                            const source = {
                                threadId: threadId,
                                displayText: `${threadId} (RED Wallet)`,
                                availableAmount: currentAvailable,
                                currency: currency,
                                sourceWallet: transaction.receivingWallet,
                                sourceType: 'victim_transaction',
                                hopLevel: 0
                            };
                            
                            console.log(` Adding source:`, source);
                            availableSources.push(source);
                        } else {
                            console.log(` Skipping ${threadId}: No availability remaining`);
                        }
                    }
                }
            });
        });
    } else {
        // Subsequent hops: ALL outputs from previous hop level across ALL victim paths
        const previousHopNumber = hopNumber - 1;
        console.log(`📋 Checking previous hop ${previousHopNumber} for available sources`);
        
        investigation.hops.forEach(hop => {
            if (hop.hopNumber === previousHopNumber) {
                hop.entries.forEach(entry => {
                    if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0 && entry.notation) {
                        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                        
                        if (!targetCurrency || currency === targetCurrency) {
                            // Thread ID is the notation itself (already contains hop number)
                            const threadId = entry.notation;
                            const currentAvailable = getMaxAssignableAmount(threadId, currency);
                            
                            if (currentAvailable > 0) {
                                availableSources.push({
                                    threadId: threadId,
                                    displayText: `${threadId}`,
                                    availableAmount: currentAvailable,
                                    currency: currency,
                                    sourceWallet: entry.toWallet,
                                    sourceType: 'hop_output',
                                    hopLevel: previousHopNumber
                                });
                            }
                        }
                    }
                });
            }
        });
    }
    
    console.log(` Final available sources (${availableSources.length}):`, availableSources);
    
    return availableSources.sort((a, b) => a.threadId.localeCompare(b.threadId));
}*/

function getMaxAssignableAmount(sourceThreadIdentifier, currency, excludeEntryId = null, excludeHopId = null) {
    // Support both internal IDs and legacy notation-based IDs
    let threadCurrency = null;
    let threadData = null;
    let internalId = null;

    // Search through all currencies to find this thread
    Object.entries(investigation.availableThreads || {}).forEach(([curr, threads]) => {
        // First try direct lookup (for internal IDs)
        if (threads[sourceThreadIdentifier]) {
            threadCurrency = curr;
            threadData = threads[sourceThreadIdentifier];
            internalId = sourceThreadIdentifier;
        } else {
            // If not found, search by notation (for backward compatibility)
            Object.entries(threads).forEach(([id, thread]) => {
                if (thread.notation === sourceThreadIdentifier) {
                    threadCurrency = curr;
                    threadData = thread;
                    internalId = id;
                }
            });
        }
    });

    if (!threadData) {
        return 0;
    }

    // If a specific currency was requested and it doesn't match the thread's currency, return 0
    if (currency && currency !== threadCurrency) {
        console.warn(`Currency mismatch: Thread ${threadData.notation || sourceThreadIdentifier} has ${threadCurrency} but ${currency} was requested`);
        return 0;
    }

    // Use the thread data we found
    const thread = threadData;
    const actualCurrency = threadCurrency;
    let totalAssignedInCurrentSession = 0;

    // Calculate what's already been assigned across ALL hop entries in the current session
    investigation.hops.forEach(hop => {
        hop.entries.forEach(entry => {
            // Skip the entry being edited to avoid double-counting
            if (excludeEntryId && excludeHopId && entry.id === excludeEntryId && hop.hopNumber === excludeHopId) {
                return; // Skip this entry
            }

            // Check trace, swap, and writeoff entries - all consume source threads
            if ((entry.entryType === 'trace' || entry.entryType === 'swap' || entry.entryType === 'writeoff') && parseFloat(entry.amount) > 0) {
                const entryCurrency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;

                if (entryCurrency === actualCurrency) {
                    // Check both internal ID fields and legacy fields
                    const usesThisThread =
                        // New internal ID system
                        entry.sourceThreadInternalId === internalId ||
                        // Legacy notation system
                        entry.sourceThreadId === sourceThreadIdentifier ||
                        entry.sourceThreadId === thread.notation;

                    if (usesThisThread) {
                        // Single source entry
                        totalAssignedInCurrentSession += parseFloat(entry.amount);
                    } else {
                        // Check multiple source assignments
                        const multipleIds = entry.multipleSourceInternalIds || entry.multipleSourceThreads || [];
                        const assignments = entry.individualSourceAssignments || {};

                        // Check if this thread is in multiple sources
                        if (multipleIds.includes(internalId) || multipleIds.includes(sourceThreadIdentifier) || multipleIds.includes(thread.notation)) {
                            // Look for assignment by internal ID, notation, or identifier
                            const assignedAmount = assignments[internalId] ||
                                                 assignments[sourceThreadIdentifier] ||
                                                 assignments[thread.notation] || 0;
                            totalAssignedInCurrentSession += parseFloat(assignedAmount);
                        }
                    }
                }
            }
        });
    });

    // Calculate available as total minus what's been assigned
    const availableAmount = thread.totalAmount - totalAssignedInCurrentSession;
    const displayName = thread.notation || sourceThreadIdentifier;
    console.log(`Thread ${displayName}: Total ${thread.totalAmount}, Assigned ${totalAssignedInCurrentSession}, Available ${availableAmount}`);

    return Math.max(0, availableAmount);
}

function validateThreadAssignment(sourceThreadId, requestedAmount, currency, excludeEntryId = null, excludeHopId = null) {
    const maxAmount = getMaxAssignableAmount(sourceThreadId, currency, excludeEntryId, excludeHopId);
    const amount = parseFloat(requestedAmount);
    
    if (isNaN(amount) || amount <= 0) {
        return { valid: false, error: 'Amount must be a positive number' };
    }
    
    if (amount > maxAmount) {
        // Get the actual currency from the source thread
        let actualCurrency = currency;
        if (!currency) {
            Object.entries(investigation.availableThreads || {}).forEach(([curr, threads]) => {
                if (threads[sourceThreadId]) {
                    actualCurrency = curr;
                }
            });
        }
        
        return { 
            valid: false, 
            error: `Amount ${amount.toLocaleString()} exceeds available ${maxAmount.toLocaleString()} ${actualCurrency}` 
        };
    }
    
    return { valid: true };
}

// DUPLICATE FUNCTION - Using the one at line 1760 instead which has Log Entry button and styling
/*function renderHopEntry(entry) {
    const isWriteoff = entry.entryType === 'writeoff';
    const isColdStorage = entry.entryType === 'cold_storage';
    const isTrace = entry.entryType === 'trace';
    
    // Get available source threads for ALL entry types (not just traces)
    const availableSourceThreads = getAvailableSourcesForHop(entry.hopNumber, null);    
    console.log(`Available sources for Hop ${entry.hopNumber}:`, availableSourceThreads);
    
    // Build source options properly with real-time amounts
    const sourceOptions = availableSourceThreads.map(source => {
        const dateStr = source.datetime ? 
            ` (${formatDateTimeForReport(source.datetime, source.timezone)})` : '';
        return `<option value="${source.threadId}" 
                ${entry.sourceThreadId === source.threadId ? 'selected' : ''}
                title="${source.displayText}${dateStr}">
            ${source.displayText} - ${source.availableAmount.toLocaleString()} ${source.currency} available${dateStr}
        </option>`;
    }).join('');
    
    // Determine if we should show single or multiple source selection
    const showMultipleSelection = availableSourceThreads.length > 1;
    
    // Calculate max amount for input field using real-time calculations
    let maxAmount = 0;
    if (entry.multipleSourceThreads && entry.multipleSourceThreads.length > 0) {
        // Multiple sources selected - sum them up without specifying currency
        entry.multipleSourceThreads.forEach(sourceId => {
            maxAmount += getMaxAssignableAmount(sourceId, null, entry.id, entry.hopNumber);
        });
    } else if (entry.sourceThreadId) {
        // Single source selected - don't pass currency, let the function find it
        maxAmount = getMaxAssignableAmount(entry.sourceThreadId, null, entry.id, hop.hopNumber);
    }
    
    // SOURCE SELECTION HTML - NOW AVAILABLE FOR ALL ENTRY TYPES
    let sourceSelectionHTML = '';
    if (showMultipleSelection) {
        // Multiple sources available - show checkboxes for commingling
        sourceSelectionHTML = `
            <div class="form-group">
                <label>Source Thread Selection ${isWriteoff ? '(Required for balanced accounting)' : '(Select multiple for commingling)'}</label>
                <div style="background: #f8f9fa; border: 1px solid #ddd; border-radius: 4px; padding: 10px;">
                    ${availableSourceThreads.map(source => {
                        const isSelected = entry.multipleSourceThreads && entry.multipleSourceThreads.includes(source.threadId);
                        const proposedAmount = entry.individualSourceAssignments && entry.individualSourceAssignments[source.threadId] || 0;
            
                        return `
                            <div style="margin-bottom: 8px;">
                                <!-- Source Selection Row -->
                                <div style="padding: 8px; background: white; border-radius: 3px; border: 1px solid ${isSelected ? '#3498db' : '#ddd'};">
                                    <input type="checkbox" 
                                        value="${source.threadId}" 
                                        ${isSelected ? 'checked' : ''}
                                        onchange="toggleSourceSelection(${hop.hopNumber}, ${entry.id}, '${source.threadId}')"
                                        style="margin-right: 10px; vertical-align: middle;"> 
                                    <span style="font-weight: bold; color: #2c3e50;">${source.displayText} - ${source.availableAmount.toLocaleString()} ${source.currency} available</span>
                                </div>
                    
                                <!-- Amount Input Row (only show if selected) -->
                                ${isSelected ? `
                                    <div style="margin-top: 6px; margin-left: 30px; display: flex; align-items: center; gap: 8px;">
                                        <span style="font-size: 12px; color: #666; min-width: 80px;">${isWriteoff ? 'Write off:' : 'Propose to use:'}</span>
                                        <input type="number" 
                                            step="0.01" 
                                            min="0" 
                                            max="${source.availableAmount}"
                                            value="${proposedAmount}"
                                            style="width: 120px; padding: 4px 6px; border: 1px solid #ddd; border-radius: 3px;"
                                            onchange="updateProposedAmount(${hop.hopNumber}, ${entry.id}, '${source.threadId}', this.value)"
                                            placeholder="0.00">
                                    <button type="button" 
                                            onclick="proposeMaxAmount(${hop.hopNumber}, ${entry.id}, '${source.threadId}')"
                                            style="padding: 4px 8px; font-size: 11px; background: #3498db; color: white; border: none; border-radius: 3px; cursor: pointer;">
                                        All
                                </button>
                                <span style="font-size: 11px; color: #666;">
                                    (${(source.availableAmount - proposedAmount).toLocaleString()} would remain)
                             </span>
                        </div>
                    ` : ''}
                </div>
            `;
                    }).join('')}
            
                    <!-- Assignment Summary and Action Button -->
                    ${entry.multipleSourceThreads && entry.multipleSourceThreads.length > 0 ? `
                        <div style="margin-top: 15px; padding: 15px; background: ${isWriteoff ? '#fff3cd' : '#e8f4f8'}; border: 1px solid ${isWriteoff ? '#ffc107' : '#3498db'}; border-radius: 6px;">
                            <div style="font-weight: bold; color: #2c3e50; margin-bottom: 10px;">${isWriteoff ? 'Proposed Write-off Summary:' : 'Proposed Assignment Summary:'}</div>
                            <div id="proposedSummary_${hop.hopNumber}_${entry.id}" style="margin-bottom: 15px;"></div>
                            <div style="text-align: center;">
                                <button type="button" 
                                        onclick="commitAssignmentToEntry(${hop.hopNumber}, ${entry.id})"
                                        style="padding: 10px 20px; font-size: 14px; background: ${isWriteoff ? '#e67e22' : '#27ae60'}; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold;">
                                    ${isWriteoff ? '📝 Confirm Write-off' : '🎯 Assign to Hop Entry'} ${entry.id}
                                </button>
                            </div>
                        </div>
                    ` : ''}
                </div>
            </div>
        `;
    } else {
        // Single source or no sources - use dropdown
        sourceSelectionHTML = `
            <div class="form-group">
                <label>Source Thread Selection ${isWriteoff ? '(Required for balanced accounting)' : ''}</label>
                <select id="sourceSelect_${hop.hopNumber}_${entry.id}" 
                        onchange="handleSourceSelection(${hop.hopNumber}, ${entry.id}, this.value)">
                    <option value="">Select source thread...</option>
                    ${sourceOptions}
                </select>
                ${entry.sourceThreadId ? `
                    <div style="margin-top: 8px; font-size: 11px; color: #666;">
                        <strong>Source:</strong> ${entry.sourceThreadId} (${getMaxAssignableAmount(entry.sourceThreadId, entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency).toLocaleString()} available)
                    </div>
                ` : ''}
            </div>
        `;
    }

    return `
        <div style="background: white; border: 2px solid #e8f0fe; border-radius: 8px; padding: 20px; margin-bottom: 15px;">
            <div class="trace-header">
                <div>
                    <span class="trace-notation">Entry ${entry.id} - ${entryTypes[entry.entryType]}</span>
                    ${entry.notation ? `<br><small style="color: #666;">${entry.notation}</small>` : ''}
                </div>
                <button class="btn btn-danger" onclick="removeHopEntry(${hop.hopNumber}, ${entry.id})">Remove</button>
            </div>
            
            <div class="form-group">
                <label>Entry Type</label>
                <select onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'entryType', this.value)">
                    ${Object.entries(entryTypes).map(([key, value]) => 
                        `<option value="${key}" ${entry.entryType === key ? 'selected' : ''}>${value}</option>`
                    ).join('')}
                </select>
            </div>
            
            ${sourceSelectionHTML}
            
            ${isTrace && availableSourceThreads.length > 0 ? `
            <!-- Smart Allocation Button -->
            <div class="form-group" style="text-align: center; margin: 20px 0;">
                <button type="button" 
                        class="btn btn-confirm"
                        onclick="openSmartAllocationModal(${hop.hopNumber}, ${entry.id})"
                        style="background: linear-gradient(135deg, #27ae60 0%, #219a52 100%); padding: 12px 30px;">
                    🎯 Smart Amount Allocation - Auto-Calculate Source Usage
                </button>
                <div style="font-size: 11px; color: #666; margin-top: 8px;">
                    ${availableSourceThreads.length > 1 
                        ? `You have ${availableSourceThreads.length} fund sources. This tool helps split the transaction amount across them.`
                        : `Calculate how much of the available ${availableSourceThreads[0]?.availableAmount.toLocaleString()} ${availableSourceThreads[0]?.currency} to use`
                    }
                </div>
                <div style="background: #e8f5e8; border: 1px solid #27ae60; border-radius: 4px; padding: 8px; margin-top: 8px; font-size: 11px;">
                    <strong>💡 When to use:</strong> You know the transaction amount from the blockchain, but need help determining 
                    which victim funds were used. The tool follows FIFO (First In, First Out) to match real blockchain behavior.
                </div>
            </div>
            ` : ''}
            
            <div class="form-group">
                <label>${isWriteoff ? 'Write-off Amount' : isColdStorage ? 'Cold Storage Amount' : 'New Thread Total'}</label>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="number" step="0.01" 
                           id="assignAmount_${hop.hopNumber}_${entry.id}"
                           value="${entry.amount || ''}"
                           max="${maxAmount}"
                           onchange="updateAssignmentAmount(${hop.hopNumber}, ${entry.id}, this.value)">
                    <button type="button" class="btn btn-secondary" 
                onclick="${isWriteoff ? 'assignMaxWriteoffAmount' : 'assignMaxAmount'}(${hop.hopNumber}, ${entry.id})"
                ${!isWriteoff && (!entry.sourceThreadId && (!entry.multipleSourceThreads || entry.multipleSourceThreads.length === 0)) ? 'disabled' : ''}>
                ${isWriteoff ? 'Balance ART' : 'Max'}
        </button>
                </div>
                <div style="font-size: 11px; color: #666; margin-top: 5px;">
                    Max assignable: ${maxAmount.toLocaleString()} ${entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency}
                </div>
                <div id="assignmentPreview_${hop.hopNumber}_${entry.id}" 
                     style="font-size: 12px; margin-top: 5px;"></div>
            </div>

            <div class="form-group">
                <label>Notation Builder</label>
                <div style="display: flex; align-items: center; gap: 5px; font-family: monospace; font-weight: bold;">
                    <span>V</span>
                    <input type="text" style="width: 60px; text-align: center;" 
                           placeholder="1" 
                           value="${entry.victimNumbers || ''}"
                           onchange="updateNotationField(${hop.hopNumber}, ${entry.id}, 'victims', this.value)">
                    <span>-T</span>
                    <input type="text" style="width: 80px; text-align: center;" 
                           placeholder="1,2,3" 
                           value="${entry.transactionNumbers || ''}"
                           onchange="updateNotationField(${hop.hopNumber}, ${entry.id}, 'transactions', this.value)">
                    <span>-H${entry.hopNumber}${isWriteoff ? '-WO' : isColdStorage ? '-CS' : ''}</span>
                </div>
                <div style="font-size: 12px; color: #666; margin-top: 5px;">
                    Preview: <span id="notation_preview_${hop.hopNumber}_${entry.id}" style="font-family: monospace; font-weight: bold;">${entry.notation || 'Enter V and T numbers'}</span>
                </div>
            </div>
            
            ${!isWriteoff ? `
                <div class="form-group">
                    <label>Full Notation Display</label>
                    <div id="notationPreview_${hop.hopNumber}_${entry.id}" 
                         style="font-family: monospace; padding: 10px; background: #f8f9fa; border-radius: 4px; min-height: 60px;">
                        ${entry.displayNotation || 'Complete source selection and notation to generate full display'}
                    </div>
                </div>
            ` : `
                <div class="form-group">
                    <label>Write-off Justification Display</label>
                    <div id="writeoffPreview_${hop.hopNumber}_${entry.id}" 
                         style="font-family: monospace; padding: 10px; background: #fff3cd; border-radius: 4px; min-height: 60px;">
                        ${entry.sourceThreadId ? `Writing off from: ${entry.sourceThreadId}` : 'Select source thread to track write-off'}
                    </div>
                </div>
            `}

            <div class="form-group">
                <label>Currency</label>
                <select onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'currency', this.value)">
                    <option value="USD" ${entry.currency === 'USD' ? 'selected' : ''}>US Dollar</option>
                    <option value="BTC" ${entry.currency === 'BTC' ? 'selected' : ''}>Bitcoin</option>
                    <option value="ETH" ${entry.currency === 'ETH' ? 'selected' : ''}>Ethereum</option>
                    <option value="USDT" ${entry.currency === 'USDT' ? 'selected' : ''}>Tether</option>
                    <option value="USDC" ${entry.currency === 'USDC' ? 'selected' : ''}>USD Coin</option>
                    <option value="TRX" ${entry.currency === 'TRX' ? 'selected' : ''}>TRON</option>
                    <option value="SOL" ${entry.currency === 'SOL' ? 'selected' : ''}>Solana</option>
                    <option value="ADA" ${entry.currency === 'ADA' ? 'selected' : ''}>Cardano</option>
                    <option value="DAI" ${entry.currency === 'DAI' ? 'selected' : ''}>DAI</option>
                    <option value="BNB" ${entry.currency === 'BNB' ? 'selected' : ''}>BNB</option>
                    <option value="MATIC" ${entry.currency === 'MATIC' ? 'selected' : ''}>MATIC</option>
                    <option value="AVAX" ${entry.currency === 'AVAX' ? 'selected' : ''}>AVAX</option>
                    <option value="HYPE" ${entry.currency === 'HYPE' ? 'selected' : ''}>HYPE</option>
                    <option value="MNT" ${entry.currency === 'MNT' ? 'selected' : ''}>MNT</option>
                    <option value="CUSTOM" ${entry.currency === 'CUSTOM' ? 'selected' : ''}>Custom Currency</option>
                </select>
            </div>
            
            <div class="form-group ${entry.currency === 'CUSTOM' ? '' : 'custom-currency-input'}" 
                 id="customEntryCurrency_${hop.hopNumber}_${entry.id}">
                <label>Custom Currency Symbol</label>
                <input type="text" value="${entry.customCurrency || ''}" 
                       placeholder="e.g., DOGE, SHIB"
                       onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'customCurrency', this.value)">
            </div>
            
            ${!isWriteoff && !isColdStorage ? `
                <div class="form-group">
                    <label>To Wallet Address</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <div class="wallet-autocomplete-container" style="flex: 1;">
                            <input type="text" 
                                   id="toWallet_${hop.hopNumber}_${entry.id}"
                                   value="${entry.toWallet || ''}" 
                                   placeholder="Select existing or enter new wallet address"
                                   onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'toWallet', this.value)"
                                   oninput="handleWalletAutocomplete(this, ${entry.hopNumber}, ${entry.id})"
                                   autocomplete="off"
                                   list="walletList_${hop.hopNumber}_${entry.id}"
                                   style="width: 100%;">
                            <div id="autocomplete_${hop.hopNumber}_${entry.id}" class="wallet-autocomplete-dropdown"></div>
                        </div>
                        <datalist id="walletList_${hop.hopNumber}_${entry.id}">
                            ${(investigation.universalWalletIndex || []).map(wallet => `
                                <option value="${wallet.address}">
                                    ${wallet.permanentId} - ${wallet.address.substring(0, 20)}...
                                </option>
                            `).join('')}
                        </datalist>
                        <button type="button" class="btn btn-secondary" style="padding: 6px 12px; font-size: 12px;"
                                onclick="showWalletSelector(${hop.hopNumber}, ${entry.id})">
                            📋 Browse
                        </button>
                    </div>
                    <div style="font-size: 11px; color: #666; margin-top: 5px;">
                        Type to search existing wallets or enter a new address
                    </div>
                </div>
                <div class="form-group">
                    <label>To Wallet Classification</label>
                    <select onchange="updateHopEntryWalletType(${hop.hopNumber}, ${entry.id}, this.value)">
                        <option value="">Select classification...</option>
                        ${Object.entries(walletTypes).filter(([key]) => key !== 'red').map(([key, value]) => 
                            `<option value="${key}" ${entry.toWalletType === key ? 'selected' : ''}>${value}</option>`
                        ).join('')}
                    </select>
                </div>
                <div class="form-group">
                    <label>Transaction Hash</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <input type="text" 
                               id="txHash_${hop.hopNumber}_${entry.id}"
                               value="${entry.txHash || ''}" 
                               placeholder="Blockchain transaction hash"
                               onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'txHash', this.value)"
                               style="flex: 1;">
                        <button type="button" 
                                class="btn btn-secondary" 
                                onclick="openBlockchainLookup(${hop.hopNumber}, ${entry.id})"
                                style="background: #3498db; color: white; padding: 8px 15px; font-size: 14px;">
                            Lookup
                        </button>
                    </div>
                </div>
                <div class="form-group">
                    <label>Timestamp with Timezone</label>
                    <div class="datetime-timezone">
                        <input type="datetime-local" 
                               id="timestamp_${hop.hopNumber}_${entry.id}"
                               value="${entry.timestamp || ''}" 
                               onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'timestamp', this.value)">
                        <select onchange="onTimezoneChange('timestamp_${hop.hopNumber}_${entry.id}', 'hop', ${hop.hopNumber}, ${entry.id})">
                            ${Object.entries(timezones).map(([key, value]) => 
                                `<option value="${key}" ${entry.timezone === key ? 'selected' : ''}>${value}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
            ` : ''}
            
            ${isWriteoff ? `
                <div class="form-group">
                    <label>Write-off Category</label>
                    <select onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'category', this.value)">
                        <option value="">Select category...</option>
                        ${Object.entries(writeoffCategories).map(([key, value]) => 
                            `<option value="${key}" ${entry.category === key ? 'selected' : ''}>${value}</option>`
                        ).join('')}
                    </select>
                </div>
                <div class="form-group" style="grid-column: span 2;">
                    <label>Justification</label>
                    <textarea rows="2" placeholder="Detailed explanation for abandoning this trace path..." 
                              onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'justification', this.value)">${entry.justification || ''}</textarea>
                </div>
            ` : `
                <div class="form-group" style="grid-column: span 2;">
                    <label>Notes</label>
                    <textarea rows="2" placeholder="PIFO application, convergence notes, etc." 
                              onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'notes', this.value)">${entry.notes || ''}</textarea>
                </div>
            `}
        </div>
    `;
}*/

// Enhanced Amount Assignment for Multiple Sources
function updateAssignmentAmountMultiple(hopNumber, entryId, amount) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    
    entry.amount = amount;
    
    if (entry.multipleSourceThreads && entry.multipleSourceThreads.length > 0) {
        updateMultipleSourcePreview(hopNumber, entryId);
        updateFullNotationDisplayMultiple(hopNumber, entryId);
    } else {
        updateAssignmentPreview(hopNumber, entryId);
        updateFullNotationDisplay(hopNumber, entryId);
    }
    
    saveToStorage();
}

// Enhanced Max Amount Assignment for Multiple Sources
function assignMaxAmountMultiple(hopNumber, entryId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    
    let maxAmount = 0;
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    
    if (entry.multipleSourceThreads && entry.multipleSourceThreads.length > 0) {
        // First, validate that all sources have the same currency as the entry
        const availableSources = getAvailableSourcesForHop(hop.hopNumber, null);
        const invalidSources = [];
        
        entry.multipleSourceThreads.forEach(sourceId => {
            const source = availableSources.find(s => s.threadId === sourceId);
            if (source && source.currency !== currency) {
                invalidSources.push(`${sourceId} (${source.currency})`);
            }
        });
        
        if (invalidSources.length > 0) {
            alert(`ERROR:  Cannot mix different asset types!\n\nEntry currency: ${currency}\nMismatched sources: ${invalidSources.join(', ')}\n\nPlease select only ${currency} threads or change the entry currency.`);
            return;
        }
        
        // Calculate total from multiple sources
        entry.multipleSourceThreads.forEach(sourceId => {
            maxAmount += getMaxAssignableAmount(sourceId, currency);
        });
    } else if (entry.sourceThreadId) {
        // Single source
        maxAmount = getMaxAssignableAmount(entry.sourceThreadId, currency);
    } else {
        alert('Please select source thread(s) first.');
        return;
    }
    
    entry.amount = maxAmount.toString();
    
    const amountInput = document.getElementById(`assignAmount_${hopNumber}_${entryId}`);
    if (amountInput) {
        amountInput.value = maxAmount;
    }
    
    updateAssignmentAmountMultiple(hopNumber, entryId, maxAmount);
}


function showAddEntryWizard(hopNumber) {
    console.log('showAddEntryWizard called for hopNumber:', hopNumber);

    // Prevent auto-reopening after write-off
    if (window.justCreatedWriteoff) {
        console.log('Preventing auto-reopen after write-off');
        return;
    }

    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    if (!hop) {
        console.error('Hop not found:', hopNumber);
        return;
    }
    
    const entryTypeDescriptions = {
        'trace': {
            icon: '🔍',
            description: 'Outgoing Transaction - Track where funds moved to another wallet',
            color: '#3498db'
        },
        'swap': {
            icon: '🔄',
            description: 'DEX/Asset Conversion - Funds were swapped for a different currency',
            color: '#ff9800'
        },
        'cold_storage': {
            icon: '🧊',
            description: 'Still in Wallet - Funds haven\'t moved yet (mark as cold storage)',
            color: '#00bcd4'
        }
    };
    
    const wizardHTML = `
        <div id="addEntryWizard" class="modal" style="display: block; z-index: 9998;">
            <div class="modal-content" style="max-width: 600px;">
                <div class="modal-header">
                    <h2>Add Entry - Hop ${hop.hopNumber}</h2>
                    <p>What type of entry do you want to document?</p>
                </div>
                
                <div style="padding: 20px;">
                    ${Object.entries(entryTypes).map(([key, value]) => {
                        const info = entryTypeDescriptions[key] || { icon: '📄', description: '', color: '#95a5a6' };
                        return `
                            <div onclick="selectEntryType('${hopNumber}', '${key}')"
                                 style="background: white; border: 2px solid #e8f0fe; border-radius: 8px; padding: 20px; margin-bottom: 15px; cursor: pointer; transition: all 0.2s;"
                                 onmouseover="this.style.borderColor='${info.color}'; this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.15)'"
                                 onmouseout="this.style.borderColor='#e8f0fe'; this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                                <div style="display: flex; align-items: center; gap: 15px;">
                                    <span style="font-size: 32px;">${info.icon}</span>
                                    <div style="flex: 1;">
                                        <h3 style="margin: 0; color: #2c3e50;">${value}</h3>
                                        <p style="margin: 5px 0 0 0; color: #7f8c8d; font-size: 14px;">${info.description}</p>
                                    </div>
                                    <span style="color: ${info.color}; font-size: 24px;">→</span>
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
                
                <div class="modal-footer">
                    <button class="btn btn-secondary" onclick="closeAddEntryWizard()">Cancel</button>
                </div>
            </div>
        </div>
    `;
    
    createCenteredModal('addEntryWizard', wizardHTML);
}

function selectEntryType(hopNumber, entryType) {
    console.log('selectEntryType called with:', hopNumber, entryType);
    closeAddEntryWizard();

    // Check if we should use wizards
    const wizardDisabled = localStorage.getItem('bats_hop_wizard_disabled') === 'true';
    console.log('Wizard disabled:', wizardDisabled);

    // Add a small delay to prevent race condition with modal closing
    setTimeout(() => {
        console.log('Inside setTimeout - entryType:', entryType, 'wizardDisabled:', wizardDisabled);
        if (entryType === 'trace' && !wizardDisabled) {
            // Use the existing trace wizard
            console.log('About to call showHopEntryWizard for hopNumber:', hopNumber);
            try {
                showHopEntryWizard(hopNumber);
                console.log('showHopEntryWizard called successfully');
                // Check if wizard was created
                setTimeout(() => {
                    const wizard = document.getElementById('hopEntryWizard');
                    console.log('Wizard element found:', !!wizard);
                    if (!wizard) {
                        console.error('Wizard element not found after creation');
                    }
                }, 50);
            } catch (error) {
                console.error('Error showing hop entry wizard:', error);
                alert('Error opening wizard: ' + error.message);
            }
        } else if (entryType === 'swap' || entryType === 'dex') {
            // For swaps, use a dedicated swap wizard
            console.log('Creating swap entry - showing swap wizard');
            showSwapWizard(hopNumber);
        } else {
            // For now, create other types directly
            // In the future, we could add specific wizards for each type
            console.log('Creating entry directly for type:', entryType);
            createHopEntryDirectly(hopNumber, entryType);
        }
    }, 250);
}

function closeAddEntryWizard() {
    const wizard = document.getElementById('addEntryWizard');
    if (wizard) wizard.remove();
}

function addHopEntry(hopNumber, entryType = 'trace') {
    // This function is now primarily used when wizards are disabled
    // or called from other parts of the code
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    if (!hop) return;

    // Check if hop is fully allocated (only for trace entries)
    if (entryType === 'trace') {
        const availableSources = getAvailableSourcesForHop(hopNumber, null);
        const hasAvailableFunds = availableSources.some(source => source.availableAmount > 0);

        if (!hasAvailableFunds) {
            showNotification('❌ This hop has been fully allocated. No funds remaining to trace. Please close this hop and proceed to the next hop.', 'error');
            return;
        }
    }

    // Check if wizard is disabled
    const wizardDisabled = localStorage.getItem('bats_hop_wizard_disabled') === 'true';
    
    if (entryType === 'trace' && !wizardDisabled) {
        // Show wizard for trace entries
        showHopEntryWizard(hopNumber);
    } else {
        // Direct creation for non-trace entries or when wizard is disabled
        createHopEntryDirectly(hopNumber, entryType);
    }
}

function createHopEntryDirectly(hopNumber, entryType = 'trace') {
    // Convert hopId to number to ensure type matching
    const numericHopNumber = typeof hopNumber === 'string' ? parseInt(hopNumber) : hopNumber;
    const hop = investigation.hops.find(h => h.hopNumber === numericHopNumber);
    if (!hop) {
        console.error('Hop not found in createHopEntryDirectly:', hopNumber, 'numericHopNumber:', numericHopNumber);
        return;
    }

    // Check if hop is fully allocated before creating entry (only for trace entries)
    if (entryType === 'trace') {
        const availableSources = getAvailableSourcesForHop(hopNumber, null);
        const hasAvailableFunds = availableSources.some(source => source.availableAmount > 0);

        if (!hasAvailableFunds) {
            showNotification('❌ This hop has been fully allocated. No funds remaining to trace. Please close this hop and proceed to the next hop.', 'error');
            return;
        }
    }

    // Apply Sequential Hop Rule for convergence scenarios
    let effectiveHopNumber = hop.hopNumber;
    if (entryType === 'trace' && hop.entries.length > 0) {
        // Check if this entry will have multiple source threads (convergence)
        const availableSources = getAvailableSourcesForHop(hop.hopNumber, null);
        if (availableSources.length > 1) {
            // This could be a convergence - prepare for Sequential Hop Rule
            effectiveHopNumber = hop.hopNumber; // Will be updated when sources are selected
        }
    }
    
    const entry = {
        id: hop.entries.length + 1,
        hopNumber: hopNumber,
        hopNumber: effectiveHopNumber,
        entryType: entryType,
        notation: '',
        fromWallet: '',
        fromWalletType: hop.hopNumber === 1 ? 'red' : 'black',
        fromWalletId: '',
        toWallet: '',
        toWalletType: entryType === 'cold_storage' ? 'blue' : '', // Auto-set BLUE for cold storage
        toWalletId: '',
        amount: '',
        currency: '', // No default currency - must be set from source thread
        customCurrency: '',
        txHash: '',
        timestamp: '',
        timezone: 'UTC',
        notes: '',
        category: '',
        justification: '',
        // Enhanced fields
        sourceChain: [],
        displayNotation: '',
        summaryNotation: '',
        victimNumbers: '',
        transactionNumbers: '',
        availableSourceAmount: 0,
        sourceThreadId: '',
        sourceThreadData: null,
        assignmentPercentage: 0,
        generatedNotation: '',
        isConvergence: false,
        convergenceData: null
    };
    
    // Save undo state
    saveUndoState(`Add ${entryType} entry to Hop ${hop.hopNumber}`);
    
    hop.entries.push(entry);
    
    // Store the original entry reference before sorting
    const newEntry = entry;
    
    // Sort entries by timestamp to maintain chronological order
    sortHopEntriesChronologically(hop);
    
    // Find the entry's new ID after sorting
    const sortedEntryIndex = hop.entries.indexOf(newEntry);
    const sortedEntryId = sortedEntryIndex >= 0 ? hop.entries[sortedEntryIndex].id : entry.id;
    
    // Rebuild thread index to ensure available amounts are updated
    buildAvailableThreadsIndex();
    
    renderHops();
    saveToStorage();
    
    // Check if hop is now fully accounted for
    checkHopCompletionStatus(hop);
    
    // Scroll to the newly created entry after a short delay to allow DOM update
    setTimeout(() => {
        const entryElement = document.getElementById(`entry_${hop.hopNumber}_${sortedEntryId}`);
        if (entryElement) {
            // Scroll the entry into view, centered on screen
            entryElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            
            // Add a temporary highlight effect
            entryElement.style.transition = 'background-color 0.5s ease';
            entryElement.style.backgroundColor = '#e3f2fd';
            setTimeout(() => {
                entryElement.style.backgroundColor = '';
            }, 2000);
        }
    }, 300);
}

function sortHopEntriesChronologically(hop) {
    // Sort entries by timestamp, with entries without timestamps at the end
    hop.entries.sort((a, b) => {
        // If both have timestamps, sort chronologically
        if (a.timestamp && b.timestamp) {
            return new Date(a.timestamp) - new Date(b.timestamp);
        }
        // If only one has timestamp, put the one with timestamp first
        if (a.timestamp && !b.timestamp) return -1;
        if (!a.timestamp && b.timestamp) return 1;
        // If neither has timestamp, maintain existing order
        return 0;
    });
    
    // Re-assign IDs to maintain sequential ordering
    hop.entries.forEach((entry, index) => {
        entry.id = index + 1;
    });
}

function showHopEntryWizard(hopNumber) {
    // Just redirect to openHopEntryWizard which has the correct implementation
    openHopEntryWizard(hopNumber);
}

function showHopWizardStep(step) {
    const content = document.getElementById('wizardContent');
    const wizardData = window.hopWizardData;

    // Safety check - if wizard data is lost, show error
    if (!wizardData) {
        console.error('Wizard data not available in showHopWizardStep');
        if (content) {
            content.innerHTML = `
                <div style="background: #f8d7da; border: 1px solid #f5c6cb; border-radius: 8px; padding: 20px; text-align: center;">
                    <strong>⚠️ Session Error</strong><br>
                    The wizard session was lost. Please close and restart.<br>
                    <button class="btn btn-secondary" onclick="closeHopWizard()" style="margin-top: 15px;">Close Wizard</button>
                </div>
            `;
        }
        return;
    }

    const progress = document.getElementById('wizardProgress');
    const header = document.querySelector('#hopEntryWizard .modal-header h2');
    const footerButtons = document.getElementById('wizardFooterButtons');

    // Check if footerButtons exists before manipulating it
    if (!footerButtons) {
        console.error('Footer buttons container not found');
        return;
    }

    // Restore standard buttons for steps 1 and 2
    if (step !== 3) {
        footerButtons.innerHTML = `
            <button class="btn btn-secondary" id="wizardBackBtn" onclick="hopWizardBack()" style="padding: 10px 20px;" ${step === 1 ? 'disabled' : ''}>← Back</button>
            <button class="btn btn-primary" id="wizardNextBtn" onclick="hopWizardNext()" style="padding: 10px 20px;">Next →</button>
        `;
    }

    // Get button references after recreating them
    const backBtn = document.getElementById('wizardBackBtn');
    const nextBtn = document.getElementById('wizardNextBtn');

    // Update progress
    progress.style.width = `${step * 33}%`;
    header.textContent = `🧙‍♂️ Hop Entry Wizard - Step ${step} of 3`;

    if (step === 1) {
        // Step 1: Select source threads
        const availableThreads = getAvailableSourcesForHop(wizardData.hopNumber, null);
        
        console.log('Step 1 - Available threads for hop', wizardData.hopNumber, ':', availableThreads);
        console.log('Available threads count:', availableThreads.length);
        
        const isHop1 = wizardData.hopNumber === 1;
        
        content.innerHTML = `
            <h3>Step 1: Select Source ${isHop1 ? 'RED Wallet(s)' : 'Threads'}</h3>
            ${isHop1 ? `
                <div style="background: #e3f2fd; border-left: 4px solid #2196f3; padding: 15px; margin-bottom: 20px;">
                    <strong>🎯 For Hop 1:</strong> Select the RED wallet(s) that sent funds in the first transaction after the theft.
                    <br><br>
                    These are the wallets where victim funds were initially received (your RED wallets from Step 2).
                </div>
            ` : ''}
            <p>Choose which ${isHop1 ? 'RED wallet' : 'thread'}(s) you want to trace from. You can select multiple if the transaction combines funds.</p>
            
            <div style="margin-top: 20px;">
                ${availableThreads.length > 0 ? `
                    ${availableThreads.map(thread => `
                        <div style="background: white; border: 2px solid #e8f0fe; border-radius: 8px; padding: 15px; margin-bottom: 10px;">
                            <label style="display: flex; align-items: center; cursor: pointer;">
                                <input type="checkbox"
                                       value="${thread.internalId || thread.threadId}"
                                       data-notation="${thread.threadId}"
                                       data-internal-id="${thread.internalId || thread.threadId}"
                                       onchange="updateWizardThreadSelection({notation: '${thread.threadId}', internalId: '${thread.internalId || thread.threadId}'})"
                                       ${(wizardData.selectedInternalIds || wizardData.selectedThreads || []).includes(thread.internalId || thread.threadId) ? 'checked' : ''}
                                       style="margin-right: 10px;">
                                <div>
                                    <strong>${thread.displayText}</strong><br>
                                    <span style="color: #666;">${thread.availableAmount.toLocaleString()} ${thread.currency} available</span>
                                </div>
                            </label>
                        </div>
                    `).join('')}
                ` : `
                    <div style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px; padding: 15px;">
                        <strong>⚠️ No source threads available</strong><br>
                        You need to complete previous hops or victim transactions first.
                    </div>
                `}
            </div>
        `;
        
        nextBtn.disabled = wizardData.selectedThreads.length === 0;
        nextBtn.textContent = 'Next';
        
    } else if (step === 2) {
        // Step 2: Allocate amounts

        // Apply allocation based on mode (default to PIFO if not set)
        if (wizardData.txData && Object.keys(wizardData.allocations).length === 0) {
            const txAmount = wizardData.txData.amount || 0;
            if (txAmount > 0 && wizardData.selectedThreads.length > 0) {
                // Default to PIFO mode if not specified
                if (!wizardData.allocationMode) {
                    wizardData.allocationMode = 'pifo';
                }

                // Apply allocation based on mode
                wizardData.allocations = applyPIFOAllocation(txAmount, wizardData.selectedThreads);

                // Create allocation notes
                const allocationNotes = [];
                const threads = getAvailableSourcesForHop(wizardData.hopNumber, null);
                for (const [threadId, amount] of Object.entries(wizardData.allocations)) {
                    if (amount > 0) {
                        const thread = threads.find(t => t.threadId === threadId);
                        if (thread) {
                            allocationNotes.push(`${threadId}: ${amount}/${thread.availableAmount} ${thread.currency}`);
                        }
                    }
                }

                const modeLabel = wizardData.allocationMode === 'matching' ? 'Transaction matching' : 'PIFO allocation';
                wizardData.pifoNote = `${modeLabel} applied: ${allocationNotes.join(', ')}`;
            }
        }

        content.innerHTML = `
            <h3>Step 2: Allocate Amounts</h3>
            <p>Specify how much from each selected thread will be traced in this transaction.</p>

            <div style="background: #f0f8ff; border: 1px solid #87ceeb; border-radius: 8px; padding: 15px; margin: 15px 0;">
                <div style="display: flex; align-items: center; gap: 15px; margin-bottom: 10px;">
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="radio"
                               name="allocationMode"
                               value="pifo"
                               ${wizardData.allocationMode !== 'matching' ? 'checked' : ''}
                               onchange="setAllocationMode('pifo')"
                               style="margin-right: 8px;">
                        <strong>PIFO Allocation</strong> <small style="margin-left: 5px;">(Proceeds In First Out)</small>
                    </label>
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="radio"
                               name="allocationMode"
                               value="matching"
                               ${wizardData.allocationMode === 'matching' ? 'checked' : ''}
                               onchange="setAllocationMode('matching')"
                               style="margin-right: 8px;">
                        <strong>Match Transaction</strong> <small style="margin-left: 5px;">(Exact amounts)</small>
                    </label>
                </div>
                ${wizardData.allocationMode === 'matching' && wizardData.txData && wizardData.txData.amount ? `
                    <div style="background: #fffbf0; border-left: 4px solid #ffa726; padding: 8px; margin-top: 10px;">
                        <small>Will attempt to match transaction amount: ${wizardData.txData.amount.toLocaleString()} ${wizardData.txData.currency || ''}</small>
                    </div>
                ` : ''}
            </div>

            ${wizardData.pifoNote ? `
                <div style="background: #e3f2fd; border-left: 4px solid #2196f3; padding: 10px; margin: 15px 0;">
                    <strong>📊 ${wizardData.allocationMode === 'matching' ? 'Matching Mode' : 'PIFO Applied'}:</strong> ${wizardData.pifoNote}
                    <br><small>You can adjust these amounts manually if needed.</small>
                </div>
            ` : ''}

            <div style="margin-top: 20px;">
                ${(wizardData.selectedInternalIds || wizardData.selectedThreads).map(id => {
                    const threads = getAvailableSourcesForHop(wizardData.hopNumber, null);
                    // Try to find by internal ID first, then by notation
                    const thread = threads.find(t => t.internalId === id) || threads.find(t => t.threadId === id);
                    const allocation = wizardData.allocations[id] || wizardData.allocations[thread?.threadId] || 0;

                    return `
                        <div style="background: white; border: 2px solid #e8f0fe; border-radius: 8px; padding: 15px; margin-bottom: 15px;">
                            <h4 style="margin-top: 0;">${thread.displayText}</h4>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <label style="min-width: 80px;">Amount:</label>
                                <input type="number"
                                       id="wizardAllocation_${id}"
                                       step="${getCurrencyStep(thread.currency)}"
                                       min="0"
                                       max="${thread.availableAmount}"
                                       value="${allocation}"
                                       onchange="updateWizardAllocation('${id}', this.value)"
                                       style="width: 150px; padding: 8px;">
                                <span>${thread.currency}</span>
                                <button class="btn btn-sm btn-primary"
                                        onclick="setWizardMaxAllocation('${id}', ${thread.availableAmount})">
                                    Max (${thread.availableAmount.toLocaleString()})
                                </button>
                            </div>
                            <div style="margin-top: 8px; font-size: 12px; color: #666;">
                                ${allocation > 0 ? `${(thread.availableAmount - allocation).toLocaleString()} ${thread.currency} will remain` : ''}
                            </div>
                        </div>
                    `;
                }).join('')}

                <div style="margin-top: 20px; padding: 15px; background: #e8f4f8; border-radius: 8px;">
                    <strong>Total to trace:</strong>
                    <span id="wizardTotalAmount">0</span>
                </div>

                <div style="margin-top: 15px;">
                    <button class="btn btn-secondary" onclick="applyPIFOToWizard()" style="padding: 8px 15px;">
                        🔄 Re-apply PIFO Allocation
                    </button>
                </div>
            </div>
        `;
        
        updateWizardTotal();
        const hasAllocations = Object.values(wizardData.allocations).some(v => v > 0);
        nextBtn.disabled = !hasAllocations;
        nextBtn.textContent = 'Next';
        
    } else if (step === 3) {
        // Step 3: Transaction details
        console.log('Showing hop wizard step 3 with write-off option');
        const isHop1 = wizardData.hopNumber === 1;

        content.innerHTML = `
            <h3>Step 3: Transaction Details</h3>
            ${window.expectingSwapEntry ? `
                <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                    <h4 style="margin-top: 0; color: #e65100;">🔄 DEX/Swap Entry Mode</h4>
                    <p style="margin: 5px 0;">Enter the transaction hash for the currency conversion (e.g., USDC → USDT at DEX).</p>
                    <ul style="margin: 10px 0; padding-left: 20px;">
                        <li>This documents the asset conversion without incrementing the hop number</li>
                        <li>The thread will continue with the new currency</li>
                        <li>DEX wallet will be marked as BROWN (asset conversion)</li>
                    </ul>
                </div>
            ` : isHop1 ? `
                <div style="background: #e8f5e9; border-left: 4px solid #4caf50; padding: 15px; margin-bottom: 20px;">
                    <strong>🎯 For Hop 1:</strong> Enter the transaction where funds LEFT the RED wallet(s).
                    <br><br>
                    This is the FIRST movement of stolen funds after the initial theft.
                </div>
            ` : ''}
            <p>Enter the transaction hash showing where the funds went:</p>
            
            <div style="margin: 20px 0;">
                <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                    <button class="btn ${wizardData.entryMode === 'lookup' ? 'btn-primary' : 'btn-secondary'}" 
                            onclick="setWizardEntryMode('lookup')" style="flex: 1;">
                        🔍 API Lookup
                    </button>
                    <button class="btn ${wizardData.entryMode === 'manual' ? 'btn-primary' : 'btn-secondary'}" 
                            onclick="setWizardEntryMode('manual')" style="flex: 1;">
                        ✏️ Manual Entry
                    </button>
                </div>
                
                ${wizardData.entryMode === 'lookup' ? `
                    <div style="background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%); padding: 20px; border-radius: 8px; border: 2px solid #2196f3;">
                        <label style="font-weight: bold; color: #0d47a1;">Transaction Hash:</label>
                        <div style="display: flex; gap: 10px; margin-top: 10px;">
                            <input type="text"
                                   id="wizardTxHash"
                                   placeholder="Paste transaction hash here"
                                   value="${wizardData.txHash || ''}"
                                   onchange="window.hopWizardData.txHash = this.value; updateStep3Buttons();"
                                   style="flex: 1; padding: 12px; font-size: 16px;">
                            <button class="btn btn-primary" onclick="lookupWizardTransaction()">
                                🔍 Lookup
                            </button>
                        </div>

                        <div class="form-group" style="margin-top: 15px;">
                            <label style="font-weight: bold; color: #0d47a1;">Notes (Optional):</label>
                            <textarea id="wizardNotesLookup"
                                      rows="3"
                                      placeholder="PIFO application, convergence notes, special circumstances, etc."
                                      onchange="updateWizardManualData('notes', this.value)"
                                      style="width: 100%; padding: 8px; margin-top: 5px;">${wizardData.manualData?.notes || ''}</textarea>
                            <small style="color: #555; display: block; margin-top: 5px;">
                                💡 Document any special handling, PIFO applications, or investigative notes here
                            </small>
                        </div>
                    </div>
                ` : `
                    <div style="background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%); padding: 20px; border-radius: 8px; border: 2px solid #ff9800;">
                        <h4 style="margin-top: 0; color: #e65100;">Manual Transaction Entry</h4>
                        
                        <div class="form-group">
                            <label>Transaction Hash:</label>
                            <input type="text" 
                                   id="wizardTxHashManual"
                                   placeholder="Enter transaction hash"
                                   value="${wizardData.txHash || ''}"
                                   onchange="window.hopWizardData.txHash = this.value; if(typeof checkWizardButtonState === 'function') checkWizardButtonState();"
                                   style="width: 100%;">
                        </div>
                        
                        <div class="form-group">
                            <label>From Wallet (Auto-filled from source):</label>
                            <div style="background: #f5f5f5; padding: 10px; border-radius: 4px; border: 1px solid #ddd;">
                                ${(() => {
                                    // Get the source wallet address from selected threads
                                    if (wizardData.selectedThreads.length > 0) {
                                        const threads = getAvailableSourcesForHop(wizardData.hopNumber, null);
                                        const sourceWallets = wizardData.selectedThreads.map(threadId => {
                                            const thread = threads.find(t => t.threadId === threadId);
                                            return thread ? `${thread.displayText}: ${thread.sourceWallet}` : 'Unknown';
                                        });
                                        return sourceWallets.join('<br>');
                                    }
                                    return 'No source thread selected';
                                })()}
                            </div>
                        </div>
                        
                        <div class="form-group">
                            <label>To Wallet:</label>
                            <input type="text" 
                                   id="wizardToWallet"
                                   placeholder="Enter receiving wallet address"
                                   value="${wizardData.manualData?.toWallet || ''}"
                                   onchange="updateWizardManualData('toWallet', this.value)"
                                   style="width: 100%;">
                        </div>
                        
                        <div class="form-group">
                            <label>Timestamp:</label>
                            <input type="datetime-local" 
                                   id="wizardTimestamp"
                                   value="${wizardData.manualData?.timestamp || ''}"
                                   onchange="updateWizardManualData('timestamp', this.value)"
                                   style="width: 100%;">
                        </div>
                        
                        <div class="form-group">
                            <label>Wallet Type (can be updated later):</label>
                            <select id="wizardWalletType"
                                    onchange="updateWizardManualData('walletType', this.value)"
                                    style="width: 100%;">
                                <option value="black" ${wizardData.manualData?.walletType === 'black' ? 'selected' : ''}>⚫ BLACK - Default Intermediary</option>
                                <option value="yellow" ${wizardData.manualData?.walletType === 'yellow' ? 'selected' : ''}>🟡 YELLOW - Hub (Convergence)</option>
                                <option value="pink" ${wizardData.manualData?.walletType === 'pink' ? 'selected' : ''}>🌸 PINK - Dividend/Deception</option>
                                <option value="orange" ${wizardData.manualData?.walletType === 'orange' ? 'selected' : ''}>🟠 ORANGE - Bitcoin Change</option>
                                <option value="brown" ${wizardData.manualData?.walletType === 'brown' ? 'selected' : ''}>🟤 BROWN - Asset Conversion</option>
                                <option value="blue" ${wizardData.manualData?.walletType === 'blue' ? 'selected' : ''}>🔵 BLUE - Cold Storage</option>
                                <option value="purple" ${wizardData.manualData?.walletType === 'purple' ? 'selected' : ''}>🟣 PURPLE - Exchange Deposit</option>
                                <option value="gray" ${wizardData.manualData?.walletType === 'gray' ? 'selected' : ''}>⚪ GRAY - Obfuscated/Diluted</option>
                                <option value="green" ${wizardData.manualData?.walletType === 'green' ? 'selected' : ''}>🟢 GREEN - Victim Owned</option>
                            </select>
                            <small style="color: #666; display: block; margin-top: 5px;">
                                💡 Tip: BLACK is the default for intermediary wallets. Update classification as patterns emerge (e.g., YELLOW for convergence hubs, PURPLE for exchanges).
                            </small>
                        </div>

                        <div class="form-group">
                            <label>Notes (Optional):</label>
                            <textarea id="wizardNotes"
                                      rows="3"
                                      placeholder="PIFO application, convergence notes, special circumstances, etc."
                                      onchange="updateWizardManualData('notes', this.value)"
                                      style="width: 100%; padding: 8px;">${wizardData.manualData?.notes || ''}</textarea>
                            <small style="color: #666; display: block; margin-top: 5px;">
                                💡 Document any special handling, PIFO applications, or investigative notes here
                            </small>
                        </div>
                    </div>
                `}
                
                <div id="wizardTxResult" style="margin-top: 20px;">
                    <!-- Transaction details will appear here -->
                </div>

                <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                    <h4 style="margin-top: 0;">Summary</h4>
                    <div style="font-size: 14px; line-height: 1.6;">
                        ${(wizardData.selectedInternalIds || wizardData.selectedThreads).map(id => {
                            const threads = getAvailableSourcesForHop(wizardData.hopNumber, null);
                            // Try to find by internal ID first, then by notation
                            const thread = threads.find(t => t.internalId === id) || threads.find(t => t.threadId === id);
                            const allocation = wizardData.allocations[id] || wizardData.allocations[thread?.threadId] || 0;
                            return thread ? `<div><strong>${thread.displayText}:</strong> ${allocation.toLocaleString()} ${thread.currency}</div>` : '';
                        }).join('')}
                    </div>
                </div>
            </div>
        `;
        
        // Replace the footer buttons for Step 3
        const footerButtons = document.getElementById('wizardFooterButtons');

        // Check if required data is available
        console.log('Checking required data - txHash:', wizardData.txHash, 'entryMode:', wizardData.entryMode);
        let hasRequiredData = false;
        if (wizardData.entryMode === 'manual') {
            hasRequiredData = wizardData.txHash && wizardData.manualData?.toWallet;
        } else {
            hasRequiredData = !!wizardData.txHash;
        }
        console.log('hasRequiredData:', hasRequiredData);

        // Clear and recreate buttons with proper event listeners
        footerButtons.innerHTML = '';

        // Back button
        const backBtn = document.createElement('button');
        backBtn.className = 'btn btn-secondary';
        backBtn.id = 'wizardBackBtn';
        backBtn.textContent = '← Back';
        backBtn.style.cssText = 'padding: 10px 20px;';
        backBtn.addEventListener('click', function() {
            console.log('Back button clicked via addEventListener');
            window.hopWizardBack();
        });
        footerButtons.appendChild(backBtn);
        console.log('Back button added to Step 3');

        // Log Entry button
        const logEntryBtn = document.createElement('button');
        logEntryBtn.className = 'btn btn-primary';
        logEntryBtn.textContent = '✅ Log Entry';
        logEntryBtn.style.cssText = 'padding: 10px 20px;';
        logEntryBtn.disabled = !hasRequiredData;
        logEntryBtn.addEventListener('click', function() {
            console.log('Log Entry button clicked via addEventListener');
            console.log('Current wizard step:', wizardData.step);
            console.log('Calling hopWizardNext...');
            // Call the global function directly
            window.hopWizardNext();
        });
        footerButtons.appendChild(logEntryBtn);
        console.log('Log Entry button added, disabled:', logEntryBtn.disabled);

        // Log Write-off button (gray with red border)
        const writeoffBtn = document.createElement('button');
        writeoffBtn.className = 'btn btn-secondary';
        writeoffBtn.textContent = '🚫 Log Write-off';
        writeoffBtn.style.cssText = 'padding: 10px 20px; background: #9e9e9e; color: white; border: 2px solid #dc3545;';
        writeoffBtn.disabled = !hasRequiredData;
        writeoffBtn.addEventListener('click', function() {
            console.log('Write-off button clicked via addEventListener');
            // Call the global function directly
            window.showWriteoffConfirmation();
        });
        footerButtons.appendChild(writeoffBtn);
        console.log('Write-off button added, disabled:', writeoffBtn.disabled);

        // Store button references globally for updating
        window.step3LogEntryBtn = logEntryBtn;
        window.step3WriteoffBtn = writeoffBtn;
    }

    wizardData.step = step;
    wizardData.currentStep = step; // Set both for compatibility
}

window.hopWizardNext = function() {
    console.log('hopWizardNext called');
    const wizardData = window.hopWizardData;

    if (!wizardData) {
        console.error('No wizard data found');
        return;
    }

    // Normal progression through steps
    if (wizardData.step === 3) {
        // From step 3, create the entry
        if (wizardData.txHash) {
            // If we have multipleTransfers but no selectedTransfers, select all by default
            if (wizardData.txData?.multipleTransfers && !wizardData.selectedTransfers) {
                console.log('Auto-selecting all transfers for multi-transfer transaction');
                wizardData.selectedTransfers = wizardData.txData.transfers.map((_, index) => index);
            }
            createHopEntryFromWizard();
            // Don't proceed to step 4 or create any additional entries
            return;
        } else {
            alert('Please enter a transaction hash before proceeding.');
        }
    } else {
        wizardData.step = wizardData.step + 1;
        showHopWizardStep(wizardData.step);
    }
}

window.hopWizardBack = function() {
    console.log('hopWizardBack called');
    const wizardData = window.hopWizardData;
    if (wizardData && wizardData.step > 1) {
        wizardData.step = wizardData.step - 1;
        showHopWizardStep(wizardData.step);
    }
}

// Update Step 3 buttons when txHash changes
window.updateStep3Buttons = function() {
    const wizardData = window.hopWizardData;
    if (!wizardData) return;

    console.log('Updating Step 3 buttons, txHash:', wizardData.txHash, 'step:', wizardData.step);

    // Use stored button references or find them
    const logEntryBtn = window.step3LogEntryBtn || document.querySelector('#wizardFooterButtons button:nth-child(2)');
    const writeoffBtn = window.step3WriteoffBtn || document.querySelector('#wizardFooterButtons button:nth-child(3)');

    // Check if we have required data - we need both txHash and txData
    let hasRequiredData = false;
    if (wizardData.entryMode === 'manual') {
        hasRequiredData = wizardData.txHash && wizardData.manualData?.toWallet;
    } else {
        // For lookup mode, we need both txHash and successful txData
        hasRequiredData = !!(wizardData.txHash && wizardData.txData);
    }

    console.log('Updating buttons - hasRequiredData:', hasRequiredData, 'txData exists:', !!wizardData.txData);

    // Enable/disable buttons
    if (logEntryBtn) {
        logEntryBtn.disabled = !hasRequiredData;
        console.log('Log Entry button disabled:', logEntryBtn.disabled);
    }
    if (writeoffBtn) {
        writeoffBtn.disabled = !hasRequiredData;
        console.log('Write-off button disabled:', writeoffBtn.disabled);
    }
}

window.showWriteoffConfirmation = function() {
    console.log('showWriteoffConfirmation called');
    const wizardData = window.hopWizardData;

    // Use the actual transaction amount, not allocations
    const actualTxAmount = wizardData.txData ? parseFloat(wizardData.txData.amount) : 0;
    const totalAmount = actualTxAmount > 0 ? actualTxAmount : Object.values(wizardData.allocations).reduce((sum, val) => sum + val, 0);

    // Get currency from first thread
    const threads = getAvailableSourcesForHop(wizardData.hopNumber, null);
    const firstThreadId = wizardData.selectedThreads[0];
    const thread = threads.find(t => t.threadId === firstThreadId);
    const currency = thread ? thread.currency : 'USD';

    // Create confirmation dialog
    const modal = document.createElement('div');
    modal.className = 'modal show';
    modal.id = 'writeoffConfirmationModal';
    modal.innerHTML = `
        <div class="modal-content" style="max-width: 500px;">
            <div class="modal-header" style="background: #ff9800; color: white;">
                <h2>🚫 Confirm Write-off</h2>
            </div>

            <div class="modal-body" style="padding: 20px;">
                <div style="background: #fff3cd; border-left: 4px solid #ffc107; padding: 15px; margin-bottom: 20px;">
                    <strong>⚠️ Write-off Confirmation</strong><br>
                    You are about to write off <strong>${totalAmount.toLocaleString()} ${currency}</strong>
                </div>

                <p><strong>This action will:</strong></p>
                <ul style="margin: 10px 0; padding-left: 20px;">
                    <li>Record the transaction hash: <code>${wizardData.txHash || 'Not provided'}</code></li>
                    <li>Document ${totalAmount.toLocaleString()} ${currency} as unrecoverable</li>
                    <li>Reduce the source thread by this amount</li>
                    <li>NOT create a new thread for further tracking</li>
                    <li>Mark the entry with "-WO" suffix</li>
                </ul>

                <div style="margin-top: 20px;">
                    <label style="font-weight: bold;">Write-off Category:</label>
                    <select id="confirmWriteoffCategory"
                            style="width: 100%; padding: 8px; margin-top: 5px;">
                        <option value="minimal_amount">Minimal Amount - Not worth tracking</option>
                        <option value="operational">Operational - Network fees/costs</option>
                        <option value="untraceable">Untraceable - Lost trail</option>
                        <option value="mixer">Mixer/Obfuscation Service</option>
                        <option value="scam_fee">Scam Fee - Paid to accomplices</option>
                        <option value="other">Other - See notes</option>
                    </select>
                </div>

                <div style="margin-top: 15px;">
                    <label style="font-weight: bold;">Justification Notes (Optional):</label>
                    <textarea id="confirmWriteoffNotes"
                              rows="3"
                              placeholder="Additional justification or notes..."
                              style="width: 100%; padding: 8px; margin-top: 5px;"></textarea>
                </div>
            </div>

            <div class="modal-footer" style="display: flex; justify-content: space-between; padding: 15px;">
                <button class="btn btn-secondary"
                        onclick="document.getElementById('writeoffConfirmationModal').remove()">
                    Cancel
                </button>
                <button class="btn btn-warning"
                        style="background: #ff9800; color: white; border: none;"
                        onclick="confirmWriteoff()">
                    🚫 Confirm Write-off
                </button>
            </div>
        </div>
    `;

    document.body.appendChild(modal);
}

window.confirmWriteoff = function() {
    // Check if wizard data exists
    if (!window.hopWizardData) {
        console.error('Wizard data lost - cannot confirm write-off');
        // Remove all modals to clean up
        document.querySelectorAll('.modal').forEach(m => m.remove());
        return;
    }

    // Get the write-off details from the confirmation dialog
    const category = document.getElementById('confirmWriteoffCategory').value;
    const notes = document.getElementById('confirmWriteoffNotes').value;

    // Store in wizard data
    window.hopWizardData.isWriteoff = true;
    window.hopWizardData.writeoffCategory = category;
    window.hopWizardData.writeoffNotes = notes;

    // Remove ONLY the confirmation modal
    const confirmModal = document.getElementById('writeoffConfirmationModal');
    if (confirmModal) {
        confirmModal.remove();
    } else {
        console.error('Confirmation modal not found - trying to clean up');
        // Fallback: remove the last modal
        const modals = document.querySelectorAll('.modal');
        if (modals.length > 1) {
            modals[modals.length - 1].remove();
        }
    }

    // Create the write-off entry
    createWriteoffEntryFromWizard();
}

function closeHopWizard() {
    console.log('closeHopWizard called');

    // Try multiple methods to find and remove the wizard
    const wizardSelectors = [
        '#hopEntryWizard',
        '.modal#hopEntryWizard',
        '[id="hopEntryWizard"]',
        '.modal.show'  // Fallback to any visible modal
    ];

    let removed = false;
    for (const selector of wizardSelectors) {
        const wizards = document.querySelectorAll(selector);
        wizards.forEach(wizard => {
            // Check if it's the hop wizard (by ID or by checking content)
            if (wizard.id === 'hopEntryWizard' ||
                (wizard.querySelector && wizard.querySelector('h2') &&
                 wizard.querySelector('h2').textContent.includes('Add Trace Entry'))) {
                console.log(`Removing wizard found with selector: ${selector}`);
                wizard.remove();
                removed = true;
            }
        });
        if (removed) break;
    }

    if (!removed) {
        console.log('Wizard not found, forcing removal of all wizard modals');
        // Force remove any element with hopEntryWizard ID
        const allElements = document.getElementsByTagName('*');
        for (let elem of allElements) {
            if (elem.id === 'hopEntryWizard') {
                console.log('Force removing element with hopEntryWizard ID');
                elem.remove();
                removed = true;
                break;
            }
        }
    }

    // Clear all wizard data
    window.hopWizardData = null;
    window.expectingSwapEntry = false;
    window.currentWizardData = null;
    window.swapWizardData = null;

    console.log('closeHopWizard completed, removed:', removed);
}

// Ensure the function is globally accessible for inline onclick handlers
window.closeHopWizard = closeHopWizard;

// Dedicated swap wizard for more flexibility
function showSwapWizard(hopNumber) {
    console.log('showSwapWizard called with hopNumber:', hopNumber, 'type:', typeof hopNumber);

    // Convert to number if it's a string
    let numericHopNumber = hopNumber;
    if (typeof hopNumber === 'string') {
        numericHopNumber = parseInt(hopNumber);
        console.log('Converted to number:', numericHopNumber);
    }

    console.log('Available hops:', investigation.hops.map(h => ({ id: h.id, hopNumber: h.hopNumber, type: typeof h.id })));

    // Try to find the hop
    let hop = investigation.hops.find(h => h.hopNumber === numericHopNumber);

    // If not found by ID, try to find by hop number (fallback)
    if (!hop && typeof numericHopNumber === 'number' && numericHopNumber <= 10) {
        // If hop number looks like a small value, try to find by hopNumber
        hop = investigation.hops.find(h => h.hopNumber === numericHopNumber);
        if (hop) {
            console.log('Found hop by hopNumber instead of ID');
        }
    }

    if (!hop) {
        console.error('Hop not found for swap wizard:', numericHopNumber);
        console.error('Looking for hop with number:', numericHopNumber);
        console.error('Available hop IDs:', investigation.hops.map(h => h.id));
        alert('Error: Could not find the hop. Please close this wizard and try again.');
        return;
    }

    console.log('Initializing swap wizard for hop:', hop);

    // Initialize swap wizard data
    // Store the hop for reference, but swap wizard primarily works with source threads
    window.swapWizardData = {
        hop: hop,  // Store the whole hop object instead of just ID
        hopNumber: hop.hopNumber,
        selectedThreads: [],
        selectedInternalIds: [],  // Track internal IDs for dual-layer support
        threadAmounts: {}, // Track partial amounts for each thread
        inputAmount: 0,
        inputCurrency: '',
        outputAmount: 0,
        outputCurrency: '',
        swapService: '',
        providerName: '', // Optional provider name (Uniswap, Binance, etc.)
        swapType: 'dex', // 'dex' or 'cex' (centralized exchange)
        txHash: '',
        notes: '',
        step: 1
    };

    // Get available threads
    const availableThreads = getAvailableSourcesForHop(hop.hopNumber, null);

    const wizardHTML = `
        <div id="swapWizard" class="modal" style="display: block; z-index: 10000;">
            <div class="modal-content" style="max-width: 700px; max-height: 90vh; overflow-y: auto;">
                <div class="modal-header" style="background: linear-gradient(135deg, #ffc107 0%, #ff9800 100%);">
                    <h2 style="color: white;">🔄 Asset Swap/Conversion - Hop ${hop.hopNumber}</h2>
                    <button onclick="closeSwapWizard()" class="close-btn" style="color: white;">×</button>
                </div>

                <div id="swapWizardContent" style="padding: 20px;">
                    <!-- Content will be populated by showSwapWizardStep -->
                </div>

                <div style="padding: 20px; border-top: 1px solid #e0e0e0; display: flex; justify-content: space-between;">
                    <button class="btn btn-secondary" id="swapBackBtn" onclick="swapWizardBack()" style="display: none;">Back</button>
                    <button class="btn btn-primary" id="swapNextBtn" onclick="swapWizardNext()">Next</button>
                </div>
            </div>
        </div>
    `;

    console.log('Creating swap wizard modal');
    createCenteredModal('swapWizard', wizardHTML);

    // Ensure modal is visible
    const swapModal = document.getElementById('swapWizard');
    if (swapModal) {
        console.log('Swap wizard modal created successfully');
        swapModal.style.display = 'block';
        swapModal.classList.add('show');
    } else {
        console.error('Failed to create swap wizard modal');
    }

    showSwapWizardStep(1);
}

function showSwapWizardStep(step) {
    console.log('Showing swap wizard step:', step);
    const content = document.getElementById('swapWizardContent');
    const backBtn = document.getElementById('swapBackBtn');
    const nextBtn = document.getElementById('swapNextBtn');
    const wizardData = window.swapWizardData;

    if (!content || !wizardData) {
        console.error('Missing swap wizard elements or data');
        return;
    }

    backBtn.style.display = step > 1 ? 'inline-block' : 'none';

    if (step === 1) {
        // Step 1: Select source threads
        const allThreads = getAvailableSourcesForHop(wizardData.hopNumber, null);

        // CRITICAL: Filter to only show threads that actually have availability
        const availableThreads = allThreads.filter(thread => thread.availableAmount > 0);

        // Log for debugging
        console.log('Swap wizard - All threads:', allThreads);
        console.log('Swap wizard - Available threads (>0 amount):', availableThreads);

        content.innerHTML = `
            <h3>Step 1: Select Source Threads</h3>
            <p>Select the thread(s) and amounts to swap:</p>

            ${availableThreads.length === 0 ? `
                <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 20px; text-align: center; margin: 20px 0;">
                    <p style="margin: 0; color: #856404; font-weight: bold;">⚠️ No threads available for swapping</p>
                    <p style="margin: 10px 0 0 0; color: #856404;">All threads have been fully assigned. Please check your previous entries.</p>
                </div>
            ` : `
            <div style="max-height: 400px; overflow-y: auto; border: 1px solid #ddd; border-radius: 8px; padding: 10px; margin: 20px 0;">
                ${availableThreads.map(thread => {
                    const internalId = thread.internalId || thread.threadId;
                    const isSelected = (wizardData.selectedInternalIds || wizardData.selectedThreads || []).includes(internalId);
                    const threadAmount = wizardData.threadAmounts[internalId] || thread.availableAmount;
                    return `
                    <div style="padding: 12px; margin: 8px 0; background: white; border: 2px solid ${isSelected ? '#4caf50' : '#e0e0e0'}; border-radius: 8px; transition: all 0.3s;">
                        <div style="display: flex; align-items: center; gap: 15px;">
                            <input type="checkbox"
                                   id="swap_thread_${thread.internalId || thread.threadId}"
                                   data-internal-id="${thread.internalId || thread.threadId}"
                                   data-notation="${thread.threadId}"
                                   ${isSelected ? 'checked' : ''}
                                   onchange="toggleSwapThread({notation: '${thread.threadId}', internalId: '${thread.internalId || thread.threadId}'})"
                                   style="width: 20px; height: 20px; cursor: pointer;">

                            <div style="flex: 1;">
                                <label for="swap_thread_${thread.threadId}" style="cursor: pointer; display: block;">
                                    <strong>${thread.displayText}</strong>
                                    <div style="font-size: 12px; color: #666; margin-top: 4px;">
                                        From: ${thread.sourceWallet ? thread.sourceWallet.substring(0, 10) + '...' : 'Unknown'}
                                    </div>
                                </label>
                            </div>

                            <div style="text-align: right; min-width: 200px;">
                                <div style="margin-bottom: 5px;">
                                    <strong>Available: ${thread.availableAmount.toLocaleString()} ${thread.currency}</strong>
                                </div>
                                ${isSelected ? `
                                    <div style="display: flex; align-items: center; gap: 5px;">
                                        <label style="font-size: 12px;">Amount:</label>
                                        <input type="number"
                                               id="swap_amount_${thread.threadId}"
                                               value="${threadAmount}"
                                               min="0"
                                               max="${thread.availableAmount}"
                                               step="0.000001"
                                               onchange="updateSwapThreadAmount('${thread.threadId}', this.value, ${thread.availableAmount})"
                                               style="width: 120px; padding: 4px; font-size: 12px;">
                                        <button onclick="setMaxSwapAmount('${thread.threadId}', ${thread.availableAmount})"
                                                class="btn btn-sm" style="padding: 2px 8px; font-size: 11px;">Max</button>
                                    </div>
                                ` : ''}
                            </div>
                        </div>
                    </div>
                `;}).join('')}
            </div>
            `}

            <div style="background: #f0f8ff; padding: 15px; border-radius: 8px; margin-top: 20px;">
                <strong>ℹ️ Partial Swaps:</strong> You can swap partial amounts from each thread.
                The remaining balance will stay in the original thread.
            </div>
        `;

        nextBtn.disabled = wizardData.selectedThreads.length === 0;
        nextBtn.textContent = 'Next';

    } else if (step === 2) {
        // Step 2: Define swap details
        const selectedThreads = wizardData.selectedThreads.map(id =>
            getAvailableSourcesForHop(wizardData.hopNumber, null).find(t => t.threadId === id)
        );

        // Auto-calculate input totals by currency using partial amounts
        const inputByCurrency = {};
        selectedThreads.forEach(thread => {
            const swapAmount = wizardData.threadAmounts[thread.threadId] || thread.availableAmount;
            if (!inputByCurrency[thread.currency]) {
                inputByCurrency[thread.currency] = 0;
            }
            inputByCurrency[thread.currency] += swapAmount;
        });

        content.innerHTML = `
            <h3>Step 2: Swap Details</h3>

            <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 15px; margin-bottom: 20px;">
                <h4 style="margin-top: 0;">Input Assets (Being Swapped)</h4>
                ${Object.entries(inputByCurrency).map(([currency, amount]) => `
                    <div style="margin: 10px 0; padding: 10px; background: white; border-radius: 4px;">
                        <strong>${amount.toLocaleString()} ${currency}</strong>
                    </div>
                `).join('')}
            </div>

            <div style="margin: 20px 0;">
                <label style="display: block; margin-bottom: 10px;">Swap Service Type:</label>
                <div style="display: flex; gap: 10px;">
                    <button class="btn ${wizardData.swapType === 'dex' ? 'btn-primary' : 'btn-secondary'}"
                            onclick="setSwapType('dex')" style="flex: 1;">
                        🔄 DEX (On-chain)
                    </button>
                    <button class="btn ${wizardData.swapType === 'cex' ? 'btn-primary' : 'btn-secondary'}"
                            onclick="setSwapType('cex')" style="flex: 1;">
                        🏦 CEX (Off-chain)
                    </button>
                </div>
            </div>

            <div style="margin: 20px 0;">
                <label>Transaction Hash:</label>
                <div style="display: flex; gap: 10px; margin-top: 5px;">
                    <input type="text" id="swapTxHash"
                           placeholder="Transaction hash"
                           value="${wizardData.txHash}"
                           onchange="window.swapWizardData.txHash = this.value"
                           style="flex: 1; padding: 10px;">
                    <button class="btn btn-primary" onclick="lookupSwapTransaction()"
                            ${wizardData.swapType === 'cex' ? 'disabled title="Lookup not available for CEX swaps"' : ''}>
                        🔍 Lookup & Auto-fill
                    </button>
                </div>
                <div id="inputInfo" style="margin-top: 10px; color: #666;"></div>
                <small style="color: #666;">
                    ${wizardData.swapType === 'dex' ?
                        '💡 Paste transaction hash to automatically extract swap amounts' :
                        '💡 Manual entry required for centralized exchange swaps'}
                </small>
            </div>

            <div style="margin: 20px 0;">
                <label>Swap Service ${wizardData.swapType === 'dex' ? 'Address' : 'Name'}:</label>
                <input type="text" id="swapService"
                       placeholder="${wizardData.swapType === 'dex' ? 'DEX contract address (e.g., 0x...)' : 'Exchange name (e.g., Binance, Coinbase)'}"
                       value="${wizardData.swapService}"
                       onchange="window.swapWizardData.swapService = this.value"
                       style="width: 100%; padding: 10px; margin-top: 5px;">
            </div>

            <div style="margin: 20px 0;">
                <label>Service Provider Name (Optional):</label>
                <input type="text" id="swapProviderName"
                       placeholder="${wizardData.swapType === 'dex' ? 'Uniswap, SushiSwap, PancakeSwap, etc.' : 'Trading desk, OTC provider, etc.'}"
                       value="${wizardData.providerName || ''}"
                       onchange="window.swapWizardData.providerName = this.value"
                       style="width: 100%; padding: 10px; margin-top: 5px;">
                <small style="color: #666;">Optional: Name of the DEX protocol or exchange for documentation</small>
            </div>

            <div style="background: #e8f5e9; border: 2px solid #4caf50; border-radius: 8px; padding: 15px; margin-top: 20px;">
                <h4 style="margin-top: 0;">Output Asset (Received Back)</h4>

                <div style="display: flex; gap: 10px; margin-bottom: 15px;">
                    <div style="flex: 1;">
                        <label>Amount Received:</label>
                        <input type="number" id="outputAmount"
                               step="0.000001"
                               placeholder="0.00"
                               value="${wizardData.outputAmount || ''}"
                               onchange="window.swapWizardData.outputAmount = parseFloat(this.value) || 0"
                               style="width: 100%; padding: 10px; margin-top: 5px;">
                    </div>
                    <div style="flex: 1;">
                        <label>Currency Received:</label>
                        <input type="text" id="outputCurrency"
                               placeholder="USDT, ETH, etc."
                               value="${wizardData.outputCurrency}"
                               onchange="window.swapWizardData.outputCurrency = this.value.toUpperCase()"
                               style="width: 100%; padding: 10px; margin-top: 5px;">
                    </div>
                </div>

                <small style="color: #666;">
                    💡 Enter the exact amount and currency returned to the sender's control after the swap
                </small>
            </div>

            <div style="margin-top: 20px;">
                <label>Notes:</label>
                <textarea id="swapNotes"
                          rows="3"
                          placeholder="Exchange records, swap rates, additional details..."
                          onchange="window.swapWizardData.notes = this.value"
                          style="width: 100%; padding: 10px; margin-top: 5px;">${wizardData.notes}</textarea>
            </div>
        `;

        nextBtn.textContent = 'Create Swap Entry';
        // Enable button if we have output amount and currency (service is optional now with provider name)
        nextBtn.disabled = !wizardData.outputAmount || !wizardData.outputCurrency;

    } else if (step === 3) {
        // Step 3: Review and confirm
        createSwapEntry();
    }

    wizardData.step = step;
}

function toggleSwapThread(threadInfo) {
    const wizardData = window.swapWizardData;

    // Support both string (legacy) and object (dual-layer) inputs
    let notation, internalId;
    if (typeof threadInfo === 'string') {
        // Legacy - find the thread to get internal ID
        const threads = getAvailableSourcesForHop(wizardData.hopNumber, null);
        const thread = threads.find(t => t.threadId === threadInfo || t.internalId === threadInfo);
        if (thread) {
            notation = thread.threadId;
            internalId = thread.internalId || thread.threadId;
        } else {
            notation = threadInfo;
            internalId = threadInfo;
        }
    } else {
        notation = threadInfo.notation || threadInfo.threadId;
        internalId = threadInfo.internalId || notation;
    }

    // Initialize arrays if needed
    if (!wizardData.selectedInternalIds) wizardData.selectedInternalIds = [];
    if (!wizardData.selectedThreads) wizardData.selectedThreads = [];

    const index = wizardData.selectedInternalIds.indexOf(internalId);
    const threads = getAvailableSourcesForHop(wizardData.hopNumber, null);
    const thread = threads.find(t => t.internalId === internalId || t.threadId === internalId);

    if (!thread) {
        alert('Error: Thread not found');
        return;
    }

    // CRITICAL: Validate thread is actually available
    if (thread.availableAmount <= 0) {
        alert(`Thread ${threadId} has no available amount to swap. It may have been fully assigned already.`);
        // Uncheck the checkbox
        const checkbox = document.getElementById(`swap_thread_${threadId}`);
        if (checkbox) checkbox.checked = false;
        return;
    }

    if (index > -1) {
        // Remove thread and clear amount
        wizardData.selectedInternalIds.splice(index, 1);
        const notationIndex = wizardData.selectedThreads.indexOf(notation);
        if (notationIndex > -1) {
            wizardData.selectedThreads.splice(notationIndex, 1);
        }
        delete wizardData.threadAmounts[internalId];
    } else {
        // Add thread and set default amount to full amount
        wizardData.selectedInternalIds.push(internalId);
        if (!wizardData.selectedThreads.includes(notation)) {
            wizardData.selectedThreads.push(notation);
        }
        wizardData.threadAmounts[internalId] = thread.availableAmount;
    }

    showSwapWizardStep(wizardData.step); // Refresh display
}

// Update partial swap amount for a thread
function updateSwapThreadAmount(threadId, value, maxAmount) {
    const wizardData = window.swapWizardData;
    const amount = parseFloat(value) || 0;

    // Clamp to valid range
    wizardData.threadAmounts[threadId] = Math.min(Math.max(0, amount), maxAmount);

    // If amount is 0, remove the thread from selection
    if (wizardData.threadAmounts[threadId] === 0) {
        const index = wizardData.selectedThreads.indexOf(threadId);
        if (index !== -1) {
            wizardData.selectedThreads.splice(index, 1);
            delete wizardData.threadAmounts[threadId];
            showSwapWizardStep(wizardData.step);
        }
    }
}

// Set max amount for a swap thread
function setMaxSwapAmount(threadId, maxAmount) {
    const amountInput = document.getElementById(`swap_amount_${threadId}`);
    if (amountInput) {
        amountInput.value = maxAmount;
        updateSwapThreadAmount(threadId, maxAmount, maxAmount);
    }
}

function setSwapType(type) {
    window.swapWizardData.swapType = type;
    showSwapWizardStep(2); // Refresh to update placeholder text
}

function swapWizardNext() {
    const wizardData = window.swapWizardData;

    if (wizardData.step === 2) {
        // Create the swap entry
        createSwapEntry();
    } else {
        wizardData.step++;
        showSwapWizardStep(wizardData.step);
    }
}

function swapWizardBack() {
    const wizardData = window.swapWizardData;
    if (wizardData.step > 1) {
        wizardData.step--;
        showSwapWizardStep(wizardData.step);
    }
}

function closeSwapWizard() {
    console.log('closeSwapWizard called');
    const wizard = document.getElementById('swapWizard');
    if (wizard) {
        console.log('Removing swap wizard element');
        wizard.remove();
    } else {
        console.log('Swap wizard element not found');
        // Try alternative removal methods
        const wizardAlt = document.querySelector('#swapWizard');
        if (wizardAlt) {
            console.log('Found swap wizard via querySelector, removing');
            wizardAlt.remove();
        }
    }
    window.swapWizardData = null;
}

async function lookupSwapTransaction() {
    const wizardData = window.swapWizardData;
    const txHash = document.getElementById('swapTxHash').value.trim();

    if (!txHash) {
        alert('Please enter a transaction hash first');
        return;
    }

    const lookupBtn = event.target;
    const originalText = lookupBtn.textContent;
    lookupBtn.textContent = 'Looking up...';
    lookupBtn.disabled = true;

    try {
        // Try to detect blockchain from hash format
        const blockchain = detectBlockchainFromHash(txHash);
        if (!blockchain) {
            alert('Could not detect blockchain from hash format');
            lookupBtn.textContent = originalText;
            lookupBtn.disabled = false;
            return;
        }

        // Get transaction data using existing lookup functions
        let txData;
        switch(blockchain) {
            case 'ethereum':
                txData = await lookupEthereumTransaction(txHash);
                break;
            case 'bitcoin':
                txData = await lookupBitcoinTransaction(txHash);
                break;
            case 'tron':
                txData = await lookupTronTransaction(txHash);
                break;
            case 'solana':
                txData = await lookupSolanaTransaction(txHash);
                break;
            default:
                alert('Unsupported blockchain: ' + blockchain);
                lookupBtn.textContent = originalText;
                lookupBtn.disabled = false;
                return;
        }

        if (!txData) {
            alert('Failed to retrieve transaction data');
            lookupBtn.textContent = originalText;
            lookupBtn.disabled = false;
            return;
        }

        // For swap transactions, we need to find:
        // 1. What left the user's wallet (outgoing)
        // 2. What came back to the user's wallet (incoming)

        // Get the user's wallet address from the source thread
        let userWallet = null;

        // First try to get it from the selected thread's last receiving wallet
        if (wizardData.selectedThreads && wizardData.selectedThreads.length > 0) {
            const threads = getAvailableSourcesForHop(wizardData.hopNumber, null);
            const sourceThread = threads.find(t => t.threadId === wizardData.selectedThreads[0]);
            if (sourceThread && sourceThread.lastReceivingWallet) {
                userWallet = sourceThread.lastReceivingWallet;
                console.log('Using wallet from source thread:', userWallet);
            }
        }

        // Fallback to transaction sender
        if (!userWallet) {
            userWallet = txData.transaction?.from || txData.from;
            console.log('Using wallet from transaction sender:', userWallet);
        }

        if (!userWallet) {
            alert('Could not determine user wallet address. Please ensure you have selected a source thread.');
            lookupBtn.textContent = originalText;
            lookupBtn.disabled = false;
            return;
        }

        // CRITICAL VALIDATION: Verify the transaction involves the correct wallet(s)
        if (wizardData.selectedThreads && wizardData.selectedThreads.length > 0) {
            const threads = getAvailableSourcesForHop(wizardData.hopNumber, null);
            const selectedThreadData = wizardData.selectedThreads.map(id => threads.find(t => t.threadId === id));

            // Get all wallets associated with selected threads
            const threadWallets = selectedThreadData.map(t => t.sourceWallet).filter(w => w);

            // Check if the transaction involves any of the thread wallets
            const txSender = (txData.transaction?.from || txData.from || '').toLowerCase();
            const hasMatchingWallet = threadWallets.some(wallet =>
                wallet.toLowerCase() === txSender
            );

            if (!hasMatchingWallet && threadWallets.length > 0) {
                const walletList = threadWallets.join(', ');
                const proceed = confirm(`⚠️ WARNING: This transaction sender does not match your selected thread wallet(s).\n\nSelected thread wallet(s): ${walletList}\nTransaction sender: ${txSender}\n\nThis may indicate you selected the wrong thread or wrong transaction.\n\nContinue anyway?`);
                if (!proceed) {
                    lookupBtn.textContent = originalText;
                    lookupBtn.disabled = false;
                    return;
                }
            }
        }

        // Filter transfers to find what left and what came back to the user
        const outgoingTransfers = [];
        const incomingTransfers = [];

        if (txData.transfers && Array.isArray(txData.transfers)) {
            txData.transfers.forEach(transfer => {
                // Normalize the from/to addresses
                const from = (transfer.from || '').toLowerCase();
                const to = (transfer.to || '').toLowerCase();
                const userAddr = userWallet.toLowerCase();

                if (from === userAddr) {
                    // User sent this
                    outgoingTransfers.push(transfer);
                } else if (to === userAddr) {
                    // User received this
                    incomingTransfers.push(transfer);
                }
            });
        }

        console.log('Swap analysis:', {
            userWallet,
            outgoing: outgoingTransfers,
            incoming: incomingTransfers
        });

        // Auto-fill based on what we found
        if (outgoingTransfers.length > 0 && incomingTransfers.length > 0) {
            // We found both sides of the swap

            // Input (what was sent from user's wallet)
            const sentAmount = outgoingTransfers.reduce((sum, t) => sum + (parseFloat(t.amount) || 0), 0);
            const sentCurrency = outgoingTransfers[0].currency || outgoingTransfers[0].symbol || 'UNKNOWN';

            // Output (what was received back to user's wallet)
            const receivedAmount = incomingTransfers.reduce((sum, t) => sum + (parseFloat(t.amount) || 0), 0);
            const receivedCurrency = incomingTransfers[0].currency || incomingTransfers[0].symbol || 'UNKNOWN';

            // The input amount/currency should match what we're tracing from source threads
            // The output is what we received back
            document.getElementById('outputAmount').value = receivedAmount;
            document.getElementById('outputCurrency').value = receivedCurrency.toUpperCase();

            // Update wizard data
            wizardData.outputAmount = receivedAmount;
            wizardData.outputCurrency = receivedCurrency.toUpperCase();

            // Display the detected input for reference
            const inputInfo = document.getElementById('inputInfo');
            if (inputInfo) {
                inputInfo.innerHTML = `<small>Detected swap: ${sentAmount} ${sentCurrency} → ${receivedAmount} ${receivedCurrency}</small>`;
            }

            // Get DEX contract address (usually the first contract interacted with)
            if (outgoingTransfers[0].to && outgoingTransfers[0].to !== userWallet) {
                document.getElementById('swapService').value = outgoingTransfers[0].to;
                wizardData.swapService = outgoingTransfers[0].to;
            }

            // Update notes with details
            const notes = `DEX Swap: ${sentAmount} ${sentCurrency} → ${receivedAmount} ${receivedCurrency}`;
            document.getElementById('swapNotes').value = notes;
            wizardData.notes = notes;

            // Refresh the UI
            showSwapWizardStep(2);

            alert(`✅ Swap detected!\n\nSent: ${sentAmount} ${sentCurrency}\nReceived: ${receivedAmount} ${receivedCurrency}\n\nPlease verify and adjust if needed.`);
        } else if (outgoingTransfers.length > 0) {
            alert('⚠️ Only found outgoing transfers. Please manually enter what was received.');
        } else if (incomingTransfers.length > 0) {
            alert('⚠️ Only found incoming transfers. Please verify this is the correct transaction.');
        } else {
            alert('⚠️ No transfers found for the user wallet. Please enter details manually.');
        }

    } catch (error) {
        console.error('Swap lookup error:', error);
        alert('Error analyzing swap transaction: ' + error.message);
    } finally {
        lookupBtn.textContent = originalText;
        lookupBtn.disabled = false;
    }
}

function createSwapEntry() {
    console.log('Creating swap entry...');
    const wizardData = window.swapWizardData;

    if (!wizardData) {
        console.error('No swap wizard data found');
        alert('Error: Swap wizard data not found. Please try again.');
        return;
    }

    // Get the hop from wizard data (we stored the whole hop object)
    const hop = wizardData.hop;
    if (!hop) {
        console.error('No hop stored in swap wizard data');
        alert('Error: Swap wizard data is incomplete. Please try again.');
        return;
    }

    // CRITICAL VALIDATION: Check for duplicate transaction hash in the same hop
    if (wizardData.txHash) {
        const duplicateEntry = hop.entries.find(entry =>
            entry.txHash &&
            entry.txHash.toLowerCase() === wizardData.txHash.toLowerCase() &&
            entry.entryType !== 'writeoff'
        );

        if (duplicateEntry) {
            alert(`❌ Transaction hash already used in this hop!\n\nTransaction ${wizardData.txHash} is already logged in entry ${duplicateEntry.id} (${duplicateEntry.notation || 'unnamed'}).\n\nSwap transactions must use unique transaction hashes.`);
            return;
        }
    }

    // Get selected thread details
    const threads = getAvailableSourcesForHop(hop.hopNumber, null);
    const selectedThreadData = wizardData.selectedThreads.map(id => threads.find(t => t.threadId === id));

    // Calculate total input amounts using partial amounts
    const inputByCurrency = {};
    const partialSwaps = [];  // Track which threads have partial amounts

    selectedThreadData.forEach(thread => {
        const swapAmount = wizardData.threadAmounts[thread.threadId] || thread.availableAmount;
        const isPartial = swapAmount < thread.availableAmount;

        if (isPartial) {
            partialSwaps.push({
                threadId: thread.threadId,
                swapAmount: swapAmount,
                remainingAmount: thread.availableAmount - swapAmount
            });
        }

        if (!inputByCurrency[thread.currency]) {
            inputByCurrency[thread.currency] = { amount: 0, threads: [] };
        }
        inputByCurrency[thread.currency].amount += swapAmount;
        inputByCurrency[thread.currency].threads.push(thread.threadId);
    });

    // Get the input currency (assuming single currency for now)
    const inputCurrency = Object.keys(inputByCurrency)[0];
    const inputData = inputByCurrency[inputCurrency];

    // Keep same notation - swaps replace threads in place
    const notation = wizardData.selectedThreads.length === 1 ?
        wizardData.selectedThreads[0] :
        wizardData.selectedThreads.map(t => t.split('-').slice(0, 2).join('-')).join('+') + `-H${hop.hopNumber}`;

    // Create the swap entry with dual-layer support
    const swapEntry = {
        id: Date.now(),
        hopNumber: hop.hopNumber,  // Use hop number as the identifier
        entryType: 'swap',

        // Dual-layer thread tracking for input threads
        sourceThreadInternalId: selectedThreadData.length === 1 && selectedThreadData[0] ?
            (selectedThreadData[0].internalId || selectedThreadData[0].threadId) : '',
        multipleSourceInternalIds: selectedThreadData.length > 1 ?
            selectedThreadData.map(t => t.internalId || t.threadId) : [],

        // Keep notation for backward compatibility
        sourceThreadId: wizardData.selectedThreads.length === 1 ? wizardData.selectedThreads[0] : '',
        multipleSourceThreads: wizardData.selectedThreads.length > 1 ? wizardData.selectedThreads : [],

        threadAmounts: wizardData.threadAmounts, // Store partial amounts for each thread
        fromWallet: selectedThreadData[0]?.sourceWallet || '',
        toWallet: wizardData.swapService,
        toWalletType: 'brown', // BROWN for asset conversion
        amount: inputData.amount.toString(),
        outputAmount: wizardData.outputAmount.toString(),
        currency: inputCurrency,
        outputCurrency: wizardData.outputCurrency,
        txHash: wizardData.txHash,
        timestamp: new Date().toISOString().slice(0, 16),
        timezone: 'UTC',
        notes: wizardData.notes || `Asset conversion: ${inputData.amount} ${inputCurrency} swapped for ${wizardData.outputAmount} ${wizardData.outputCurrency} via ${wizardData.providerName || (wizardData.swapType === 'cex' ? 'CEX' : 'DEX')}`,
        notation: notation,
        isSwap: true,
        partialSwaps: partialSwaps, // Track which threads had partial amounts
        swapDetails: {
            fromCurrency: inputCurrency,
            toCurrency: wizardData.outputCurrency,
            fromAmount: inputData.amount,
            toAmount: wizardData.outputAmount,
            dexAddress: wizardData.swapService,
            providerName: wizardData.providerName,
            type: wizardData.swapType
        }
    };

    // Save undo state
    saveUndoState(`Add swap entry to Hop ${hop.hopNumber}`);

    // Add entry to hop
    hop.entries.push(swapEntry);

    // Update available threads - use the dual-layer version
    // updateThreadsAfterSwap(hop, swapEntry); // OLD function
    updateThreadAvailabilityFromSwap(swapEntry); // NEW dual-layer function

    // Close wizard and update UI
    closeSwapWizard();

    // Mark the swap entry as logged/collapsed immediately
    const entryKey = `${hop.hopNumber}_${swapEntry.id}`;
    window.entryCollapseState[entryKey] = true;

    buildAvailableThreadsIndex();
    renderHops();
    saveToStorage();

    // Show success message
    const providerInfo = wizardData.providerName ? ` via ${wizardData.providerName}` : '';
    showNotification(
        `✅ Swap entry created: ${inputData.amount} ${inputCurrency} → ${wizardData.outputAmount} ${wizardData.outputCurrency}${providerInfo}`,
        'success',
        4000
    );

    console.log('Swap entry created successfully:', swapEntry);

    // Check if all source threads are consumed - if not, show add entry dialog for remaining threads
    const remainingSources = getAvailableSourcesForHop(hop.hopNumber + 1, null);
    if (remainingSources && remainingSources.length > 0) {
        // Show the next entry wizard for continuing the trace with the new currency
        setTimeout(() => {
            showAddEntryWizard(hop.hopNumber + 1);
        }, 500);
    } else {
        // Show remaining threads summary
        showRemainingThreadsSummary(hop);
    }
}

function createAndFinalizeEntry() {
    // This function is deprecated but kept for backwards compatibility
    // The new workflow creates entries directly from step 2
    window.hopWizardData.shouldFinalize = true;
    createHopEntryFromWizard();
}

function reopenHopWizard(hopNumber, entryId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop?.entries.find(e => e.id === entryId);
    if (!hop || !entry) return;

    // Initialize wizard data with existing entry data
    window.hopWizardData = {
        entryId: entryId,  // Store the entry ID for updating
        hopNumber: hop.hopNumber,
        selectedThreads: entry.multipleSourceThreads || (entry.sourceThreadId ? [entry.sourceThreadId] : []),
        allocations: entry.individualSourceAssignments || {},
        step: 1,
        txHash: entry.txHash || '',
        entryMode: 'lookup',
        manualData: {
            fromWallet: entry.fromWallet || '',
            toWallet: entry.toWallet || '',
            timestamp: entry.timestamp || new Date().toISOString().slice(0, 16)
        },
        isEditMode: true  // Flag to indicate we're editing an existing entry
    };

    // If entry has a single source thread and amount, set the allocation
    if (entry.sourceThreadId && !entry.multipleSourceThreads) {
        window.hopWizardData.allocations[entry.sourceThreadId] = parseFloat(entry.amount) || 0;
    }

    // Detect chain from selected threads
    const selectedThreadIds = entry.multipleSourceThreads || (entry.sourceThreadId ? [entry.sourceThreadId] : []);
    if (selectedThreadIds.length > 0) {
        const availableThreads = getAvailableSourcesForHop(hopNumber, null);
        for (const threadId of selectedThreadIds) {
            const thread = availableThreads.find(t => t.threadId === threadId || t.internalId === threadId);
            if (thread && thread.chainId) {
                window.hopWizardData.detectedChain = thread.chainId;
                console.log(`Detected chain ${thread.chainId} from thread ${threadId} when reopening wizard`);
                break;
            }
        }
    }

    openHopEntryWizard(hopNumber);
}

function openHopEntryWizard(hopNumber) {
    console.log('openHopEntryWizard called with hopNumber:', hopNumber, 'type:', typeof hopNumber);

    // Convert to number if it's a string
    const numericHopNumber = typeof hopNumber === 'string' ? parseInt(hopNumber) : hopNumber;

    // Get hop data
    const hop = investigation.hops.find(h => h.hopNumber === numericHopNumber);
    if (!hop) {
        console.error('Hop not found for hopNumber:', numericHopNumber);
        console.error('Available hops:', investigation.hops.map(h => h.hopNumber));
        return;
    }
    console.log('Hop found:', hop);

    // IMPORTANT: Rebuild threads database to ensure we have latest state after any swaps
    buildAvailableThreadsIndex();
    console.log('Rebuilt threads database before opening wizard');

    // Initialize wizard data if not already editing
    if (!window.hopWizardData || !window.hopWizardData.isEditMode) {
        window.hopWizardData = {
            hopNumber: numericHopNumber,
            selectedThreads: [],
            selectedInternalIds: [],  // Add for dual-layer support
            selectedNotations: [],    // Add for dual-layer support
            allocations: {},
            step: 1,
            txHash: '',
            entryMode: 'lookup'
        };
    }
    
    const wizardHTML = `
        <div id="hopEntryWizard" class="modal show">
            <div class="modal-content" style="max-width: 900px; width: 90%;">
                <div class="modal-header" style="position: relative;">
                    <h2>🔍 Add Trace Entry - Hop ${numericHopNumber}</h2>
                    <button class="close-btn" onclick="closeHopWizard(); return false;"
                            style="position: absolute; right: 15px; top: 15px; width: 30px; height: 30px;
                                   font-size: 24px; background: #e74c3c; color: white; border: none;
                                   border-radius: 50%; cursor: pointer; display: flex; align-items: center;
                                   justify-content: center; box-shadow: 0 2px 5px rgba(0,0,0,0.2);
                                   transition: all 0.3s ease; font-weight: bold; line-height: 1;
                                   z-index: 10000;"
                            onmouseover="this.style.background='#c0392b'; this.style.transform='scale(1.1)'"
                            onmouseout="this.style.background='#e74c3c'; this.style.transform='scale(1)'"
                            title="Close Wizard">&times;</button>
                </div>
                
                <div class="wizard-progress" id="wizardProgress">
                    <div class="wizard-step active" id="wizStep1">1. Select Source</div>
                    <div class="wizard-step" id="wizStep2">2. Lookup Transaction</div>
                    <div class="wizard-step" id="wizStep3">3. Review & Create</div>
                </div>
                
                <div id="wizardContent" style="min-height: 400px; padding: 20px;">
                    <!-- Content will be loaded here -->
                </div>
                
                <div class="wizard-footer" style="padding: 20px; border-top: 1px solid #ddd;">
                    <div id="wizardFooterButtons" style="display: flex; justify-content: space-around; align-items: center;">
                        <button class="btn btn-secondary" id="wizardBackBtn" onclick="hopWizardBack()" style="padding: 10px 20px;" disabled>← Back</button>
                        <button class="btn btn-primary" id="wizardNextBtn" onclick="hopWizardNext()" style="padding: 10px 20px;">Next →</button>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    // Remove any existing wizard
    const existingWizard = document.getElementById('hopEntryWizard');
    if (existingWizard) {
        console.log('Removing existing wizard');
        existingWizard.remove();
    }

    console.log('About to insert wizard HTML to DOM');
    console.log('HTML length:', wizardHTML.length);

    // Add wizard directly to DOM
    document.body.insertAdjacentHTML('beforeend', wizardHTML);

    console.log('Wizard HTML inserted, checking for element...');

    // Verify wizard was created
    const wizardElement = document.getElementById('hopEntryWizard');

    // Add event listener to the close button as a fallback
    if (wizardElement) {
        const closeBtn = wizardElement.querySelector('.close-btn');
        if (closeBtn) {
            // Add click event listener (keep onclick as primary)
            closeBtn.addEventListener('click', function(e) {
                console.log('Close button clicked via event listener');
                if (!this.onclick) {
                    // Only handle if onclick didn't fire
                    e.preventDefault();
                    e.stopPropagation();
                    if (window.closeHopWizard) {
                        window.closeHopWizard();
                    } else if (typeof closeHopWizard === 'function') {
                        closeHopWizard();
                    } else {
                        // Direct removal as last resort
                        wizardElement.remove();
                    }
                }
            });
            console.log('Close button event listener attached');
        }
    }
    console.log('Wizard element found:', !!wizardElement);

    if (!wizardElement) {
        console.error('Failed to create hop entry wizard');
        console.error('Body children count:', document.body.children.length);
        return;
    }

    console.log('Wizard created successfully, showing first step');

    // Show first step
    showHopWizardStep(1);
}

function skipHopWizard() {
    closeHopWizard();
    createHopEntryDirectly(window.hopWizardData.hopNumber, 'trace');
}

// Skip wizard just for this entry without disabling it permanently
function skipWizardThisTime() {
    const hopNumber = window.hopWizardData.hopNumber;
    closeHopWizard();
    createHopEntryDirectly(hopNumber, 'trace');
}

// Cancel wizard and transfer data to manual entry form
function cancelWizardToManual() {
    const wizardData = window.hopWizardData;
    if (!wizardData) return;
    
    const hopNumber = wizardData.hopNumber;
    
    // Close wizard
    closeHopWizard();
    
    // Create manual entry with pre-filled data
    createHopEntryDirectly(hopNumber, 'trace');
    
    // Wait for DOM update then fill in the data
    setTimeout(() => {
        // Find the last added entry form
        const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
        if (!hop) return;
        
        const lastEntry = hop.entries[hop.entries.length - 1];
        if (!lastEntry) return;
        
        // Pre-fill amount if allocations exist
        const totalAmount = Object.values(wizardData.allocations).reduce((sum, val) => sum + val, 0);
        if (totalAmount > 0) {
            const amountInput = document.querySelector(`[onchange*="updateEntryAmount(${hopNumber}, ${lastEntry.id}"]`);
            if (amountInput) {
                amountInput.value = totalAmount;
                updateEntryAmount(hopNumber, lastEntry.id, totalAmount.toString());
            }
        }
        
        // Pre-fill transaction hash
        if (wizardData.txHash) {
            const txHashInput = document.querySelector(`[onchange*="updateEntryField(${hopNumber}, ${lastEntry.id}, 'txHash'"]`);
            if (txHashInput) {
                txHashInput.value = wizardData.txHash;
                updateEntryField(hopNumber, lastEntry.id, 'txHash', wizardData.txHash);
            }
        }
        
        // Pre-fill manual data if available
        if (wizardData.manualData) {
            if (wizardData.manualData.fromWallet) {
                const fromInput = document.querySelector(`[onchange*="updateEntryField(${hopNumber}, ${lastEntry.id}, 'fromWallet'"]`);
                if (fromInput) {
                    fromInput.value = wizardData.manualData.fromWallet;
                    updateEntryField(hopNumber, lastEntry.id, 'fromWallet', wizardData.manualData.fromWallet);
                }
            }
            
            if (wizardData.manualData.toWallet) {
                const toInput = document.querySelector(`[onchange*="updateEntryField(${hopNumber}, ${lastEntry.id}, 'toWallet'"]`);
                if (toInput) {
                    toInput.value = wizardData.manualData.toWallet;
                    updateEntryField(hopNumber, lastEntry.id, 'toWallet', wizardData.manualData.toWallet);
                }
            }
            
            if (wizardData.manualData.timestamp) {
                const timestampInput = document.querySelector(`[onchange*="updateEntryField(${hopNumber}, ${lastEntry.id}, 'timestamp'"]`);
                if (timestampInput) {
                    timestampInput.value = wizardData.manualData.timestamp;
                    updateEntryField(hopNumber, lastEntry.id, 'timestamp', wizardData.manualData.timestamp);
                }
            }
        }
        
        // Pre-fill source threads if single thread
        if (wizardData.selectedThreads.length === 1) {
            const threadId = wizardData.selectedThreads[0];
            const sourceSelect = document.querySelector(`[onchange*="updateSourceThread(${hopNumber}, ${lastEntry.id}"]`);
            if (sourceSelect) {
                sourceSelect.value = threadId;
                updateSourceThread(hopNumber, lastEntry.id, threadId);
            }
        }
        
        // Scroll to the new entry
        const entryElement = document.getElementById(`entry_${hopNumber}_${lastEntry.id}`);
        if (entryElement) {
            entryElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            // Highlight it briefly
            entryElement.style.border = '3px solid #3498db';
            setTimeout(() => {
                entryElement.style.border = '';
            }, 2000);
        }
    }, 100);
}

// Set wizard entry mode (lookup vs manual)
function setWizardEntryMode(mode) {
    window.hopWizardData.entryMode = mode;
    // When switching modes, preserve existing data
    if (mode === 'manual' && !window.hopWizardData.manualData) {
        window.hopWizardData.manualData = {};
    }
    showHopWizardStep(3); // Refresh step 3
}

// Update wizard manual data
function updateWizardManualData(field, value) {
    if (!window.hopWizardData.manualData) {
        window.hopWizardData.manualData = {};
    }
    window.hopWizardData.manualData[field] = value;
    // Check if we can enable the button now
    checkWizardButtonState();
}

function checkWizardButtonState() {
    if (!window.hopWizardData) return;

    const nextBtn = document.getElementById('wizardNextBtn');
    if (!nextBtn) return;

    const wizardData = window.hopWizardData;

    if (wizardData.step === 3) {
        // On step 3, check if we have minimum requirements
        if (wizardData.entryMode === 'manual') {
            nextBtn.disabled = !wizardData.txHash || !wizardData.manualData?.toWallet;
        } else {
            // In lookup mode, just need the hash
            nextBtn.disabled = !wizardData.txHash;
        }
    }
}

function toggleWizardPreference() {
    const checkbox = document.getElementById('disableWizardCheckbox');
    localStorage.setItem('bats_hop_wizard_disabled', checkbox.checked ? 'true' : 'false');
}

function updateWizardThreadSelection(threadInfo) {
    const wizardData = window.hopWizardData;

    // Support both string (legacy) and object (dual-layer) inputs
    let notation, internalId;
    if (typeof threadInfo === 'string') {
        // Legacy mode - just notation
        notation = threadInfo;
        internalId = threadInfo;  // Use notation as internal ID for backward compatibility
    } else {
        // Dual-layer mode - object with both notation and internalId
        notation = threadInfo.notation || threadInfo.threadId;
        internalId = threadInfo.internalId || threadInfo.notation || threadInfo.threadId;
    }

    // Store selections using internal IDs
    const index = wizardData.selectedInternalIds?.indexOf(internalId) ?? -1;

    if (!wizardData.selectedInternalIds) {
        wizardData.selectedInternalIds = [];
    }
    if (!wizardData.selectedNotations) {
        wizardData.selectedNotations = [];
    }

    if (index > -1) {
        wizardData.selectedInternalIds.splice(index, 1);
        const notationIndex = wizardData.selectedNotations.indexOf(notation);
        if (notationIndex > -1) {
            wizardData.selectedNotations.splice(notationIndex, 1);
        }
        delete wizardData.allocations[internalId];
    } else {
        wizardData.selectedInternalIds.push(internalId);
        wizardData.selectedNotations.push(notation);
    }

    // Keep backward compatibility
    wizardData.selectedThreads = wizardData.selectedNotations;

    // Detect chain from selected threads
    if (wizardData.selectedInternalIds.length > 0) {
        const availableThreads = getAvailableSourcesForHop(wizardData.hopNumber, null);
        let detectedChain = null;

        // Check all selected threads for chain information
        for (const selectedId of wizardData.selectedInternalIds) {
            const thread = availableThreads.find(t =>
                t.internalId === selectedId || t.threadId === selectedId
            );
            if (thread && thread.chainId) {
                detectedChain = thread.chainId;
                console.log(`Detected chain ${detectedChain} from thread ${selectedId}`);
                break;  // Use the first thread with chain info
            }
        }

        if (detectedChain) {
            wizardData.detectedChain = detectedChain;
            console.log(`Wizard chain detection: Set detectedChain to ${detectedChain}`);
        }
    } else {
        // Clear detected chain if no threads selected
        wizardData.detectedChain = null;
    }

    const nextBtn = document.getElementById('wizardNextBtn');
    nextBtn.disabled = wizardData.selectedInternalIds.length === 0;
}

function updateWizardAllocation(threadInfo, value) {
    // Support both string and object inputs
    const internalId = typeof threadInfo === 'string' ?
                      threadInfo :
                      (threadInfo.internalId || threadInfo.threadId);

    window.hopWizardData.allocations[internalId] = parseFloat(value) || 0;
    updateWizardTotal();
}

// Set allocation mode (PIFO or Matching)
function setAllocationMode(mode) {
    if (!window.hopWizardData) return;

    window.hopWizardData.allocationMode = mode;

    // Re-apply allocation based on the selected mode
    if (mode === 'pifo') {
        applyPIFOToWizard();
    } else if (mode === 'matching' && window.hopWizardData.txData) {
        // Apply matching allocation (use full transaction amount)
        applyMatchingAllocation();
    }

    // Re-render the step
    hopWizardNextStep();
    hopWizardPrevStep(); // Go back to step 2 to show updated allocations
    hopWizardNextStep();
}

// Apply matching allocation (use exact transaction amounts)
function applyMatchingAllocation() {
    if (!window.hopWizardData || !window.hopWizardData.txData) return;

    const wizardData = window.hopWizardData;
    const txAmount = wizardData.txData.amount || 0;

    if (txAmount > 0 && wizardData.selectedThreads.length > 0) {
        // For matching mode, try to match the exact transaction amount
        wizardData.allocations = applyPIFOAllocation(txAmount, wizardData.selectedThreads);

        // Add note indicating matching mode
        const matchNotes = [];
        const threads = getAvailableSourcesForHop(wizardData.hopNumber, null);
        for (const [threadId, amount] of Object.entries(wizardData.allocations)) {
            if (amount > 0) {
                const thread = threads.find(t => t.threadId === threadId);
                if (thread) {
                    matchNotes.push(`${threadId}: ${amount}/${thread.availableAmount} ${thread.currency}`);
                }
            }
        }
        wizardData.pifoNote = `Transaction matching (${txAmount.toLocaleString()}): ${matchNotes.join(', ')}`;
    }
}

// Apply PIFO (Proceeds In First Out) allocation across multiple source threads
function applyPIFOAllocation(totalAmount, selectedThreads) {
    const allocations = {};
    let remainingAmount = totalAmount;
    const threads = getAvailableSourcesForHop(window.hopWizardData.hopNumber, null);

    // Sort threads by victim ID and transaction ID for consistent PIFO order
    const sortedThreadIds = selectedThreads.sort((a, b) => {
        // Parse thread IDs (e.g., "V1-T1-H1" or "V1-T1")
        const parseThreadId = (id) => {
            const parts = id.match(/V(\d+)-T(\d+)/);
            if (parts) {
                return { victim: parseInt(parts[1]), transaction: parseInt(parts[2]) };
            }
            return { victim: 999, transaction: 999 };
        };

        const threadA = parseThreadId(a);
        const threadB = parseThreadId(b);

        // Sort by victim first, then by transaction
        if (threadA.victim !== threadB.victim) {
            return threadA.victim - threadB.victim;
        }
        return threadA.transaction - threadB.transaction;
    });

    // Calculate total available across all selected threads
    let totalAvailable = 0;
    for (const threadId of sortedThreadIds) {
        const thread = threads.find(t => t.threadId === threadId);
        if (thread) {
            totalAvailable += thread.availableAmount;
        }
    }

    // If transaction amount exceeds total available, this is partial tracing
    // Only allocate what we have available
    if (totalAmount > totalAvailable) {
        console.log(`Partial trace: Transaction amount ${totalAmount} exceeds available ${totalAvailable}`);
        remainingAmount = totalAvailable; // Cap at what's available
    }

    // Apply PIFO allocation
    for (const threadId of sortedThreadIds) {
        if (remainingAmount <= 0) break;

        const thread = threads.find(t => t.threadId === threadId);
        if (!thread) continue;

        const available = thread.availableAmount;
        const toAllocate = Math.min(available, remainingAmount);

        allocations[threadId] = toAllocate;
        remainingAmount -= toAllocate;
    }

    return allocations;
}

// Re-apply PIFO to current wizard state
function applyPIFOToWizard() {
    if (!window.hopWizardData) return;

    const wizardData = window.hopWizardData;
    const txAmount = wizardData.txData ? wizardData.txData.amount : 0;

    if (txAmount > 0 && wizardData.selectedThreads.length > 0) {
        // Apply PIFO allocation
        wizardData.allocations = applyPIFOAllocation(txAmount, wizardData.selectedThreads);

        // Update the UI
        for (const [threadId, amount] of Object.entries(wizardData.allocations)) {
            const input = document.getElementById(`wizardAllocation_${threadId}`);
            if (input) {
                input.value = amount;
            }
        }

        // Update the total
        updateWizardTotal();
    }
}

function setWizardMaxAllocation(threadId, maxAmount) {
    document.getElementById(`wizardAllocation_${threadId}`).value = maxAmount;
    updateWizardAllocation(threadId, maxAmount);
}

function updateWizardTotal() {
    const wizardData = window.hopWizardData;
    if (!wizardData) {
        console.error('Wizard data not available in updateWizardTotal');
        return;
    }
    const threads = getAvailableSourcesForHop(wizardData.hopNumber, null);
    
    let totalText = [];
    const currencyTotals = {};
    
    Object.entries(wizardData.allocations).forEach(([threadId, amount]) => {
        if (amount > 0) {
            const thread = threads.find(t => t.threadId === threadId);
            if (thread) {
                if (!currencyTotals[thread.currency]) {
                    currencyTotals[thread.currency] = 0;
                }
                currencyTotals[thread.currency] += amount;
            }
        }
    });
    
    Object.entries(currencyTotals).forEach(([currency, total]) => {
        totalText.push(`${total.toLocaleString()} ${currency}`);
    });
    
    const totalElement = document.getElementById('wizardTotalAmount');
    if (totalElement) {
        totalElement.textContent = totalText.join(' + ') || '0';
    }
    
    const nextBtn = document.getElementById('wizardNextBtn');
    const hasAllocations = Object.values(wizardData.allocations).some(v => v > 0);
    nextBtn.disabled = !hasAllocations;
}

async function lookupWizardTransaction() {
    // Ensure wizard data is initialized
    if (!window.hopWizardData) {
        console.error('Wizard data not initialized when looking up transaction');
        alert('Error: Wizard not properly initialized. Please close and reopen the wizard.');
        return;
    }

    // Store the wizard session ID to detect if wizard was closed during lookup
    const sessionId = Date.now();
    window.hopWizardData.lookupSessionId = sessionId;

    const txHash = document.getElementById('wizardTxHash').value.trim();
    if (!txHash) return;

    const resultDiv = document.getElementById('wizardTxResult');
    resultDiv.innerHTML = '<div style="text-align: center;">Looking up transaction...</div>';

    try {
        // First check if chain was detected from source thread
        let detectedChain = window.hopWizardData?.detectedChain;

        // If no chain from source thread, check if chain selector exists (main lookup modal)
        if (!detectedChain) {
            detectedChain = document.getElementById('chainSelector')?.value;
        }

        // If still no chain, try to detect from hash
        if (!detectedChain) {
            detectedChain = detectBlockchainFromHash(txHash);
        }

        if (!detectedChain) {
            throw new Error('Unable to detect blockchain from hash');
        }

        console.log(`Using chain: ${detectedChain} for transaction lookup`);

        // Call the appropriate lookup function based on chain type
        let txData;
        const evmChains = ['ethereum', 'base', 'arbitrum', 'optimism', 'polygon', 'bsc',
                          'avalanche', 'hyperevm', 'linea', 'scroll', 'mantle', 'blast',
                          'zksync', 'gnosis', 'celo', 'moonbeam', 'moonriver', 'fraxtal',
                          'taiko', 'arbitrumnova', 'bittorrent', 'opbnb'];

        if (evmChains.includes(detectedChain)) {
            // For EVM chains, temporarily set chain selector and use the ethereum lookup
            // which will actually use the detected chain from the selector
            const originalChain = document.getElementById('chainSelector')?.value;
            if (document.getElementById('chainSelector')) {
                document.getElementById('chainSelector').value = detectedChain;
            }

            // Call the existing lookup with the specific chain
            txData = await lookupEthereumTransaction(txHash, detectedChain);

            // Restore original chain selector
            if (document.getElementById('chainSelector') && originalChain !== undefined) {
                document.getElementById('chainSelector').value = originalChain;
            }
        } else {
            switch(detectedChain) {
                case 'bitcoin':
                    txData = await lookupBitcoinTransaction(txHash);
                    break;
                case 'tron':
                    txData = await lookupTronTransaction(txHash);
                    break;
                case 'solana':
                    txData = await lookupSolanaTransaction(txHash);
                    break;
                default:
                    throw new Error('Unsupported blockchain');
            }
        }

        // Check if wizard was closed or session changed during the async operation
        if (!window.hopWizardData || window.hopWizardData.lookupSessionId !== sessionId) {
            console.log('Wizard closed or session changed during transaction lookup');
            return; // Exit silently as wizard was closed
        }

        // Determine the currency we're tracking from source threads
        // IMPORTANT: For swap outputs, we need to track the OUTPUT currency, not the input
        let trackingCurrency = null;
        if (window.hopWizardData.selectedThreads && window.hopWizardData.selectedThreads.length > 0) {
            const threads = getAvailableSourcesForHop(window.hopWizardData.hopNumber, null);
            const sourceCurrencies = new Set();
            window.hopWizardData.selectedThreads.forEach(threadId => {
                const thread = threads.find(t => t.threadId === threadId);
                if (thread) {
                    // The thread object from getAvailableSourcesForHop already has the correct currency
                    // For swap outputs, it will be the output currency
                    sourceCurrencies.add(thread.currency);
                    console.log(`Thread ${threadId} has currency: ${thread.currency} (type: ${thread.sourceType})`);
                }
            });
            // If all source threads are the same currency, that's what we're tracking
            if (sourceCurrencies.size === 1) {
                trackingCurrency = Array.from(sourceCurrencies)[0];
                console.log(`Tracking currency determined: ${trackingCurrency}`);
            } else if (sourceCurrencies.size > 1) {
                console.log(`Multiple currencies in source threads: ${Array.from(sourceCurrencies).join(', ')}`);
            }
        }

        // Check if there are token transfers that need selection
        if (txData.transfers && txData.transfers.length > 0) {
            // Ensure wizard data still exists with proper session
            if (!window.hopWizardData || window.hopWizardData.lookupSessionId !== sessionId) {
                console.error('Wizard data lost or session changed during transaction processing');
                return;
            }

            // Filter transfers to only show those matching the tracking currency
            let relevantTransfers = txData.transfers;
            if (trackingCurrency) {
                // Filter to only transfers of the currency we're tracking
                relevantTransfers = txData.transfers.filter(t => t.currency === trackingCurrency);
                console.log(`Filtered ${txData.transfers.length} transfers to ${relevantTransfers.length} ${trackingCurrency} transfers`);

                // If no transfers match our currency, this might be an issue
                if (relevantTransfers.length === 0) {
                    throw new Error(`No ${trackingCurrency} transfers found in this transaction. Found: ${txData.transfers.map(t => t.currency).join(', ')}`);
                }
            }

            // If after filtering we only have one transfer, treat it as a single transfer
            if (relevantTransfers.length === 1) {
                // Single transfer - no need for selection
                window.hopWizardData.txData = {
                    ...txData,
                    ...relevantTransfers[0], // Use the single relevant transfer's data
                    transfers: relevantTransfers
                };
                // Update txData to use the filtered single transfer
                txData = window.hopWizardData.txData;
                // Important: Don't process this transfer twice - skip the multi-transfer handling
            } else if (relevantTransfers.length > 1) {
                // Multiple transfers of the same currency - need selection
                window.hopWizardData.pendingTransfers = relevantTransfers;
                window.hopWizardData.txData = txData;

                // Initialize selection tracking
                window.hopWizardData.selectedOutputs = window.hopWizardData.selectedOutputs || [];
                window.hopWizardData.outputClassifications = window.hopWizardData.outputClassifications || {};

                // Auto-detect potential change outputs
                const sourceWallet = window.hopWizardData.selectedThreads && window.hopWizardData.selectedThreads.length > 0 ?
                    getAvailableSourcesForHop(window.hopWizardData.hopNumber, null).find(t => t.threadId === window.hopWizardData.selectedThreads[0])?.sourceWallet : null;

                // Pre-classify outputs based on advanced change detection heuristics
                relevantTransfers.forEach((transfer, index) => {
                    const isBackToSender = sourceWallet && transfer.to.toLowerCase() === sourceWallet.toLowerCase();

                    // Advanced change detection heuristics
                    let changeScore = 0;
                    let changeReasons = [];

                    // 1. Same address (100% change)
                    if (isBackToSender) {
                        changeScore = 100;
                        changeReasons.push('Same address as sender');
                    } else {
                        // 2. Round amount heuristic (payments are often round)
                        const isRoundAmount = transfer.amount % 1 === 0 || transfer.amount % 0.1 === 0 || transfer.amount % 0.01 === 0;
                        const hasManySigFigs = transfer.amount.toString().split('.')[1]?.length > 4;

                        if (hasManySigFigs) {
                            changeScore += 30;
                            changeReasons.push('Many decimal places');
                        } else if (!isRoundAmount) {
                            changeScore += 20;
                            changeReasons.push('Non-round amount');
                        }

                        // 3. Output order heuristic (change often comes last in Bitcoin)
                        if (relevantTransfers.length === 2 && index === 1) {
                            changeScore += 15;
                            changeReasons.push('Second of two outputs');
                        }

                        // 4. Address type matching (change often uses same script type)
                        if (transfer.scriptType && sourceWallet) {
                            // Check if address types match (P2PKH, P2SH, P2WPKH, etc.)
                            const sourcePrefix = sourceWallet.substring(0, 1);
                            const destPrefix = transfer.to.substring(0, 1);

                            // Bitcoin address prefixes
                            const p2pkhPrefixes = ['1']; // Legacy
                            const p2shPrefixes = ['3'];  // SegWit nested
                            const bech32Prefixes = ['bc1']; // Native SegWit

                            const sourceType = transfer.to.startsWith('bc1') ? 'bech32' :
                                              p2shPrefixes.includes(sourcePrefix) ? 'p2sh' :
                                              p2pkhPrefixes.includes(sourcePrefix) ? 'p2pkh' : 'unknown';

                            const destType = transfer.to.startsWith('bc1') ? 'bech32' :
                                            p2shPrefixes.includes(destPrefix) ? 'p2sh' :
                                            p2pkhPrefixes.includes(destPrefix) ? 'p2pkh' : 'unknown';

                            if (sourceType === destType && sourceType !== 'unknown') {
                                changeScore += 10;
                                changeReasons.push('Same address type');
                            }
                        }

                        // 5. Amount comparison (change is often smaller than payment in simple transactions)
                        if (relevantTransfers.length === 2) {
                            const otherTransfer = relevantTransfers[1 - index];
                            if (transfer.amount < otherTransfer.amount * 0.5) {
                                changeScore += 10;
                                changeReasons.push('Smaller output');
                            }
                        }

                        // 6. Unnecessary input heuristic (most reliable)
                        // If payment could be made with fewer inputs, there MUST be change
                        if (relevantTransfers.length > 0 && relevantTransfers[0].totalInputAmount) {
                            const totalInputAmount = relevantTransfers[0].totalInputAmount;
                            const inputCount = relevantTransfers[0].inputCount || 0;
                            const inputDetails = relevantTransfers[0].inputDetails || [];

                            // Calculate total output amount
                            const totalOutputAmount = relevantTransfers.reduce((sum, t) => sum + t.amount, 0);

                            // Estimated fee (very rough: ~0.0001 BTC per input)
                            const estimatedFee = inputCount * 0.0001;

                            // Check if we could have made the largest output with fewer inputs
                            if (inputDetails.length > 1 && relevantTransfers.length === 2) {
                                const largestOutput = Math.max(relevantTransfers[0].amount, relevantTransfers[1].amount);

                                // Sort inputs by size (largest first)
                                const sortedInputs = [...inputDetails].sort((a, b) => b.amount - a.amount);

                                // See if we could make the payment with fewer inputs
                                let runningTotal = 0;
                                let neededInputs = 0;

                                for (const input of sortedInputs) {
                                    runningTotal += input.amount;
                                    neededInputs++;

                                    // If we have enough for the largest output plus estimated fee
                                    if (runningTotal >= largestOutput + estimatedFee) {
                                        break;
                                    }
                                }

                                // If we used ALL inputs but only needed some, there MUST be change
                                if (neededInputs < inputCount) {
                                    changeScore += 40; // Very strong indicator
                                    changeReasons.push(`Unnecessary input used (${inputCount} inputs used, only ${neededInputs} needed)`);
                                }
                            }

                            // 7. Perfect change calculation
                            // Change should approximately equal: inputs - other output - fee
                            if (relevantTransfers.length === 2 && totalInputAmount > 0) {
                                const otherOutput = relevantTransfers[1 - index];
                                const expectedChange = totalInputAmount - otherOutput.amount - estimatedFee;
                                const actualAmount = transfer.amount;

                                // If this output is within 10% of expected change amount
                                const difference = Math.abs(expectedChange - actualAmount);
                                if (difference < expectedChange * 0.1 && expectedChange > 0) {
                                    changeScore += 25;
                                    changeReasons.push(`Matches expected change amount (~${expectedChange.toFixed(8)} BTC)`);
                                }
                            }
                        }
                    }

                    // Store change analysis for display
                    transfer.changeScore = changeScore;
                    transfer.changeReasons = changeReasons;

                    // Classification based on score
                    if (isBackToSender) {
                        // Automatic change classification for same-address
                        window.hopWizardData.outputClassifications[index] = 'change';
                        window.hopWizardData.selectedOutputs.push(index);
                    } else if (changeScore >= 40) {
                        // High probability of change
                        window.hopWizardData.outputClassifications[index] = 'change';
                        // Don't auto-select suspected change for tracking (user decides)
                    } else {
                        // Likely payment
                        window.hopWizardData.outputClassifications[index] = 'payment';
                        window.hopWizardData.selectedOutputs.push(index);
                    }
                });

                resultDiv.innerHTML = `
                <div style="background: #fff3e0; border: 2px solid #ff9800; border-radius: 8px; padding: 15px;">
                    <h4 style="margin-top: 0; color: #e65100;">Multiple Outputs Detected - Select All to Track</h4>
                    <p style="margin-bottom: 10px;">This transaction has ${relevantTransfers.length} ${trackingCurrency ? trackingCurrency + ' ' : ''}outputs. Select each output you want to track and classify it:</p>

                    <div style="background: #e3f2fd; border-left: 4px solid #2196f3; padding: 10px; margin-bottom: 15px;">
                        <strong>💡 Change Detection:</strong><br>
                        • Outputs returning to sender address are likely change<br>
                        • Round amounts are likely payments<br>
                        • Decimal amounts are often change<br>
                        • Change creates ORANGE threads (same custody)
                    </div>

                    <div style="max-height: 400px; overflow-y: auto;">
                        ${relevantTransfers.map((transfer, index) => {
                            const isBackToSender = sourceWallet && transfer.to.toLowerCase() === sourceWallet.toLowerCase();
                            const isDefinitelyChange = isBackToSender; // Same address = definitely change
                            const changeScore = transfer.changeScore || 0;
                            const likelyChange = !isDefinitelyChange && changeScore >= 40; // High change probability

                            // Check attribution for this output asynchronously
                            getWalletAttribution(transfer.to).then(attribution => {
                                if (attribution) {
                                    const outputDiv = document.getElementById(`wizardOutput_${index}`);
                                    if (outputDiv) {
                                        // Add attribution badge
                                        let badgeHtml;
                                        if (attribution.isPersonalLabel) {
                                            // Personal label - informational only
                                            badgeHtml = `
                                                <div style="background: #e3f2fd; border: 1px solid #2196f3; border-radius: 4px; padding: 8px; margin-bottom: 10px;">
                                                    <strong style="color: #1565c0;">🏷️ Label: ${attribution.name || attribution.label}</strong><br>
                                                    <small>Personal label | Not a terminal wallet</small>
                                                </div>
                                            `;
                                        } else {
                                            // Actual terminal wallet (exchange/service)
                                            badgeHtml = `
                                                <div style="background: #e1bee7; border: 1px solid #9c27b0; border-radius: 4px; padding: 8px; margin-bottom: 10px;">
                                                    <strong style="color: #6a1b9a;">🟣 Terminal Wallet: ${attribution.name || attribution.label}</strong><br>
                                                    <small>Type: ${attribution.type} | This is an exchange or service</small>
                                                </div>
                                            `;
                                        }
                                        // Insert after the amount div
                                        const amountDiv = outputDiv.querySelector('div[style*="margin-bottom: 10px"]');
                                        if (amountDiv && !outputDiv.querySelector('div[style*="#e1bee7"]')) {
                                            amountDiv.insertAdjacentHTML('afterend', badgeHtml);
                                        }
                                    }
                                }
                            }).catch(err => console.log('Attribution check failed for output:', err));

                            return `
                            <div style="background: white; border: 2px solid #ddd; border-radius: 6px; padding: 15px; margin: 10px 0;" id="wizardOutput_${index}">
                                <div style="display: flex; justify-content: space-between; align-items: start;">
                                    <div style="flex: 1;">
                                        <div style="margin-bottom: 10px;">
                                            <strong style="font-size: 16px;">${transfer.amount} ${transfer.currency}</strong>
                                            ${isDefinitelyChange ?
                                                '<span style="color: #ff9800; margin-left: 10px; font-weight: bold;">🔄 Auto-detected Change (Same Address)</span>' :
                                                likelyChange ?
                                                `<span style="color: #ff9800; margin-left: 10px;">⚠️ Likely Change (Score: ${changeScore}%)</span>` : ''}
                                        </div>
                                        ${transfer.changeReasons && transfer.changeReasons.length > 0 && !isDefinitelyChange ? `
                                        <div style="background: #fff8e1; padding: 8px; border-radius: 4px; margin-bottom: 10px; font-size: 11px;">
                                            <strong>Change indicators:</strong>
                                            <ul style="margin: 5px 0 0 20px; padding: 0;">
                                                ${transfer.changeReasons.map(reason => `<li>${reason}</li>`).join('')}
                                            </ul>
                                        </div>
                                        ` : ''}
                                        <div style="font-size: 12px; color: #666; margin-bottom: 10px;">
                                            <div>From: ${transfer.from.slice(0, 15)}...${transfer.from.slice(-10)}</div>
                                            <div>To: ${transfer.to.slice(0, 15)}...${transfer.to.slice(-10)}</div>
                                        </div>
                                        
                                        <div style="background: #f5f5f5; padding: 10px; border-radius: 4px;">
                                            <label style="display: block; margin-bottom: 5px; font-weight: bold;">
                                                Classification:
                                                ${isDefinitelyChange ?
                                                    '<span style="color: #ff9800; font-size: 12px; margin-left: 10px;">(Automatically set as Change - same address)</span>' : ''}
                                            </label>
                                            <div>
                                                <label style="display: inline-block; margin-right: 15px; cursor: pointer; ${isDefinitelyChange ? 'opacity: 0.5;' : ''}">
                                                    <input type="radio" name="outputType_${index}" value="payment"
                                                           ${!isDefinitelyChange && !likelyChange ? 'checked' : ''}
                                                           ${isDefinitelyChange ? 'disabled' : ''}
                                                           onchange="classifyWizardOutput(${index}, 'payment')">
                                                    <span style="color: #27ae60;">✓ Payment (New Hop)</span>
                                                </label>
                                                <label style="display: inline-block; margin-right: 15px; cursor: pointer;">
                                                    <input type="radio" name="outputType_${index}" value="change"
                                                           ${isDefinitelyChange || likelyChange ? 'checked' : ''}
                                                           ${isDefinitelyChange ? 'disabled checked' : ''}
                                                           onchange="classifyWizardOutput(${index}, 'change')">
                                                    <span style="color: #ff9800;">↻ Change (Same-Hop Thread)</span>
                                                </label>
                                                <label style="display: inline-block; cursor: pointer; ${isDefinitelyChange ? 'opacity: 0.5;' : ''}">
                                                    <input type="radio" name="outputType_${index}" value="ignore"
                                                           ${isDefinitelyChange ? 'disabled' : ''}
                                                           onchange="classifyWizardOutput(${index}, 'ignore')">
                                                    <span style="color: #95a5a6;">✗ Ignore</span>
                                                </label>
                                            </div>
                                        </div>
                                    </div>
                                    
                                    <div style="margin-left: 15px;">
                                        <label style="display: block; text-align: center;">
                                            <input type="checkbox"
                                                   id="wizardOutputSelect_${index}"
                                                   value="${index}"
                                                   onchange="toggleWizardOutput(${index})"
                                                   ${isDefinitelyChange ? 'checked' : !likelyChange ? 'checked' : ''}
                                                   style="width: 20px; height: 20px; cursor: pointer;">
                                            <div style="margin-top: 5px; font-size: 12px;">Track</div>
                                        </label>
                                    </div>
                                </div>
                            </div>
                            `;
                        }).join('')}
                    </div>
                    
                    <div style="margin-top: 15px; padding: 15px; background: #f0f0f0; border-radius: 4px;">
                        <strong>Selected Outputs Summary:</strong>
                        <div id="wizardOutputSummary" style="margin-top: 10px;"></div>
                    </div>
                    
                    <button class="btn btn-primary" onclick="confirmWizardOutputSelection()" style="margin-top: 15px; width: 100%;">
                        Confirm Selection and Continue
                    </button>
                </div>
            `;

            // Initialize classifications
            relevantTransfers.forEach((transfer, index) => {
                const isRoundAmount = transfer.amount % 1 === 0 || transfer.amount % 10 === 0;
                const isBackToSender = sourceWallet && transfer.to === sourceWallet;
                const likelyChange = !isRoundAmount || isBackToSender;

                window.hopWizardData.outputClassifications[index] = likelyChange ? 'change' : 'payment';
                if (!likelyChange) {
                    toggleWizardOutput(index);
                }
            });
            
            updateWizardOutputSummary();
            return; // Exit early - multi-output UI will handle the rest
        }
        // If we reach here with a single transfer, fall through to display it
    }

    // Single transfer or non-transfer transaction display
    // This handles both single transfers after filtering and regular transactions
    if (!window.hopWizardData.txData) {
        window.hopWizardData.txData = txData;
    }

    // Check if this might be a DEX swap
    let swapWarning = '';
    let isSwap = false;
    let swapFromCurrency = null;

    if (window.hopWizardData.selectedThreads && window.hopWizardData.selectedThreads.length > 0) {
        const threads = getAvailableSourcesForHop(window.hopWizardData.hopNumber, null);
        const sourceCurrencies = new Set();
        window.hopWizardData.selectedThreads.forEach(threadId => {
            const thread = threads.find(t => t.threadId === threadId);
            if (thread) sourceCurrencies.add(thread.currency);
        });

        // If source currency differs from transaction currency, it's a swap
        if (sourceCurrencies.size === 1) {
            const sourceCurrency = Array.from(sourceCurrencies)[0];
            if (txData.currency && sourceCurrency !== txData.currency) {
                isSwap = true;
                swapFromCurrency = sourceCurrency;
                window.hopWizardData.isSwap = true;
                window.hopWizardData.swapDetails = {
                    fromCurrency: sourceCurrency,
                    toCurrency: txData.currency,
                    fromAmount: Object.values(window.hopWizardData.allocations).reduce((sum, val) => sum + val, 0),
                    toAmount: txData.amount,
                    dexAddress: txData.to
                };

                swapWarning = `
                            <div style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px; padding: 15px; margin-top: 10px;">
                                <h4 style="margin-top: 0; color: #e65100;">🔄 DEX Swap Detected</h4>
                                <div style="margin: 10px 0;">
                                    <strong>Swap Details:</strong><br>
                                    • Input: ${window.hopWizardData.swapDetails.fromAmount} ${sourceCurrency}<br>
                                    • Output: ${txData.amount} ${txData.currency}<br>
                                    • DEX: <span style="font-family: monospace; font-size: 11px;">${txData.to}</span>
                                </div>
                                <div style="background: white; padding: 10px; border-radius: 4px; margin-top: 10px;">
                                    <strong>This will create:</strong><br>
                                    1. A <strong>swap entry</strong> documenting the conversion<br>
                                    2. DEX marked as <span style="color: #8B4513; font-weight: bold;">🟤 BROWN wallet</span><br>
                                    3. Thread converts from ${sourceCurrency} to ${txData.currency} (no hop increment)
                                </div>
                                <div style="margin-top: 10px; padding: 8px; background: #e3f2fd; border-radius: 4px;">
                                    ℹ️ The next hop will continue with ${txData.currency} threads
                                </div>
                            </div>
                `;
            }
        }
    }

    // Check for wallet attributions based on blockchain type
    let attributionAlert = '';
    const isBitcoin = txData.blockchain === 'Bitcoin' || txData.currency === 'BTC';

    // Use appropriate attribution function based on blockchain
    const attributionFunction = isBitcoin ? getBitcoinWalletAttribution : getWalletAttribution;

    // Check the TO address for attribution
    attributionFunction(txData.to).then(attribution => {
        if (attribution) {
            if (attribution.isPersonalLabel) {
                console.log('🏷️ Personal label found in transaction lookup:', attribution);
            } else {
                console.log('🟣 Terminal wallet detected in transaction lookup:', attribution);
            }

            // Update the result div with attribution alert
            const alertDiv = document.createElement('div');

            if (attribution.isPersonalLabel) {
                // Check if this might be a misidentified exchange
                const suspectedType = attribution.suspectedExchange && attribution.detectionMatches?.length > 0;

                if (suspectedType && attribution.detectionConfidence >= 50) {
                    // Show intelligent detection popup
                    alertDiv.style.cssText = 'background: #fff3cd; border: 2px solid #ff9800; border-radius: 8px; padding: 15px; margin-top: 15px;';
                    alertDiv.innerHTML = `
                        <h4 style="margin: 0 0 10px 0; color: #e65100;">⚠️ Suspected Exchange/Service Detected</h4>
                        <div style="font-size: 14px;">
                            <strong>Label:</strong> ${attribution.name || attribution.label}<br>
                            <strong>Confidence:</strong> <span style="color: ${attribution.detectionConfidence >= 70 ? '#27ae60' : '#e67e22'}; font-weight: bold;">${attribution.detectionConfidence}%</span><br>
                            <strong>Wallet:</strong> <span style="font-family: monospace; font-size: 12px;">${txData.to}</span><br>

                            <div style="margin-top: 15px; padding: 12px; background: white; border-radius: 4px; border-left: 4px solid #ff9800;">
                                <strong>🔍 Detection Analysis:</strong><br>
                                <div style="margin-top: 8px;">
                                    ${attribution.detectionMatches.map(match => `
                                        <div style="margin: 4px 0; padding: 4px 8px; background: #f5f5f5; border-radius: 3px;">
                                            • Found <strong>${match.type}</strong> indicator: <code>${match.name}</code>
                                            <span style="color: #666; font-size: 12px;">(${match.confidence}% confidence)</span>
                                        </div>
                                    `).join('')}
                                </div>
                            </div>

                            <div style="margin-top: 15px; padding: 12px; background: #e8f4fd; border-radius: 4px;">
                                <strong>📊 Recommendation:</strong><br>
                                <p style="margin: 8px 0;">
                                    ${attribution.detectionConfidence >= 85 ?
                                        'This appears to be a known exchange or service. Consider marking it as a terminal wallet.' :
                                        attribution.detectionConfidence >= 70 ?
                                        'This likely represents an exchange or service. Review carefully before proceeding.' :
                                        'Some indicators suggest this might be an exchange. Use your judgment based on investigation context.'}
                                </p>
                            </div>

                            <div style="margin-top: 15px;">
                                <strong>Choose an action:</strong>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-top: 10px;">
                                    <button class="btn btn-warning" onclick="convertToTerminalWallet()"
                                            style="background: #9c27b0; border-color: #9c27b0; padding: 10px;">
                                        🟣 Mark as Terminal Wallet<br>
                                        <small style="opacity: 0.8;">Funds arrived at exchange</small>
                                    </button>
                                    <button class="btn btn-secondary" onclick="convertToConversionWallet()"
                                            style="background: #8B4513; border-color: #8B4513; padding: 10px;">
                                        🟤 Mark as Bridge/DEX<br>
                                        <small style="opacity: 0.8;">Currency conversion service</small>
                                    </button>
                                    <button class="btn btn-info" onclick="keepAsPersonalLabel()"
                                            style="background: #3498db; border-color: #3498db; padding: 10px; grid-column: span 2;">
                                        🏷️ Keep as Personal Label<br>
                                        <small style="opacity: 0.8;">Not an exchange - just a labeled wallet</small>
                                    </button>
                                </div>
                            </div>
                        </div>
                    `;
                } else {
                    // Regular personal label with low/no exchange indicators
                    alertDiv.style.cssText = 'background: #e3f2fd; border: 2px solid #2196f3; border-radius: 8px; padding: 15px; margin-top: 15px;';
                    alertDiv.innerHTML = `
                        <h4 style="margin: 0 0 10px 0; color: #1565c0;">🏷️ Personal Label Detected</h4>
                        <div style="font-size: 14px;">
                            <strong>Label:</strong> ${attribution.name || attribution.label}<br>
                            <strong>Wallet:</strong> <span style="font-family: monospace; font-size: 12px;">${txData.to}</span><br>
                            <div style="margin-top: 10px; padding: 10px; background: white; border-radius: 4px;">
                                <strong>ℹ️ Note:</strong><br>
                                • This is a personal label, not an exchange<br>
                                • The wallet can still send funds elsewhere<br>
                                • Continue tracing as normal<br>
                                • The label will be added to your entry notes
                            </div>
                            ${attribution.detectionConfidence > 0 ? `
                                <div style="margin-top: 10px; padding: 8px; background: #f0f0f0; border-radius: 4px; font-size: 12px;">
                                    <em>Low confidence (${attribution.detectionConfidence}%) exchange indicators detected.
                                    If you believe this is an exchange, use the buttons below to convert.</em>
                                </div>
                            ` : ''}
                            <div style="margin-top: 15px; padding: 10px; background: #fff3cd; border: 1px solid #ff9800; border-radius: 4px;">
                                <strong>❓ Is this actually an exchange or conversion service?</strong><br>
                                <p style="margin: 8px 0; font-size: 13px;">If this label indicates a centralized exchange or DEX/Bridge, convert it to the appropriate wallet type:</p>
                                <div style="display: flex; gap: 10px; margin-top: 10px;">
                                    <button class="btn btn-warning" onclick="convertToTerminalWallet()" style="background: #9c27b0; border-color: #9c27b0;">
                                        🟣 Convert to Terminal Wallet
                                    </button>
                                    <button class="btn btn-secondary" onclick="convertToConversionWallet()" style="background: #8B4513; border-color: #8B4513;">
                                        🟤 Convert to Conversion Wallet
                                    </button>
                                </div>
                            </div>
                        </div>
                    `;
                }
            } else {
                // Actual terminal wallet (exchange/service)
                alertDiv.style.cssText = 'background: #e1bee7; border: 2px solid #9c27b0; border-radius: 8px; padding: 15px; margin-top: 15px;';
                alertDiv.innerHTML = `
                    <h4 style="margin: 0 0 10px 0; color: #6a1b9a;">🟣 Exchange Wallet Detected - MANDATORY Terminal Entry</h4>
                    <div style="font-size: 14px;">
                        <strong>Exchange/Service:</strong> ${attribution.name || attribution.label}<br>
                        <strong>Type:</strong> ${attribution.type}<br>
                        <strong>Wallet:</strong> <span style="font-family: monospace; font-size: 12px;">${txData.to}</span><br>
                        <div style="margin-top: 10px; padding: 10px; background: white; border-radius: 4px;">
                            <strong>⚠️ IMPORTANT:</strong><br>
                            • Funds have arrived at a centralized exchange<br>
                            • This MUST be marked as a terminal wallet (PURPLE)<br>
                            • Further recovery requires legal process<br>
                            • The trace ends here for this thread
                        </div>
                        <div style="margin-top: 10px; padding: 10px; background: #fff3cd; border: 1px solid #9c27b0; border-radius: 4px;">
                            <strong>🛑 Exchange Detected - Confirm Terminal Entry:</strong><br>
                            <p style="margin: 10px 0; color: #6a1b9a; font-weight: bold;">
                                You must confirm this terminal wallet to continue.
                            </p>
                            <button class="btn btn-warning" onclick="confirmTerminalWallet()" style="margin-top: 10px; background: #9c27b0; border-color: #9c27b0; font-size: 16px; padding: 10px 20px;">
                                ✅ Confirm Terminal Wallet Entry
                            </button>
                            <div style="margin-top: 10px; font-size: 12px; color: #666;">
                                ⚖️ Legal process (subpoena/court order) will be required to recover funds from ${attribution.name || 'this exchange'}
                            </div>
                        </div>
                    </div>
                `;
            }

            // Insert the alert after the transaction details
            const resultDiv = document.getElementById('wizardTxResult');
            const existingAlert = resultDiv.querySelector('div[style*="#e1bee7"]');
            if (!existingAlert) {
                const transactionBox = resultDiv.querySelector('div[style*="#e8f4f8"]');
                if (transactionBox) {
                    transactionBox.insertAdjacentElement('afterend', alertDiv);
                }
            }

            // Store attribution in wizard data for later use
            if (window.hopWizardData) {
                window.hopWizardData.detectedAttribution = attribution;
            }
        }
    }).catch(err => {
        console.log('Attribution check failed:', err);
    });

    resultDiv.innerHTML = `
        <div style="background: #e8f4f8; border: 1px solid #3498db; border-radius: 8px; padding: 15px;">
            <h4 style="margin-top: 0;">Transaction Found ✓</h4>
            <div style="display: grid; gap: 8px; font-size: 14px;">
                <div><strong>Chain:</strong> ${txData.blockchain}</div>
                <div><strong>Amount:</strong> ${txData.amount} ${txData.currency}</div>
                <div><strong>From:</strong> <span style="font-family: monospace; font-size: 12px;">${txData.from}</span></div>
                <div><strong>To:</strong> <span style="font-family: monospace; font-size: 12px;">${txData.to}</span></div>
                <div><strong>Time:</strong> ${new Date(txData.time).toLocaleString()} UTC</div>
            </div>
            ${swapWarning}
            <div style="margin-top: 15px; padding: 10px; background: #d4edda; border-radius: 4px;">
                <strong>✅ Ready to create entry</strong><br>
                <small>Click "Log Entry" to add this transaction to Hop ${window.hopWizardData.hopNumber}</small>
            </div>
        </div>
    `;

    // Check if terminal wallet was detected
    const hasTerminalWallet = window.hopWizardData && window.hopWizardData.detectedAttribution;

    // Handle button state based on terminal wallet detection
    const nextBtn = document.getElementById('wizardNextBtn');
    if (nextBtn) {
        if (hasTerminalWallet && !window.hopWizardData.isTerminalWallet) {
            // Terminal wallet detected but not confirmed - disable button
            nextBtn.disabled = true;
            nextBtn.textContent = 'Confirm Terminal Wallet First';
            nextBtn.style.background = '#6c757d'; // Gray out the button
        } else {
            // Normal case or terminal confirmed
            nextBtn.disabled = false;
            if (window.hopWizardData.isTerminalWallet) {
                nextBtn.textContent = 'Create Terminal Entry';
                nextBtn.style.background = '#9c27b0'; // Purple for terminal
            } else {
                nextBtn.textContent = 'Log Entry';
                nextBtn.style.background = ''; // Default color
            }
        }
        // Make sure the wizard data has the txData
        if (!window.hopWizardData.txData) {
            window.hopWizardData.txData = txData;
        }
    }

    // Update Step 3 buttons if we're in Step 3
    if (window.hopWizardData && (window.hopWizardData.currentStep === 3 || window.hopWizardData.step === 3) && window.updateStep3Buttons) {
        window.hopWizardData.txHash = txHash; // Store the hash
        window.updateStep3Buttons();
    }

    } catch (error) {
        console.error('Transaction lookup error:', error);

        // Check if wizardData was lost
        if (!window.hopWizardData) {
            resultDiv.innerHTML = `
                <div style="background: #f8d7da; border: 1px solid #f5c6cb; border-radius: 8px; padding: 15px;">
                    <strong>❌ Session Error</strong><br>
                    The wizard session was lost. Please close this wizard and start again.<br>
                    <button class="btn btn-secondary" onclick="closeHopWizard()" style="margin-top: 10px;">Close Wizard</button>
                </div>
            `;
        } else {
            let errorMessage = error.message || 'Unknown error occurred';
            let suggestions = '';

            if (error.name === 'AbortError' || errorMessage.includes('timeout')) {
                errorMessage = 'Transaction lookup timed out';
                suggestions = '<br><small>• Check your internet connection<br>• The blockchain API may be slow<br>• Try again in a few moments</small>';
            } else if (errorMessage.includes('HTTP 429')) {
                errorMessage = 'API rate limit exceeded';
                suggestions = '<br><small>• Wait a few seconds before retrying<br>• The API has temporary limits</small>';
            } else if (errorMessage.includes('HTTP 404')) {
                errorMessage = 'Transaction not found';
                suggestions = '<br><small>• Verify the transaction hash is correct<br>• The transaction may not be confirmed yet</small>';
            } else if (errorMessage.includes('Failed to fetch')) {
                errorMessage = 'Network connection error';
                suggestions = '<br><small>• Check your internet connection<br>• The blockchain API may be unavailable</small>';
            }

            resultDiv.innerHTML = `
                <div style="background: #f8d7da; border: 1px solid #f5c6cb; border-radius: 8px; padding: 15px;">
                    <strong>❌ Lookup Failed</strong><br>
                    ${errorMessage}
                    ${suggestions}
                </div>
            `;
        }
    }
}

function toggleWizardOutput(index) {
    const wizardData = window.hopWizardData;
    if (!wizardData) {
        console.error('Wizard data not available in toggleWizardOutput');
        return;
    }

    const checkbox = document.getElementById(`wizardOutputSelect_${index}`);

    if (!wizardData.selectedOutputs) {
        wizardData.selectedOutputs = [];
    }
    
    if (checkbox.checked) {
        if (!wizardData.selectedOutputs.includes(index)) {
            wizardData.selectedOutputs.push(index);
        }
    } else {
        wizardData.selectedOutputs = wizardData.selectedOutputs.filter(i => i !== index);
    }
    
    updateWizardOutputSummary();
}

function classifyWizardOutput(index, type) {
    if (!window.hopWizardData) {
        console.error('Wizard data not available in classifyWizardOutput');
        return;
    }
    window.hopWizardData.outputClassifications[index] = type;
    
    // Auto-check/uncheck based on classification
    const checkbox = document.getElementById(`wizardOutputSelect_${index}`);
    if (type === 'ignore') {
        checkbox.checked = false;
        toggleWizardOutput(index);
    } else if (!checkbox.checked) {
        checkbox.checked = true;
        toggleWizardOutput(index);
    }
    
    updateWizardOutputSummary();
}

function updateWizardOutputSummary() {
    const wizardData = window.hopWizardData;
    const summaryDiv = document.getElementById('wizardOutputSummary');
    if (!summaryDiv) return;
    
    const selectedOutputs = wizardData.selectedOutputs || [];
    const transfers = wizardData.pendingTransfers || [];
    
    if (selectedOutputs.length === 0) {
        summaryDiv.innerHTML = '<em style="color: #666;">No outputs selected</em>';
        return;
    }
    
    let paymentCount = 0;
    let changeCount = 0;
    let totalAmount = {};
    
    selectedOutputs.forEach(index => {
        const transfer = transfers[index];
        const classification = wizardData.outputClassifications[index];
        
        if (classification === 'payment') paymentCount++;
        if (classification === 'change') changeCount++;
        
        if (!totalAmount[transfer.currency]) {
            totalAmount[transfer.currency] = 0;
        }
        totalAmount[transfer.currency] += transfer.amount;
    });
    
    summaryDiv.innerHTML = `
        <div style="color: #27ae60;">✓ ${paymentCount} Payment${paymentCount !== 1 ? 's' : ''}</div>
        <div style="color: #ff9800;">↻ ${changeCount} Change Output${changeCount !== 1 ? 's' : ''}</div>
        <div style="margin-top: 5px; font-weight: bold;">
            Total: ${Object.entries(totalAmount).map(([curr, amt]) => `${amt} ${curr}`).join(' + ')}
        </div>
    `;
}

function confirmWizardOutputSelection() {
    const wizardData = window.hopWizardData;
    const selectedOutputs = wizardData.selectedOutputs || [];
    
    if (selectedOutputs.length === 0) {
        alert('Please select at least one output to track');
        return;
    }
    
    // Store the selected outputs info for creating multiple entries
    wizardData.multipleOutputs = selectedOutputs.map(index => {
        const transfer = wizardData.pendingTransfers[index];
        const classification = wizardData.outputClassifications[index];
        
        return {
            ...transfer,
            classification: classification,
            isChange: classification === 'change'
        };
    });
    
    // Clear the selection UI and show summary
    const resultDiv = document.getElementById('wizardTxResult');
    resultDiv.innerHTML = `
        <div style="background: #e8f4f8; border: 1px solid #3498db; border-radius: 8px; padding: 15px;">
            <h4 style="margin-top: 0;">✅ ${selectedOutputs.length} Output${selectedOutputs.length !== 1 ? 's' : ''} Selected</h4>
            <div style="margin-top: 10px;">
                ${wizardData.multipleOutputs.map((output, i) => `
                    <div style="padding: 8px; background: white; border-radius: 4px; margin: 5px 0;">
                        <strong>${i + 1}.</strong> ${output.amount} ${output.currency} → 
                        <span style="font-family: monospace; font-size: 11px;">${output.to.slice(0, 8)}...</span>
                        <span style="color: ${output.isChange ? '#ff9800' : '#27ae60'}; margin-left: 10px;">
                            (${output.isChange ? 'CHANGE' : 'PAYMENT'})
                        </span>
                    </div>
                `).join('')}
            </div>
        </div>
    `;
    
    document.getElementById('wizardNextBtn').disabled = false;

    // Update Step 3 buttons if we're in Step 3
    if (window.hopWizardData && (window.hopWizardData.currentStep === 3 || window.hopWizardData.step === 3) && window.updateStep3Buttons) {
        window.updateStep3Buttons();
    }
}

// Keep the old function for backward compatibility but update it
function selectWizardTransfer(index) {
    // This function is now replaced by the multi-select system
    // Convert single selection to multi-select format
    window.hopWizardData.selectedOutputs = [index];
    window.hopWizardData.outputClassifications = { [index]: 'payment' };
    confirmWizardOutputSelection();
}

// [REMOVED: createSwapEntryFromWizard function - redundant with createSwapEntry()]
// The dedicated swap wizard's createSwapEntry function is used instead

function updateThreadsAfterSwap(hop, swapEntry) {
    // This function updates the available threads to reflect the currency conversion
    // Now handles partial swaps - leaving remainder in original thread

    if (!investigation.availableThreads) {
        investigation.availableThreads = {};
    }

    const swapDetails = swapEntry.swapDetails;

    // Handle partial swaps - update or remove source threads based on amounts used
    if (swapEntry.partialSwaps && swapEntry.partialSwaps.length > 0) {
        // Process each partial swap
        swapEntry.partialSwaps.forEach(partial => {
            if (investigation.availableThreads[swapDetails.fromCurrency] &&
                investigation.availableThreads[swapDetails.fromCurrency][partial.threadId]) {

                // Update the original thread to only have the remaining amount
                const thread = investigation.availableThreads[swapDetails.fromCurrency][partial.threadId];
                thread.totalAmount = partial.remainingAmount;

                // If remaining amount is very small (dust), remove the thread
                if (partial.remainingAmount < 0.0001) {
                    delete investigation.availableThreads[swapDetails.fromCurrency][partial.threadId];
                }
            }
        });
    } else {
        // Full swap - remove the old currency threads completely
        if (swapEntry.sourceThreadId) {
            // Single source
            if (investigation.availableThreads[swapDetails.fromCurrency]) {
                delete investigation.availableThreads[swapDetails.fromCurrency][swapEntry.sourceThreadId];
            }
        } else if (swapEntry.multipleSourceThreads) {
            // Multiple sources - remove all
            swapEntry.multipleSourceThreads.forEach(threadId => {
                if (investigation.availableThreads[swapDetails.fromCurrency]) {
                    delete investigation.availableThreads[swapDetails.fromCurrency][threadId];
                }
            });
        }
    }

    // Create new thread(s) in the output currency
    if (!investigation.availableThreads[swapDetails.toCurrency]) {
        investigation.availableThreads[swapDetails.toCurrency] = {};
    }

    // Use the SAME thread ID as the source (no swap suffix)
    const newThreadId = swapEntry.sourceThreadId ||
        (swapEntry.multipleSourceThreads ? swapEntry.multipleSourceThreads.join('+') : null);

    if (!newThreadId) return;

    // Get chain info from the swap entry or inherit from source thread
    let chainId = swapEntry.chain || null;
    let chainName = null;

    // If this is a bridge, use the destination chain
    if (swapDetails.toChain) {
        chainId = swapDetails.toChain;
        chainName = window.blockchainAPIs?.[swapDetails.toChain]?.name || swapDetails.toChain;
    } else if (!chainId && swapEntry.sourceThreadId) {
        // Try to inherit from source thread
        const sourceThreadData = getThreadByNotation(swapEntry.sourceThreadId);
        if (sourceThreadData) {
            chainId = sourceThreadData.chainId || null;
            chainName = sourceThreadData.chainName || null;
        }
    }

    // Create the thread with SAME ID in the output currency
    investigation.availableThreads[swapDetails.toCurrency][newThreadId] = {
        threadId: newThreadId,
        totalAmount: swapDetails.toAmount,
        availableAmount: swapDetails.toAmount, // Important: include availableAmount
        currency: swapDetails.toCurrency,
        sourceWallet: swapEntry.toWallet, // DEX/CEX address becomes the source for the new thread
        sourceType: 'swap_output',
        hopLevel: hop.hopNumber,
        swapConverted: true,
        originalCurrency: swapDetails.fromCurrency,
        partialSwap: swapEntry.partialSwaps && swapEntry.partialSwaps.length > 0,
        isActive: true,
        assignments: [],
        swapDetails: {
            fromCurrency: swapDetails.fromCurrency,
            fromAmount: swapDetails.fromAmount,
            toCurrency: swapDetails.toCurrency,
            toAmount: swapDetails.toAmount,
            provider: swapDetails.providerName || 'Unknown'
        },
        // Chain tracking
        chainId: chainId,
        chainName: chainName
    };

    console.log(`Created swap output thread ${newThreadId} with ${swapDetails.toAmount} ${swapDetails.toCurrency}`);
}

function createSingleHopEntry(hop, wizardData, output, outputIndex) {
    // Handle change outputs - create a same-hop thread (like swaps)
    if (output.isChange) {
        console.log(`Processing change output: ${output.amount} ${output.currency} to ${output.to}`);

        // Create a change entry that generates a same-hop thread
        // This works like a swap - consumes source thread and creates new thread at same hop level

        // Generate the base notation for the change thread
        let changeNotation = '';
        if (wizardData.selectedThreads.length === 1) {
            const baseNotation = wizardData.selectedThreads[0];
            // Change threads stay at same hop level (no -H increment)
            // Extract the base V-T notation without hop
            const vtMatch = baseNotation.match(/^(V\d+-T[\d,]+)/);
            if (vtMatch) {
                changeNotation = vtMatch[1];
                // If source already has hop, keep same hop level
                const hopMatch = baseNotation.match(/-H(\d+)/);
                if (hopMatch) {
                    changeNotation += `-H${hopMatch[1]}`;
                }
            } else {
                changeNotation = baseNotation;
            }
        } else {
            // Commingling - create combined notation
            const threadsByVictim = {};
            wizardData.selectedThreads.forEach(threadId => {
                const match = threadId.match(/V(\d+)-T([\d,]+)/);
                if (match) {
                    const victimId = match[1];
                    const transactionIds = match[2];
                    if (!threadsByVictim[victimId]) {
                        threadsByVictim[victimId] = [];
                    }
                    threadsByVictim[victimId].push(transactionIds);
                }
            });

            const notationParts = [];
            Object.keys(threadsByVictim).sort((a, b) => parseInt(a) - parseInt(b)).forEach(victimId => {
                const transactions = threadsByVictim[victimId].sort().join(',');
                notationParts.push(`(V${victimId}-T${transactions})`);
            });

            // For change, stay at current hop level (not incrementing)
            const currentHopLevel = hop.hopNumber - 1; // Since we're in hop N, threads come from hop N-1
            changeNotation = currentHopLevel > 0 ?
                `${notationParts.join(' ')} H${currentHopLevel}` :
                notationParts.join(' ');
        }

        // Create the change entry
        const changeEntry = {
            id: Date.now() + outputIndex + 1000, // Ensure unique ID
            hopNumber: hop.hopNumber,
            entryType: 'change', // New entry type for change addresses

            // Thread tracking
            sourceThreadInternalId: wizardData.selectedInternalIds && wizardData.selectedInternalIds.length === 1 ?
                wizardData.selectedInternalIds[0] : '',
            multipleSourceInternalIds: wizardData.selectedInternalIds && wizardData.selectedInternalIds.length > 1 ?
                wizardData.selectedInternalIds : [],
            sourceThreadId: wizardData.selectedThreads.length === 1 ? wizardData.selectedThreads[0] : '',
            multipleSourceThreads: wizardData.selectedThreads.length > 1 ? wizardData.selectedThreads : [],

            amount: output.amount.toString(),
            currency: output.currency || 'BTC',
            txHash: wizardData.txHash,
            fromWallet: output.from,
            toWallet: output.to,
            toWalletType: 'orange', // ORANGE for change addresses
            timestamp: wizardData.txData?.time ? new Date(wizardData.txData.time).toISOString() : new Date().toISOString(),
            timezone: 'UTC',
            notes: `Change output: ${output.amount} ${output.currency} sent to ${output.to}\nFunds remain trackable at same hop level (${changeNotation})`,
            notation: changeNotation,
            isChange: true,
            createsSameHopThread: true, // Flag to indicate this creates a same-hop thread
            chain: wizardData.detectedChain || wizardData.txData?.blockchain || null // Store chain info
        };

        // Add to hop entries
        hop.entries.push(changeEntry);

        // The thread will be created by updateThreadAvailabilityFromHop
        // but we need to ensure it's created at the same hop level
        console.log(`Created change entry with notation ${changeNotation} at hop ${hop.hopNumber}`);

        // Don't return - continue to process other outputs
        // But skip the rest of this function for this output
        return;
    }

    // Calculate how much of the source amount goes to this output
    const totalSelectedAmount = Object.values(wizardData.allocations).reduce((sum, val) => sum + val, 0);
    const outputProportion = output.amount / wizardData.multipleOutputs.reduce((sum, o) => sum + o.amount, 0);
    const allocatedAmount = totalSelectedAmount * outputProportion;

    // Check if this is a swap (source currency differs from output currency)
    let isSwap = false;
    let swapDetails = null;
    const threads = getAvailableSourcesForHop(hop.hopNumber, null);
    const sourceCurrencies = new Set();
    wizardData.selectedThreads.forEach(threadId => {
        const thread = threads.find(t => t.threadId === threadId);
        if (thread) sourceCurrencies.add(thread.currency);
    });

    if (sourceCurrencies.size === 1) {
        const sourceCurrency = Array.from(sourceCurrencies)[0];
        if (output.currency && sourceCurrency !== output.currency) {
            isSwap = true;
            swapDetails = {
                fromCurrency: sourceCurrency,
                toCurrency: output.currency,
                type: 'DEX'
            };
        }
    }

    // Generate thread notation
    let notation = '';
    if (wizardData.selectedThreads.length === 1) {
        const baseNotation = wizardData.selectedThreads[0];
        // For change outputs, add -C suffix
        notation = output.isChange ? `${baseNotation}-C` : baseNotation;
    } else {
        // Commingling notation using parentheses format
        const threadsByVictim = {};
        wizardData.selectedThreads.forEach(threadId => {
            const match = threadId.match(/V(\d+)-T([\d,]+)/);
            if (match) {
                const victimId = match[1];
                const transactionIds = match[2];
                if (!threadsByVictim[victimId]) {
                    threadsByVictim[victimId] = [];
                }
                threadsByVictim[victimId].push(transactionIds);
            }
        });

        const notationParts = [];
        Object.keys(threadsByVictim).sort((a, b) => parseInt(a) - parseInt(b)).forEach(victimId => {
            const transactions = threadsByVictim[victimId].sort().join(',');
            notationParts.push(`(V${victimId}-T${transactions})`);
        });
        notation = `${notationParts.join(' ')} H${hop.hopNumber}`;
        if (output.isChange) notation += '-C';
    }

    // Add swap notation if applicable
    if (isSwap && swapDetails) {
        notation += ` [SWAP: ${swapDetails.fromCurrency} → ${swapDetails.toCurrency}]`;
    }

    // Determine wallet type
    let toWalletType = 'black';
    let exchangeAttribution = null;

    // First check if we have detected attribution for this address
    if (wizardData.detectedAttribution && output.to &&
        output.to.toLowerCase() === wizardData.txData.to.toLowerCase()) {
        exchangeAttribution = wizardData.detectedAttribution;
        toWalletType = 'purple'; // PURPLE for exchanges/VASPs
        console.log(`🟣 Using detected terminal wallet: ${exchangeAttribution.name || exchangeAttribution.label}`);
    }
    // Fallback: Check if destination is a known exchange (synchronous check)
    else if (output.to) {
        const attribution = checkExchangeAttribution(output.to);
        if (attribution) {
            exchangeAttribution = attribution;
            toWalletType = 'purple'; // PURPLE for exchanges/VASPs
            if (attribution.isPersonalLabel) {
                console.log(`🏷️ Personal label found: ${attribution.name}`);
            } else {
                console.log(`🟣 Terminal wallet detected: ${exchangeAttribution.name}`);
            }
        }
    }

    // Override with specific types if needed (only if not an exchange)
    if (!exchangeAttribution) {
        if (isSwap) {
            toWalletType = 'brown'; // BROWN for asset conversion/swap
        } else if (output.isChange) {
            toWalletType = 'orange'; // ORANGE for change
        }
    }

    // Create the entry with dual-layer support
    const entry = {
        id: Date.now() + outputIndex, // Ensure unique IDs for multiple outputs
        hopNumber: hop.hopNumber,
        entryType: 'trace',

        // Dual-layer thread tracking
        // Store internal IDs for precise tracking
        sourceThreadInternalId: wizardData.selectedInternalIds && wizardData.selectedInternalIds.length === 1 ?
            wizardData.selectedInternalIds[0] : '',
        multipleSourceInternalIds: wizardData.selectedInternalIds && wizardData.selectedInternalIds.length > 1 ?
            wizardData.selectedInternalIds : [],

        // Keep notations for backward compatibility and display
        sourceThreadId: wizardData.selectedThreads.length === 1 ? wizardData.selectedThreads[0] : '',
        multipleSourceThreads: wizardData.selectedThreads.length > 1 ? wizardData.selectedThreads : [],

        // Update allocations to use internal IDs
        individualSourceAssignments: wizardData.selectedInternalIds && wizardData.selectedInternalIds.length > 1 ?
            Object.fromEntries(Object.entries(wizardData.allocations).map(([k, v]) => [k, v * outputProportion])) : {},

        amount: allocatedAmount.toString(),
        currency: output.currency,
        fromWallet: output.from,
        fromWalletType: 'black',
        toWallet: output.to,
        toWalletType: toWalletType,
        txHash: wizardData.txHash,
        timestamp: wizardData.txData ? new Date(wizardData.txData.time).toISOString().slice(0, 16) : '',
        timezone: 'UTC',
        chain: wizardData.detectedChain || wizardData.txData?.blockchain || null, // Store the chain!
        notes: exchangeAttribution ?
            `Terminal wallet: ${exchangeAttribution.name || exchangeAttribution.label}\nType: ${exchangeAttribution.type}\nAddress: ${output.to}${exchangeAttribution.source ? '\nDetection source: ' + exchangeAttribution.source : ''}` :
            isSwap ?
            `DEX Swap: ${swapDetails.fromCurrency} converted to ${swapDetails.toCurrency} at ${output.to}` :
            `Payment output ${outputIndex + 1} of ${wizardData.multipleOutputs.length}` +
            (wizardData.changeNotes && wizardData.changeNotes.length > 0 ? '\n' + wizardData.changeNotes.join('\n') : ''),
        notation: notation,
        isConvergence: wizardData.selectedThreads.length > 1,
        isChange: output.isChange,
        isSwap: isSwap,
        swapDetails: swapDetails
    };
    
    // Add exchange attribution to entry if detected
    if (exchangeAttribution) {
        entry.exchangeAttribution = exchangeAttribution;
    }

    hop.entries.push(entry);

    // If this is a terminal wallet, add to the terminal wallet index
    if (toWalletType === 'purple' && exchangeAttribution) {
        addToTerminalWalletIndex(entry);
        console.log('🟣 Added terminal wallet arrival to index');
    }

    // Mark entry as wizard-created for auto-collapse
    const entryKey = `${hop.hopNumber}_${entry.id}`;
    window.entryCollapseState = window.entryCollapseState || {};
    window.entryCollapseState[entryKey] = true; // Auto-collapse wizard entries

    console.log(`Created ${output.isChange ? 'CHANGE' : 'PAYMENT'} thread:`, notation, allocatedAmount, output.currency);
}

function validateThreadAllocation(threadId, requestedAmount, currency, excludeEntryId = null, excludeHopId = null) {
    // Validate that a thread assignment won't exceed available amounts
    const maxAvailable = getMaxAssignableAmount(threadId, currency, excludeEntryId, excludeHopId);
    const requested = parseAmount(requestedAmount);

    if (requested > maxAvailable) {
        return {
            valid: false,
            message: `Thread ${threadId} only has ${maxAvailable} ${currency} available, but ${requested} was requested.`,
            maxAvailable: maxAvailable
        };
    }

    return { valid: true };
}

// Function to write off all rounding remainders at once
function writeOffAllRoundingRemainders(hopNumber) {
    if (!hopNumber) {
        showNotification('Error: No hop number specified', 'error');
        return;
    }

    // Get all available threads for this hop
    const currentHopThreads = getAvailableSourcesForHop(hopNumber, null);

    // Filter to only rounding remainders
    const roundingThreads = currentHopThreads.filter(thread => {
        if (thread.availableAmount <= 0.01) return false;

        const original = thread.totalAmount || thread.availableAmount;
        const assigned = original - thread.availableAmount;
        const percentAssigned = original > 0 ? Math.round((assigned / original) * 100) : 0;

        return percentAssigned >= 99 && thread.availableAmount < (original * 0.01);
    });

    if (roundingThreads.length === 0) {
        showNotification('No rounding remainders to write off', 'warning');
        return;
    }

    // Group by currency
    const byCurrency = {};
    roundingThreads.forEach(thread => {
        if (!byCurrency[thread.currency]) {
            byCurrency[thread.currency] = [];
        }
        byCurrency[thread.currency].push(thread);
    });

    // Create a write-off entry for each currency
    Object.entries(byCurrency).forEach(([currency, threads]) => {
        const totalAmount = threads.reduce((sum, t) => sum + t.availableAmount, 0);
        const threadIds = threads.map(t => t.threadId).join(', ');

        // Create the write-off entry
        const entry = {
            id: Date.now() + '_' + Math.random().toString(36).substring(2, 9),
            type: 'writeoff',
            hopNumber: hopNumber,
            amount: totalAmount,
            currency: currency,
            sourceThreadIds: threads.map(t => t.internalId || t.threadId),
            sourceThreadNotations: threadIds,
            notes: `Rounding remainder write-off from ${threads.length} threads (each < 1% of original): ${threadIds}`,
            timestamp: new Date().toISOString(),
            isTerminal: true
        };

        // Add to hop entries
        const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
        if (hop) {
            if (!hop.entries) hop.entries = [];
            hop.entries.push(entry);

            // Update thread allocations
            threads.forEach(thread => {
                updateThreadAllocation(thread.internalId || thread.threadId, thread.availableAmount, currency);
            });

            console.log(`Created rounding write-off for ${totalAmount.toFixed(6)} ${currency} from ${threads.length} threads`);
        }
    });

    // Save and update UI
    saveToStorage();
    pushToUndoStack('Write off rounding remainders');
    updateUI();

    const totalThreads = roundingThreads.length;
    const currencies = Object.keys(byCurrency).join(', ');
    showNotification(`✅ Written off rounding remainders from ${totalThreads} threads (${currencies})`, 'success', 5000);
}

function createWriteoffEntryFromWizard() {
    const wizardData = window.hopWizardData;
    const hop = investigation.hops.find(h => h.hopNumber === wizardData.hopNumber);
    if (!hop) {
        console.error('Hop not found for write-off entry');
        return;
    }

    saveUndoState(`Create write-off entry in Hop ${hop.hopNumber}`);

    // Use the actual transaction amount if available, otherwise use allocations
    const actualTxAmount = wizardData.txData ? parseFloat(wizardData.txData.amount) : 0;
    const totalAmount = actualTxAmount > 0 ? actualTxAmount : Object.values(wizardData.allocations).reduce((sum, val) => sum + val, 0);

    // Get currency from transaction data or first thread
    const threads = getAvailableSourcesForHop(hop.hopNumber, null);
    const firstThreadId = wizardData.selectedThreads[0];
    const thread = threads.find(t => t.threadId === firstThreadId);
    const currency = wizardData.txData?.currency || (thread ? thread.currency : 'USD');

    // Adjust allocations to use actual transaction amount
    const adjustedAllocations = {};
    if (actualTxAmount > 0 && wizardData.selectedThreads.length === 1) {
        // For single thread, use the actual transaction amount
        adjustedAllocations[wizardData.selectedThreads[0]] = totalAmount;
    } else if (actualTxAmount > 0 && wizardData.selectedThreads.length > 1) {
        // For multiple threads, proportionally adjust based on transaction amount
        const allocationTotal = Object.values(wizardData.allocations).reduce((sum, val) => sum + val, 0);
        for (const [threadId, allocation] of Object.entries(wizardData.allocations)) {
            adjustedAllocations[threadId] = (allocation / allocationTotal) * totalAmount;
        }
    } else {
        // No transaction data, use original allocations
        Object.assign(adjustedAllocations, wizardData.allocations);
    }

    // Create write-off entry
    const writeoffEntry = {
        id: Date.now(),
        hopNumber: hop.hopNumber,
        entryType: 'writeoff',
        txHash: wizardData.txHash || '',
        amount: totalAmount.toString(),
        currency: currency === 'CUSTOM' ? 'CUSTOM' : currency,
        customCurrency: currency === 'CUSTOM' ? currency : '',
        category: wizardData.writeoffCategory || 'minimal_amount',
        justification: wizardData.writeoffNotes || `Amount too small to track: ${totalAmount.toLocaleString()} ${currency}`,
        notes: wizardData.manualData?.notes || '',

        // Thread allocation data with adjusted amounts
        sourceThreadId: wizardData.selectedThreads.length === 1 ? wizardData.selectedThreads[0] : '',
        multipleSourceThreads: wizardData.selectedThreads.length > 1 ? wizardData.selectedThreads : null,
        individualSourceAssignments: adjustedAllocations,

        // Transaction details if available
        fromWallet: '',
        toWallet: wizardData.txData?.to || wizardData.manualData?.toWallet || '',
        timestamp: wizardData.txData ? new Date(wizardData.txData.time).toISOString().slice(0, 16) :
                   wizardData.manualData?.timestamp || new Date().toISOString().slice(0, 16),

        // Auto-calculate notation
        victimNumbers: '',
        transactionNumbers: '',
        notation: '',

        // Finalize immediately since it's a write-off
        isFinalized: true
    };

    // Get from wallet from source threads
    if (wizardData.selectedThreads.length === 1) {
        const sourceThread = threads.find(t => t.threadId === wizardData.selectedThreads[0]);
        writeoffEntry.fromWallet = sourceThread ? sourceThread.sourceWallet : '';
    } else if (wizardData.selectedThreads.length > 1) {
        writeoffEntry.fromWallet = 'Multiple Sources';
    }

    // Build source chain from selected threads
    const sourceChain = wizardData.selectedThreads.map(threadId => {
        const thread = threads.find(t => t.threadId === threadId);
        return {
            threadId: threadId,
            amount: wizardData.allocations[threadId] || 0,
            currency: thread ? thread.currency : currency
        };
    });
    writeoffEntry.sourceChain = sourceChain;

    // Calculate victim and transaction numbers
    const victimNums = new Set();
    const transNums = new Set();
    wizardData.selectedThreads.forEach(threadId => {
        const match = threadId.match(/V(\d+)-T(\d+)/);
        if (match) {
            victimNums.add(match[1]);
            transNums.add(match[2]);
        }
    });
    writeoffEntry.victimNumbers = Array.from(victimNums).join(',');
    writeoffEntry.transactionNumbers = Array.from(transNums).join(',');

    // Generate notation with WO suffix
    writeoffEntry.notation = `V${writeoffEntry.victimNumbers}-T${writeoffEntry.transactionNumbers}-H${hop.hopNumber}-WO`;
    writeoffEntry.generatedNotation = writeoffEntry.notation;

    // Add entry to hop
    hop.entries.push(writeoffEntry);

    // Close wizard
    closeHopWizard();

    // Rebuild and render
    buildAvailableThreadsIndex();
    renderHops();
    saveToStorage();

    // Do NOT show remaining threads summary for write-offs - it can trigger reopening the wizard
    // The alert below is sufficient

    // Calculate remaining balance in source thread
    let remainingBalance = 'N/A';
    if (wizardData.selectedThreads.length === 1) {
        const sourceThread = threads.find(t => t.threadId === wizardData.selectedThreads[0]);
        if (sourceThread) {
            const originalAmount = sourceThread.amount || 0;
            remainingBalance = (originalAmount - totalAmount).toLocaleString();
        }
    }

    // Show confirmation
    const confirmMsg = `✅ Write-off entry created:\n\n` +
                       `Amount Written Off: ${totalAmount.toLocaleString()} ${currency}\n` +
                       `Transaction: ${wizardData.txHash || 'Not provided'}\n` +
                       `Category: ${wizardData.writeoffCategory || 'minimal_amount'}\n` +
                       `\nThe source thread has been reduced by ${totalAmount.toLocaleString()} ${currency}.\n` +
                       `Remaining traceable amount: ${remainingBalance} ${currency}`;

    // Collapse the entry BEFORE showing the alert
    const entryKey = `${hop.hopNumber}_${writeoffEntry.id}`;
    window.entryCollapseState = window.entryCollapseState || {};
    window.entryCollapseState[entryKey] = true;

    // Set a flag to prevent auto-reopening wizard after write-off
    window.justCreatedWriteoff = true;
    setTimeout(() => {
        window.justCreatedWriteoff = false;
    }, 1000);

    // Show confirmation
    alert(confirmMsg);

    // Ensure the entry is shown as collapsed in the UI
    setTimeout(() => {
        const entryContent = document.getElementById(`entryContent_${entryKey}`);
        const entrySummary = document.getElementById(`entrySummary_${entryKey}`);
        if (entryContent && entrySummary) {
            entryContent.style.display = 'none';
            entrySummary.style.display = 'block';
        }
    }, 50);
}

function createHopEntryFromWizard() {
    const wizardData = window.hopWizardData;
    const hop = investigation.hops.find(h => h.hopNumber === wizardData.hopNumber);
    if (!hop) {
        console.error('Hop not found for hopNumber:', wizardData.hopNumber);
        return;
    }

    // CRITICAL VALIDATION: Check for duplicate transaction hash in the same hop
    if (wizardData.txHash && !wizardData.isWriteoff) {
        const duplicateEntry = hop.entries.find(entry =>
            entry.txHash &&
            entry.txHash.toLowerCase() === wizardData.txHash.toLowerCase() &&
            entry.entryType !== 'writeoff'
        );

        if (duplicateEntry) {
            alert(`❌ Transaction hash already used in this hop!\n\nTransaction ${wizardData.txHash} is already logged in entry ${duplicateEntry.id} (${duplicateEntry.notation || 'unnamed'}).\n\nIf multiple threads move in the same transaction, they must all be logged in the same entry using multiple source thread selection.`);
            return;
        }
    }

    // Check if this is a write-off entry
    if (wizardData.isWriteoff) {
        console.log('Creating write-off entry from wizard');
        createWriteoffEntryFromWizard();
        return;
    }

    // Check if this is a swap transaction
    if (wizardData.isSwap && wizardData.swapDetails) {
        // Redirect to the dedicated swap wizard instead of using the old function
        console.log('Swap detected - redirecting to dedicated swap wizard');
        closeHopWizard();
        alert('Swap transaction detected! Please use "Add Entry" → "DEX/Asset Conversion" for proper swap tracking.');
        return;
    }

    // Check if we have multiple outputs to process
    if (wizardData.multipleOutputs && wizardData.multipleOutputs.length > 0) {
        // Create an entry for each selected output
        wizardData.multipleOutputs.forEach((output, index) => {
            createSingleHopEntry(hop, wizardData, output, index);
        });

        // Close wizard FIRST before re-rendering
        closeHopWizard();

        // Rebuild and render
        buildAvailableThreadsIndex();
        renderHops();
        saveToStorage();
        checkHopCompletionStatus(hop);

        // Ensure entries are collapsed (double-check after render)
        setTimeout(() => {
            wizardData.multipleOutputs.forEach((output, index) => {
                if (!output.isChange) { // Only for actual entries, not change
                    const entryId = Date.now() + index;
                    const entryKey = `${hop.hopNumber}_${entryId}`;
                    window.entryCollapseState[entryKey] = true;

                    // Force collapse if element exists
                    const entryElement = document.querySelector(`[id*="${entryKey}"]`);
                    if (entryElement) {
                        const content = entryElement.querySelector('.entry-content');
                        const summary = entryElement.querySelector('.entry-summary');
                        if (content) content.style.display = 'none';
                        if (summary) summary.style.display = 'block';
                    }
                }
            });
        }, 100);

        return; // Exit to prevent manual form from appearing
    }

    // Original single entry logic continues below...

    // Determine data source based on entry mode
    let fromWallet, toWallet, timestamp, currency, amount;

    // Get the transaction data if available
    const txData = wizardData.txData;

    if (wizardData.entryMode === 'manual') {
        // Get from wallet from the source thread(s)
        const threads = getAvailableSourcesForHop(hop.hopNumber, null);
        if (wizardData.selectedThreads.length === 1) {
            const thread = threads.find(t => t.threadId === wizardData.selectedThreads[0]);
            fromWallet = thread ? thread.sourceWallet : '';
        } else {
            // For multiple sources, use the first one or combine them
            fromWallet = 'Multiple Sources';
        }
        toWallet = wizardData.manualData?.toWallet || '';
        timestamp = wizardData.manualData?.timestamp || '';
    } else {
        fromWallet = wizardData.txData?.from || '';
        toWallet = wizardData.txData?.to || '';
        timestamp = wizardData.txData ? new Date(wizardData.txData.time).toISOString().slice(0, 16) : '';
    }
    
    // Validate thread allocations before proceeding
    const totalAmount = Object.values(wizardData.allocations).reduce((sum, val) => sum + val, 0);

    // Calculate total available across all selected threads
    const threads = getAvailableSourcesForHop(hop.hopNumber, null);
    let totalAvailable = 0;
    let currencies = new Set();

    wizardData.selectedThreads.forEach(threadId => {
        const thread = threads.find(t => t.threadId === threadId);
        if (thread) {
            totalAvailable += thread.availableAmount;
            currencies.add(thread.currency);
        }
    });

    // Allow partial allocation - cap at the available amount
    if (totalAmount > totalAvailable) {
        console.log(`Allocation exceeds available: Requested ${totalAmount}, Available ${totalAvailable}`);

        // Automatically adjust allocation to use all available funds
        const adjustmentRatio = totalAvailable / totalAmount;

        // First pass: Adjust each thread's allocation proportionally
        Object.keys(wizardData.allocations).forEach(threadId => {
            const originalAmount = wizardData.allocations[threadId];
            wizardData.allocations[threadId] = Math.floor(originalAmount * adjustmentRatio * 100) / 100; // Round down to 2 decimals
        });

        // Recalculate to see how much is left due to rounding
        let adjustedTotal = Object.values(wizardData.allocations).reduce((sum, val) => sum + val, 0);
        let remainder = totalAvailable - adjustedTotal;

        // Second pass: Distribute the remainder to ensure we use EXACTLY the available amount
        // Add the remainder to threads one by one until it's fully distributed
        if (remainder > 0.001) { // Only adjust if remainder is significant
            const threadIds = Object.keys(wizardData.allocations);
            let i = 0;
            while (remainder > 0.001 && i < threadIds.length) {
                const threadId = threadIds[i];
                const thread = threads.find(t => t.threadId === threadId || t.internalId === threadId);
                if (thread) {
                    // Add as much of the remainder as this thread can handle
                    const maxAddition = Math.min(remainder, thread.availableAmount - wizardData.allocations[threadId]);
                    if (maxAddition > 0) {
                        wizardData.allocations[threadId] = Math.round((wizardData.allocations[threadId] + maxAddition) * 100) / 100;
                        remainder -= maxAddition;
                    }
                }
                i++;
            }
        }

        // Final adjustment to ensure exact match (handle tiny rounding errors)
        adjustedTotal = Object.values(wizardData.allocations).reduce((sum, val) => sum + val, 0);
        if (Math.abs(adjustedTotal - totalAvailable) < 0.01 && adjustedTotal !== totalAvailable) {
            // Find the largest allocation and adjust it by the tiny difference
            const largestThread = Object.keys(wizardData.allocations).reduce((max, threadId) =>
                wizardData.allocations[threadId] > wizardData.allocations[max] ? threadId : max
            );
            wizardData.allocations[largestThread] = Math.round((wizardData.allocations[largestThread] + (totalAvailable - adjustedTotal)) * 100) / 100;
        }

        console.log(`Auto-adjusted allocations to ${totalAvailable} (from ${totalAmount})`);
        console.log('Adjusted allocations:', wizardData.allocations);

        // Update totalAmount to reflect the adjustment
        totalAmount = totalAvailable;

        // Note this partial allocation in the entry
        if (!wizardData.notes) wizardData.notes = '';
        wizardData.notes += `\n[Auto-adjusted: Allocated ${totalAvailable} of ${wizardData.txData?.amount || totalAmount} ${Array.from(currencies)[0]}]`;
    }

    // Check if mixing currencies (which shouldn't be allowed)
    if (currencies.size > 1 && !wizardData.isSwap) {
        alert(`⚠️ Currency Mismatch!\n\nYou cannot mix different currencies in a single entry unless it's a swap.\nCurrencies found: ${Array.from(currencies).join(', ')}\n\nPlease select threads with the same currency or use the swap wizard.`);
        return; // Hard block
    }

    // Check if this is partial tracing (transaction amount exceeds our allocation)
    let partialTraceNote = '';
    if (wizardData.txData && wizardData.txData.amount && wizardData.txData.amount > totalAmount) {
        // This is partial tracing - we're only following our portion
        partialTraceNote = `Partial trace: Following ${totalAmount} of ${wizardData.txData.amount} ${wizardData.txData.currency || ''} (transaction total)`;
        console.log('Partial trace detected:', partialTraceNote);
    }

    // Validate individual thread allocations don't exceed available amounts
    for (const [threadId, allocation] of Object.entries(wizardData.allocations)) {
        // Determine currency from the thread
        const threads = getAvailableSourcesForHop(hop.hopNumber, null);
        const thread = threads.find(t => t.threadId === threadId);
        if (thread) {
            const validation = validateThreadAllocation(
                threadId,
                allocation,
                thread.currency,
                wizardData.isEditMode ? wizardData.entryId : null,
                wizardData.isEditMode ? wizardData.hopNumber : null
            );

            if (!validation.valid) {
                alert(`⚠️ Allocation Error:\n\n${validation.message}\n\nPlease adjust the amount and try again.`);
                return; // Don't create the entry
            }
        }
    }

    // Check if we're in edit mode
    if (wizardData.isEditMode && wizardData.entryId) {
        // Update existing entry
        const existingEntry = hop.entries.find(e => e.id === wizardData.entryId);
        if (existingEntry) {
            saveUndoState(`Update trace entry in Hop ${hop.hopNumber}`);

            // Update the existing entry
            existingEntry.txHash = wizardData.txHash;
            existingEntry.fromWallet = fromWallet;
            existingEntry.toWallet = toWallet;
            existingEntry.toWalletType = wizardData.manualData?.walletType || existingEntry.toWalletType || 'black';
            existingEntry.timestamp = timestamp;
            existingEntry.amount = totalAmount.toString();
            existingEntry.sourceThreadId = wizardData.selectedThreads.length === 1 ? wizardData.selectedThreads[0] : '';
            existingEntry.multipleSourceThreads = wizardData.selectedThreads.length > 1 ? wizardData.selectedThreads : [];
            existingEntry.individualSourceAssignments = wizardData.selectedThreads.length > 1 ? wizardData.allocations : {};
            
            // Update currency if single source
            if (wizardData.selectedThreads.length === 1) {
                const source = getAvailableSourcesForHop(hop.hopNumber, null).find(t => t.threadId === wizardData.selectedThreads[0]);
                if (source) {
                    existingEntry.currency = source.currency;
                }
            }
            
            closeHopWizard();
            
            // Rebuild thread index to ensure available amounts are updated
            buildAvailableThreadsIndex();
            
            renderHops();
            saveToStorage();
            
            // Log the thread usage update
            console.log(`✅ Updated hop entry threads:`, wizardData.selectedThreads);
            console.log(`   Total amount: ${Object.values(wizardData.allocations).reduce((sum, val) => sum + val, 0)}`);
            console.log(`   Thread allocations:`, wizardData.allocations);
            
            // Scroll to the updated entry
            setTimeout(() => {
                const entryElement = document.getElementById(`entry_${hop.hopNumber}_${existingEntry.id}`);
                if (entryElement) {
                    entryElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    entryElement.style.border = '3px solid #27ae60';
                    setTimeout(() => {
                        entryElement.style.border = '';
                    }, 2000);
                }
            }, 100);
            
            return;
        }
    }
    
    // Apply Sequential Hop Rule for convergence
    let effectiveHopNumber = hop.hopNumber;
    let convergenceData = null;
    
    if (wizardData.selectedThreads.length > 1) {
        // This is a convergence - apply Sequential Hop Rule
        let maxSourceHopNumber = 0;
        wizardData.selectedThreads.forEach(threadId => {
            const threadMatch = threadId.match(/-H(\d+)$/);
            if (threadMatch) {
                const sourceHopNumber = parseInt(threadMatch[1]);
                maxSourceHopNumber = Math.max(maxSourceHopNumber, sourceHopNumber);
            }
        });
        
        if (investigation.tracingMethod === 'PIFO') {
            // Sequential Hop Rule: convergence output is at max source hop + 1
            effectiveHopNumber = maxSourceHopNumber + 1;
            
            convergenceData = {
                sourceCount: wizardData.selectedThreads.length,
                maxSourceHop: maxSourceHopNumber,
                sequentialHopRuleApplied: true
            };
            
            showNotification(
                `Sequential Hop Rule applied: Convergence of ${wizardData.selectedThreads.length} sources, output at hop ${effectiveHopNumber}`,
                'info'
            );
        }
    }
    
    // Determine currency from transaction data or source threads
    let entryCurrency = '';
    let isSwap = false;
    let swapDetails = null;

    // First check if we have transaction data with currency
    if (txData && txData.currency) {
        entryCurrency = txData.currency;
    }

    // Check if source threads have different currency than the transaction
    if (wizardData.selectedThreads.length === 1) {
        const sourceThread = getAvailableSourcesForHop(hop.hopNumber, null).find(t => t.threadId === wizardData.selectedThreads[0]);
        if (sourceThread) {
            if (!entryCurrency) {
                entryCurrency = sourceThread.currency;
            } else if (sourceThread.currency !== entryCurrency) {
                // This is a swap - source currency differs from transaction currency
                isSwap = true;
                swapDetails = {
                    fromCurrency: sourceThread.currency,
                    toCurrency: entryCurrency,
                    type: 'DEX'
                };
            }
        }
    } else if (wizardData.selectedThreads.length > 1) {
        // Multiple sources - check if they all have same currency
        const threads = getAvailableSourcesForHop(hop.hopNumber, null);
        const sourceCurrencies = new Set();
        wizardData.selectedThreads.forEach(threadId => {
            const thread = threads.find(t => t.threadId === threadId);
            if (thread) sourceCurrencies.add(thread.currency);
        });

        if (sourceCurrencies.size === 1) {
            const sourceCurrency = Array.from(sourceCurrencies)[0];
            if (!entryCurrency) {
                entryCurrency = sourceCurrency;
            } else if (sourceCurrency !== entryCurrency) {
                // Swap from single source currency to different output
                isSwap = true;
                swapDetails = {
                    fromCurrency: sourceCurrency,
                    toCurrency: entryCurrency,
                    type: 'DEX'
                };
            }
        }
    }

    // Generate notation based on selected threads
    let notation = '';
    if (wizardData.selectedThreads.length === 1) {
        // Extract base thread ID without hop suffix
        const threadId = wizardData.selectedThreads[0];
        const baseThread = threadId.match(/^(V\d+-T[\d,]+)/)?.[1] || threadId;
        notation = `${baseThread}-H${effectiveHopNumber}`;
    } else if (wizardData.selectedThreads.length > 1) {
        // For commingling, use parentheses format: (V1-T1) (V2-T1) H2
        // Group threads by victim
        const threadsByVictim = {};
        wizardData.selectedThreads.forEach(threadId => {
            // Parse thread ID like "V1-T2-H1" or "V1-T2"
            const match = threadId.match(/V(\d+)-T([\d,]+)/);
            if (match) {
                const victimId = match[1];
                const transactionIds = match[2];
                if (!threadsByVictim[victimId]) {
                    threadsByVictim[victimId] = [];
                }
                threadsByVictim[victimId].push(transactionIds);
            }
        });

        // Build notation with parentheses
        const notationParts = [];
        Object.keys(threadsByVictim).sort((a, b) => parseInt(a) - parseInt(b)).forEach(victimId => {
            const transactions = threadsByVictim[victimId].sort().join(',');
            notationParts.push(`(V${victimId}-T${transactions})`);
        });
        notation = `${notationParts.join(' ')} H${effectiveHopNumber}`;
    }

    // Add swap notation if applicable
    if (isSwap && swapDetails) {
        notation += ` [SWAP: ${swapDetails.fromCurrency} → ${swapDetails.toCurrency}]`;
    }

    // Determine wallet type - BROWN for swaps/DEX, otherwise use manual selection or default
    let toWalletType = 'black';
    if (isSwap) {
        toWalletType = 'brown'; // BROWN indicates asset conversion/DEX swap
    } else if (wizardData.manualData?.walletType) {
        toWalletType = wizardData.manualData.walletType;
    }

    // Calculate the amount to trace - limited by transaction amount if available
    let totalAllocated = Object.values(wizardData.allocations).reduce((sum, val) => sum + val, 0);
    let traceAmount = totalAllocated;

    // Adjust allocations if they exceed transaction amount
    if (wizardData.txData && wizardData.txData.amount) {
        const txAmount = wizardData.txData.amount;
        if (totalAllocated > txAmount) {
            console.log(`Limiting trace amount from ${totalAllocated} to transaction amount ${txAmount}`);
            traceAmount = txAmount;

            // Re-apply PIFO allocation with the correct amount instead of proportional reduction
            console.log(`Re-applying PIFO allocation for ${txAmount} across selected threads`);
            wizardData.allocations = applyPIFOAllocation(txAmount, wizardData.selectedThreads);

            // Log PIFO results
            const allocLog = [];
            for (const [threadId, amount] of Object.entries(wizardData.allocations)) {
                if (amount > 0) {
                    allocLog.push(`${threadId}: ${amount.toFixed(2)}`);
                }
            }
            console.log(`PIFO allocations applied:`, allocLog.join(', '));
        }
    }

    // Check if this is a terminal wallet
    let isTerminalWallet = false;
    let terminalAttribution = null;

    if (wizardData.isTerminalWallet || wizardData.terminalWalletType === 'purple') {
        isTerminalWallet = true;
        terminalAttribution = wizardData.detectedAttribution;
        toWalletType = 'purple';
    } else if (wizardData.detectedAttribution && toWallet &&
               toWallet.toLowerCase() === (wizardData.txData?.to || '').toLowerCase()) {
        // Auto-detect terminal wallet (only for actual exchanges, not personal labels)
        const attribution = wizardData.detectedAttribution;
        if (attribution && attribution.isExchange && !attribution.isPersonalLabel) {
            // This is a real exchange/service - mark as terminal wallet
            isTerminalWallet = true;
            terminalAttribution = attribution;
            toWalletType = 'purple';
        } else if (attribution && attribution.isPersonalLabel) {
            // This is just a personal label - add to notes but don't mark as terminal
            console.log('Personal label detected, not marking as terminal:', attribution.name);
            // The label will be added to notes below
        }
    }

    // Handle terminal wallet and attribution notes
    let entryNotes = wizardData.manualData?.notes || '';
    if (isTerminalWallet && terminalAttribution) {
        const terminalNote = `Terminal wallet: ${terminalAttribution.name || terminalAttribution.label}\nType: ${terminalAttribution.type || 'CEX'}\nDetection source: ${terminalAttribution.source || 'detected'}`;
        entryNotes = terminalNote + (entryNotes ? '\n' + entryNotes : '');
    } else if (wizardData.detectedAttribution && wizardData.detectedAttribution.isPersonalLabel) {
        // Add personal label to notes (not a terminal wallet)
        const labelNote = wizardData.detectedAttribution.noteText || `Label: ${wizardData.detectedAttribution.name}`;
        entryNotes = labelNote + (entryNotes ? '\n' + entryNotes : '');
    }

    if (isSwap) {
        entryNotes = `DEX Swap: ${swapDetails.fromCurrency} converted to ${swapDetails.toCurrency} at ${toWallet}` + (entryNotes ? '\n' + entryNotes : '');
    }
    if (partialTraceNote) {
        entryNotes += `\n${partialTraceNote}`;
    }
    if (wizardData.pifoNote) {
        entryNotes += `\n${wizardData.pifoNote}`;
    }

    // Create new entry with wizard data
    const entry = {
        id: hop.entries.length + 1,
        hopNumber: wizardData.hopNumber,
        hopNumber: effectiveHopNumber,
        entryType: 'trace',
        notation: notation,
        fromWallet: fromWallet,
        fromWalletType: hop.hopNumber === 1 ? 'red' : 'black',
        fromWalletId: '',
        toWallet: toWallet,
        toWalletType: toWalletType,
        toWalletId: '',
        amount: traceAmount.toString(),
        currency: entryCurrency,
        customCurrency: '',
        txHash: wizardData.txHash,
        timestamp: timestamp,
        timezone: 'UTC',
        notes: entryNotes,
        category: '',
        justification: '',
        // Swap tracking
        isSwap: isSwap,
        swapDetails: swapDetails,
        // Enhanced fields
        sourceChain: [],
        displayNotation: '',
        summaryNotation: '',
        victimNumbers: '',
        transactionNumbers: '',
        availableSourceAmount: 0,
        sourceThreadId: wizardData.selectedThreads.length === 1 ? wizardData.selectedThreads[0] : '',
        sourceThreadData: null,
        assignmentPercentage: 0,
        generatedNotation: '',
        isConvergence: wizardData.selectedThreads.length > 1,
        convergenceData: convergenceData,
        // New fields for multiple sources
        multipleSourceThreads: wizardData.selectedThreads.length > 1 ? wizardData.selectedThreads : [],
        // IMPORTANT: For single source, also store allocation in individualSourceAssignments
        individualSourceAssignments: wizardData.selectedThreads.length > 1 ? wizardData.allocations :
            wizardData.selectedThreads.length === 1 ? {[wizardData.selectedThreads[0]]: traceAmount} : {}
    };

    // Add terminal wallet attribution if present
    if (isTerminalWallet && terminalAttribution) {
        entry.exchangeAttribution = terminalAttribution;
        entry.isTerminalWallet = true;

        // For terminal wallets, we use the allocated amounts (not the full thread amounts)
        // The allocations already respect the transaction amount limits
        console.log(`Terminal wallet entry created with allocated amounts:`, entry.individualSourceAssignments);

        // Just log what we're using - don't modify the allocations
        if (entry.individualSourceAssignments) {
            Object.entries(entry.individualSourceAssignments).forEach(([threadId, amount]) => {
                console.log(`Terminal wallet: Using allocated amount ${amount} from thread ${threadId}`);
            });
        }
    }

    // Store internal IDs for proper thread tracking (especially for terminal exhaustion)
    if (wizardData.selectedInternalIds && wizardData.selectedInternalIds.length > 0) {
        entry.sourceThreadIds = wizardData.selectedInternalIds;
        entry.multipleSourceInternalIds = wizardData.selectedInternalIds;
    } else {
        // Fallback to thread notations if internal IDs not available
        entry.sourceThreadIds = wizardData.selectedThreads || [];
    }

    // Save undo state
    saveUndoState(`Add trace entry to Hop ${hop.hopNumber}`);

    hop.entries.push(entry);

    // If this is a terminal wallet, add to the terminal wallet index
    if (isTerminalWallet && terminalAttribution) {
        addToTerminalWalletIndex(entry);
        console.log('🟣 Added terminal wallet arrival to index');
    }

    // Handle remainder thread creation for terminal wallets
    if (isTerminalWallet && totalAllocated > traceAmount) {
        const remainderAmount = totalAllocated - traceAmount;
        console.log(`Creating remainder thread for untraced amount: ${remainderAmount} ${entryCurrency}`);

        // For each source thread that contributed, create a remainder thread
        for (const threadId in wizardData.allocations) {
            const originalAllocation = wizardData.allocations[threadId];
            const usedAmount = originalAllocation * (traceAmount / totalAllocated);
            const threadRemainder = originalAllocation - usedAmount;

            if (threadRemainder > 0.01) { // Only create remainder if significant
                // The remainder stays at the current hop level for future tracing
                console.log(`Thread ${threadId}: Used ${usedAmount}, Remainder ${threadRemainder}`);

                // Update the available threads database to reflect the partial use
                // The buildAvailableThreadsIndex() call later will handle this
            }
        }
    }

    // Mark entry for auto-collapse BEFORE sorting
    const entryKey = `${hop.hopNumber}_${entry.id}`;
    window.entryCollapseState = window.entryCollapseState || {};
    window.entryCollapseState[entryKey] = true;

    // Store the original entry reference before sorting
    const newEntry = entry;

    // Sort entries by timestamp to maintain chronological order
    sortHopEntriesChronologically(hop);

    // Find the entry's new ID after sorting
    const sortedEntryIndex = hop.entries.indexOf(newEntry);
    const sortedEntryId = sortedEntryIndex >= 0 ? hop.entries[sortedEntryIndex].id : entry.id;

    // Update collapse state with sorted ID if different
    if (sortedEntryId !== entry.id) {
        const sortedEntryKey = `${hop.hopNumber}_${sortedEntryId}`;
        window.entryCollapseState[sortedEntryKey] = true;
    }

    // Close wizard BEFORE re-rendering
    closeHopWizard();

    // Rebuild thread index to ensure available amounts are updated
    buildAvailableThreadsIndex();

    // Render with collapsed state already set
    renderHops();
    saveToStorage();

    // Check if hop is now fully accounted for
    checkHopCompletionStatus(hop);

    // Log the thread usage
    console.log(`✅ Created hop entry consuming threads:`, wizardData.selectedThreads);
    console.log(`   Total amount used: ${Object.values(wizardData.allocations).reduce((sum, val) => sum + val, 0)}`);
    console.log(`   Thread allocations:`, wizardData.allocations);

    // Show progress indicator in hop header instead of modal
    updateHopProgressIndicator(hop);

    // Brief highlight animation to show where entry was created
    setTimeout(() => {
        const finalEntryKey = `${hop.hopNumber}_${sortedEntryId}`;
        const entryElement = document.getElementById(`entry_${hop.hopNumber}_${sortedEntryId}`);

        if (entryElement) {
            // Ensure it's collapsed (double-check)
            const content = document.getElementById(`entryContent_${finalEntryKey}`);
            const summary = document.getElementById(`entrySummary_${finalEntryKey}`);

            if (content && summary) {
                content.style.display = 'none';
                summary.style.display = 'block';
            }

            // Scroll to the new entry
            entryElement.scrollIntoView({ behavior: 'smooth', block: 'center' });

            // Add a temporary highlight effect
            entryElement.style.transition = 'box-shadow 0.5s ease';
            entryElement.style.boxShadow = '0 0 10px rgba(76, 175, 80, 0.5)';
            setTimeout(() => {
                entryElement.style.boxShadow = '';
            }, 2000);
        }
    }, 100);

    // Show remaining threads summary after wizard completion
    showRemainingThreadsSummary(hop);

    // Return to prevent any further processing that might open forms
    return;
}
// Calculate remaining ART for write-offs
function calculateRemainingARTForHop(hopNumber, currency) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    if (!hop) return 0;
    
    // Get the starting ART for this hop
    const startingART = hop.artAtStartByCurrency || {};
    const artForCurrency = startingART[currency] || 0;
    
    // Calculate total traced/written off so far in this hop
    let totalAllocated = 0;
    hop.entries.forEach(entry => {
        const entryCurrency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
        if (entryCurrency === currency && parseFloat(entry.amount) > 0) {
            totalAllocated += parseFloat(entry.amount);
        }
    });
    
    const remaining = artForCurrency - totalAllocated;
    console.log(`Hop ${hop.hopNumber} ${currency}: Starting ART ${artForCurrency}, Allocated ${totalAllocated}, Remaining ${remaining}`);
    
    return Math.max(0, remaining); // Don't return negative
}

// Auto-fill max write-off amount
function assignMaxWriteoffAmount(hopNumber, entryId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    
    if (entry.entryType !== 'writeoff') {
        alert('This function is only for write-off entries.');
        return;
    }
    
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    const remainingART = calculateRemainingARTForHop(hopNumber, currency);
    
    if (remainingART <= 0) {
        alert(`No remaining ${currency} to write off in this hop.`);
        return;
    }
    
    entry.amount = remainingART.toString();
    
    const amountInput = document.getElementById(`writeoffAmount_${hopNumber}_${entryId}`);
    if (amountInput) {
        amountInput.value = remainingART;
    }
    
    updateWriteoffPreview(hopNumber, entryId);
    saveToStorage();
    
    // Re-render hops to update validation
    renderHops();
}

// Update write-off preview with balance information
function updateWriteoffPreview(hopNumber, entryId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    const previewElement = document.getElementById(`writeoffPreview_${hopNumber}_${entryId}`);
    
    if (!previewElement || entry.entryType !== 'writeoff') {
        return;
    }
    
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    const amount = parseFloat(entry.amount) || 0;
    const remainingART = calculateRemainingARTForHop(hopNumber, currency);
    const afterWriteoff = remainingART - amount;
    
    let previewHTML = '';
    if (amount > 0) {
        const isValid = amount <= remainingART;
        previewHTML = `
            <div style="background: #f8f9fa; border: 1px solid #ddd; border-radius: 4px; padding: 10px; margin-top: 10px;">
                <div style="font-weight: bold; margin-bottom: 8px; color: #2c3e50;">Write-off Impact:</div>
                <div style="font-size: 12px; color: #666; margin-bottom: 5px;">
                    Remaining ART before write-off: ${remainingART.toLocaleString()} ${currency}
                </div>
                <div style="color: ${isValid ? '#27ae60' : '#e74c3c'}; font-weight: bold;">
                    ${isValid ? '✓' : '⚠'} Writing off: ${amount.toLocaleString()} ${currency}
                </div>
                ${isValid ? `
                    <div style="font-size: 12px; color: #666; margin-top: 5px;">
                        Remaining after write-off: ${afterWriteoff.toLocaleString()} ${currency}
                        ${afterWriteoff === 0 ? ' <span style="color: #27ae60; font-weight: bold;">(Fully balanced!)</span>' : ''}
                    </div>
                ` : `
                    <div style="font-size: 12px; color: #e74c3c; margin-top: 5px;">
                        Cannot write off more than remaining ART!
                    </div>
                `}
            </div>
        `;
    }
    
    previewElement.innerHTML = previewHTML;
}

// Get suggested write-off categories with descriptions
function getSuggestedWriteoffCategory(amount, currency) {
    if (amount < 50) {
        return {
            category: 'dust',
            suggestion: 'Dust - Below practical threshold',
            description: `Amount of ${amount.toLocaleString()} ${currency} is below the typical investigation threshold of $50.`
        };
    } else if (amount < 500) {
        return {
            category: 'operational',
            suggestion: 'Operational - Resource constraints',
            description: `Small amount of ${amount.toLocaleString()} ${currency} may not justify continued investigation resources.`
        };
    } else {
        return {
            category: 'dilution',
            suggestion: 'Dilution - Too diluted to trace',
            description: `Amount may have become too diluted in larger transactions to trace effectively.`
        };
    }
}

// Enhanced write-off section renderer
function renderWriteoffSection(entry) {
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    const amount = parseFloat(entry.amount) || 0;
    const suggestion = amount > 0 ? getSuggestedWriteoffCategory(amount, currency) : null;
    
    return `
        <div class="form-group">
            <label>Write-off Amount</label>
            <div style="display: flex; gap: 10px; align-items: center;">
                <input type="number" step="0.01" 
                       id="writeoffAmount_${hop.hopNumber}_${entry.id}"
                       value="${entry.amount || ''}"
                       onchange="updateWriteoffAmount(${hop.hopNumber}, ${entry.id}, this.value)">
                <button type="button" class="btn btn-secondary" 
                        onclick="assignMaxWriteoffAmount(${hop.hopNumber}, ${entry.id})">
                    Max (Balance ART)
                </button>
            </div>
            <div id="writeoffPreview_${hop.hopNumber}_${entry.id}" 
                 style="font-size: 12px; margin-top: 5px;"></div>
        </div>
        
        <div class="form-group">
            <label>Write-off Category</label>
            <select onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'category', this.value)">
                <option value="">Select category...</option>
                ${Object.entries(writeoffCategories).map(([key, value]) => 
                    `<option value="${key}" ${entry.category === key ? 'selected' : ''}>${value}</option>`
                ).join('')}
            </select>
            ${suggestion ? `
                <div style="margin-top: 8px; padding: 8px; background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px; font-size: 12px;">
                    <strong>💡 Suggestion:</strong> ${suggestion.suggestion}<br>
                    <small style="color: #666;">${suggestion.description}</small>
                </div>
            ` : ''}
        </div>
        
        <div class="form-group" style="grid-column: span 2;">
            <label>Justification</label>
            <textarea rows="3" 
                      placeholder="Detailed explanation for abandoning this trace path. Example: Amount too small to justify continued investigation resources..." 
                      onchange="updateHopEntry(${hop.hopNumber}, ${entry.id}, 'justification', this.value)">${entry.justification || ''}</textarea>
            ${suggestion && !entry.justification ? `
                <div style="margin-top: 5px; font-size: 11px; color: #666;">
                    <strong>Suggested justification:</strong> ${suggestion.description}
                </div>
            ` : ''}
        </div>
    `;
}

// Update write-off amount with validation
function updateWriteoffAmount(hopNumber, entryId, amount) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    
    entry.amount = amount;
    updateWriteoffPreview(hopNumber, entryId);
    updateHopEntry(hopNumber, entryId, 'amount', amount);
}

        function updateHopEntry(hopNumber, entryId, field, value) {
            const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
            const entry = hop.entries.find(e => e.id === entryId);

            // CRITICAL VALIDATION: Check for duplicate transaction hash
            if (field === 'txHash' && value && entry.entryType !== 'writeoff') {
                const duplicateEntry = hop.entries.find(e =>
                    e.id !== entryId &&  // Not the same entry
                    e.txHash &&
                    e.txHash.toLowerCase() === value.toLowerCase() &&
                    e.entryType !== 'writeoff'
                );

                if (duplicateEntry) {
                    alert(`❌ Transaction hash already used in this hop!\n\nTransaction ${value} is already logged in entry ${duplicateEntry.id} (${duplicateEntry.notation || 'unnamed'}).\n\nIf multiple threads move in the same transaction, they must all be logged in the same entry using multiple source thread selection.`);
                    // Reset the input field
                    const inputField = document.getElementById(`txHash_${hopNumber}_${entryId}`);
                    if (inputField) {
                        inputField.value = entry.txHash || '';
                    }
                    return;
                }
            }

            entry[field] = value;

            // If timestamp changed, re-sort entries chronologically
            if (field === 'timestamp') {
                sortHopEntriesChronologically(hop);
            }

            if (field === 'entryType') {
                // Regenerate notation if victim and transaction numbers exist
                if (entry.victimNumbers && entry.transactionNumbers) {
                    generateNotationPreview(hopNumber, entryId);
                }
                renderHops();
                saveToStorage();
                return;
            }
            
            if (field === 'currency') {
                const customInput = document.getElementById(`customEntryCurrency_${hopNumber}_${entryId}`);
                if (customInput) {
                    if (value === 'CUSTOM') {
                        customInput.style.display = 'block';
                        customInput.classList.remove('custom-currency-input');
                    } else {
                        customInput.style.display = 'none';
                        customInput.classList.add('custom-currency-input');
                    }
                }
            }
            
            // Handle wallet address changes
            if (field === 'toWallet' || field === 'fromWallet') {
                // Check if this is a known wallet and auto-set the type
                if (field === 'toWallet' && value) {
                    const knownWallet = investigation.universalWalletIndex?.find(w => w.address === value.trim());
                    if (knownWallet) {
                        // Auto-set the wallet type from UWI
                        entry.toWalletType = knownWallet.permanentType;
                        
                        // Update the wallet type dropdown if it exists
                        const typeSelect = document.querySelector(`select[onchange="updateHopEntryWalletType(${hopNumber}, ${entryId}, this.value)"]`);
                        if (typeSelect) {
                            typeSelect.value = knownWallet.permanentType;
                        }
                    }
                    
                    // Check all attribution sources for the address
                    checkAllAttributions(value.trim()).then(attributions => {
                        if (attributions && attributions.length > 0) {
                            showAttributionModal(attributions, hopNumber, entryId);
                        }
                    });
                }
                
                buildUniversalWalletIndex();
                buildRedWalletIndex();
            }
            
            if (field === 'amount' || field === 'currency' || field === 'toWallet' || field === 'entryType') {
                renderHops();
            }
            
            // If amount changed, mark downstream hops for validation
            if (field === 'amount' && parseFloat(value) !== parseFloat(entry._previousAmount || 0)) {
                entry._previousAmount = value;
                markDownstreamHopsForValidation(hop.hopNumber);
            }
            
            saveToStorage();
            updateValidationStatus();
            buildAvailableThreadsIndex(); // Rebuild thread index when entry is updated
            
            // Update progress indicator
            updateProgressIndicator();
            
            // Check if hop is now fully accounted for
            checkHopCompletionStatus(hop);
        }
        
        // Mark all hops downstream from a given hop number for validation
        function markDownstreamHopsForValidation(fromHopNumber) {
            investigation.hops.forEach(hop => {
                if (hop.hopNumber > fromHopNumber) {
                    hop.needsValidation = true;
                }
            });
        }

        function updateHopEntryWalletType(hopNumber, entryId, walletType) {
            updateHopEntry(hopNumber, entryId, 'toWalletType', walletType);
            
            // If BROWN wallet is selected, open asset conversion modal
            if (walletType === 'brown') {
                openAssetConversionModal(hopNumber, entryId);
            }
        }

        function openAssetConversionModal(hopNumber, entryId) {
            showModal('assetConversionModal');
            
            // Store the hop and entry ID for later use
            window.currentConversionHopId = hopNumber;
            window.currentConversionEntryId = entryId;
            
            // Pre-populate with entry data if available
            const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
            const entry = hop.entries.find(e => e.id === entryId);
            if (entry) {
                // Set from currency based on the entry's current currency
                if (entry.currency === 'CUSTOM') {
                    document.getElementById('conversionFromCurrency').value = 'CUSTOM';
                    document.getElementById('customFromCurrencyGroup').style.display = 'block';
                    document.getElementById('conversionFromCurrencyCustom').value = entry.customCurrency || '';
                } else {
                    document.getElementById('conversionFromCurrency').value = entry.currency || '';
                }
                document.getElementById('conversionFromAmount').value = entry.amount || '';
            }
        }

        function confirmAssetConversion() {
            const hopNumber = window.currentConversionHopId;
            const entryId = window.currentConversionEntryId;
            if (!hopNumber || !entryId) return;
            
            const fromCurrency = document.getElementById('conversionFromCurrency').value;
            const toCurrency = document.getElementById('conversionToCurrency').value;
            const fromAmount = document.getElementById('conversionFromAmount').value;
            const toAmount = document.getElementById('conversionToAmount').value;
            const platform = document.getElementById('conversionPlatform').value;
            const notes = document.getElementById('conversionNotes').value;
            
            // Get custom currencies if selected
            const fromCustom = document.getElementById('conversionFromCurrencyCustom').value;
            const toCustom = document.getElementById('conversionToCurrencyCustom').value;
            
            // Update entry with conversion data
            const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
            const entry = hop.entries.find(e => e.id === entryId);
            if (entry) {
                // Store original currency info for the conversion record
                const originalCurrency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                const originalAmount = entry.amount || fromAmount;
                
                // Update the entry currency to the "to" currency
                entry.currency = toCurrency;
                entry.customCurrency = toCurrency === 'CUSTOM' ? toCustom : '';
                entry.amount = toAmount;
                
                // Add conversion info to notes
                const conversionInfo = `Asset Conversion: ${originalAmount} ${originalCurrency} ${toAmount} ${toCurrency === 'CUSTOM' ? toCustom : toCurrency} via ${platform}. ${notes}`;
                entry.notes = entry.notes ? entry.notes + '\n' + conversionInfo : conversionInfo;
                
                // Mark this as a conversion entry
                entry.isConversion = true;
                entry.conversionData = {
                    fromCurrency: originalCurrency,
                    fromAmount: parseFloat(originalAmount) || 0,
                    toCurrency: toCurrency === 'CUSTOM' ? toCustom : toCurrency,
                    toAmount: parseFloat(toAmount) || 0,
                    platform: platform,
                    conversionRate: parseFloat(toAmount) / parseFloat(originalAmount)
                };
            }
            
            // Store conversion details
            const conversion = {
                id: (investigation.conversions || []).length + 1,
                hopNumber: hopNumber,
                entryId: entryId,
                fromCurrency: fromCurrency === 'CUSTOM' ? fromCustom : fromCurrency,
                toCurrency: toCurrency === 'CUSTOM' ? toCustom : toCurrency,
                fromAmount: parseFloat(fromAmount) || 0,
                toAmount: parseFloat(toAmount) || 0,
                platform: platform,
                notes: notes
            };
            
            if (!investigation.conversions) {
                investigation.conversions = [];
            }
            investigation.conversions.push(conversion);
            
            closeAssetConversionModal();
            
            // Rebuild thread index to ensure new currency is tracked
            buildAvailableThreadsIndex();
            
            // Update ART calculations for the hop
            updateHopARTForConversion(hop, originalCurrency, originalAmount, toCurrency === 'CUSTOM' ? toCustom : toCurrency, toAmount);
            
            renderHops();
            saveToStorage();
        }

        function closeAssetConversionModal() {
            hideModal('assetConversionModal');
            window.currentConversionHopId = null;
            window.currentConversionEntryId = null;
        }
        
        function updateHopARTForConversion(hop, fromCurrency, fromAmount, toCurrency, toAmount) {
            // Ensure hop has ART tracking by currency
            if (!hop.artAtStartByCurrency) {
                hop.artAtStartByCurrency = {};
            }
            
            // For conversions, we need to track both currencies
            // The original currency is consumed and the new currency is created
            
            // If this is the first time we see the new currency in this hop
            if (!hop.artAtStartByCurrency[toCurrency]) {
                hop.artAtStartByCurrency[toCurrency] = 0;
            }
            
            // Mark the hop as having a conversion
            if (!hop.hasConversions) {
                hop.hasConversions = true;
            }
            
            // Store conversion tracking data
            if (!hop.conversions) {
                hop.conversions = [];
            }
            
            hop.conversions.push({
                fromCurrency: fromCurrency,
                fromAmount: parseFloat(fromAmount),
                toCurrency: toCurrency,
                toAmount: parseFloat(toAmount),
                timestamp: new Date().toISOString()
            });
            
            console.log(`Conversion tracked in Hop ${hop.hopNumber}: ${fromAmount} ${fromCurrency} → ${toAmount} ${toCurrency}`);
            console.log('Updated hop ART by currency:', hop.artAtStartByCurrency);
        }
        
        function copyConversionAmount() {
            const fromAmount = document.getElementById('conversionFromAmount').value;
            if (fromAmount) {
                // Copy to clipboard
                navigator.clipboard.writeText(fromAmount).then(() => {
                    // Also populate the converted amount field
                    document.getElementById('conversionToAmount').value = fromAmount;
                    
                    // Show success feedback
                    const button = event.target;
                    const originalText = button.innerHTML;
                    button.innerHTML = '✅ Copied!';
                    button.style.background = '#27ae60';
                    
                    setTimeout(() => {
                        button.innerHTML = originalText;
                        button.style.background = '';
                    }, 1500);
                }).catch(err => {
                    console.error('Failed to copy:', err);
                    // Fallback - just copy to the field
                    document.getElementById('conversionToAmount').value = fromAmount;
                });
            }
        }

        function openConvergenceHelper() {
            if (!investigation.hops || investigation.hops.length < 1) {
                alert('Need at least 1 hop with multiple entries to record convergence.');
                return;
            }
            
            let content = '<div style="margin: 15px 0;"><strong>Select entries that are converging:</strong></div>';
            investigation.hops.forEach(hop => {
                hop.entries.forEach(entry => {
                    if (entry.entryType === 'trace') {
                        content += `
                            <label style="display: block; margin: 8px 0; cursor: pointer;">
                                <input type="checkbox" value="${hop.hopNumber}_${entry.id}" onchange="updateConvergenceSelection()"> 
                                ${entry.notation || 'Entry ' + entry.id} - ${entry.amount} ${entry.currency} (H${entry.hopNumber})
                            </label>
                        `;
                    }
                });
            });
            
            document.getElementById('convergenceTraceSelection').innerHTML = content;
            showModal('convergenceModal');
        }

        function updateConvergenceSelection() {
            const selected = Array.from(document.querySelectorAll('#convergenceTraceSelection input:checked'));
            if (selected.length < 2) return;
            
            const selectedEntries = selected.map(input => {
                const [hopNumber, entryId] = input.value.split('_');
                const hop = investigation.hops.find(h => h.id == hopNumber);
                return hop.entries.find(e => e.id == entryId);
            });
            
            const maxHop = Math.max(...selectedEntries.map(e => e.hopNumber));
            document.getElementById('convergenceHopLevel').value = maxHop + 1;
            
            // Group amounts by currency for convergence
            const amountsByCurrency = {};
            selectedEntries.forEach(entry => {
                const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                if (!amountsByCurrency[currency]) {
                    amountsByCurrency[currency] = 0;
                }
                amountsByCurrency[currency] += parseFloat(entry.amount) || 0;
            });

            // Display all currencies in convergence amount
            const amountDisplay = Object.entries(amountsByCurrency)
                .map(([currency, amount]) => `${amount} ${currency}`)
                .join(' | ');
            document.getElementById('convergenceAmount').value = amountDisplay;
            
            const victimSets = new Set();
            const transactionSets = new Set();
            selectedEntries.forEach(entry => {
                const parts = entry.notation.split('-');
                if (parts.length >= 2) {
                    victimSets.add(parts[0]);
                    transactionSets.add(parts[1]);
                }
            });
            
            const victims = Array.from(victimSets).join(',');
            const transactions = Array.from(transactionSets).join('(') + (transactionSets.size > 1 ? ')' : '');
            const suggestedNotation = `${victims}-${transactions}-H${maxHop + 1}`;
            document.getElementById('convergenceNotation').value = suggestedNotation;
        }

        function createConvergenceTrace() {
            const notation = document.getElementById('convergenceNotation').value;
            const hopLevel = document.getElementById('convergenceHopLevel').value;
            const amount = document.getElementById('convergenceAmount').value;
            
            if (!notation) {
                alert('Please enter the convergence notation.');
                return;
            }
            
            // Create new hop for convergence
            const hop = {
                id: investigation.hops.length + 1,
                hopNumber: parseInt(hopLevel),
                entries: [],
                artAtStartByCurrency: { 'USD': parseFloat(amount) },
                completed: false
            };
            
            // Add convergence entry
            const entry = {
                id: 1,
                hopNumber: hop.hopNumber,
                hopNumber: hop.hopNumber,
                entryType: 'trace',
                notation: notation,
                fromWallet: 'CONVERGENCE',
                fromWalletType: 'yellow',
                toWallet: '',
                toWalletType: 'yellow',
                amount: amount,
                currency: 'USD',
                customCurrency: '',
                txHash: '',
                timestamp: '',
                timezone: 'UTC',
                notes: 'Convergence of multiple traces',
                category: '',
                justification: ''
            };
            
            hop.entries.push(entry);
            
            // Sort entries chronologically
            sortHopEntriesChronologically(hop);
            
            investigation.hops.push(hop);
            
            closeConvergenceModal();
            renderHops();
            saveToStorage();
        }

        function closeConvergenceModal() {
            hideModal('convergenceModal');
        }

        function setupConversionModalListeners() {
            const fromCurrencySelect = document.getElementById('conversionFromCurrency');
            const toCurrencySelect = document.getElementById('conversionToCurrency');
            
            if (fromCurrencySelect) {
                fromCurrencySelect.addEventListener('change', function() {
                    const customGroup = document.getElementById('customFromCurrencyGroup');
                    if (this.value === 'CUSTOM') {
                        customGroup.style.display = 'block';
                    } else {
                        customGroup.style.display = 'none';
                    }
                });
            }
            
            if (toCurrencySelect) {
                toCurrencySelect.addEventListener('change', function() {
                    const customGroup = document.getElementById('customToCurrencyGroup');
                    if (this.value === 'CUSTOM') {
                        customGroup.style.display = 'block';
                    } else {
                        customGroup.style.display = 'none';
                    }
                });
            }
        }

        function removeHop(hopNumber) {
            if (confirm('Are you sure you want to remove this entire hop?')) {
                const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
                saveUndoState(`Remove Hop ${hop.hopNumber}`);
                
                investigation.hops = investigation.hops.filter(h => h.id !== hopNumber);
                renderHops();
                saveToStorage();
                updateValidationStatus();
                updateWorkflowSteps();
            }
        }

        function removeHopEntry(hopNumber, entryId) {
            const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
            const entry = hop.entries.find(e => e.id === entryId);

            saveUndoState(`Remove entry ${entry.notation || `Entry ${entry.id}`} from Hop ${hop.hopNumber}`);

            hop.entries = hop.entries.filter(e => e.id !== entryId);

            // Mark downstream hops for validation since an entry was removed
            markDownstreamHopsForValidation(hop.hopNumber);

            renderHops();
            saveToStorage();
            updateValidationStatus();
        }

        // Log bridge output from terminal wallet (can keep as CEX or convert to DeFi bridge)
        function logBridgeOutput(hopNumber, entryId) {
            const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
            const entry = hop.entries.find(e => e.id === entryId);

            if (!entry || entry.toWalletType !== 'purple') {
                showNotification('❌ Only purple terminal wallets can log bridge outputs', 'error');
                return;
            }

            // Show bridge output logging modal
            const modal = document.createElement('div');
            modal.id = 'bridgeOutputModal';
            modal.className = 'modal show';
            modal.innerHTML = `
                <div class="modal-content" style="max-width: 700px; padding: 30px;">
                    <h2 style="margin-bottom: 20px;">🌉 Log Bridge/CEX Output Transaction</h2>

                    <!-- Transaction Details Section -->
                    <div style="background: #f0f7ff; border: 2px solid #2196f3; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
                        <h3 style="margin-top: 0; color: #0d47a1; font-size: 16px;">Source Transaction Details</h3>

                        <div style="margin-bottom: 15px;">
                            <label style="font-weight: bold; color: #555; display: block; margin-bottom: 5px;">Transaction Hash:</label>
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <input type="text"
                                       value="${entry.txHash || 'Not available'}"
                                       readonly
                                       style="flex: 1; padding: 8px; font-family: monospace; font-size: 12px; background: white; border: 1px solid #ddd; border-radius: 4px;">
                                <button onclick="navigator.clipboard.writeText('${entry.txHash || ''}'); this.textContent = '✓ Copied!'; setTimeout(() => this.textContent = '📋 Copy', 2000);"
                                        style="padding: 8px 12px; background: #2196f3; color: white; border: none; border-radius: 4px; cursor: pointer;">
                                    📋 Copy
                                </button>
                            </div>
                        </div>

                        <div style="margin-bottom: 15px;">
                            <label style="font-weight: bold; color: #555; display: block; margin-bottom: 5px;">Bridge Address (Receiving Wallet):</label>
                            <div style="display: flex; gap: 10px; align-items: center;">
                                <input type="text"
                                       value="${entry.toWallet}"
                                       readonly
                                       style="flex: 1; padding: 8px; font-family: monospace; font-size: 12px; background: white; border: 1px solid #ddd; border-radius: 4px;">
                                <button onclick="navigator.clipboard.writeText('${entry.toWallet}'); this.textContent = '✓ Copied!'; setTimeout(() => this.textContent = '📋 Copy', 2000);"
                                        style="padding: 8px 12px; background: #2196f3; color: white; border: none; border-radius: 4px; cursor: pointer;">
                                    📋 Copy
                                </button>
                            </div>
                        </div>

                        <div style="margin-bottom: 15px;">
                            <label style="font-weight: bold; color: #555; display: block; margin-bottom: 5px;">Amount:</label>
                            <div style="padding: 8px; background: white; border: 1px solid #ddd; border-radius: 4px;">
                                ${entry.amount} ${entry.currency || 'Unknown'}
                            </div>
                        </div>

                        <div>
                            <label style="font-weight: bold; color: #555; display: block; margin-bottom: 5px;">Timestamp (UTC):</label>
                            <div style="padding: 8px; background: white; border: 1px solid #ddd; border-radius: 4px;">
                                ${entry.timestamp ? new Date(entry.timestamp).toLocaleString('en-US', {
                                    timeZone: 'UTC',
                                    year: 'numeric',
                                    month: '2-digit',
                                    day: '2-digit',
                                    hour: '2-digit',
                                    minute: '2-digit',
                                    second: '2-digit',
                                    hour12: false
                                }) + ' UTC' : 'Not available'}
                            </div>
                        </div>
                    </div>

                    <p style="margin: 20px 0; color: #666; background: #fff9e6; padding: 15px; border-radius: 6px; border: 1px solid #ffd666;">
                        <strong>💡 Tip:</strong> Use the transaction hash and address above to search in bridge explorers, CEX records, or the destination chain explorer to find the output transaction.
                    </p>

                    <div style="background: #fff8f4; padding: 20px; border-radius: 8px; margin-bottom: 20px; border: 2px solid #8b4513;">
                        <h3 style="margin-top: 0; font-size: 16px; color: #8b4513;">🌉 Wallet Classification Update</h3>
                        <p style="margin: 10px 0; color: #6b3410;">
                            <strong>This terminal wallet will be automatically converted to a DeFi Bridge (Brown)</strong>
                        </p>
                        <p style="margin: 0; color: #666; font-size: 14px;">
                            Logging a bridge output indicates this wallet is a bridge/conversion service, not a terminal wallet.
                            The wallet color will change from purple to brown to reflect its true nature as a bridge.
                        </p>
                    </div>

                    <div style="border-top: 2px solid #e0e0e0; padding-top: 20px; margin-top: 20px;">
                        <h3 style="font-size: 16px; margin-bottom: 15px; color: #2c3e50;">Destination Transaction Details</h3>

                        <div style="margin-bottom: 20px;">
                            <label style="font-weight: bold; display: block; margin-bottom: 10px; color: #2c3e50;">
                                Select Destination Chain:
                            </label>
                            <select id="bridgeDestChain" onchange="window.bridgeDestChain = this.value"
                                    style="width: 100%; padding: 12px; font-size: 14px; border: 2px solid #ddd; border-radius: 4px;">
                                <option value="">Select blockchain...</option>
                                ${Object.entries(window.blockchainAPIs || {}).map(([key, chain]) =>
                                    `<option value="${key}">${chain.name}</option>`
                                ).join('')}
                            </select>
                        </div>

                        <div style="margin-bottom: 20px;">
                            <label style="font-weight: bold; display: block; margin-bottom: 10px; color: #2c3e50;">
                                Destination Transaction Hash:
                            </label>
                            <div style="display: flex; gap: 10px;">
                                <input type="text"
                                       id="bridgeDestTxHash"
                                       placeholder="Paste the transaction hash from the destination chain"
                                       style="flex: 1; padding: 12px; font-size: 14px; border: 2px solid #ddd; border-radius: 4px;">
                                <button class="btn btn-primary" onclick="lookupBridgeDestTransaction()"
                                        style="padding: 12px 20px; font-size: 14px;">
                                    🔍 Auto-fill
                                </button>
                            </div>
                            <small style="color: #666; display: block; margin-top: 5px;">
                                Enter the hash and click Auto-fill to populate the fields below
                            </small>
                        </div>

                        <!-- Lookup result area -->
                        <div id="bridgeLookupResult" style="display: none; margin-bottom: 20px;">
                            <div style="background: #e8f5e9; border: 1px solid #4caf50; border-radius: 6px; padding: 10px; color: #2e7d32;">
                                ✅ Transaction found! Fields have been auto-filled.
                            </div>
                        </div>

                        <div style="background: #f5f5f5; padding: 15px; border-radius: 8px; margin-bottom: 20px;">
                            <div style="margin-bottom: 15px;">
                                <label style="font-weight: bold; display: block; margin-bottom: 8px; color: #555;">
                                    Receiving Wallet Address:
                                </label>
                                <input type="text"
                                       id="bridgeDestWallet"
                                       placeholder="Enter or auto-fill the receiving wallet address"
                                       style="width: 100%; padding: 10px; font-family: monospace; font-size: 13px; border: 1px solid #ddd; border-radius: 4px;">
                            </div>

                            <div style="display: flex; gap: 15px;">
                                <div style="flex: 2;">
                                    <label style="font-weight: bold; display: block; margin-bottom: 8px; color: #555;">
                                        Amount Received:
                                    </label>
                                    <input type="number"
                                           id="bridgeDestAmount"
                                           placeholder="0.00"
                                           step="0.000001"
                                           style="width: 100%; padding: 10px; font-size: 14px; border: 1px solid #ddd; border-radius: 4px;">
                                </div>

                                <div style="flex: 1;">
                                    <label style="font-weight: bold; display: block; margin-bottom: 8px; color: #555;">
                                        Asset/Currency:
                                    </label>
                                    <input type="text"
                                           id="bridgeDestAsset"
                                           placeholder="e.g., ETH, USDT"
                                           value="${entry.currency || ''}"
                                           style="width: 100%; padding: 10px; font-size: 14px; border: 1px solid #ddd; border-radius: 4px;">
                                </div>
                            </div>

                            <small style="color: #666; display: block; margin-top: 10px;">
                                These fields will be auto-filled when you lookup the transaction, or you can enter them manually
                            </small>
                        </div>

                        <div style="display: flex; justify-content: center; gap: 10px;">
                            <button class="btn btn-primary" onclick="confirmBridgeOutput(${hopNumber}, ${entryId})"
                                    style="padding: 12px 24px; font-size: 16px;">
                                🌉 Log Output Transaction
                            </button>
                            <button class="btn btn-secondary" onclick="document.getElementById('bridgeOutputModal').remove()"
                                    style="padding: 12px 24px; font-size: 16px;">
                                Cancel
                            </button>
                        </div>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        function showBridgeTransferSelectionModal(transfers) {
            // Store transfers globally
            window.allBridgeTransfers = transfers;
            window.filteredBridgeTransfers = transfers;

            // Get unique assets for filter
            const uniqueAssets = [...new Set(transfers.map(t => t.currency))].sort();

            // Create modal HTML (similar to victim transaction selector)
            const modalHTML = `
                <div id="bridgeTransferModal" class="modal show">
                    <div class="modal-content" style="max-width: 900px;">
                        <div class="modal-header">
                            <h2>Select Bridge Output Transfer</h2>
                            <button class="close" onclick="document.getElementById('bridgeTransferModal').remove()">&times;</button>
                        </div>

                        <p style="margin: 15px 0;">This transaction contains ${transfers.length} transfers. Please select the bridge output:</p>

                        <!-- Filter Section -->
                        <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 15px 0;">
                            <div style="display: grid; grid-template-columns: 1fr 1fr 1fr auto; gap: 10px; align-items: end;">
                                <div>
                                    <label style="display: block; margin-bottom: 5px; font-weight: 500;">Filter by Asset:</label>
                                    <select id="bridgeTransferAssetFilter"
                                           style="width: 100%; padding: 8px; border: 2px solid #e8f0fe; border-radius: 6px;"
                                           onchange="filterBridgeTransfersModal()">
                                        <option value="">All Assets (${uniqueAssets.length})</option>
                                        ${uniqueAssets.map(asset => {
                                            const count = transfers.filter(t => t.currency === asset).length;
                                            return `<option value="${asset}">${asset} (${count})</option>`;
                                        }).join('')}
                                    </select>
                                </div>
                                <div>
                                    <label style="display: block; margin-bottom: 5px; font-weight: 500;">Min Amount:</label>
                                    <input type="number" id="bridgeTransferAmountFilter" placeholder="e.g., 0.01" step="0.000001"
                                           style="width: 100%; padding: 8px; border: 2px solid #e8f0fe; border-radius: 6px;"
                                           oninput="filterBridgeTransfersModal()">
                                </div>
                                <div>
                                    <label style="display: block; margin-bottom: 5px; font-weight: 500;">Filter by Address:</label>
                                    <input type="text" id="bridgeTransferAddressFilter" placeholder="To or From address"
                                           style="width: 100%; padding: 8px; border: 2px solid #e8f0fe; border-radius: 6px;"
                                           oninput="filterBridgeTransfersModal()">
                                </div>
                                <button class="btn btn-secondary" onclick="clearBridgeTransferFilters()" style="padding: 8px 15px;">
                                    Clear Filters
                                </button>
                            </div>

                            <div style="margin-top: 10px; font-size: 14px; color: #666;">
                                <span id="bridgeTransferFilterInfo">Showing ${transfers.length} of ${transfers.length} transfers</span>
                            </div>
                        </div>

                        <!-- Transfers List -->
                        <div id="bridgeTransfersList" style="max-height: 400px; overflow-y: auto;">
                            ${renderBridgeTransferModalCards(transfers)}
                        </div>

                        <div style="text-align: center; margin-top: 20px;">
                            <button class="btn btn-secondary" onclick="document.getElementById('bridgeTransferModal').remove()">
                                Cancel
                            </button>
                        </div>
                    </div>
                </div>
            `;

            // Add modal to body
            document.body.insertAdjacentHTML('beforeend', modalHTML);
        }

        function renderBridgeTransferModalCards(transfers) {
            if (transfers.length === 0) {
                return '<div style="text-align: center; padding: 40px; color: #666;">No transfers match your filters</div>';
            }

            return transfers.map((transfer, filteredIndex) => {
                // Find original index
                const originalIndex = window.allBridgeTransfers.indexOf(transfer);

                return `
                    <div class="transfer-card" style="background: white; border: 2px solid #e8f0fe; border-radius: 8px; padding: 15px; margin-bottom: 10px; cursor: pointer; transition: all 0.2s;"
                         onmouseover="this.style.borderColor='#3498db'; this.style.transform='translateY(-2px)'"
                         onmouseout="this.style.borderColor='#e8f0fe'; this.style.transform='translateY(0)'"
                         onclick="selectBridgeTransferFromModal(${originalIndex})">
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px;">
                            <div>
                                <div style="font-size: 12px; color: #666; margin-bottom: 4px;">From:</div>
                                <div style="font-family: monospace; font-size: 13px; word-break: break-all;">
                                    ${transfer.from || 'Unknown'}
                                </div>
                            </div>
                            <div>
                                <div style="font-size: 12px; color: #666; margin-bottom: 4px;">To:</div>
                                <div style="font-family: monospace; font-size: 13px; word-break: break-all;">
                                    ${transfer.to || 'Unknown'}
                                </div>
                            </div>
                        </div>
                        <div style="margin-top: 12px; padding-top: 12px; border-top: 1px solid #f0f0f0;">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <span style="font-size: 20px; font-weight: bold; color: #2c3e50;">
                                        ${transfer.amount} ${transfer.currency}
                                    </span>
                                    ${transfer.type ? `<span style="margin-left: 10px; font-size: 12px; color: #666;">(${transfer.type})</span>` : ''}
                                </div>
                                <button class="btn btn-primary" onclick="event.stopPropagation(); selectBridgeTransferFromModal(${originalIndex})">
                                    Select This Transfer
                                </button>
                            </div>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function filterBridgeTransfersModal() {
            const assetFilter = document.getElementById('bridgeTransferAssetFilter')?.value || '';
            const amountFilter = parseFloat(document.getElementById('bridgeTransferAmountFilter')?.value) || 0;
            const addressFilter = document.getElementById('bridgeTransferAddressFilter')?.value?.toLowerCase() || '';

            let filtered = window.allBridgeTransfers;

            // Filter by asset
            if (assetFilter) {
                filtered = filtered.filter(t => t.currency === assetFilter);
            }

            // Filter by minimum amount
            if (amountFilter > 0) {
                filtered = filtered.filter(t => parseFloat(t.amount) >= amountFilter);
            }

            // Filter by address (to or from)
            if (addressFilter) {
                filtered = filtered.filter(t =>
                    (t.to && t.to.toLowerCase().includes(addressFilter)) ||
                    (t.from && t.from.toLowerCase().includes(addressFilter))
                );
            }

            window.filteredBridgeTransfers = filtered;

            // Update display
            const listContainer = document.getElementById('bridgeTransfersList');
            if (listContainer) {
                listContainer.innerHTML = renderBridgeTransferModalCards(filtered);
            }

            // Update filter info
            const filterInfo = document.getElementById('bridgeTransferFilterInfo');
            if (filterInfo) {
                filterInfo.textContent = `Showing ${filtered.length} of ${window.allBridgeTransfers.length} transfers`;
            }
        }

        function clearBridgeTransferFilters() {
            document.getElementById('bridgeTransferAssetFilter').value = '';
            document.getElementById('bridgeTransferAmountFilter').value = '';
            document.getElementById('bridgeTransferAddressFilter').value = '';
            filterBridgeTransfersModal();
        }

        function selectBridgeTransferFromModal(index) {
            const transfers = window.allBridgeTransfers;
            if (!transfers || !transfers[index]) return;

            const transfer = transfers[index];

            // Auto-fill the fields with selected transfer
            document.getElementById('bridgeDestWallet').value = transfer.to || '';
            document.getElementById('bridgeDestAmount').value = transfer.amount || '';
            document.getElementById('bridgeDestAsset').value = transfer.currency || '';

            // Update result message
            const resultDiv = document.getElementById('bridgeLookupResult');
            if (resultDiv) {
                resultDiv.innerHTML = `
                    <div style="background: #e8f5e9; border: 1px solid #4caf50; border-radius: 6px; padding: 10px; color: #2e7d32;">
                        ✅ Transfer selected: ${transfer.amount} ${transfer.currency} to ${transfer.to ? transfer.to.substring(0, 30) + '...' : 'Unknown'}
                    </div>
                `;
            }

            // Close the modal
            const modal = document.getElementById('bridgeTransferModal');
            if (modal) {
                modal.remove();
            }
        }

        // Keep the old function for backward compatibility but have it call the modal version
        function showBridgeTransferSelection(transfers) {
            const container = document.getElementById('bridgeLookupResult');
            if (!container) return;

            // Store all transfers for filtering
            window.allBridgeTransfers = transfers;
            window.filteredBridgeTransfers = transfers;

            // Get unique assets for filter
            const uniqueAssets = [...new Set(transfers.map(t => t.currency))].sort();

            let selectionHTML = `
                <div style="background: #fff3cd; border: 1px solid #ffc107; border-radius: 6px; padding: 15px; margin-bottom: 15px;">
                    <h4 style="margin: 0 0 15px 0; color: #856404;">Select the Bridge Output Transfer:</h4>

                    <!-- Filters Section -->
                    <div style="background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 6px; padding: 12px; margin-bottom: 15px;">
                        <div style="display: flex; gap: 10px; margin-bottom: 10px;">
                            <div style="flex: 1;">
                                <label style="font-size: 12px; font-weight: bold; color: #495057; display: block; margin-bottom: 4px;">Asset Type:</label>
                                <select id="bridgeAssetFilter" onchange="filterBridgeTransfers()"
                                        style="width: 100%; padding: 6px; border: 1px solid #ced4da; border-radius: 4px;">
                                    <option value="">All Assets (${uniqueAssets.length})</option>
                                    ${uniqueAssets.map(asset => {
                                        const count = transfers.filter(t => t.currency === asset).length;
                                        return `<option value="${asset}">${asset} (${count})</option>`;
                                    }).join('')}
                                </select>
                            </div>
                            <div style="flex: 1;">
                                <label style="font-size: 12px; font-weight: bold; color: #495057; display: block; margin-bottom: 4px;">Min Amount:</label>
                                <input type="number" id="bridgeAmountFilter" placeholder="e.g., 0.01" step="0.000001"
                                       onkeyup="filterBridgeTransfers()"
                                       style="width: 100%; padding: 6px; border: 1px solid #ced4da; border-radius: 4px;">
                            </div>
                        </div>
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <span id="bridgeFilterInfo" style="font-size: 12px; color: #6c757d;">
                                Showing ${transfers.length} of ${transfers.length} transfers
                            </span>
                            <button class="btn btn-sm" onclick="clearBridgeFilters()"
                                    style="font-size: 12px; padding: 4px 8px; background: #6c757d; color: white; border: none; border-radius: 4px;">
                                Clear Filters
                            </button>
                        </div>
                    </div>

                    <!-- Transfers List -->
                    <div id="bridgeTransfersList" style="max-height: 300px; overflow-y: auto;">
                        ${renderBridgeTransferCards(transfers)}
                    </div>
                </div>
            `;

            container.innerHTML = selectionHTML;
            container.style.display = 'block';
        }

        function renderBridgeTransferCards(transfers) {
            if (transfers.length === 0) {
                return '<div style="text-align: center; padding: 20px; color: #666;">No transfers match your filters</div>';
            }

            return transfers.map((transfer, filteredIndex) => {
                // Find original index
                const originalIndex = window.allBridgeTransfers.indexOf(transfer);

                return `
                    <div style="background: white; border: 1px solid #ddd; border-radius: 4px; padding: 10px; margin-bottom: 8px; cursor: pointer;"
                         onclick="selectBridgeTransfer(${originalIndex})"
                         onmouseover="this.style.backgroundColor='#e3f2fd'"
                         onmouseout="this.style.backgroundColor='white'">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <div>
                                <strong>${transfer.amount} ${transfer.currency}</strong><br>
                                <small style="color: #666;">
                                    To: ${transfer.to ? transfer.to.substring(0, 20) + '...' : 'Unknown'}<br>
                                    ${transfer.type ? `Type: ${transfer.type}` : ''}
                                    ${transfer.from ? `From: ${transfer.from.substring(0, 20)}...` : ''}
                                </small>
                            </div>
                            <button class="btn btn-sm btn-primary" onclick="selectBridgeTransfer(${originalIndex}); event.stopPropagation();">
                                Select
                            </button>
                        </div>
                    </div>
                `;
            }).join('');
        }

        function filterBridgeTransfers() {
            const assetFilter = document.getElementById('bridgeAssetFilter').value;
            const amountFilter = parseFloat(document.getElementById('bridgeAmountFilter').value) || 0;

            let filtered = window.allBridgeTransfers;

            // Filter by asset
            if (assetFilter) {
                filtered = filtered.filter(t => t.currency === assetFilter);
            }

            // Filter by minimum amount
            if (amountFilter > 0) {
                filtered = filtered.filter(t => parseFloat(t.amount) >= amountFilter);
            }

            window.filteredBridgeTransfers = filtered;

            // Update display
            const listContainer = document.getElementById('bridgeTransfersList');
            listContainer.innerHTML = renderBridgeTransferCards(filtered);

            // Update filter info
            document.getElementById('bridgeFilterInfo').textContent =
                `Showing ${filtered.length} of ${window.allBridgeTransfers.length} transfers`;
        }

        function clearBridgeFilters() {
            document.getElementById('bridgeAssetFilter').value = '';
            document.getElementById('bridgeAmountFilter').value = '';
            filterBridgeTransfers();
        }

        function selectBridgeTransfer(index) {
            const transfers = window.bridgeDestTransfers;
            if (!transfers || !transfers[index]) return;

            const transfer = transfers[index];

            // Auto-fill the fields with selected transfer
            document.getElementById('bridgeDestWallet').value = transfer.to || '';
            document.getElementById('bridgeDestAmount').value = transfer.amount || '';
            document.getElementById('bridgeDestAsset').value = transfer.currency || '';

            // Update result message
            const container = document.getElementById('bridgeLookupResult');
            container.innerHTML = `
                <div style="background: #e8f5e9; border: 1px solid #4caf50; border-radius: 6px; padding: 10px; color: #2e7d32;">
                    ✅ Transfer selected! Fields have been auto-filled with: ${transfer.amount} ${transfer.currency} to ${transfer.to ? transfer.to.substring(0, 20) + '...' : 'Unknown'}
                </div>
            `;
        }

        async function lookupBridgeDestTransaction() {
            const txHash = document.getElementById('bridgeDestTxHash').value.trim();
            const destChain = document.getElementById('bridgeDestChain').value;

            if (!txHash) {
                showNotification('❌ Please enter a transaction hash', 'error');
                return;
            }

            if (!destChain) {
                showNotification('❌ Please select the destination blockchain first', 'error');
                return;
            }

            // Show loading state
            const resultDiv = document.getElementById('bridgeLookupResult');
            resultDiv.style.display = 'block';
            resultDiv.innerHTML = `
                <div style="background: #fff3cd; border: 1px solid #ffc107; border-radius: 6px; padding: 10px; color: #856404;">
                    🔍 Looking up transaction...
                </div>
            `;

            try {
                // Use existing transaction lookup logic
                let txData;
                const evmChains = ['ethereum', 'base', 'arbitrum', 'optimism', 'polygon', 'bsc',
                                  'avalanche', 'hyperevm', 'linea', 'scroll', 'mantle', 'blast',
                                  'zksync', 'gnosis', 'celo', 'moonbeam', 'moonriver', 'fraxtal',
                                  'taiko', 'arbitrumnova', 'bittorrent', 'opbnb'];

                if (evmChains.includes(destChain)) {
                    // Temporarily set chain selector for lookup
                    const originalChain = document.getElementById('chainSelector')?.value;
                    if (document.getElementById('chainSelector')) {
                        document.getElementById('chainSelector').value = destChain;
                    }

                    txData = await lookupEthereumTransaction(txHash, destChain);

                    // Restore original chain
                    if (document.getElementById('chainSelector') && originalChain) {
                        document.getElementById('chainSelector').value = originalChain;
                    }
                } else if (destChain === 'bitcoin') {
                    txData = await lookupBitcoinTransaction(txHash);
                } else if (destChain === 'tron') {
                    txData = await lookupTronTransaction(txHash);
                } else if (destChain === 'solana') {
                    txData = await lookupSolanaTransaction(txHash);
                } else if (destChain === 'ripple' || destChain === 'xrp') {
                    txData = await lookupRippleTransaction(txHash);
                } else {
                    throw new Error(`Unsupported blockchain: ${destChain}`);
                }

                if (txData) {
                    console.log('Bridge destination txData:', txData);

                    // Check if we have multiple transfers (Solana often has these)
                    if (txData.multipleTransfers && txData.transfers && txData.transfers.length > 0) {
                        console.log('Multiple transfers detected:', txData.transfers);

                        // Store transfers for selection
                        window.bridgeDestTransfers = txData.transfers;

                        // Show message about multiple transfers
                        resultDiv.innerHTML = `
                            <div style="background: #fff3cd; border: 1px solid #ffc107; border-radius: 6px; padding: 10px; color: #856404;">
                                ⚠️ ${txData.transfers.length} transfers detected. Opening selection window...
                            </div>
                        `;

                        // Show transfer selection modal (like victim transaction selector)
                        showBridgeTransferSelectionModal(txData.transfers);
                    } else {
                        // Auto-fill the fields
                        document.getElementById('bridgeDestWallet').value = txData.to || '';
                        document.getElementById('bridgeDestAmount').value = txData.amount || '';
                        document.getElementById('bridgeDestAsset').value = txData.currency || '';

                        // Show success message
                        resultDiv.innerHTML = `
                            <div style="background: #e8f5e9; border: 1px solid #4caf50; border-radius: 6px; padding: 10px; color: #2e7d32;">
                                ✅ Transaction found! Fields have been auto-filled.
                            </div>
                        `;
                    }

                    // Store tx data for later use
                    window.bridgeDestTxData = txData;
                } else {
                    throw new Error('Transaction not found');
                }
            } catch (error) {
                console.error('Bridge destination lookup error:', error);
                resultDiv.innerHTML = `
                    <div style="background: #ffebee; border: 1px solid #f44336; border-radius: 6px; padding: 10px; color: #c62828;">
                        ❌ Failed to lookup transaction: ${error.message}
                    </div>
                `;
            }
        }

        async function confirmBridgeOutput(hopNumber, entryId) {
            const txHash = document.getElementById('bridgeDestTxHash').value.trim();
            const destChain = document.getElementById('bridgeDestChain').value;
            const destWallet = document.getElementById('bridgeDestWallet').value.trim();
            const destAmount = document.getElementById('bridgeDestAmount').value;
            const destAsset = document.getElementById('bridgeDestAsset').value.trim();
            // Always use brown wallet type for bridges
            const walletType = 'brown';

            if (!txHash || !destChain || !destWallet || !destAmount || !destAsset) {
                showNotification('❌ Please fill in all destination transaction details', 'error');
                return;
            }

            const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
            const entry = hop.entries.find(e => e.id === entryId);

            if (!entry) {
                showNotification('❌ Entry not found', 'error');
                return;
            }

            // Save undo state
            saveUndoState(`Log bridge output from terminal wallet in Hop ${hop.hopNumber}`);

            // Always convert to DeFi bridge when logging bridge output
            // This overwrites the previous purple (terminal) classification
            entry.toWalletType = 'brown'; // Brown for bridges/conversions
            entry.isBridge = true;
            entry.wasTerminalWallet = true; // Track that this was originally classified as terminal
            entry.isTerminalWallet = false; // NO LONGER a terminal wallet - it's a bridge!

            const noteType = 'BRIDGE OUTPUT';
            const existingNotes = entry.notes || '';
            entry.notes = existingNotes + `\n[${noteType}] Wallet reclassified from terminal to bridge:\n` +
                `  Output Chain: ${destChain}\n` +
                `  Output Tx: ${txHash}\n` +
                `  Output Wallet: ${destWallet}\n` +
                `  Output Amount: ${destAmount} ${destAsset}\n` +
                `  Reclassified: ${new Date().toISOString()}`;

            // Store bridge details for both types
            entry.bridgeDetails = {
                sourceChain: entry.chain || 'unknown',
                destinationChain: destChain,
                destinationTxHash: txHash,
                destinationWallet: destWallet,
                destinationAmount: parseFloat(destAmount),
                destinationAsset: destAsset,
                bridgeAddress: entry.toWallet,
                walletType: walletType
            };

            // Mark that bridge output has been logged
            entry.bridgeOutputLogged = true;

            // CRITICAL: Work exactly like swaps - replace the thread in the SAME HOP
            // The bridge converts the existing thread from one currency to another

            const inputCurrency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
            const outputCurrency = destAsset;
            const inputAmount = parseFloat(entry.amount);
            const outputAmount = parseFloat(destAmount);

            console.log(`Processing bridge conversion: ${inputAmount} ${inputCurrency} → ${outputAmount} ${outputCurrency}`);

            // Get the source thread information
            const sourceInternalId = entry.sourceThreadInternalId;
            const sourceNotation = entry.notation;

            // Find and consume the source thread in the input currency
            if (investigation.availableThreads[inputCurrency]) {
                // Look for the source thread
                for (const key in investigation.availableThreads[inputCurrency]) {
                    const thread = investigation.availableThreads[inputCurrency][key];

                    // Check if this is our source thread
                    if (key === sourceInternalId || thread.internalId === sourceInternalId ||
                        thread.notation === sourceNotation || key.includes(sourceNotation)) {

                        // For bridges, we consume the ENTIRE thread (not partial like some swaps)
                        delete investigation.availableThreads[inputCurrency][key];
                        console.log(`Consumed thread ${key} from ${inputCurrency} for bridge conversion`);
                        break;
                    }
                }
            }

            // Create the output thread in the new currency (exactly like swaps do)
            if (!investigation.availableThreads[outputCurrency]) {
                investigation.availableThreads[outputCurrency] = {};
            }

            // For bridge outputs, we need TRULY unique IDs for the dual-layer system
            // Each bridge output is a separate thread with its own unique internal ID
            // The notation stays the same for display, but internal ID must be unique
            // Force unique ID generation for every bridge output
            const outputInternalId = generateInternalThreadId(`bridge_${entryId}`, outputCurrency, true); // Force unique with timestamp

            // For bridge outputs, check if this exact bridge output already exists (same tx hash)
            // Multiple bridge outputs from the same source notation are allowed
            let existingThread = null;
            let existingThreadKey = null;

            // Check if this exact bridge output already exists (using the unique key that includes entry ID)
            if (investigation.availableThreads[outputCurrency][outputInternalId]) {
                existingThread = investigation.availableThreads[outputCurrency][outputInternalId];
                existingThreadKey = outputInternalId;
                console.log(`Found existing bridge output for entry ${entryId}, will update it`);
            }
            // REMOVED: We no longer check for same tx hash across different entries
            // Each bridge conversion entry should create its own thread

            if (existingThread) {
                console.log(`Updating existing thread for ${sourceNotation} in ${outputCurrency}, amount from ${existingThread.totalAmount} to ${outputAmount}`);
                // Update the existing thread
                existingThread.totalAmount = outputAmount;
                existingThread.availableAmount = outputAmount;
                existingThread.destinationTxHash = txHash;
                existingThread.sourceWallet = destWallet;
                existingThread.chainId = destChain;
                existingThread.chainName = window.blockchainAPIs?.[destChain]?.name || destChain;
                existingThread.sourceType = 'bridge_output';

                // If the thread has a different key, delete it and re-add with correct key
                if (existingThreadKey !== outputInternalId) {
                    delete investigation.availableThreads[outputCurrency][existingThreadKey];
                    investigation.availableThreads[outputCurrency][outputInternalId] = existingThread;
                    existingThread.internalId = outputInternalId;
                }

                showNotification(`✅ Bridge output updated! Thread ${sourceNotation} updated to ${outputAmount} ${outputCurrency} on ${destChain}.`, 'success', 8000);
            } else {
                // Create the bridge output thread (mirrors swap output structure)
                investigation.availableThreads[outputCurrency][outputInternalId] = {
                    // Dual-layer tracking (same as swap outputs)
                    notation: sourceNotation,  // KEEP ORIGINAL NOTATION for audit trail
                    internalId: outputInternalId,
                    entryId: entryId,  // Track which entry created this bridge output

                    // Thread amounts
                    totalAmount: outputAmount,
                    availableAmount: outputAmount,
                    assignments: [],

                    // Source information
                    sourceWallet: destWallet,  // Bridge destination becomes the source
                    sourceType: 'bridge_output',  // Mark as bridge output (like swap_output)
                    hopLevel: hop.hopNumber,  // SAME HOP LEVEL (critical!)

                    // Tracking information
                    createdAt: new Date().toISOString(),
                    isActive: true,
                    parentThreads: [sourceInternalId || sourceNotation],
                    childThreads: [],
                    currency: outputCurrency,

                    // Chain tracking - use destination chain
                    chainId: destChain,
                    chainName: window.blockchainAPIs?.[destChain]?.name || destChain,

                    // Bridge-specific metadata (like swap metadata)
                    bridgeConverted: true,  // Like swapConverted flag
                    originalCurrency: inputCurrency,
                    bridgeType: walletType === 'brown' ? 'defi' : 'cex',
                    sourceTxHash: entry.txHash,
                    destinationTxHash: txHash,

                    // Bridge details for audit
                    bridgeDetails: {
                        fromChain: entry.chain || 'unknown',
                        toChain: destChain,
                        fromAmount: inputAmount,
                        toAmount: outputAmount,
                        fromCurrency: inputCurrency,
                        toCurrency: outputCurrency,
                        bridgeAddress: entry.toWallet
                    }
                };

                console.log(`Created bridge output thread: ${sourceNotation} with ${outputAmount} ${outputCurrency} on ${destChain} at hop ${hop.hopNumber}`);
                showNotification(`✨ Bridge conversion complete: ${inputAmount} ${inputCurrency} → ${outputAmount} ${outputCurrency} (available in Hop ${hop.hopNumber})`, 'info', 5000);
            }

            // Close modal - find the specific bridge output modal
            const modal = document.getElementById('bridgeOutputModal') || document.querySelector('.modal');
            if (modal) {
                modal.remove();
            }

            // Re-render
            buildAvailableThreadsIndex(); // Rebuild to create output threads
            renderHops();
            saveToStorage();

            // Always shows as bridge since we force brown wallet type
            showNotification(`✅ Bridge output logged! Wallet reclassified to bridge (brown). Thread ${entry.notation} converted to ${outputAmount} ${outputCurrency} on ${destChain}. Continue tracing in Hop ${hop.hopNumber}.`, 'success', 8000);
        }

        function validateTransactionChronology(victim) {
            // Get all transactions with dates
            const transactionsWithDates = victim.transactions
                .filter(t => t.datetime && t.datetime.trim() !== '')
                .map(t => ({
                    id: t.id,
                    datetime: t.datetime,
                    timezone: t.timezone || 'UTC',
                    timestamp: convertToUTC(t.datetime, t.timezone || 'UTC')
                }));
            
            // Check if transactions are in chronological order
            for (let i = 0; i < transactionsWithDates.length - 1; i++) {
                const current = transactionsWithDates[i];
                const next = transactionsWithDates[i + 1];
                
                if (current.timestamp > next.timestamp) {
                    return `Transaction V${victim.id}-T${current.id} (${formatDateTimeDisplay(current.datetime, current.timezone)}) occurs AFTER V${victim.id}-T${next.id} (${formatDateTimeDisplay(next.datetime, next.timezone)}).\n\nTransaction IDs must be in chronological order.`;
                }
            }
            
            return null; // No errors
        }
        
        function convertToUTC(datetime, timezone) {
            // Convert datetime string to UTC timestamp for comparison
            const date = new Date(datetime);
            
            // For better timezone handling, check if the date is in DST period
            const isDST = (d) => {
                const jan = new Date(d.getFullYear(), 0, 1).getTimezoneOffset();
                const jul = new Date(d.getFullYear(), 6, 1).getTimezoneOffset();
                return Math.max(jan, jul) !== d.getTimezoneOffset();
            };
            
            // Timezone offset map with DST handling
            const timezoneOffsets = {
                'UTC': 0,
                'EST': -5,
                'EDT': -4,
                'CST': -6,
                'CDT': -5,
                'MST': -7,
                'MDT': -6,
                'PST': -8,
                'PDT': -7,
                'GMT': 0,
                'CET': 1,
                'CEST': 2,
                'JST': 9,
                // Auto-detect DST for common US timezones
                'ET': isDST(date) ? -4 : -5,  // Eastern Time
                'CT': isDST(date) ? -5 : -6,  // Central Time
                'MT': isDST(date) ? -6 : -7,  // Mountain Time
                'PT': isDST(date) ? -7 : -8   // Pacific Time
            };
            
            const offset = timezoneOffsets[timezone] || 0;
            // Subtract offset to convert to UTC (negative offsets become positive)
            return date.getTime() - (offset * 60 * 60 * 1000);
        }
        
        function formatDateTimeDisplay(datetime, timezone) {
            if (!datetime) return 'No date';
            const date = new Date(datetime);
            const options = { 
                year: 'numeric', 
                month: '2-digit', 
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit'
            };
            return `${date.toLocaleDateString('en-US', options)} ${timezone}`;
        }
        
        // Get timezone offset in hours
        function getTimezoneOffset(timezone) {
            const timezoneOffsets = {
                'UTC': 0,
                'EST': -5,
                'EDT': -4,
                'CST': -6,
                'CDT': -5,
                'MST': -7,
                'MDT': -6,
                'PST': -8,
                'PDT': -7,
                'GMT': 0,
                'CET': 1,
                'CEST': 2,
                'JST': 9,
                'ET': -5,  // Will be handled with DST check
                'CT': -6,  // Will be handled with DST check
                'MT': -7,  // Will be handled with DST check
                'PT': -8   // Will be handled with DST check
            };
            
            return timezoneOffsets[timezone] !== undefined ? timezoneOffsets[timezone] : null;
        }
        
        // Convert datetime between timezones for display
        function convertDateTimeBetweenTimezones(datetime, fromTimezone, toTimezone) {
            if (!datetime) return '';
            
            // First convert to UTC
            const utcTimestamp = convertToUTC(datetime, fromTimezone);
            if (!utcTimestamp) return datetime;
            
            // Then convert to target timezone
            const toOffset = getTimezoneOffset(toTimezone);
            if (toOffset === null) return datetime;
            
            const targetDate = new Date(utcTimestamp + (toOffset * 60 * 60 * 1000));
            
            // Format as YYYY-MM-DDTHH:MM for datetime-local input
            const year = targetDate.getFullYear();
            const month = String(targetDate.getMonth() + 1).padStart(2, '0');
            const day = String(targetDate.getDate()).padStart(2, '0');
            const hours = String(targetDate.getHours()).padStart(2, '0');
            const minutes = String(targetDate.getMinutes()).padStart(2, '0');
            
            return `${year}-${month}-${day}T${hours}:${minutes}`;
        }
        
        // Handle timezone change in UI
        function onTimezoneChange(elementId, entryType, ...ids) {
            const timezoneSelect = event.target;
            const newTimezone = timezoneSelect.value;
            const datetimeInput = document.getElementById(elementId);
            
            if (!datetimeInput || !datetimeInput.value) return;
            
            // Get the current stored timezone
            let currentTimezone;
            if (entryType === 'victim') {
                const [victimId, transactionId] = ids;
                const victim = investigation.victims.find(v => v.id === victimId);
                const transaction = victim?.transactions.find(t => t.id === transactionId);
                currentTimezone = transaction?.timezone || 'UTC';
            } else if (entryType === 'hop') {
                const [hopNumber, entryId] = ids;
                const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
                const entry = hop?.entries.find(e => e.id === entryId);
                currentTimezone = entry?.timezone || 'UTC';
            }
            
            // Convert the displayed time to the new timezone
            const convertedTime = convertDateTimeBetweenTimezones(datetimeInput.value, currentTimezone, newTimezone);
            if (convertedTime && convertedTime !== datetimeInput.value) {
                datetimeInput.value = convertedTime;
            }
            
            // Update the stored timezone
            if (entryType === 'victim') {
                updateTransaction(...ids, 'timezone', newTimezone);
            } else if (entryType === 'hop') {
                updateHopEntry(...ids, 'timezone', newTimezone);
            }
        }

        function updateTransaction(victimId, transactionId, field, value) {
            const victim = investigation.victims.find(v => v.id === victimId);
            const transaction = victim.transactions.find(t => t.id === transactionId);
            
            // Store the old value in case we need to revert
            const oldValue = transaction[field];
            
            // Check for duplicate transaction hash
            if (field === 'txHash' && value && value.trim() !== '') {
                const duplicate = checkTransactionDuplicate(value, victimId, transactionId);
                if (duplicate) {
                    alert(`⚠️ Duplicate Transaction Hash!\n\nThis transaction hash already exists:\n- ${duplicate.victimName}, Transaction ${duplicate.transactionId}\n\nEach transaction hash must be unique.`);
                    // Don't update the value
                    const input = document.getElementById(`txHash_victim_${victimId}_${transactionId}`);
                    if (input) {
                        input.value = oldValue || '';
                    }
                    return;
                }
            }
            
            // Validate wallet address format
            if (field === 'receivingWallet' && value && value.trim() !== '') {
                const currency = getCurrencyFromTransaction(transaction);
                if (currency) {
                    const validation = validateWalletAddress(value, currency);
                    if (!validation.valid) {
                        const message = validation.suggestion ? 
                            `${validation.error}\n\n${validation.suggestion}` : 
                            validation.error;
                        
                        const proceed = confirm(`⚠️ Wallet Address Warning!\n\n${message}\n\nDo you want to use this address anyway?`);
                        
                        if (!proceed) {
                            // Revert the value
                            const input = document.querySelector(`input[onchange*="updateTransaction(${victimId}, ${transactionId}, 'receivingWallet'"]`);
                            if (input) {
                                input.value = oldValue || '';
                            }
                            return;
                        }
                    }
                }
                
                // Check all attribution sources for the address
                checkAllAttributions(value.trim()).then(attributions => {
                    if (attributions && attributions.length > 0) {
                        // Build attribution notes from all sources
                        let attributionNotes = [];
                        let displayInfo = [];
                        
                        attributions.forEach(attr => {
                            const entity = attr.entity;
                            const source = attr.source || 'Arkham';
                            attributionNotes.push(`[${source}] Entity: ${entity.name}${entity.type ? ` (${entity.type})` : ''}${entity.service ? ` - ${entity.service}` : ''}`);
                            displayInfo.push(`${source}: ${entity.name}${entity.type ? ` (${entity.type})` : ''}`);
                        });
                        
                        const attributionNote = attributionNotes.join('\n');
                        const displayText = displayInfo.join('\n');
                        
                        // Show a notification for victim transactions
                        const shouldAddNote = confirm(`🔍 Attribution Found!\n\n${displayText}\n\nWould you like to add this attribution to the transaction notes?`);
                        
                        if (shouldAddNote) {
                            if (transaction.notes) {
                                transaction.notes = attributionNote + '\n' + transaction.notes;
                            } else {
                                transaction.notes = attributionNote;
                            }
                            saveToStorage();
                            renderVictims();
                        }
                    }
                });
            }
            
            transaction[field] = value;
            
            // Validate chronological order when datetime is updated
            if (field === 'datetime' && value) {
                const chronologyError = validateTransactionChronology(victim);
                if (chronologyError) {
                    // Revert the change
                    transaction[field] = oldValue;
                    
                    // Show error message with fix option
                    const shouldFix = confirm(`❌ Chronological Order Error!\n\n${chronologyError}\n\nTransactions must be entered in chronological order for proper PIFO (Proceeds In First Out) compliance and smart allocation features.\n\nWould you like to automatically fix the order?\n\nClick OK to automatically reorder transactions chronologically.\nClick Cancel to revert your change.`);
                    
                    if (shouldFix) {
                        // Fix the order
                        fixVictimTransactionOrder(victimId);
                        return;
                    }
                    
                    // Re-render to show the reverted value
                    renderVictims();
                    return;
                }
            }
            
            // If receiving wallet changed and root total is confirmed, rebuild Universal Wallet Index
            if (field === 'receivingWallet' && investigation.rootTotalConfirmed) {
                buildUniversalWalletIndex();
                buildRedWalletIndex();
                renderHops(); // Re-render to update dropdowns
            }
            
            // Update red wallet index when any transaction field changes
            if (investigation.rootTotalConfirmed) {
                buildRedWalletIndex();
            }
            
            saveToStorage();
            updateValidationStatus();
            updateWorkflowSteps();
            updateGenerateRootSection();
        }

        function removeVictim(victimId) {
            if (confirm('Are you sure you want to remove this victim? This will also reset the root total confirmation.')) {
                investigation.victims = investigation.victims.filter(v => v.id !== victimId);
                investigation.rootTotalConfirmed = false;
                investigation.confirmedRootTotal = 0;
                investigation.confirmedRootTotalsByCurrency = {};
                renderVictims();
                saveToStorage();
                updateValidationStatus();
                updateWorkflowSteps();
            }
        }
        
        function completeVictim(victimId) {
            const victim = investigation.victims.find(v => v.id === victimId);
            if (!victim) return;
            
            // Validate victim has at least one transaction
            const validTransactions = victim.transactions.filter(t => 
                parseFloat(t.amount) > 0 && t.receivingWallet && t.receivingWallet.trim() !== ''
            );
            
            if (validTransactions.length === 0) {
                alert('Please add at least one transaction with amount and receiving wallet before completing this victim.');
                return;
            }
            
            // Validate all transactions have required data
            const incompleteTransactions = victim.transactions.filter(t => 
                parseFloat(t.amount) > 0 && (!t.receivingWallet || t.receivingWallet.trim() === '')
            );
            
            if (incompleteTransactions.length > 0) {
                alert(`Cannot complete victim ${victimId}: ${incompleteTransactions.length} transaction(s) are missing receiving wallet addresses.`);
                return;
            }
            
            if (confirm(`Complete Victim ${victimId}?\n\nThis will minimize the view to show only a summary. You can edit later if needed.`)) {
                victim.isCompleted = true;
                console.log(`Victim ${victimId} marked as completed:`, victim.isCompleted);

                // Build wallet indexes even before root total confirmation to allow early access
                buildUniversalWalletIndex();
                buildRedWalletIndex();

                renderVictims();
                saveToStorage();
                updateWorkflowSteps();
                updateGenerateRootSection();

                // Check if the state actually updated
                console.log('Victim state after completion:', victim);
                console.log('All victims:', investigation.victims);

                // Force a re-check of the Add Victim button
                setTimeout(() => {
                    const addVictimSection = document.getElementById('addVictimSection');
                    if (addVictimSection) {
                        const hasIncompleteVictim = investigation.victims.some(v => !v.isCompleted);
                        console.log('Has incomplete victims after completion:', hasIncompleteVictim);
                    }
                }, 100);
            }
        }
        
        function reopenVictim(victimId) {
            const victim = investigation.victims.find(v => v.id === victimId);
            if (victim) {
                victim.isCompleted = false;
                renderVictims();
                saveToStorage();
            }
        }

        function renderSummary() {
            const container = document.getElementById('summaryContent');
            
            const totalVictims = investigation.victims.length;
            const totalTransactions = investigation.victims.reduce((sum, v) => sum + v.transactions.length, 0);
            
            // Calculate totals by currency
            const rootTotalsByCurrency = investigation.confirmedRootTotalsByCurrency || {};
            const writeoffsByCurrency = {};
            const artByCurrency = {};
            
            // Calculate write-offs by currency from hop entries
            investigation.hops.forEach(hop => {
                hop.entries.forEach(entry => {
                    if (entry.entryType === 'writeoff' && parseFloat(entry.amount) > 0) {
                        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                        if (!writeoffsByCurrency[currency]) {
                            writeoffsByCurrency[currency] = 0;
                        }
                        writeoffsByCurrency[currency] += parseFloat(entry.amount);
                    }
                });
            });
            
            // Calculate ART by currency
            Object.entries(rootTotalsByCurrency).forEach(([currency, rootAmount]) => {
                const writeoffAmount = writeoffsByCurrency[currency] || 0;
                artByCurrency[currency] = rootAmount - writeoffAmount;
            });

            container.innerHTML = `
                <div class="summary-grid">
                    <div class="summary-card">
                        <h3>Total Victims</h3>
                        <div class="value">${totalVictims}</div>
                    </div>
                    <div class="summary-card">
                        <h3>Total Transactions</h3>
                        <div class="value">${totalTransactions}</div>
                    </div>
                    <div class="summary-card">
                        <h3>Total Hops</h3>
                        <div class="value">${investigation.hops.length}</div>
                    </div>
                </div>
                
                <div style="margin: 30px 0;">
                    <h3 style="color: #2c3e50; margin-bottom: 20px;">Financial Summary by Currency</h3>
                    ${Object.keys(rootTotalsByCurrency).length > 0 ? `
                        <div style="background: #f8f9fa; border-radius: 8px; padding: 20px; border: 2px solid #e8f0fe;">
                            ${Object.entries(rootTotalsByCurrency).map(([currency, rootAmount]) => {
                                const writeoffAmount = writeoffsByCurrency[currency] || 0;
                                const artAmount = artByCurrency[currency] || rootAmount - writeoffAmount;
                                return `
                                    <div style="margin-bottom: 20px; padding: 15px; background: white; border-radius: 6px; border-left: 4px solid #3498db;">
                                        <h4 style="color: #2c3e50; margin-bottom: 10px;">${currency}</h4>
                                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; font-size: 14px;">
                                            <div>
                                                <strong>Root Total:</strong><br>
                                                <span style="font-size: 1.2rem; color: #27ae60;">${rootAmount.toLocaleString()}</span>
                                            </div>
                                            <div>
                                                <strong>Write-offs:</strong><br>
                                                <span style="font-size: 1.2rem; color: #e74c3c;">${writeoffAmount.toLocaleString()}</span>
                                            </div>
                                            <div>
                                                <strong>Adjusted Root Total:</strong><br>
                                                <span style="font-size: 1.2rem; color: #3498db;">${artAmount.toLocaleString()}</span>
                                            </div>
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    ` : `
                        <div style="text-align: center; padding: 40px; color: #7f8c8d; background: #f8f9fa; border-radius: 8px; border: 2px dashed #bdc3c7;">
                            <p>No root totals confirmed yet. Please complete the victim setup and confirm your root total.</p>
                        </div>
                    `}
                </div>
            `;
        }

        // Update tracing method (PIFO vs LIBR)
        function updateTracingMethod(method) {
            investigation.tracingMethod = method;
            saveToUndoHistory();
            
            // Show warning if switching methods mid-investigation
            if (investigation.hops.length > 0) {
                const warning = method === 'LIBR' ? 
                    'LIBR method selected: This will arrest asset flow and keep funds in fewer wallets closer to the RED wallet. Useful for stablecoin burn/reissue strategies or when private key access may be obtained. Ensure consistency throughout your investigation.' :
                    'Switched back to PIFO (default method). Ensure all previous entries follow PIFO methodology.';
                showNotification(warning, 'info');
            }
            
            // Update any UI elements that might display the method
            const methodDisplay = document.getElementById('currentTracingMethod');
            if (methodDisplay) {
                methodDisplay.textContent = method;
            }
        }
        
        // Apply LIBR (Lowest Intermediate Balance Rule) when needed
        function applyLIBRMethod(walletAddress, startTime, endTime) {
            // LIBR: Find the lowest balance between two time points
            // This is a placeholder for when we implement blockchain lookups
            console.log(`LIBR method would analyze wallet ${walletAddress} between ${startTime} and ${endTime}`);
            
            // For now, return a warning that this needs manual calculation
            showNotification(
                'LIBR method requires manual balance analysis. Please determine the lowest intermediate balance for the wallet during the specified period.',
                'warning'
            );
            
            return null; // Would return the lowest balance amount
        }

        function updateValidationStatus() {
            const validationPanel = document.getElementById('validationStatus');
            
            // Early return if element doesn't exist (it was removed from the UI)
            if (!validationPanel) {
                return;
            }
            
            if (!investigation.rootTotalConfirmed) {
                validationPanel.className = 'validation-panel validation-warning';
                validationPanel.innerHTML = '<div>⚠ Setup Required</div><div>Complete steps 1-3 to begin tracing</div>';
                return;
            }

            const artByCurrency = getCurrentART();
            const currentThreadsByCurrency = {};
            
            // Calculate current thread totals by finding the highest hop entries for each trace path
            // Group entries by V-T notation to track each victim-transaction path
            const tracePathsByCurrency = {};
            
            investigation.hops.forEach(hop => {
                hop.entries.forEach(entry => {
                    if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0 && entry.notation) {
                        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                        
                        // Extract V-T path from notation (e.g., "V1-T1-H3" -> "V1-T1")
                        const pathMatch = entry.notation.match(/^(V\d+-T\d+)/);
                        if (pathMatch) {
                            const vtPath = pathMatch[1];
                            
                            if (!tracePathsByCurrency[currency]) {
                                tracePathsByCurrency[currency] = {};
                            }
                            if (!tracePathsByCurrency[currency][vtPath]) {
                                tracePathsByCurrency[currency][vtPath] = [];
                            }
                            
                            tracePathsByCurrency[currency][vtPath].push({
                                hopNumber: entry.hopNumber,
                                amount: parseFloat(entry.amount),
                                notation: entry.notation,
                                isConvergence: entry.isConvergence || false
                            });
                        }
                    }
                });
            });
            
            // For each currency and path, take only the highest hop number (current thread value)
            Object.entries(tracePathsByCurrency).forEach(([currency, paths]) => {
                if (!currentThreadsByCurrency[currency]) {
                    currentThreadsByCurrency[currency] = 0;
                }
                
                Object.entries(paths).forEach(([vtPath, entries]) => {
                    // Sort by hop number and take the highest (most recent)
                    entries.sort((a, b) => b.hopNumber - a.hopNumber);
                    const currentEntry = entries[0];
                    currentThreadsByCurrency[currency] += currentEntry.amount;
                });
            });
            
            // Check validation for each currency
            let allValid = true;
            let validationDetails = [];
            
            Object.keys(artByCurrency).forEach(currency => {
                const artAmount = artByCurrency[currency];
                const threadAmount = currentThreadsByCurrency[currency] || 0;
                const difference = Math.abs(threadAmount - artAmount);
                
                if (difference >= 0.01) {
                    allValid = false;
                    validationDetails.push(`${currency}: Thread ${threadAmount.toLocaleString()} != ART ${artAmount.toLocaleString()}`);
                } else {
                    validationDetails.push(`${currency}: ✓ ${threadAmount.toLocaleString()}`);
                }
            });
            
            if (allValid && Object.keys(artByCurrency).length > 0) {
                validationPanel.className = 'validation-panel';
                validationPanel.innerHTML = `<div>✓ Validation Passed</div><div>${validationDetails.join('<br>')}</div>`;
            } else {
                validationPanel.className = 'validation-panel validation-error';
                validationPanel.innerHTML = `<div>✗ Validation Failed</div><div>${validationDetails.join('<br>')}</div>`;
            }
        }

        function validateTraces() {
            updateValidationStatus();
        }

        // DUPLICATE FUNCTION REMOVED - Using the global version at line 9714
        /*function getWalletColor(type) {
            const colors = {
                'red': '#e74c3c',
                'pink': '#e91e63', 
                'yellow': '#f1c40f',
                'orange': '#f39c12',
                'brown': '#8d6e63',
                'black': '#2c3e50',
                'blue': '#3498db',
                'purple': '#9b59b6',
                'gray': '#95a5a6',
                'green': '#27ae60'
            };
            return colors[type] || '#3498db';
        }*/

        async function saveInvestigation() {
            if (!investigation.caseId) {
                alert('Please enter a Case ID before saving.');
                return;
            }

            // Ensure all necessary indices are built before saving
            buildAvailableThreadsIndex();

            // The investigation object now includes availableThreads index
            const dataStr = JSON.stringify(investigation, null, 2);
            
            // If we have a file handle from the File System Access API, use it
            if (fileHandle && isFileSystemAvailable) {
                try {
                    const writable = await fileHandle.createWritable();
                    await writable.write(dataStr);
                    await writable.close();
                    
                    showNotification('Investigation saved successfully!', 'success');
                    return;
                } catch (error) {
                    console.error('Error saving with file handle:', error);
                    // Fall back to download if file handle save fails
                }
            }
            
            // Default download method - use case ID as filename
            const filename = `${investigation.caseId}.bats`;
            downloadFile(dataStr, filename, 'application/json');
        }

        function loadInvestigation(event) {
    const file = event.target.files[0];
    if (!file) {
        console.log('No file selected');
        return;
    }

    console.log('Starting file load:', file.name, 'Size:', file.size, 'Type:', file.type);

    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            console.log('File read successfully, parsing JSON...');
            const content = e.target.result;
            
            // Parse JSON
            const loadedData = JSON.parse(content);
            console.log('JSON parsed successfully:', loadedData);
            
            // Validate basic structure
            if (!loadedData.victims || !loadedData.hops) {
                throw new Error('Invalid BATS investigation file - missing required data structure');
            }
            
            console.log('Basic validation passed');
            
            // Initialize enhanced structure if missing
            initializeCompleteIntegration(loadedData);
            
            // Migrate data structure if needed
            migrateToEnhancedStructure(loadedData);
            
            // Set the global investigation object
            investigation = loadedData;

            // Sort all hop entries chronologically after loading
            if (investigation.hops) {
                investigation.hops.forEach(hop => {
                    if (hop.entries && hop.entries.length > 0) {
                        sortHopEntriesChronologically(hop);
                    }
                });
            }

            // Set all hops and entries to collapsed state when loading a saved file
            // This keeps the interface clean when viewing large investigations
            window.hopCollapseState = {};
            window.entryCollapseState = {};
            if (investigation.hops) {
                investigation.hops.forEach(hop => {
                    // Collapse the hop itself
                    window.hopCollapseState[hop.hopNumber] = true; // Start collapsed

                    // Collapse all entries within the hop
                    if (hop.entries) {
                        hop.entries.forEach(entry => {
                            const entryKey = `${hop.hopNumber}_${entry.id}`;
                            window.entryCollapseState[entryKey] = true; // Start collapsed
                        });
                    }
                });
            }
            
            // Update form fields
            updateFormFieldsFromInvestigation();
            
            // Check chronological order of transactions
            const chronologyErrors = [];
            investigation.victims.forEach(victim => {
                const error = validateTransactionChronology(victim);
                if (error) {
                    chronologyErrors.push(`Victim ${victim.id}:\n${error}`);
                }
            });
            
            // Re-render everything
            // IMPORTANT: Rebuild thread index after loading to ensure availability
            buildAvailableThreadsIndex();

            renderAll();
            updateWorkflowSteps();

            // Update investigation completion status to show proper buttons
            updateInvestigationCompletionStatus();

            // Alert about chronology errors after rendering
            if (chronologyErrors.length > 0) {
                setTimeout(() => {
                    alert(`⚠️ WARNING: Transaction Chronology Issues Detected!\n\n${chronologyErrors.join('\n\n')}\n\nThe V-T notation requires transactions to be numbered in chronological order. Please review and correct the transaction order to ensure PIFO (Proceeds In First Out) compliance.\n\nYou can manually adjust the dates or re-number the transactions.`);
                }, 500);
            }

            // Clear the file input to allow re-loading the same file
            event.target.value = '';

            console.log('Investigation loaded successfully!');
            console.log('Available threads after loading:', investigation.availableThreads);

            // Show case status dashboard instead of simple alert
            showCaseStatusDashboard();
            
        } catch (error) {
            console.error('Error loading file:', error);
            alert('Error loading file: ' + error.message);
            
            // Clear the file input on error too
            event.target.value = '';
        }
    };
    
    reader.onerror = function() {
        console.error('File reading failed');
        alert('Failed to read the file. Please try again.');
        event.target.value = '';
    };
    
    reader.readAsText(file);
}
        function exportReport() {
            const report = generateBATSReport();
            downloadFile(report, 'BATS_Report_' + (investigation.caseId || 'Investigation') + '.html', 'text/html');
        }

        function exportJSON() {
            const data = JSON.stringify(investigation, null, 2);
            const filename = 'BATS_Data_' + (investigation.caseId || 'Investigation') + '.json';
            downloadFile(data, filename, 'application/json');
        }

        function exportCSV() {
            let csv = 'Type,Notation,Amount,Currency,From,To,WalletType,Hop,DateTime,Timezone,Notes\n';

            // Export hop entries (including writeoffs)
            investigation.hops.forEach(hop => {
                hop.entries.forEach(entry => {
                    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                    const utcTimestamp = entry.timestamp ? formatDateTimeForReport(entry.timestamp, entry.timezone || 'UTC') : 'Not specified';
                    csv += [
                        escapeCSVCell(entry.entryType),
                        escapeCSVCell(entry.notation),
                        escapeCSVCell(entry.amount),
                        escapeCSVCell(currency),
                        escapeCSVCell(entry.fromWallet),
                        escapeCSVCell(entry.toWallet),
                        escapeCSVCell(entry.toWalletType),
                        escapeCSVCell(entry.hopNumber),
                        escapeCSVCell(utcTimestamp),
                        escapeCSVCell('UTC'),
                        escapeCSVCell(entry.notes || entry.justification || '')
                    ].join(',') + '\n';
                });
            });

            const filename = 'BATS_Data_' + (investigation.caseId || 'Investigation') + '.csv';
            downloadFile(csv, filename, 'text/csv');
        }

        function generateBATSReport() {
            const totalVictims = investigation.victims.length;
            const rootTotalsByCurrency = investigation.confirmedRootTotalsByCurrency || {};
            
            // Calculate write-offs by currency from hop entries
            const writeoffsByCurrency = {};
            investigation.hops.forEach(hop => {
                hop.entries.forEach(entry => {
                    if (entry.entryType === 'writeoff' && parseFloat(entry.amount) > 0) {
                        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                        if (!writeoffsByCurrency[currency]) {
                            writeoffsByCurrency[currency] = 0;
                        }
                        writeoffsByCurrency[currency] += parseFloat(entry.amount);
                    }
                });
            });

            // Build Red Wallet Index section
            const redWalletSection = investigation.redWalletIndex && investigation.redWalletIndex.length > 0 ? `
                <div class="section">
                    <div class="section-title">Section 2: Red Wallet Index - Victim Deposit Summary</div>
                    <table>
                        <tr>
                            <th>V-T Notation</th>
                            <th>Wallet ID</th>
                            <th>Deposit Date</th>
                            <th>Amount</th>
                            <th>Currency</th>
                            <th>Wallet Address</th>
                            <th>Notes</th>
                        </tr>
                        ${investigation.redWalletIndex.map(entry => `
                            <tr>
                                <td>${entry.vtNotation}</td>
                                <td>${entry.walletId || 'Not assigned'}</td>
                                <td>${entry.depositDate ? formatDateTimeForReport(entry.depositDate, entry.timezone) : 'Not specified'}</td>
                                <td>${entry.amount.toLocaleString()}</td>
                                <td>${entry.currency}</td>
                                <td style="font-family: monospace; font-size: 11px; word-break: break-all;">${entry.walletAddress}</td>
                                <td>${(entry.notes || '') + (entry.investigativeNotes ? ' | ' + entry.investigativeNotes : '')}</td>
                            </tr>
                        `).join('')}
                    </table>
                </div>
            ` : '';

            return `<!DOCTYPE html>
<html>
<head>
    <title>B.A.T.S. Investigation Report - ${investigation.caseId}</title>
    <style>
        body { font-family: 'Segoe UI', Arial, sans-serif; margin: 40px; line-height: 1.6; color: #2c3e50; }
        .header { text-align: center; border-bottom: 3px solid #2c3e50; padding-bottom: 20px; margin-bottom: 30px; }
        .section { margin: 30px 0; }
        .section-title { background: #2c3e50; color: white; padding: 15px; margin-bottom: 20px; font-weight: 600; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        th, td { border: 1px solid #ddd; padding: 12px; text-align: left; }
        th { background: #f8f9fa; font-weight: bold; color: #2c3e50; }
        .summary-box { background: #e8f5e8; border: 2px solid #27ae60; padding: 20px; margin: 20px 0; border-radius: 8px; }
        .currency-section { background: #f8f9fa; border: 1px solid #ddd; padding: 15px; margin: 10px 0; border-radius: 6px; }
    </style>
</head>
<body>
    <div class="header">
        <h1>B.A.T.S. Investigation Report</h1>
        <h2>Block Audit Tracing Standard</h2>
        <p><strong>Case ID:</strong> ${investigation.caseId}</p>
        <p><strong>Investigator:</strong> ${investigation.investigator}</p>
        <p><strong>Report Generated:</strong> ${new Date().toISOString().replace('T', ' ').replace('.000Z', ' UTC')}</p>
        <p style="font-style: italic; color: #666;">All timestamps in this report are displayed in UTC for compliance and consistency.</p>
    </div>

    <div class="section">
        <div class="section-title">Section 1: Case Summary</div>
        <p><strong>Case Type:</strong> ${investigation.caseType}</p>
        <p><strong>Total Victims:</strong> ${totalVictims}</p>
        <p><strong>Investigation Period:</strong> ${new Date(investigation.created).toLocaleDateString()} - ${new Date().toLocaleDateString()}</p>
        ${investigation.caseSynopsis ? `
        <div style="margin-top: 20px;">
            <p><strong>Case Synopsis:</strong></p>
            <div style="background: #f8f9fa; border-left: 4px solid #3498db; padding: 15px; margin-top: 10px;">
                ${investigation.caseSynopsis.replace(/\n/g, '<br>')}
            </div>
        </div>
        ` : ''}
    </div>

    ${redWalletSection}

    ${investigation.hops.length > 0 ? `
    <div class="section">
        <div class="section-title">Section 3: Hop Documentation</div>
        ${investigation.hops.map(hop => `
            <h3>Hop ${hop.hopNumber}</h3>
            <table>
                <tr>
                    <th>Entry Type</th>
                    <th>Notation</th>
                    <th>Amount</th>
                    <th>Currency</th>
                    <th>From Wallet</th>
                    <th>To Wallet</th>
                    <th>Classification</th>
                    <th>Transaction Hash</th>
                    <th>Timestamp</th>
                    <th>Notes</th>
                </tr>
                ${hop.entries.map(entry => `
                    <tr>
                        <td>${entry.entryType}</td>
                        <td>${entry.notation}</td>
                        <td>${(parseFloat(entry.amount) || 0).toLocaleString()}</td>
                        <td>${entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency}</td>
                        <td style="font-family: monospace; font-size: 11px; word-break: break-all;">${entry.fromWallet}</td>
                        <td style="font-family: monospace; font-size: 11px; word-break: break-all;">${entry.toWallet}</td>
                        <td>${walletTypes[entry.toWalletType] || entry.toWalletType}</td>
                        <td style="font-family: monospace; font-size: 11px; word-break: break-all;">${entry.txHash}</td>
                        <td>${entry.timestamp ? formatDateTimeForReport(entry.timestamp, entry.timezone || 'UTC') : 'Not specified'}</td>
                        <td>${entry.notes || entry.justification || ''}</td>
                    </tr>
                `).join('')}
            </table>
        `).join('')}
    </div>
    ` : ''}

    <div class="section">
        <div class="section-title">Section 4: Summary of Findings</div>
        <div class="summary-box">
            <h3>Golden Thread Analysis by Currency</h3>
            ${Object.keys(rootTotalsByCurrency).length > 0 ? Object.entries(rootTotalsByCurrency).map(([currency, rootAmount]) => {
                const writeoffAmount = writeoffsByCurrency[currency] || 0;
                const adjustedTotal = rootAmount - writeoffAmount;
                
                // Calculate traced amount for this currency
                let tracedAmount = 0;
                investigation.hops.forEach(hop => {
                    hop.entries.forEach(entry => {
                        if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0) {
                            const entryCurrency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                            if (entryCurrency === currency) {
                                tracedAmount += parseFloat(entry.amount);
                            }
                        }
                    });
                });
                
                const isValid = Math.abs(tracedAmount - adjustedTotal) < 0.01;
                
                return `
                    <div class="currency-section">
                        <h4>${currency}</h4>
                        <p><strong>Root Total:</strong> ${rootAmount.toLocaleString()}</p>
                        <p><strong>Write-offs:</strong> ${writeoffAmount.toLocaleString()}</p>
                        <p><strong>Adjusted Root Total:</strong> ${adjustedTotal.toLocaleString()}</p>
                        <p><strong>Traced Amount:</strong> ${tracedAmount.toLocaleString()}</p>
                        <p><strong>Mathematical Validation:</strong> <span style="color: ${isValid ? 'green' : 'red'}; font-weight: bold;">${isValid ? 'PASSED' : 'FAILED'}</span></p>
                    </div>
                `;
            }).join('') : '<p>No confirmed root totals available.</p>'}
        </div>
    </div>
</body>
</html>`;
        }

        // Comprehensive Narrative Report Generator for Word/Legal Documentation
        function exportNarrativeReport() {
            const report = generateNarrativeReport();
            const filename = `BATS_Narrative_Report_${investigation.caseId || 'Investigation'}_${new Date().toISOString().split('T')[0]}.doc`;
            downloadFile(report, filename, 'application/msword');
        }

        // Comprehensive Report Function
        function showComprehensiveReport() {
            // Generate all reports and indices
            const narrativeReport = generateNarrativeReport();
            const victimIndex = generateVictimIndex();
            const walletIndex = generateUniversalWalletIndex();
            const terminalReport = generateTerminalWalletReport();
            const redWalletIndex = generateRedWalletIndex();

            // Create modal with all reports
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.8);
                z-index: 10000;
                display: flex;
                justify-content: center;
                align-items: center;
                overflow: auto;
            `;

            const content = document.createElement('div');
            content.style.cssText = `
                background: white;
                width: 90%;
                max-width: 1200px;
                max-height: 90vh;
                overflow-y: auto;
                border-radius: 12px;
                position: relative;
            `;

            // Calculate totals
            let totalsByCurrency = {};
            if (investigation.rootTotals) {
                Object.entries(investigation.rootTotals).forEach(([currency, amount]) => {
                    if (!totalsByCurrency[currency]) totalsByCurrency[currency] = 0;
                    totalsByCurrency[currency] += amount;
                });
            }

            const totalAmount = Object.values(totalsByCurrency).reduce((sum, amount) => sum + amount, 0);
            const currencyBreakdown = Object.entries(totalsByCurrency)
                .map(([currency, amount]) => `${amount.toFixed(6)} ${currency}`)
                .join(' + ');

            content.innerHTML = `
                <div style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); color: white; padding: 30px; border-radius: 12px 12px 0 0;">
                    <button onclick="this.closest('[style*=\\"z-index: 10000\\"]').remove()" style="position: absolute; right: 15px; top: 15px; background: rgba(255,255,255,0.2); border: none; color: white; padding: 8px 12px; border-radius: 4px; cursor: pointer; font-size: 16px;">✕</button>
                    <h2 style="margin: 0 0 10px 0; font-size: 2rem;">📋 Comprehensive Investigation Report</h2>
                    <p style="margin: 0; opacity: 0.95;">Complete analysis with all indices, narratives, and terminal wallet tracking</p>
                    <div style="margin-top: 15px; padding: 15px; background: rgba(255,255,255,0.1); border-radius: 8px;">
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                            <div>
                                <div style="opacity: 0.8; font-size: 12px;">Total Traced</div>
                                <div style="font-size: 20px; font-weight: bold;">${totalAmount.toFixed(2)}</div>
                                <div style="opacity: 0.8; font-size: 11px;">${currencyBreakdown}</div>
                            </div>
                            <div>
                                <div style="opacity: 0.8; font-size: 12px;">Victims</div>
                                <div style="font-size: 20px; font-weight: bold;">${investigation.victims ? investigation.victims.length : 0}</div>
                            </div>
                            <div>
                                <div style="opacity: 0.8; font-size: 12px;">Hops Traced</div>
                                <div style="font-size: 20px; font-weight: bold;">${investigation.hops ? investigation.hops.length : 0}</div>
                            </div>
                            <div>
                                <div style="opacity: 0.8; font-size: 12px;">Terminal Wallets</div>
                                <div style="font-size: 20px; font-weight: bold;">${investigation.terminalWalletIndex ? investigation.terminalWalletIndex.length : 0}</div>
                            </div>
                        </div>
                    </div>
                </div>

                <div style="padding: 20px;">
                    <!-- Navigation Tabs -->
                    <div style="display: flex; gap: 5px; margin-bottom: 20px; border-bottom: 2px solid #e0e0e0;">
                        <button onclick="showReportSection('narrative')" class="report-tab-btn active" style="padding: 10px 20px; background: #667eea; color: white; border: none; border-radius: 8px 8px 0 0; cursor: pointer;">📖 Narrative</button>
                        <button onclick="showReportSection('victims')" class="report-tab-btn" style="padding: 10px 20px; background: #f0f0f0; color: #333; border: none; border-radius: 8px 8px 0 0; cursor: pointer;">👥 Victims</button>
                        <button onclick="showReportSection('wallets')" class="report-tab-btn" style="padding: 10px 20px; background: #f0f0f0; color: #333; border: none; border-radius: 8px 8px 0 0; cursor: pointer;">💼 All Wallets</button>
                        <button onclick="showReportSection('terminals')" class="report-tab-btn" style="padding: 10px 20px; background: #f0f0f0; color: #333; border: none; border-radius: 8px 8px 0 0; cursor: pointer;">🏦 Exchanges</button>
                        <button onclick="showReportSection('redwallets')" class="report-tab-btn" style="padding: 10px 20px; background: #f0f0f0; color: #333; border: none; border-radius: 8px 8px 0 0; cursor: pointer;">🚨 Red Wallets</button>
                    </div>

                    <!-- Report Sections -->
                    <div id="narrative-section" class="report-section" style="display: block;">
                        <h3>📖 Narrative Report</h3>
                        <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; max-height: 500px; overflow-y: auto;">
                            ${narrativeReport}
                        </div>
                    </div>

                    <div id="victims-section" class="report-section" style="display: none;">
                        <h3>👥 Victim Index</h3>
                        <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; max-height: 500px; overflow-y: auto;">
                            ${victimIndex}
                        </div>
                    </div>

                    <div id="wallets-section" class="report-section" style="display: none;">
                        <h3>💼 Universal Wallet Index</h3>
                        <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; max-height: 500px; overflow-y: auto;">
                            ${walletIndex}
                        </div>
                    </div>

                    <div id="terminals-section" class="report-section" style="display: none;">
                        <h3>🏦 Terminal Wallet Report</h3>
                        <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; max-height: 500px; overflow-y: auto;">
                            ${terminalReport}
                        </div>
                    </div>

                    <div id="redwallets-section" class="report-section" style="display: none;">
                        <h3>🚨 Red Wallet Index</h3>
                        <div style="background: #f8f9fa; padding: 20px; border-radius: 8px; max-height: 500px; overflow-y: auto;">
                            ${redWalletIndex}
                        </div>
                    </div>

                    <!-- Export Buttons -->
                    <div style="margin-top: 20px; padding-top: 20px; border-top: 1px solid #e0e0e0; display: flex; gap: 10px; justify-content: center;">
                        <button onclick="exportComprehensiveReport('pdf')" class="btn btn-primary">📄 Export as PDF</button>
                        <button onclick="exportComprehensiveReport('html')" class="btn btn-success">🌐 Export as HTML</button>
                        <button onclick="copyComprehensiveReport()" class="btn btn-info">📋 Copy to Clipboard</button>
                        <button onclick="printComprehensiveReport()" class="btn btn-secondary">🖨️ Print Report</button>
                    </div>
                </div>
            `;

            modal.appendChild(content);
            document.body.appendChild(modal);

            // Add styles for tab switching
            const style = document.createElement('style');
            style.textContent = `
                .report-tab-btn.active {
                    background: #667eea !important;
                    color: white !important;
                }
                .report-section {
                    animation: fadeIn 0.3s ease;
                }
                @keyframes fadeIn {
                    from { opacity: 0; }
                    to { opacity: 1; }
                }
            `;
            document.head.appendChild(style);
        }

        // Function to switch between report sections
        window.showReportSection = function(section) {
            // Hide all sections
            document.querySelectorAll('.report-section').forEach(s => s.style.display = 'none');
            // Show selected section
            document.getElementById(`${section}-section`).style.display = 'block';
            // Update tab buttons
            document.querySelectorAll('.report-tab-btn').forEach(btn => {
                btn.classList.remove('active');
                btn.style.background = '#f0f0f0';
                btn.style.color = '#333';
            });
            event.target.classList.add('active');
            event.target.style.background = '#667eea';
            event.target.style.color = 'white';
        };

        // Export comprehensive report function
        window.exportComprehensiveReport = function(format) {
            const allReports = {
                narrative: generateNarrativeReport(),
                victims: generateVictimIndex(),
                wallets: generateUniversalWalletIndex(),
                terminals: generateTerminalWalletReport(),
                redWallets: generateRedWalletIndex()
            };

            if (format === 'html') {
                const htmlContent = `
                    <!DOCTYPE html>
                    <html>
                    <head>
                        <title>BATS Investigation Report - ${investigation.metadata?.caseNumber || 'Investigation'}</title>
                        <style>
                            body { font-family: Arial, sans-serif; max-width: 1200px; margin: 0 auto; padding: 20px; }
                            h1 { color: #667eea; }
                            h2 { color: #764ba2; border-bottom: 2px solid #e0e0e0; padding-bottom: 10px; }
                            .section { margin-bottom: 40px; }
                            table { width: 100%; border-collapse: collapse; }
                            th, td { padding: 8px; text-align: left; border: 1px solid #ddd; }
                            th { background: #f0f0f0; }
                        </style>
                    </head>
                    <body>
                        <h1>Comprehensive Investigation Report</h1>
                        <div class="section">
                            <h2>Narrative Report</h2>
                            ${allReports.narrative}
                        </div>
                        <div class="section">
                            <h2>Victim Index</h2>
                            ${allReports.victims}
                        </div>
                        <div class="section">
                            <h2>Universal Wallet Index</h2>
                            ${allReports.wallets}
                        </div>
                        <div class="section">
                            <h2>Terminal Wallet Report</h2>
                            ${allReports.terminals}
                        </div>
                        <div class="section">
                            <h2>Red Wallet Index</h2>
                            ${allReports.redWallets}
                        </div>
                    </body>
                    </html>
                `;
                const blob = new Blob([htmlContent], { type: 'text/html' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `BATS_Report_${investigation.metadata?.caseNumber || 'Investigation'}_${new Date().toISOString().split('T')[0]}.html`;
                a.click();
            } else if (format === 'pdf') {
                alert('PDF export requires print functionality. Please use Print Report and select "Save as PDF" in the print dialog.');
            }
        };

        // Copy comprehensive report to clipboard
        window.copyComprehensiveReport = function() {
            const allReports = `
COMPREHENSIVE INVESTIGATION REPORT
Generated: ${new Date().toISOString()}

=== NARRATIVE REPORT ===
${generateNarrativeReport().replace(/<[^>]*>/g, '')}

=== VICTIM INDEX ===
${generateVictimIndex().replace(/<[^>]*>/g, '')}

=== UNIVERSAL WALLET INDEX ===
${generateUniversalWalletIndex().replace(/<[^>]*>/g, '')}

=== TERMINAL WALLET REPORT ===
${generateTerminalWalletReport().replace(/<[^>]*>/g, '')}

=== RED WALLET INDEX ===
${generateRedWalletIndex().replace(/<[^>]*>/g, '')}
            `;
            navigator.clipboard.writeText(allReports);
            alert('Comprehensive report copied to clipboard!');
        };

        // Print comprehensive report
        window.printComprehensiveReport = function() {
            const printWindow = window.open('', '_blank');
            const allReports = {
                narrative: generateNarrativeReport(),
                victims: generateVictimIndex(),
                wallets: generateUniversalWalletIndex(),
                terminals: generateTerminalWalletReport(),
                redWallets: generateRedWalletIndex()
            };

            printWindow.document.write(`
                <!DOCTYPE html>
                <html>
                <head>
                    <title>BATS Investigation Report</title>
                    <style>
                        body { font-family: Arial, sans-serif; }
                        h1, h2 { color: #333; }
                        table { width: 100%; border-collapse: collapse; margin-bottom: 20px; }
                        th, td { padding: 8px; text-align: left; border: 1px solid #ddd; }
                        th { background: #f0f0f0; }
                        .section { margin-bottom: 40px; page-break-inside: avoid; }
                    </style>
                </head>
                <body>
                    <h1>Comprehensive Investigation Report</h1>
                    <div class="section">
                        <h2>Narrative Report</h2>
                        ${allReports.narrative}
                    </div>
                    <div class="section">
                        <h2>Victim Index</h2>
                        ${allReports.victims}
                    </div>
                    <div class="section">
                        <h2>Universal Wallet Index</h2>
                        ${allReports.wallets}
                    </div>
                    <div class="section">
                        <h2>Terminal Wallet Report</h2>
                        ${allReports.terminals}
                    </div>
                    <div class="section">
                        <h2>Red Wallet Index</h2>
                        ${allReports.redWallets}
                    </div>
                </body>
                </html>
            `);
            printWindow.document.close();
            printWindow.print();
        };

        function generateNarrativeReport() {
            const reportDate = new Date().toISOString().split('T')[0];
            const reportTime = new Date().toISOString().split('T')[1].replace('.000Z', ' UTC');

            // Helper function to format currency amounts
            const formatAmount = (amount, currency) => {
                const val = parseFloat(amount);
                return `${val.toLocaleString('en-US', { minimumFractionDigits: 2, maximumFractionDigits: 6 })} ${currency}`;
            };

            // Helper function to format wallet addresses
            const formatWallet = (address) => {
                if (!address) return 'N/A';
                return `${address.substring(0, 10)}...${address.substring(address.length - 8)}`;
            };

            // Build victim narrative section
            const victimNarratives = investigation.victims.map(victim => {
                const totalLoss = parseFloat(victim.totalLoss);
                const transactions = victim.transactions.map(tx => {
                    const currency = tx.currency === 'CUSTOM' ? tx.customCurrency : tx.currency;
                    return `Transaction ${tx.id} occurred on ${formatDateTimeForReport(tx.datetime, tx.timezone || 'UTC')}, ` +
                           `transferring ${formatAmount(tx.amount, currency)} to wallet ${formatWallet(tx.receivingWallet)}` +
                           (tx.notes ? `. ${tx.notes}` : '.');
                }).join(' ');

                return `<p><strong>Victim ${victim.id}: ${victim.name}</strong><br/>
                Contact: ${victim.contactInfo}<br/>
                Total Loss: ${formatAmount(totalLoss, 'USD equivalent')}<br/>
                ${victim.notes ? `Background: ${victim.notes}<br/>` : ''}
                <br/>
                ${transactions}</p>`;
            }).join('\n');

            // Build hop-by-hop narrative
            let hopNarratives = '';
            let previousWallets = new Set();

            investigation.hops.forEach(hop => {
                const hopART = hop.artAtStartByCurrency || {};
                const hopStartAmounts = Object.entries(hopART).map(([currency, amount]) =>
                    formatAmount(amount, currency)
                ).join(', ');

                hopNarratives += `<h3>Hop ${hop.hopNumber}: Movement Analysis</h3>\n`;
                hopNarratives += `<p><em>Starting ART (Adjusted Root Total): ${hopStartAmounts}</em></p>\n`;

                const narrativeEntries = hop.entries.map(entry => {
                    let narrative = '';
                    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                    const amount = formatAmount(entry.amount, currency);

                    if (entry.entryType === 'trace') {
                        const walletType = walletTypes[entry.toWalletType] || entry.toWalletType;
                        narrative = `On ${formatDateTimeForReport(entry.timestamp, entry.timezone || 'UTC')}, ` +
                                  `traced funds totaling ${amount} moving from wallet ${formatWallet(entry.fromWallet)} ` +
                                  `to wallet ${formatWallet(entry.toWallet)} (classified as ${walletType}). ` +
                                  `Transaction hash: ${entry.txHash || 'Not provided'}. `;

                        if (entry.isTerminalWallet) {
                            const exchangeName = entry.exchangeName || 'Unknown Exchange';
                            narrative += `<strong>TERMINAL WALLET DETECTED:</strong> These funds have arrived at ${exchangeName}. `;
                        }

                        if (entry.notes) {
                            narrative += `<em>Investigator's notes: ${entry.notes}</em> `;
                        }
                    } else if (entry.entryType === 'swap') {
                        const outputAmount = formatAmount(entry.outputAmount || entry.swapDetails?.toAmount,
                                                         entry.outputCurrency || entry.swapDetails?.toCurrency);
                        const dexName = entry.swapDetails?.dexName || 'Unknown DEX';

                        narrative = `On ${formatDateTimeForReport(entry.timestamp, entry.timezone || 'UTC')}, ` +
                                  `observed a currency swap on ${dexName} converting ${amount} to ${outputAmount}. ` +
                                  `The swap occurred within wallet ${formatWallet(entry.fromWallet)}. ` +
                                  `Transaction hash: ${entry.txHash || 'Not provided'}. `;

                        if (entry.notes) {
                            narrative += `<em>Investigator's notes: ${entry.notes}</em> `;
                        }
                    } else if (entry.entryType === 'writeoff') {
                        const category = entry.category || 'unspecified';
                        narrative = `Write-off documented: ${amount} marked as unrecoverable (Category: ${category}). ` +
                                  `Justification: ${entry.justification || 'No justification provided'}. `;

                        if (entry.notes) {
                            narrative += `<em>Additional notes: ${entry.notes}</em> `;
                        }
                    } else if (entry.entryType === 'cold_storage') {
                        narrative = `Cold storage identified: ${amount} moved to cold storage wallet ${formatWallet(entry.toWallet)}. ` +
                                  `Transaction hash: ${entry.txHash || 'Not provided'}. `;

                        if (entry.notes) {
                            narrative += `<em>Investigator's notes: ${entry.notes}</em> `;
                        }
                    }

                    // Add source thread information
                    if (entry.sourceThreadId) {
                        narrative += `[Source: Thread ${entry.sourceThreadId}] `;
                    }

                    return `<p>${narrative}</p>`;
                }).join('\n');

                hopNarratives += narrativeEntries;

                if (hop.completed) {
                    hopNarratives += `<p><strong>Hop ${hop.hopNumber} Status:</strong> COMPLETED</p>\n`;
                } else {
                    hopNarratives += `<p><strong>Hop ${hop.hopNumber} Status:</strong> IN PROGRESS</p>\n`;
                }

                hopNarratives += '<hr/>\n';
            });

            // Build terminal wallet summary
            let terminalWalletNarrative = '';
            if (investigation.terminalWalletIndex && investigation.terminalWalletIndex.length > 0) {
                const groupedByExchange = {};
                investigation.terminalWalletIndex.forEach(terminal => {
                    const exchange = terminal.exchangeName || 'Unknown Exchange';
                    if (!groupedByExchange[exchange]) {
                        groupedByExchange[exchange] = [];
                    }
                    groupedByExchange[exchange].push(terminal);
                });

                terminalWalletNarrative = '<h2>Terminal Wallet Analysis</h2>\n';
                terminalWalletNarrative += '<p>The following funds have been traced to cryptocurrency exchanges where legal process may be required for recovery:</p>\n';

                Object.entries(groupedByExchange).forEach(([exchange, terminals]) => {
                    const totalByExchange = {};
                    terminals.forEach(t => {
                        if (!totalByExchange[t.currency]) {
                            totalByExchange[t.currency] = 0;
                        }
                        totalByExchange[t.currency] += parseFloat(t.amount);
                    });

                    terminalWalletNarrative += `<h3>${exchange}</h3>\n`;
                    terminalWalletNarrative += '<ul>\n';

                    terminals.forEach(terminal => {
                        terminalWalletNarrative += `<li>${formatDateTimeForReport(terminal.timestamp, 'UTC')}: ` +
                                                  `${formatAmount(terminal.amount, terminal.currency)} ` +
                                                  `received at wallet ${formatWallet(terminal.toWallet)} ` +
                                                  `(Transaction: ${terminal.txHash})</li>\n`;
                    });

                    terminalWalletNarrative += '</ul>\n';
                    terminalWalletNarrative += '<p><strong>Total at ' + exchange + ':</strong> ';
                    terminalWalletNarrative += Object.entries(totalByExchange).map(([curr, amt]) =>
                        formatAmount(amt, curr)
                    ).join(', ');
                    terminalWalletNarrative += '</p>\n';
                });
            }

            // Build investigation summary
            const rootTotalsByCurrency = investigation.confirmedRootTotalsByCurrency || {};
            const summaryByCurrency = Object.entries(rootTotalsByCurrency).map(([currency, amount]) => {
                return formatAmount(amount, currency);
            }).join(', ');

            // Calculate total traced and write-offs
            let tracedByCurrency = {};
            let writeoffByCurrency = {};

            investigation.hops.forEach(hop => {
                hop.entries.forEach(entry => {
                    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                    if (entry.entryType === 'trace' && entry.isTerminalWallet) {
                        if (!tracedByCurrency[currency]) tracedByCurrency[currency] = 0;
                        tracedByCurrency[currency] += parseFloat(entry.amount);
                    } else if (entry.entryType === 'writeoff') {
                        if (!writeoffByCurrency[currency]) writeoffByCurrency[currency] = 0;
                        writeoffByCurrency[currency] += parseFloat(entry.amount);
                    }
                });
            });

            // Generate the full Word-compatible HTML report
            return `<!DOCTYPE html>
<html xmlns:o="urn:schemas-microsoft-com:office:office" xmlns:w="urn:schemas-microsoft-com:office:word" xmlns:m="http://schemas.microsoft.com/office/2004/12/omml" xmlns="http://www.w3.org/TR/REC-html40">
<head>
    <meta charset="UTF-8">
    <title>B.A.T.S. Investigation Narrative Report - ${investigation.caseId}</title>
    <style>
        @page {
            size: 8.5in 11in;
            margin: 1in;
        }
        body {
            font-family: 'Times New Roman', serif;
            font-size: 12pt;
            line-height: 1.5;
            color: #000000;
            background: white;
            margin: 0;
            padding: 20px;
        }
        h1 {
            font-size: 18pt;
            text-align: center;
            margin-bottom: 12pt;
            font-weight: bold;
            text-transform: uppercase;
        }
        h2 {
            font-size: 14pt;
            margin-top: 18pt;
            margin-bottom: 12pt;
            font-weight: bold;
            border-bottom: 2px solid #000;
            padding-bottom: 4pt;
        }
        h3 {
            font-size: 12pt;
            margin-top: 12pt;
            margin-bottom: 8pt;
            font-weight: bold;
            font-style: italic;
        }
        p {
            margin: 8pt 0;
            text-align: justify;
        }
        .header-info {
            text-align: center;
            margin-bottom: 24pt;
            border: 2px solid #000;
            padding: 12pt;
        }
        .header-info p {
            margin: 4pt 0;
            text-align: center;
        }
        strong {
            font-weight: bold;
        }
        em {
            font-style: italic;
            color: #444;
        }
        ul {
            margin-left: 24pt;
        }
        li {
            margin: 6pt 0;
        }
        hr {
            border: none;
            border-top: 1px solid #ccc;
            margin: 12pt 0;
        }
        .executive-summary {
            background: #f5f5f5;
            border: 1px solid #ccc;
            padding: 12pt;
            margin: 18pt 0;
        }
        .conclusion {
            margin-top: 24pt;
            padding-top: 12pt;
            border-top: 2px solid #000;
        }
        @media print {
            .page-break {
                page-break-before: always;
            }
        }
    </style>
</head>
<body>
    <h1>B.A.T.S. CRYPTOCURRENCY INVESTIGATION<br/>NARRATIVE REPORT</h1>

    <div class="header-info">
        <p><strong>CASE IDENTIFIER:</strong> ${investigation.caseId}</p>
        <p><strong>CASE TITLE:</strong> ${investigation.caseTitle || 'Cryptocurrency Fraud Investigation'}</p>
        <p><strong>LEAD INVESTIGATOR:</strong> ${investigation.investigator}</p>
        <p><strong>INVESTIGATION PERIOD:</strong> ${new Date(investigation.startDate || investigation.created).toLocaleDateString()} - ${new Date().toLocaleDateString()}</p>
        <p><strong>REPORT GENERATED:</strong> ${reportDate} at ${reportTime}</p>
        <p><strong>CLASSIFICATION:</strong> ${investigation.caseType || 'Financial Crime Investigation'}</p>
    </div>

    <div class="executive-summary">
        <h2>EXECUTIVE SUMMARY</h2>
        <p>This report documents the comprehensive blockchain analysis conducted as part of investigation ${investigation.caseId}.
        The investigation encompasses ${investigation.victims.length} victim(s) with confirmed losses totaling ${summaryByCurrency}.
        Through systematic application of the Block Audit Tracing Standard (B.A.T.S.) methodology,
        ${investigation.hops.length} transaction hops were analyzed to trace the movement of stolen cryptocurrency assets.</p>

        ${investigation.caseSynopsis ? `
        <p><strong>Case Synopsis:</strong><br/>
        ${investigation.caseSynopsis.replace(/\n/g, '<br/>')}</p>
        ` : ''}
    </div>

    <h2>SECTION 1: VICTIM IMPACT ASSESSMENT</h2>
    ${victimNarratives}

    <div class="page-break"></div>

    <h2>SECTION 2: BLOCKCHAIN TRANSACTION ANALYSIS</h2>
    <p>The following section provides a detailed chronological narrative of all cryptocurrency movements identified during the investigation.
    Each "hop" represents a distinct phase in the money laundering chain, with funds being transferred between different blockchain addresses
    in an attempt to obfuscate their origin.</p>

    ${hopNarratives}

    ${terminalWalletNarrative}

    <div class="page-break"></div>

    <h2>SECTION 3: FINANCIAL RECONCILIATION</h2>

    <h3>Root Total Analysis</h3>
    <p>The confirmed root total for this investigation is: <strong>${summaryByCurrency}</strong></p>

    ${Object.keys(tracedByCurrency).length > 0 ? `
    <h3>Funds Successfully Traced to Exchanges</h3>
    <ul>
        ${Object.entries(tracedByCurrency).map(([currency, amount]) =>
            `<li>${formatAmount(amount, currency)}</li>`
        ).join('\n')}
    </ul>
    ` : ''}

    ${Object.keys(writeoffByCurrency).length > 0 ? `
    <h3>Unrecoverable Funds (Write-offs)</h3>
    <ul>
        ${Object.entries(writeoffByCurrency).map(([currency, amount]) =>
            `<li>${formatAmount(amount, currency)}</li>`
        ).join('\n')}
    </ul>
    ` : ''}

    <div class="conclusion">
        <h2>SECTION 4: INVESTIGATIVE CONCLUSIONS</h2>

        <p>This investigation has successfully traced cryptocurrency transactions through ${investigation.hops.length} distinct hops,
        documenting the flow of funds from initial victim deposits through various intermediary wallets
        ${investigation.terminalWalletIndex && investigation.terminalWalletIndex.length > 0 ?
            `to their current location at identified cryptocurrency exchange(s)` :
            'to their current locations'}.</p>

        ${investigation.terminalWalletIndex && investigation.terminalWalletIndex.length > 0 ? `
        <h3>Recommended Legal Actions</h3>
        <p>Based on the terminal wallet analysis, the following legal processes are recommended:</p>
        <ol>
            <li><strong>Immediate Asset Preservation:</strong> Issue preservation orders to identified exchanges to prevent withdrawal of traced funds.</li>
            <li><strong>Subpoena Requirements:</strong> Obtain court orders for KYC (Know Your Customer) information from exchanges holding terminal wallets.</li>
            <li><strong>International Cooperation:</strong> If exchanges operate in foreign jurisdictions, coordinate with appropriate international law enforcement agencies.</li>
            <li><strong>Civil Recovery:</strong> Initiate civil asset recovery proceedings based on the documented fund flow.</li>
        </ol>
        ` : ''}

        <h3>Methodology Statement</h3>
        <p>All blockchain analysis was conducted using industry-standard forensic techniques and the B.A.T.S. (Block Audit Tracing Standard) methodology.
        Transaction data was verified against multiple blockchain explorers and validated through mathematical reconciliation.
        This report represents a true and accurate accounting of cryptocurrency movements as recorded on the relevant blockchain(s).</p>

        <h3>Certification</h3>
        <p>I, ${investigation.investigator}, certify that the information contained in this report is true and accurate to the best of my knowledge,
        based on blockchain data available as of ${reportDate}. This report was generated using validated blockchain forensic methodologies
        and may be used for legal proceedings, regulatory compliance, and asset recovery efforts.</p>

        <br/><br/>
        <p>_________________________________<br/>
        ${investigation.investigator}<br/>
        Lead Investigator<br/>
        ${reportDate}</p>
    </div>

    <div style="margin-top: 40pt; padding-top: 20pt; border-top: 1px solid #ccc; font-size: 10pt; color: #666;">
        <p><em>This report was generated using the B.A.T.S. Tool - Block Audit Tracing Standard<br/>
        Report Version: 1.0 | Tool Version: ${investigation.version || '2.0'}<br/>
        All timestamps are in ${investigation.defaultTimezone || 'UTC'} unless otherwise specified</em></p>
    </div>
</body>
</html>`;
        }
// =================================
// PART 4: ENHANCED EXPORT FUNCTIONS
// Add these functions to your existing JavaScript
// =================================

function generateSourceChainReport() {
    console.log(' Generating source chain report...');
    
    const report = {
        timestamp: new Date().toISOString(),
        caseId: investigation.caseId,
        investigator: investigation.investigator,
        sourceChains: [],
        statistics: {
            totalChains: 0,
            totalConvergences: 0,
            totalSingleSource: 0,
            currenciesAnalyzed: new Set()
        }
    };
    
    // Analyze source chains for each trace entry
    investigation.hops.forEach(hop => {
        hop.entries.forEach(entry => {
            if (entry.entryType === 'trace' && entry.sourceChain && entry.sourceChain.length > 0) {
                const chainAnalysis = {
                    notation: entry.notation,
                    hopNumber: entry.hopNumber,
                    targetAmount: parseFloat(entry.amount),
                    currency: entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency,
                    sourceCount: entry.sourceChain.length,
                    isConvergence: entry.sourceChain.length > 1,
                    sources: entry.sourceChain.map(source => ({
                        sourceNotation: source.sourceNotation,
                        amount: source.amount,
                        percentage: (source.amount / parseFloat(entry.amount)) * 100,
                        currency: source.currency
                    })),
                    displayNotation: entry.displayNotation || '',
                    summaryNotation: entry.summaryNotation || '',
                    toWallet: entry.toWallet,
                    toWalletType: entry.toWalletType
                };
                
                report.sourceChains.push(chainAnalysis);
                report.statistics.totalChains++;
                report.statistics.currenciesAnalyzed.add(chainAnalysis.currency);
                
                if (chainAnalysis.isConvergence) {
                    report.statistics.totalConvergences++;
                } else {
                    report.statistics.totalSingleSource++;
                }
            }
        });
    });
    
    // Convert Set to Array for JSON serialization
    report.statistics.currenciesAnalyzed = Array.from(report.statistics.currenciesAnalyzed);
    
    // Store the report
    investigation.sourceChainReports.push(report);
    
    console.log(' Source chain report generated:', report);
    return report;
}

function exportEnhancedReport() {
    console.log('Generating enhanced B.A.T.S. report...');
    
    // Run latest validation
    const validationResults = validateTracesEnhanced();
    
    // Generate source chain report
    const sourceChainReport = generateSourceChainReport();
    
    // Generate enhanced HTML report
    const enhancedReport = generateEnhancedBATSReport(validationResults, sourceChainReport);
    
    const filename = `Enhanced_BATS_Report_${investigation.caseId || 'Investigation'}_${new Date().toISOString().slice(0,10)}.html`;
    downloadFile(enhancedReport, filename, 'text/html');
}

function exportSourceChainReport() {
    const sourceChainReport = generateSourceChainReport();
    const filename = `Source_Chain_Analysis_${investigation.caseId || 'Investigation'}_${new Date().toISOString().slice(0,10)}.json`;
    downloadFile(JSON.stringify(sourceChainReport, null, 2), filename, 'application/json');
}

function generateEnhancedBATSReport(validationResults, sourceChainReport) {
    const timestamp = new Date().toLocaleString();
    
    return `<!DOCTYPE html>
<html>
<head>
    <title>Enhanced B.A.T.S. Investigation Report - ${investigation.caseId}</title>
    <style>
        body { font-family: 'Segoe UI', Arial, sans-serif; margin: 40px; line-height: 1.6; color: #2c3e50; }
        .header { text-align: center; border-bottom: 3px solid #2c3e50; padding-bottom: 20px; margin-bottom: 30px; }
        .section { margin: 30px 0; }
        .section-title { background: #2c3e50; color: white; padding: 15px; margin-bottom: 20px; font-weight: 600; }
        .enhanced-section { background: #3498db; color: white; padding: 15px; margin-bottom: 20px; font-weight: 600; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        th, td { border: 1px solid #ddd; padding: 12px; text-align: left; }
        th { background: #f8f9fa; font-weight: bold; color: #2c3e50; }
        .summary-box { background: #e8f5e8; border: 2px solid #27ae60; padding: 20px; margin: 20px 0; border-radius: 8px; }
        .warning-box { background: #fff3cd; border: 2px solid #ffc107; padding: 20px; margin: 20px 0; border-radius: 8px; }
        .error-box { background: #f8d7da; border: 2px solid #dc3545; padding: 20px; margin: 20px 0; border-radius: 8px; }
        .currency-section { background: #f8f9fa; border: 1px solid #ddd; padding: 15px; margin: 10px 0; border-radius: 6px; }
        .thread-analysis { background: #e8f4f8; border: 1px solid #3498db; padding: 15px; margin: 10px 0; border-radius: 6px; }
        .source-chain { font-family: 'Courier New', monospace; background: #f8f9fa; padding: 10px; border-radius: 4px; margin: 5px 0; }
        .convergence { background: #fff3cd; border-left: 4px solid #ffc107; padding: 10px; margin: 5px 0; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Enhanced B.A.T.S. Investigation Report</h1>
        <h2>Block Audit Tracing Standard - Phase 3 Complete Integration</h2>
        <p><strong>Case ID:</strong> ${investigation.caseId}</p>
        <p><strong>Investigator:</strong> ${investigation.investigator}</p>
        <p><strong>Report Generated:</strong> ${timestamp}</p>
        <p><strong>Integration Version:</strong> ${investigation.integrationVersion}</p>
    </div>

    <div class="section">
        <div class="enhanced-section">Section 1: Enhanced Validation Results</div>
        ${validationResults.overall ? 
            '<div class="summary-box"><h3>✅ Validation Status: PASSED</h3><p>All mathematical balances verified, thread assignments validated, source chains confirmed.</p></div>' :
            '<div class="error-box"><h3>❌ Validation Status: FAILED</h3><p>Critical errors detected in thread tracking or mathematical balance.</p></div>'
        }
        
        <h3>Thread Analysis by Currency</h3>
        ${Object.entries(validationResults.threadAnalysis).map(([currency, analysis]) => `
            <div class="thread-analysis">
                <h4>${currency}</h4>
                <p><strong>Total Threads:</strong> ${analysis.totalThreads}</p>
                <p><strong>Total Available:</strong> ${analysis.totalAvailable.toLocaleString()}</p>
                <p><strong>Total Assigned:</strong> ${analysis.totalAssigned.toLocaleString()}</p>
                ${analysis.unassignedThreads.length > 0 ? `<p style="color: #e67e22;"><strong>Unassigned Threads:</strong> ${analysis.unassignedThreads.join(', ')}</p>` : ''}
                ${analysis.overassignedThreads.length > 0 ? `<p style="color: #dc3545;"><strong>Over-assigned Threads:</strong> ${analysis.overassignedThreads.join(', ')}</p>` : ''}
            </div>
        `).join('')}

        <h3>Mathematical Balance Verification</h3>
        ${Object.entries(validationResults.mathematicalBalance).map(([currency, balance]) => `
            <div class="currency-section">
                <h4>${currency}</h4>
                <p><strong>Root Total:</strong> ${balance.rootTotal.toLocaleString()}</p>
                <p><strong>Write-offs:</strong> ${balance.writeoffAmount.toLocaleString()}</p>
                <p><strong>Adjusted Root Total:</strong> ${balance.adjustedRootTotal.toLocaleString()}</p>
                <p><strong>Current Thread Total:</strong> ${balance.currentThreadTotal.toLocaleString()}</p>
                <p><strong>Difference:</strong> ${balance.difference.toLocaleString()}</p>
                <p><strong>Balance Status:</strong> <span style="color: ${balance.isValid ? 'green' : 'red'}; font-weight: bold;">${balance.isValid ? 'BALANCED' : 'IMBALANCED'}</span></p>
            </div>
        `).join('')}
        
        ${validationResults.errors.length > 0 ? `
            <div class="error-box">
                <h3>Validation Errors</h3>
                <ul>
                    ${validationResults.errors.map(error => `<li>${error}</li>`).join('')}
                </ul>
            </div>
        ` : ''}
        
        ${validationResults.warnings.length > 0 ? `
            <div class="warning-box">
                <h3>Validation Warnings</h3>
                <ul>
                    ${validationResults.warnings.map(warning => `<li>${warning}</li>`).join('')}
                </ul>
            </div>
        ` : ''}
    </div>

    <div class="section">
        <div class="enhanced-section">Section 2: Source Chain Analysis</div>
        <div class="summary-box">
            <h3>Source Chain Statistics</h3>
            <p><strong>Total Source Chains:</strong> ${sourceChainReport.statistics.totalChains}</p>
            <p><strong>Single Source Chains:</strong> ${sourceChainReport.statistics.totalSingleSource}</p>
            <p><strong>Convergence Chains:</strong> ${sourceChainReport.statistics.totalConvergences}</p>
            <p><strong>Currencies Analyzed:</strong> ${sourceChainReport.statistics.currenciesAnalyzed.join(', ')}</p>
        </div>
        
        <h3>Detailed Source Chain Documentation</h3>
        <table>
            <tr>
                <th>Target Notation</th>
                <th>Hop</th>
                <th>Source Type</th>
                <th>Source Chain</th>
                <th>Amount</th>
                <th>Currency</th>
                <th>Target Wallet</th>
            </tr>
            ${sourceChainReport.sourceChains.map(chain => `
                <tr>
                    <td><strong>${chain.notation}</strong></td>
                    <td>${chain.hopNumber}</td>
                    <td>${chain.isConvergence ? '<span class="convergence">CONVERGENCE</span>' : 'Single Source'}</td>
                    <td class="source-chain">
                        ${chain.sources.map(source => 
                            `${source.sourceNotation}(${source.amount.toLocaleString()})`
                        ).join(' + ')} ${chain.notation}
                    </td>
                    <td>${chain.targetAmount.toLocaleString()}</td>
                    <td>${chain.currency}</td>
                    <td style="font-family: monospace; font-size: 11px;">${chain.toWallet}</td>
                </tr>
            `).join('')}
        </table>
    </div>

    <div class="section">
        <div class="enhanced-section">Section 3: Investigation Integrity Assessment</div>
        <div class="summary-box">
            <h3>Golden Thread Verification</h3>
            <p>This enhanced B.A.T.S. report includes mathematical thread tracking that ensures every dollar traced can be accounted for from victim loss to final disposition.</p>
            <p><strong>Validation Timestamp:</strong> ${validationResults.timestamp}</p>
            <p><strong>Thread Tracking Status:</strong> ${validationResults.overall ? 'VERIFIED' : 'REQUIRES ATTENTION'}</p>
            <p><strong>Source Chain Completeness:</strong> ${sourceChainReport.statistics.totalChains > 0 ? 'DOCUMENTED' : 'INCOMPLETE'}</p>
        </div>
    </div>
</body>
</html>`;
}

function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            window.URL.revokeObjectURL(url);
        }

        function clearAll() {
            if (confirm('Are you sure you want to clear all data? This cannot be undone.')) {
                investigation = {
                    caseId: '',
                    investigator: '',
                    caseType: '',
                    victims: [],
                    hops: [],
                    conversions: [],
                    redWalletIndex: [],
                    universalWalletIndex: [],
                    rootTotalConfirmed: false,
                    confirmedRootTotal: 0,
                    confirmedRootTotalsByCurrency: {},
                    currentART: {},
                    created: new Date().toISOString()
                };
                renderAll();
                saveToStorage();
                updateWorkflowSteps();
            }
        }

        function renderAll() {
            renderVictims();
            renderHops();
            updateValidationStatus();
            checkOnboardingState();
        }

        // Storage functions
        function saveToStorage() {
            investigation.caseId = document.getElementById('caseId').value;
            investigation.investigator = document.getElementById('investigator').value;
            investigation.caseType = document.getElementById('caseType').value;
            investigation.caseSynopsis = document.getElementById('caseSynopsis').value || '';
            
            window.batsData = investigation;
            updateWorkflowSteps();
        }
        function saveToStorageEnhanced() {
        // Call existing saveToStorage function
        saveToStorage();
    
        // Additional validation for enhanced structure
        const errors = validateEnhancedDataStructure();
        if (errors.length > 0) {
        console.warn('Data structure validation errors:', errors);
         }
    }
        function loadFromStorage() {
            if (window.batsData) {
                investigation = window.batsData;
                
                // Ensure all hops have entries arrays
                if (investigation.hops) {
                    investigation.hops.forEach(hop => {
                        if (!hop.entries) {
                            hop.entries = [];
                        }
                    });
                }
                
                document.getElementById('caseId').value = investigation.caseId || '';
                document.getElementById('investigator').value = investigation.investigator || '';
                document.getElementById('caseType').value = investigation.caseType || '';
                document.getElementById('caseSynopsis').value = investigation.caseSynopsis || '';
            }
        }

        // Close modals when clicking outside
        window.onclick = function(event) {
            const modals = ['rootTotalModal', 'convergenceModal', 'assetConversionModal', 'excelImportModal'];
            modals.forEach(modalId => {
                const modal = document.getElementById(modalId);
                if (event.target == modal) {
                    modal.style.display = 'none';
                }
            });
        }

        // Excel Import Functions
        let parsedExcelData = null;

        function importExcelTraces(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    let data;
                    if (file.name.endsWith('.csv')) {
                        data = parseCSV(e.target.result);
                    } else {
                        // For Excel files, we'll need to handle this differently
                        // For now, show instructions for CSV format
                        alert('Please export your data as CSV format. Excel support coming soon!');
                        return;
                    }
                    
                    if (data && data.length > 0) {
                        parsedExcelData = data;
                        showImportPreview(data);
                        showModal('excelImportModal');
                    } else {
                        alert('No valid data found in file. Please check the format.');
                    }
                } catch (error) {
                    alert('Error reading file: ' + error.message);
                }
            };
            
            if (file.name.endsWith('.csv')) {
                reader.readAsText(file);
            } else {
                reader.readAsArrayBuffer(file);
            }
        }

        function parseCSV(csvText) {
            const lines = csvText.split('\n').map(line => line.trim()).filter(line => line);
            if (lines.length < 2) return [];
            
            const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
            const data = [];
            
            // Expected headers
            const expectedHeaders = ['hop_notation', 'wallet_address', 'wallet_id', 'amount', 'currency'];
            const headerMap = {};
            
            // Map headers to expected format
            expectedHeaders.forEach(expected => {
                const found = headers.find(h => 
                    h.includes(expected.replace('_', '')) || 
                    h.includes(expected) ||
                    (expected === 'hop_notation' && (h.includes('notation') || h.includes('hop'))) ||
                    (expected === 'wallet_address' && (h.includes('address') || h.includes('wallet'))) ||
                    (expected === 'wallet_id' && h.includes('id')) ||
                    (expected === 'amount' && h.includes('amount')) ||
                    (expected === 'currency' && h.includes('currency'))
                );
                if (found) {
                    headerMap[expected] = headers.indexOf(found);
                }
            });
            
            // Parse data rows
            for (let i = 1; i < lines.length; i++) {
                const row = lines[i].split(',').map(cell => cell.trim().replace(/"/g, ''));
                if (row.length >= 5) {
                    const entry = {
                        hopNotation: row[headerMap.hop_notation] || '',
                        walletAddress: row[headerMap.wallet_address] || '',
                        walletId: row[headerMap.wallet_id] || '',
                        amount: parseFloat(row[headerMap.amount]) || 0,
                        currency: row[headerMap.currency] || 'USD'
                    };
                    
                    if (entry.hopNotation && entry.walletAddress && entry.amount > 0) {
                        data.push(entry);
                    }
                }
            }
            
            return data;
        }

        function showImportPreview(data) {
            const victims = new Set();
            const wallets = new Set();
            const currencies = new Set();
            let totalEntries = data.length;
            let errors = [];
            
            // Analyze the data
            data.forEach((entry, index) => {
                // Extract victim info
                const match = entry.hopNotation.match(/^V(\d+)-T(\d+)/);
                if (match) {
                    victims.add(`V${match[1]}-T${match[2]}`);
                }
                
                wallets.add(entry.walletId);
                currencies.add(entry.currency);
                
                // Validate wallet ID format
                if (!entry.walletId.match(/^(RED|BLACK|BLUE|PURPLE|YELLOW|ORANGE|BROWN|PINK|GRAY|GREEN)\d+$/i)) {
                    errors.push(`Row ${index + 2}: Invalid wallet ID format "${entry.walletId}"`);
                }
            });
            
            // Show summary
            const summary = `
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;">
                    <div><strong>Total Entries:</strong> ${totalEntries}</div>
                    <div><strong>Victim Transactions:</strong> ${victims.size}</div>
                    <div><strong>Unique Wallets:</strong> ${wallets.size}</div>
                    <div><strong>Currencies:</strong> ${Array.from(currencies).join(', ')}</div>
                </div>
                <div style="margin-top: 15px;">
                    <strong>Victims Found:</strong> ${Array.from(victims).join(', ')}
                </div>
            `;
            
            document.getElementById('importSummary').innerHTML = summary;
            document.getElementById('importPreview').style.display = 'block';
            
            if (errors.length > 0) {
                document.getElementById('importErrors').innerHTML = `
                    <div style="background: #fdf2f2; border: 2px solid #e74c3c; border-radius: 6px; padding: 15px; margin-bottom: 15px;">
                        <h4 style="color: #c0392b; margin-bottom: 10px;">⚠️ Validation Errors</h4>
                        ${errors.map(error => `<div style="color: #c0392b; margin-bottom: 5px;">• ${error}</div>`).join('')}
                    </div>
                `;
                document.getElementById('importErrors').style.display = 'block';
            } else {
                document.getElementById('importErrors').style.display = 'none';
                document.getElementById('confirmImportBtn').style.display = 'inline-block';
            }
        }

        function confirmExcelImport() {
            if (!parsedExcelData) return;
            
            try {
                // Clear existing data
                investigation = {
                    caseId: '',
                    investigator: '',
                    caseType: '',
                    victims: [],
                    hops: [],
                    conversions: [],
                    redWalletIndex: [],
                    universalWalletIndex: [],
                    rootTotalConfirmed: false,
                    confirmedRootTotal: 0,
                    confirmedRootTotalsByCurrency: {},
                    currentART: {},
                    created: new Date().toISOString()
                };
                
                // Process the imported data
                processImportedData(parsedExcelData);
                
                // Check chronological order of imported transactions
                const chronologyErrors = [];
                investigation.victims.forEach(victim => {
                    const error = validateTransactionChronology(victim);
                    if (error) {
                        chronologyErrors.push(`Victim ${victim.id}:\n${error}`);
                    }
                });
                
                // Update UI
                renderAll();
                updateWorkflowSteps();
                
                closeExcelImportModal();
                
                // Show success message with chronology warning if needed
                if (chronologyErrors.length > 0) {
                    const shouldFix = confirm(`⚠️ Import Successful with Warnings!\n\nImported ${parsedExcelData.length} entries, but transaction chronology issues were detected:\n\n${chronologyErrors.join('\n\n')}\n\nThe V-T notation requires transactions to be numbered in chronological order.\n\nWould you like to automatically fix the order?\n\nClick OK to reorder transactions chronologically.\nClick Cancel to fix manually later.`);
                    
                    if (shouldFix) {
                        // Fix order for all victims with errors
                        investigation.victims.forEach(victim => {
                            const error = validateTransactionChronology(victim);
                            if (error) {
                                fixVictimTransactionOrder(victim.id);
                            }
                        });
                        alert(` Transactions have been reordered chronologically!`);
                    }
                } else {
                    alert(`Successfully imported ${parsedExcelData.length} entries! Please review and confirm your root total.`);
                }
                
                // Clear the file input
                document.getElementById('excelInput').value = '';
                
            } catch (error) {
                alert('Error processing import: ' + error.message);
            }
        }

        function processImportedData(data) {
            const victimMap = new Map();
            const hopMap = new Map();
            
            // First pass: identify victims and transactions
            data.forEach(entry => {
                const match = entry.hopNotation.match(/^V(\d+)-T(\d+)(?:-H(\d+))?$/);
                if (match) {
                    const victimId = parseInt(match[1]);
                    const transactionId = parseInt(match[2]);
                    const hopNumber = match[3] ? parseInt(match[3]) : 0;
                    
                    if (hopNumber === 0) {
                        // This is a victim transaction
                        if (!victimMap.has(victimId)) {
                            victimMap.set(victimId, {
                                id: victimId,
                                transactions: []
                            });
                        }
                        
                        const victim = victimMap.get(victimId);
                        victim.transactions.push({
                            id: transactionId,
                            amount: entry.amount.toString(),
                            currency: entry.currency,
                            customCurrency: '',
                            receivingWallet: entry.walletAddress,
                            datetime: '',
                            timezone: 'UTC',
                            notes: `Imported from trace data`
                        });
                    } else {
                        // This is a hop entry
                        const hopKey = `${victimId}-${transactionId}-${hopNumber}`;
                        if (!hopMap.has(hopNumber)) {
                            hopMap.set(hopNumber, {
                                id: hopNumber,
                                hopNumber: hopNumber,
                                entries: [],
                                artAtStartByCurrency: {},
                                completed: false
                            });
                        }
                        
                        const hop = hopMap.get(hopNumber);
                        
                        // Find the source wallet from previous hop or victim transaction
                        let fromWallet = '';
                        if (hopNumber === 1) {
                            // Source is the victim transaction wallet
                            fromWallet = data.find(d => d.hopNotation === `V${victimId}-T${transactionId}`)?.walletAddress || '';
                        } else {
                            // Source is from previous hop
                            const prevEntry = data.find(d => d.hopNotation === `V${victimId}-T${transactionId}-H${hopNumber-1}`);
                            fromWallet = prevEntry?.walletAddress || '';
                        }
                        
                        hop.entries.push({
                            id: hop.entries.length + 1,
                            hopNumber: hopNumber,
                            hopNumber: hopNumber,
                            entryType: 'trace',
                            notation: entry.hopNotation,
                            fromWallet: fromWallet,
                            fromWalletType: hopNumber === 1 ? 'red' : 'black',
                            fromWalletId: '',
                            toWallet: entry.walletAddress,
                            toWalletType: parseWalletType(entry.walletId),
                            toWalletId: '',
                            amount: entry.amount.toString(),
                            currency: entry.currency,
                            customCurrency: '',
                            txHash: '',
                            timestamp: '',
                            timezone: 'UTC',
                            notes: `Imported from trace data`,
                            category: '',
                            justification: ''
                        });
                    }
                }
            });
            
            // Convert to arrays
            investigation.victims = Array.from(victimMap.values());
            investigation.hops = Array.from(hopMap.values());
            
            // Calculate root total and ART for each hop
            investigation.confirmedRootTotalsByCurrency = calculateRootTotal();
            investigation.rootTotalConfirmed = true;

            // Keep legacy confirmedRootTotal for backward compatibility (sum of all)
            investigation.confirmedRootTotal = Object.values(investigation.confirmedRootTotalsByCurrency).reduce((sum, amount) => sum + amount, 0);
            
            investigation.hops.forEach(hop => {
                hop.artAtStartByCurrency = getCurrentART();
            });
            
            // Build Universal Wallet Index
            buildUniversalWalletIndex();
            buildRedWalletIndex();
        }

        function parseWalletType(walletId) {
            const match = walletId.match(/^([A-Z]+)\d+$/);
            if (match) {
                return match[1].toLowerCase();
            }
            return 'black';
        }

        function closeExcelImportModal() {
            hideModal('excelImportModal');
            document.getElementById('importPreview').style.display = 'none';
            document.getElementById('confirmImportBtn').style.display = 'none';
            parsedExcelData = null;
        }
        function closeExcelImportModal() {
            hideModal('excelImportModal');
            document.getElementById('importPreview').style.display = 'none';
            document.getElementById('confirmImportBtn').style.display = 'none';
            parsedExcelData = null;
        }

        // ADD THE NEW HELPER FUNCTIONS HERE:
        function updateIndividualSourceAssignment(hopNumber, entryId, sourceId, amount) {
            const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    
    if (!entry.individualSourceAssignments) {
        entry.individualSourceAssignments = {};
    }
    
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    const maxAmount = getMaxAssignableAmount(sourceId, currency, entry.id, entry.hopNumber);
    const assignedAmount = Math.min(parseFloat(amount) || 0, maxAmount);
    
    entry.individualSourceAssignments[sourceId] = assignedAmount;
    
    // Calculate total from all individual assignments
    let totalAssigned = 0;
    Object.values(entry.individualSourceAssignments).forEach(amt => {
        totalAssigned += parseFloat(amt) || 0;
    });
    
    // Update the main amount field
    entry.amount = totalAssigned.toString();
    
    // Update the main amount input field in the UI
    const mainAmountInput = document.getElementById(`assignAmount_${hopNumber}_${entryId}`);
    if (mainAmountInput) {
        mainAmountInput.value = totalAssigned;
    }
}

// DUPLICATE FUNCTION REMOVED - Using the more complete version at line 10336
/*function validateHopCompletion(hopNumber) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    if (!hop) return { valid: false, errors: ['Hop not found'] };
    
    const errors = [];
    const warnings = [];
    
    // Get starting ART by currency for this hop
    const startingART = hop.artAtStartByCurrency || {};
    
    // Calculate totals by currency from all entries in this hop
    const entryTotalsByCurrency = {};
    hop.entries.forEach(entry => {
        if (parseFloat(entry.amount) > 0) {
            const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
            if (!entryTotalsByCurrency[currency]) {
                entryTotalsByCurrency[currency] = 0;
            }
            entryTotalsByCurrency[currency] += parseFloat(entry.amount);
        }
    });
    
    // Validate each currency balances
    Object.entries(startingART).forEach(([currency, startAmount]) => {
        const tracedAmount = entryTotalsByCurrency[currency] || 0;
        const difference = Math.abs(startAmount - tracedAmount);
        
        if (difference >= 0.01) {
            if (tracedAmount > startAmount) {
                errors.push(`${currency}: Traced ${tracedAmount.toLocaleString()} exceeds ART ${startAmount.toLocaleString()}`);
            } else {
                warnings.push(`${currency}: Missing ${(startAmount - tracedAmount).toLocaleString()} (${tracedAmount.toLocaleString()} of ${startAmount.toLocaleString()} traced)`);
            }
        }
    });
    
    // Check for source thread over-assignment
    const sourceThreadUsage = {};
    hop.entries.forEach(entry => {
        if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0) {
            const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
            
            if (entry.sourceThreadId) {
                if (!sourceThreadUsage[currency]) sourceThreadUsage[currency] = {};
                if (!sourceThreadUsage[currency][entry.sourceThreadId]) {
                    sourceThreadUsage[currency][entry.sourceThreadId] = 0;
                }
                sourceThreadUsage[currency][entry.sourceThreadId] += parseFloat(entry.amount);
            }
            
            if (entry.individualSourceAssignments) {
                Object.entries(entry.individualSourceAssignments).forEach(([sourceId, amount]) => {
                    if (!sourceThreadUsage[currency]) sourceThreadUsage[currency] = {};
                    if (!sourceThreadUsage[currency][sourceId]) {
                        sourceThreadUsage[currency][sourceId] = 0;
                    }
                    sourceThreadUsage[currency][sourceId] += parseFloat(amount);
                });
            }
        }
    });
    
    // Validate source thread assignments don't exceed availability
    Object.entries(sourceThreadUsage).forEach(([currency, threads]) => {
        Object.entries(threads).forEach(([threadId, usedAmount]) => {
            if (investigation.availableThreads[currency] && investigation.availableThreads[currency][threadId]) {
                const totalAvailable = investigation.availableThreads[currency][threadId].totalAmount;
                if (usedAmount > totalAvailable + 0.01) {
                    errors.push(`${threadId}: Assigned ${usedAmount.toLocaleString()} exceeds available ${totalAvailable.toLocaleString()} ${currency}`);
                }
            }
        });
    });
    
    return {
        valid: errors.length === 0,
        errors: errors,
        warnings: warnings,
        balanceStatus: entryTotalsByCurrency
    };
}*/

function autoGenerateNotationFromSource(hopNumber, entryId, sourceThreadId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    
    console.log(` Auto-generating notation from source: ${sourceThreadId}`);
    
    // Parse the source thread ID (e.g., "V1-T1" or "V1-T1-H2" or "V(1)-T(1)-H1")
    const match = sourceThreadId.match(/^V([^-]+)-T([^-]+)/);
    if (match) {
        let victimPart = match[1];
        let transactionPart = match[2];
        
        console.log(` Parsed victim: ${victimPart}, transaction: ${transactionPart}`);
        
        // If the parts are simple numbers, add parentheses
        if (/^\d+$/.test(victimPart)) {
            victimPart = `(${victimPart})`;
        }
        if (/^\d+$/.test(transactionPart)) {
            transactionPart = `(${transactionPart})`;
        }
        
        // Auto-fill notation fields
        entry.victimNumbers = victimPart;
        entry.transactionNumbers = transactionPart;
        
        // Generate the notation
        generateNotationPreview(hopNumber, entryId);
        
        // Update the UI fields
        updateNotationFieldsInUI(hopNumber, entryId);
        
        console.log(` Notation auto-generated: ${entry.notation}`);
    } else {
        console.log(`⚠️ Could not parse source thread ID: ${sourceThreadId}`);
    }
}

function autoGenerateNotationFromMultipleSources(hopNumber, entryId, selectedSources) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    
    console.log(` Auto-generating notation from multiple sources:`, selectedSources);
    
    const victimNumbers = new Set();
    const transactionNumbers = new Set();
    
    // Parse all selected source thread IDs
    selectedSources.forEach(sourceId => {
        const match = sourceId.match(/^V(\d+)-T(\d+)/);
        if (match) {
            victimNumbers.add(match[1]);
            transactionNumbers.add(match[2]);
            console.log(` Parsed from ${sourceId}: V${match[1]}, T${match[2]}`);
        }
    });
    
    // Convert to sorted arrays and format with parentheses
    const sortedVictims = Array.from(victimNumbers).sort((a, b) => parseInt(a) - parseInt(b));
    const sortedTransactions = Array.from(transactionNumbers).sort((a, b) => parseInt(a) - parseInt(b));
    
    // Format with individual parentheses: V(1)(2) - T(1)(3)
    entry.victimNumbers = sortedVictims.map(v => `(${v})`).join('');
    entry.transactionNumbers = sortedTransactions.map(t => `(${t})`).join('');
    
    console.log(` Generated victim numbers: ${entry.victimNumbers}, transaction numbers: ${entry.transactionNumbers}`);
    
    // Generate the notation
    generateNotationPreview(hopNumber, entryId);
    
    console.log(` Final notation: ${entry.notation}`);
    
    // Update the UI fields
    updateNotationFieldsInUI(hopNumber, entryId);
}

function clearNotationFields(hopNumber, entryId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    
    entry.victimNumbers = '';
    entry.transactionNumbers = '';
    entry.notation = '';
    entry.generatedNotation = '';
    
    updateNotationFieldsInUI(hopNumber, entryId);
}

function updateNotationFieldsInUI(hopNumber, entryId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    
    console.log(`Updating notation UI for hop ${hopNumber} entry ${entryId}:`, {
        victimNumbers: entry.victimNumbers,
        transactionNumbers: entry.transactionNumbers,
        notation: entry.notation
    });
    
    // Find and update the victim numbers input - try multiple selectors
    let victimInput = document.querySelector(`input[onchange*="updateNotationField(${hopNumber}, ${entryId}, 'victims'"]`);
    if (!victimInput) {
        // Try finding by ID pattern
        const inputs = document.querySelectorAll('input');
        inputs.forEach(input => {
            if (input.getAttribute('onchange') && input.getAttribute('onchange').includes(`updateNotationField(${hopNumber}, ${entryId}, 'victims'`)) {
                victimInput = input;
            }
        });
    }
    
    if (victimInput) {
        victimInput.value = entry.victimNumbers || '';
        console.log(` Updated victim input to: ${entry.victimNumbers}`);
    } else {
        console.log(` Could not find victim input for hop ${hopNumber} entry ${entryId}`);
    }
    
    // Find and update the transaction numbers input
    let transactionInput = document.querySelector(`input[onchange*="updateNotationField(${hopNumber}, ${entryId}, 'transactions'"]`);
    if (!transactionInput) {
        // Try finding by ID pattern
        const inputs = document.querySelectorAll('input');
        inputs.forEach(input => {
            if (input.getAttribute('onchange') && input.getAttribute('onchange').includes(`updateNotationField(${hopNumber}, ${entryId}, 'transactions'`)) {
                transactionInput = input;
            }
        });
    }
    
    if (transactionInput) {
        transactionInput.value = entry.transactionNumbers || '';
        console.log(` Updated transaction input to: ${entry.transactionNumbers}`);
    } else {
        console.log(` Could not find transaction input for hop ${hopNumber} entry ${entryId}`);
    }
    
    // Update the preview
    const previewElement = document.getElementById(`notation_preview_${hopNumber}_${entryId}`);
    if (previewElement) {
        previewElement.textContent = entry.notation || 'Enter V and T numbers';
        console.log(` Updated preview to: ${entry.notation}`);
    } else {
        console.log(` Could not find preview element`);
    }
}
function assignMaxToIndividualSource(hopNumber, entryId, sourceId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    
    // Get REAL-TIME maximum amount available
    const maxAmount = getMaxAssignableAmount(sourceId, currency, entry.id, entry.hopNumber);
    
    updateIndividualSourceAssignment(hopNumber, entryId, sourceId, maxAmount);
    
    // Also update the input field in the UI immediately
    const inputField = document.querySelector(`input[onchange*="updateIndividualSourceAssignment(${hopNumber}, ${entryId}, '${sourceId}'"]`);
    if (inputField) {
        inputField.value = maxAmount;
        inputField.max = maxAmount; // Update the max attribute too
    }
}
function toggleSourceSelection(hopNumber, entryId, sourceId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    
    if (!entry.multipleSourceThreads) {
        entry.multipleSourceThreads = [];
    }
    if (!entry.individualSourceAssignments) {
        entry.individualSourceAssignments = {};
    }
    
    const isCurrentlySelected = entry.multipleSourceThreads.includes(sourceId);
    
    if (isCurrentlySelected) {
        // Remove from selection
        entry.multipleSourceThreads = entry.multipleSourceThreads.filter(id => id !== sourceId);
        delete entry.individualSourceAssignments[sourceId];
        
        // If no sources are selected anymore, clear the currency
        if (entry.multipleSourceThreads.length === 0) {
            entry.currency = '';
            entry.customCurrency = '';
        }
    } else {
        // Before adding, check if currencies match
        const availableSourceThreads = getAvailableSourcesForHop(entry.hopNumber, null);
        const newSource = availableSourceThreads.find(s => s.threadId === sourceId);
        
        if (newSource && entry.multipleSourceThreads.length > 0) {
            // Check if the new source has the same currency as existing sources
            const existingCurrencies = new Set();
            entry.multipleSourceThreads.forEach(existingId => {
                const existingSource = availableSourceThreads.find(s => s.threadId === existingId);
                if (existingSource) {
                    existingCurrencies.add(existingSource.currency);
                }
            });
            
            if (existingCurrencies.size > 0 && !existingCurrencies.has(newSource.currency)) {
                alert(`ERROR:  Cannot mix different asset types!\n\nSelected threads have: ${Array.from(existingCurrencies).join(', ')}\nThis thread has: ${newSource.currency}\n\nPlease select threads with the same currency only.`);
                
                // Uncheck the checkbox
                const checkbox = document.querySelector(`#smartAllocationModal input[data-source-id="${sourceId}"]`);
                if (checkbox) {
                    checkbox.checked = false;
                }
                return;
            }
        }
        
        // Add to selection
        entry.multipleSourceThreads.push(sourceId);
        entry.individualSourceAssignments[sourceId] = 0; // Start with 0
        
        // Auto-update currency from the first selected source
        if (entry.multipleSourceThreads.length === 1) {
            const sourceThread = availableSourceThreads.find(s => s.threadId === sourceId);
            
            if (sourceThread) {
                const currency = sourceThread.currency;
                const isCustomCurrency = !Object.keys(currencies).includes(currency);
                
                if (isCustomCurrency) {
                    entry.currency = 'CUSTOM';
                    entry.customCurrency = currency;
                } else {
                    entry.currency = currency;
                    entry.customCurrency = '';
                }
            }
        }
    }
    
    // Clear the committed amounts since we're changing the selection
    entry.amount = '';
    const mainAmountInput = document.getElementById(`assignAmount_${hopNumber}_${entryId}`);
    if (mainAmountInput) {
        mainAmountInput.value = '';
    }
    
    // Re-render to show/hide amount inputs
    renderHops();
    saveToStorage();
}

function updateProposedAmount(hopNumber, entryId, sourceId, amount) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    
    if (!entry.individualSourceAssignments) {
        entry.individualSourceAssignments = {};
    }
    
    // Get the currency from the source thread, not the entry
    const availableSourceThreads = getAvailableSourcesForHop(entry.hopNumber, null);
    const sourceThread = availableSourceThreads.find(s => s.threadId === sourceId);
    
    if (!sourceThread) {
        alert(`Source thread ${sourceId} not found.`);
        return;
    }
    
    const currency = sourceThread.currency;
    
    // Auto-update entry currency to match source thread if needed
    if (entry.currency !== currency || (entry.currency === 'CUSTOM' && entry.customCurrency !== currency)) {
        const isCustomCurrency = !Object.keys(currencies).includes(currency);
        
        if (isCustomCurrency) {
            entry.currency = 'CUSTOM';
            entry.customCurrency = currency;
        } else {
            entry.currency = currency;
            entry.customCurrency = '';
        }
    }
    
    const maxAmount = getMaxAssignableAmount(sourceId, currency, entry.id, entry.hopNumber);
    const proposedAmount = Math.min(parseFloat(amount) || 0, maxAmount);
    
    entry.individualSourceAssignments[sourceId] = proposedAmount;
    
    // Update the proposed summary
    updateProposedSummary(hopNumber, entryId);
    saveToStorage();
}

function proposeMaxAmount(hopNumber, entryId, sourceId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    const maxAmount = getMaxAssignableAmount(sourceId, currency, entry.id, entry.hopNumber);
    
    updateProposedAmount(hopNumber, entryId, sourceId, maxAmount);
    
    // Update the input field
    const inputField = document.querySelector(`input[onchange*="updateProposedAmount(${hopNumber}, ${entryId}, '${sourceId}'"]`);
    if (inputField) {
        inputField.value = maxAmount;
    }
}

function updateProposedSummary(hopNumber, entryId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    const summaryElement = document.getElementById(`proposedSummary_${hopNumber}_${entryId}`);
    
    if (!summaryElement || !entry.individualSourceAssignments) return;
    
    // GET THE CORRECT CURRENCY FROM THE ENTRY (not defaulting to USD)
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    let totalProposed = 0;
    let summaryHTML = '';
    
    Object.entries(entry.individualSourceAssignments).forEach(([sourceId, amount]) => {
        if (amount > 0) {
            totalProposed += amount;
            summaryHTML += `<div style="font-size: 12px; margin-bottom: 3px;">• ${sourceId}: ${amount.toLocaleString()} ${currency}</div>`;
        }
    });
    
    summaryHTML += `<div style="font-weight: bold; margin-top: 8px; padding-top: 8px; border-top: 1px solid #ddd;">Total Proposed: ${totalProposed.toLocaleString()} ${currency}</div>`;
    
    summaryElement.innerHTML = summaryHTML;
}

function commitAssignmentToEntry(hopNumber, entryId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    
    if (!entry.individualSourceAssignments) {
        alert('No amounts proposed for assignment.');
        return;
    }
    
    // Calculate total proposed amount
    let totalAmount = 0;
    Object.values(entry.individualSourceAssignments).forEach(amount => {
        totalAmount += parseFloat(amount) || 0;
    });
    
    if (totalAmount <= 0) {
        alert('Please specify amounts to assign from selected sources.');
        return;
    }
    
    // Commit the assignment
    entry.amount = totalAmount.toString();
    
    // Update the main amount input field
    const mainAmountInput = document.getElementById(`assignAmount_${hopNumber}_${entryId}`);
    if (mainAmountInput) {
        mainAmountInput.value = totalAmount;
    }
    
    // Generate notation if needed
    if (entry.multipleSourceThreads && entry.multipleSourceThreads.length > 0) {
        autoGenerateNotationFromMultipleSources(hopNumber, entryId, entry.multipleSourceThreads);
    }
    
    // Update full notation display
    updateFullNotationDisplayMultiple(hopNumber, entryId);
    
    alert(` Assignment committed! New thread total: ${totalAmount.toLocaleString()} ${entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency}`);
    
    saveToStorage();
    
    // Re-render all hops to update availability for other entries
    renderHops();
}
// ADD THESE MISSING FUNCTIONS

function validateTracesEnhanced() {
    console.log(' Running enhanced validation...');
    
    const errors = [];
    const warnings = [];
    const threadAnalysis = {};
    const mathematicalBalance = {};
    
    // Build analysis by currency
    Object.keys(investigation.confirmedRootTotalsByCurrency || {}).forEach(currency => {
        threadAnalysis[currency] = {
            totalThreads: 0,
            totalAvailable: 0,
            totalAssigned: 0,
            unassignedThreads: [],
            overassignedThreads: []
        };
        
        mathematicalBalance[currency] = {
            rootTotal: investigation.confirmedRootTotalsByCurrency[currency] || 0,
            writeoffAmount: 0,
            adjustedRootTotal: 0,
            currentThreadTotal: 0,
            difference: 0,
            isValid: false
        };
    });
    
    // Calculate write-offs
    investigation.hops.forEach(hop => {
        hop.entries.forEach(entry => {
            if (entry.entryType === 'writeoff' && parseFloat(entry.amount) > 0) {
                const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                if (mathematicalBalance[currency]) {
                    mathematicalBalance[currency].writeoffAmount += parseFloat(entry.amount);
                }
            }
        });
    });
    
    // Complete balance calculations
    Object.keys(mathematicalBalance).forEach(currency => {
        const balance = mathematicalBalance[currency];
        balance.adjustedRootTotal = balance.rootTotal - balance.writeoffAmount;
        
        // Calculate current thread total
        let currentTotal = 0;
        investigation.hops.forEach(hop => {
            hop.entries.forEach(entry => {
                if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0) {
                    const entryCurrency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                    if (entryCurrency === currency) {
                        currentTotal += parseFloat(entry.amount);
                    }
                }
            });
        });
        
        balance.currentThreadTotal = currentTotal;
        balance.difference = Math.abs(balance.adjustedRootTotal - balance.currentThreadTotal);
        balance.isValid = balance.difference < 0.01;
        
        if (!balance.isValid) {
            errors.push(`${currency}: Balance mismatch - ART: ${balance.adjustedRootTotal}, Current: ${balance.currentThreadTotal}`);
        }
    });
    
    return {
        overall: errors.length === 0,
        errors: errors,
        warnings: warnings,
        threadAnalysis: threadAnalysis,
        mathematicalBalance: mathematicalBalance,
        timestamp: new Date().toISOString()
    };
}

function distributeProportionally(hopNumber, entryId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    
    if (!entry.multipleSourceThreads || entry.multipleSourceThreads.length === 0) return;
    
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    let totalAvailable = 0;
    
    // Calculate total available
    entry.multipleSourceThreads.forEach(sourceId => {
        totalAvailable += getMaxAssignableAmount(sourceId, currency);
    });
    
    if (totalAvailable <= 0) return;
    
    // Apply PIFO allocation instead of proportional distribution
    let remainingToAllocate = totalAvailable;
    if (!entry.individualSourceAssignments) {
        entry.individualSourceAssignments = {};
    }

    // Sort threads for PIFO order (V1-T1 before V1-T2, etc.)
    const sortedThreads = [...entry.multipleSourceThreads].sort((a, b) => {
        const parseThreadId = (id) => {
            const parts = id.match(/V(\d+)-T(\d+)/);
            if (parts) {
                return { victim: parseInt(parts[1]), transaction: parseInt(parts[2]) };
            }
            return { victim: 999, transaction: 999 };
        };
        const threadA = parseThreadId(a);
        const threadB = parseThreadId(b);
        if (threadA.victim !== threadB.victim) {
            return threadA.victim - threadB.victim;
        }
        return threadA.transaction - threadB.transaction;
    });

    // Apply PIFO allocation
    sortedThreads.forEach(sourceId => {
        if (remainingToAllocate <= 0) {
            entry.individualSourceAssignments[sourceId] = 0;
            return;
        }

        const available = getMaxAssignableAmount(sourceId, currency);
        const toAllocate = Math.min(available, remainingToAllocate);

        entry.individualSourceAssignments[sourceId] = toAllocate;
        remainingToAllocate -= toAllocate;

        console.log(`PIFO allocation for ${sourceId}: ${toAllocate}/${available} ${currency}`);
    });
    
    // Update total
    entry.amount = totalAvailable.toString();
    updateMultipleSourcePreview(hopNumber, entryId);
    saveToStorage();
}

function depleteInOrder(hopNumber, entryId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    
    if (!entry.multipleSourceThreads || entry.multipleSourceThreads.length === 0) return;
    
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    
    if (!entry.individualSourceAssignments) {
        entry.individualSourceAssignments = {};
    }
    
    // Deplete each source in order
    entry.multipleSourceThreads.forEach(sourceId => {
        const maxAmount = getMaxAssignableAmount(sourceId, currency, entry.id, entry.hopNumber);
        entry.individualSourceAssignments[sourceId] = maxAmount;
    });
    
    // Calculate total
    let total = 0;
    Object.values(entry.individualSourceAssignments).forEach(amount => {
        total += parseFloat(amount) || 0;
    });
    
    entry.amount = total.toString();
    updateMultipleSourcePreview(hopNumber, entryId);
    saveToStorage();
}

function clearAllAssignments(hopNumber, entryId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);
    
    if (entry.individualSourceAssignments) {
        Object.keys(entry.individualSourceAssignments).forEach(sourceId => {
            entry.individualSourceAssignments[sourceId] = 0;
        });
    }
    
    entry.amount = '0';
    updateMultipleSourcePreview(hopNumber, entryId);
    saveToStorage();
}

// Blockchain API Integration Functions
function formatDatetimeLocal(timestamp) {
    return new Date(timestamp).toISOString().slice(0, 16);
}

function detectBlockchainFromHash(hash) {
    const detectedDiv = document.getElementById('detectedBlockchain');
    const chainSelector = document.getElementById('chainSelector');
    
    // If a chain is manually selected, don't auto-detect
    if (chainSelector && chainSelector.value) {
        return chainSelector.value;
    }
    
    if (!hash || hash.length < 10) {
        detectedDiv.innerHTML = '';
        return null;
    }
    
    // Check each blockchain pattern
    for (const [chain, config] of Object.entries(blockchainAPIs)) {
        if (config.txPattern.test(hash)) {
            detectedDiv.innerHTML = `<span style="color: #27ae60;">✓ Detected: ${config.name} transaction</span>`;
            return chain;
        }
    }
    
    detectedDiv.innerHTML = '<span style="color: #e74c3c;">✗ Unknown transaction format</span>';
    return null;
}

function updateChainDisplay() {
    const chainSelector = document.getElementById('chainSelector');
    const detectedDiv = document.getElementById('detectedBlockchain');
    
    if (chainSelector.value) {
        const config = blockchainAPIs[chainSelector.value];
        detectedDiv.innerHTML = `<span style="color: #3498db;">ℹ️ Selected: ${config.name}</span>`;
    } else {
        // Re-detect from hash if present
        const txHash = document.getElementById('txHashInput').value;
        if (txHash) {
            detectBlockchainFromHash(txHash);
        } else {
            detectedDiv.innerHTML = '';
        }
    }
}

function openBlockchainLookup(hopNumber, entryId) {
    // Store context for applying data later
    targetEntryContext = { hopNumber, entryId };

    // Clear previous data
    currentTxData = null;
    document.getElementById('txHashInput').value = '';
    document.getElementById('detectedBlockchain').innerHTML = '';
    document.getElementById('lookupResult').style.display = 'none';
    document.getElementById('lookupError').style.display = 'none';
    document.getElementById('applyTxDataBtn').style.display = 'none';

    // Try to detect chain from source thread
    let detectedChain = '';
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop?.entries.find(e => e.id === entryId);

    if (entry?.sourceThreadId) {
        // Parse the source thread notation to get victim and transaction IDs
        const match = entry.sourceThreadId.match(/V(\d+)-T(\d+)/);
        if (match) {
            const victimId = parseInt(match[1]);
            const transactionId = parseInt(match[2]);

            // Find the victim transaction
            const victim = investigation.victims.find(v => v.id === victimId);
            const transaction = victim?.transactions.find(t => t.id === transactionId);

            // Get the chain from the transaction
            if (transaction?.chain) {
                detectedChain = transaction.chain;
                console.log(`Detected chain '${detectedChain}' from source thread ${entry.sourceThreadId}`);
            }
        }
    }

    // Set the chain selector if we detected a chain
    document.getElementById('chainSelector').value = detectedChain;
    if (detectedChain) {
        const chainConfig = blockchainAPIs[detectedChain];
        if (chainConfig) {
            document.getElementById('detectedBlockchain').innerHTML =
                `<span style="color: #27ae60;">✓ Auto-selected ${chainConfig.name} based on source thread</span>`;
        }
    }

    showModal('blockchainLookupModal');
}

function closeBlockchainLookupModal() {
    hideModal('blockchainLookupModal');
    targetEntryContext = null;
    currentTxData = null;
}

async function lookupTransaction() {
    const txHash = document.getElementById('txHashInput').value.trim();
    const selectedChain = document.getElementById('chainSelector').value;
    let detectedChain = selectedChain || detectBlockchainFromHash(txHash);
    
    if (!txHash) {
        showLookupError('Please enter a transaction hash');
        return;
    }
    
    if (!detectedChain) {
        showLookupError('Please select a blockchain or enter a valid transaction hash');
        return;
    }
    
    const config = blockchainAPIs[detectedChain];
    // Disable CORS proxy to avoid CSP issues - APIs should handle CORS natively
    const corsEnabled = false;
    const corsProxyUrl = '';
    
    // Show loading
    document.getElementById('lookupLoading').style.display = 'block';
    document.getElementById('lookupError').style.display = 'none';
    document.getElementById('lookupResult').style.display = 'none';
    
    // Build array of URLs to try (primary + fallbacks)
    const urlsToTry = [config.apiUrl, ...(config.fallbackUrls || [])];
    let lastError = null;
    
    for (let apiUrl of urlsToTry) {
        try {
            let data;
            let url;
            let tokenData = null; // Define tokenData at this scope
            
            if (detectedChain === 'bitcoin') {
                url = apiUrl + txHash;
                if (config.apiKey) {
                    url += `?api_key=${config.apiKey}`;
                }
                if (corsEnabled) url = corsProxyUrl + url;
                
                const response = await fetch(url);
                if (!response.ok) throw new Error('Transaction not found');
                data = await response.json();
                
            } else if (detectedChain === 'ethereum') {
                const apiKey = localStorage.getItem('bats_etherscan_api_key') || config.apiKey || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8';
                
                // First get the basic transaction
                url = `${apiUrl}${txHash}&apikey=${apiKey}`;
                if (corsEnabled) url = corsProxyUrl + url;
                
                const response = await fetch(url);
                if (!response.ok) throw new Error('API request failed');
                data = await response.json();
                if (!data.result || data.result === null) throw new Error('Transaction not found');
                
                // Get block data for timestamp - but don't let it block token transfers
                let blockData = null;
                if (data.result && data.result.blockNumber) {
                    try {
                        const blockUrl = corsEnabled ?
                            corsProxyUrl + `${config.blockApiUrl}${data.result.blockNumber}&boolean=true&apikey=${apiKey}` :
                            `${config.blockApiUrl}${data.result.blockNumber}&boolean=true&apikey=${apiKey}`;
                        
                        const blockResponse = await fetch(blockUrl);
                        if (blockResponse.ok) {
                            blockData = await blockResponse.json();
                            if (blockData && blockData.result && blockData.result.timestamp) {
                                blockTimestamp = parseInt(blockData.result.timestamp, 16) * 1000;
                                console.log('Got block timestamp:', new Date(blockTimestamp).toISOString());
                            }
                        }
                    } catch (err) {
                        console.log('Failed to fetch block timestamp, will proceed without it:', err);
                    }
                }
                
                // Small delay to avoid rate limit
                if (blockTimestamp) {
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
                
                // Also check for token transfers
                let tokenData = null;
                try {
                    const tokenUrl = corsEnabled ? 
                        corsProxyUrl + `${config.tokenApiUrl}${txHash}&apikey=${apiKey}` :
                        `${config.tokenApiUrl}${txHash}&apikey=${apiKey}`;
                    
                    const tokenResponse = await fetch(tokenUrl).catch(err => {
                        console.warn(`Token fetch failed:`, err);
                        return null;
                    });
                    if (tokenResponse && tokenResponse.ok) {
                        tokenData = await tokenResponse.json();
                        console.log('Receipt/Token data received:', tokenData);
                        
                        // Check if Etherscan returned an error
                        if (tokenData && tokenData.status === '0' && tokenData.message === 'NOTOK') {
                            console.error('Etherscan API error:', tokenData.result);
                            throw new Error(tokenData.result);
                        }
                    }
                } catch (err) {
                    console.log('No token transfers found');
                }
                
            } else if (detectedChain === 'tron') {
                url = apiUrl + txHash;
                if (config.apiKey) {
                    // TronGrid uses header authentication
                    const headers = { 'TRON-PRO-API-KEY': config.apiKey };
                    if (corsEnabled) url = corsProxyUrl + url;
                    
                    const response = await fetch(url, { headers });
                    if (!response.ok) throw new Error('Transaction not found');
                    data = await response.json();
                } else {
                    if (corsEnabled) url = corsProxyUrl + url;
                    const response = await fetch(url);
                    if (!response.ok) throw new Error('Transaction not found');
                    data = await response.json();
                }
                
            } else if (detectedChain === 'solana') {
                url = apiUrl;
                if (corsEnabled) url = corsProxyUrl + url;
                
                // Solana RPC call
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        jsonrpc: '2.0',
                        id: 1,
                        method: 'getTransaction',
                        params: [txHash, { encoding: 'json', maxSupportedTransactionVersion: 0 }]
                    })
                });
                if (!response.ok) throw new Error('RPC request failed');
                data = await response.json();
                if (data.error) throw new Error(data.error.message);
            }
            
            // Parse the response (pass tokenData and blockTimestamp for EVM chains)
            const isEVMChain = ['ethereum', 'base', 'arbitrum', 'optimism', 'polygon', 'bsc',
                               'avalanche', 'hyperevm', 'linea', 'scroll', 'mantle', 'blast',
                               'zksync', 'gnosis', 'celo', 'moonbeam', 'moonriver', 'fraxtal',
                               'taiko', 'arbitrumnova', 'bittorrent', 'opbnb'].includes(detectedChain);
            currentTxData = isEVMChain ?
                config.parseResponse(data, tokenData, blockTimestamp, config) :
                config.parseResponse(data);
            if (!currentTxData) throw new Error('Failed to parse transaction data');
            
            currentTxData.blockchain = config.name;
            currentTxData.rawHash = txHash;
            
            // Display the results
            displayTransactionData(currentTxData);
            
            // Success! Break out of the loop
            return;
            
        } catch (error) {
            console.error(`Failed with ${apiUrl}:`, error);
            lastError = error;
            // Continue to next URL
        }
    }
    
    // If we get here, all URLs failed
    const errorMsg = lastError ? lastError.message : 'Failed to fetch transaction';
    if (errorMsg.includes('CORS') || errorMsg.includes('Failed to fetch')) {
        showLookupError(`${errorMsg}\n\nTip: The app will retry with different connection methods automatically.`);
    } else {
        showLookupError(`Failed to fetch transaction: ${errorMsg}`);
    }
    
    document.getElementById('lookupLoading').style.display = 'none';
}

function showLookupError(message) {
    // Show error in existing error div if it exists
    const existingErrorDiv = document.getElementById('lookupError');
    if (existingErrorDiv) {
        existingErrorDiv.textContent = message;
        existingErrorDiv.style.display = 'block';
        return;
    }

    // Otherwise create a modal
    const errorDiv = document.createElement('div');
    errorDiv.style.cssText = `
        position: fixed;
        top: 50%;
        left: 50%;
        transform: translate(-50%, -50%);
        background: #ff6b6b;
        color: white;
        padding: 20px;
        border-radius: 8px;
        z-index: 10000;
        max-width: 500px;
        text-align: center;
        box-shadow: 0 10px 40px rgba(0,0,0,0.3);
    `;

    // Check if it's a network/API issue
    const isNetworkIssue = message && (
        message.includes('Network') ||
        message.includes('timeout') ||
        message.includes('API') ||
        message.includes('rate')
    );

    errorDiv.innerHTML = `
        <h3>🔄 Lookup Failed</h3>
        <p style="white-space: pre-line;">${message || 'Network connection error'}</p>
        ${isNetworkIssue ? `
        <div style="background: rgba(255,255,255,0.1); padding: 10px; border-radius: 6px; margin: 15px 0; text-align: left;">
            <strong>Quick Solutions:</strong>
            <ul style="margin: 10px 0; padding-left: 20px;">
                <li>Wait 30 seconds if rate limited</li>
                <li>Try using a VPN if blocked</li>
                <li>Check transaction on Etherscan directly</li>
                <li>Use manual entry as fallback</li>
            </ul>
        </div>
        <div style="display: flex; gap: 10px; justify-content: center; margin-top: 15px;">
            <button onclick="this.parentElement.parentElement.remove(); setTimeout(() => document.querySelector('[onclick*=lookupWizardTransaction]')?.click(), 100)"
                    class="btn btn-primary" style="background: white; color: #ff6b6b;">🔄 Retry Lookup</button>
            <button onclick="this.parentElement.parentElement.remove()"
                    class="btn btn-secondary" style="background: rgba(255,255,255,0.2);">Close</button>
        </div>
        ` : `
        <button onclick="this.parentElement.remove()" class="btn btn-secondary" style="margin-top: 15px;">Close</button>
        `}
    `;

    document.body.appendChild(errorDiv);

    // Auto-remove after 30 seconds
    setTimeout(() => {
        if (errorDiv.parentElement) {
            errorDiv.remove();
        }
    }, 30000);
}

function displayTransactionData(txData) {
    const displayDiv = document.getElementById('txDetailsDisplay');
    
    const timeFormatted = new Date(txData.time).toLocaleString();
    
    displayDiv.innerHTML = `
        <div style="display: grid; gap: 10px;">
            <div><strong>Blockchain:</strong> ${txData.blockchain}</div>
            <div><strong>Hash:</strong> <span style="font-family: monospace; font-size: 12px; word-break: break-all;">${txData.rawHash}</span></div>
            <div><strong>Time:</strong> ${timeFormatted} (UTC)</div>
            <div><strong>Amount:</strong> ${txData.amount.toFixed(8)} ${txData.currency}</div>
            <div><strong>From:</strong> <span style="font-family: monospace; font-size: 12px; word-break: break-all;">${txData.from}</span></div>
            <div><strong>To:</strong> <span style="font-family: monospace; font-size: 12px; word-break: break-all;">${txData.to}</span></div>
            ${txData.fee ? `<div><strong>Fee:</strong> ${txData.fee} ${txData.currency}</div>` : ''}
        </div>
    `;
    
    document.getElementById('lookupResult').style.display = 'block';

    // Validate against source thread wallet and show appropriate warnings
    if (targetEntryContext && currentTxData) {
        const { hopNumber, entryId } = targetEntryContext;
        const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
        const entry = hop?.entries.find(e => e.id === entryId);

        if (entry?.sourceThreadId) {
            const sourceThread = getThreadByNotation(entry.sourceThreadId);
            if (sourceThread?.sourceWallet) {
                const threadWallet = sourceThread.sourceWallet.toLowerCase();
                const txFromWallet = currentTxData.from.toLowerCase();

                if (threadWallet !== txFromWallet) {
                    // Add wallet mismatch warning
                    const warningHtml = `
                        <div style="background: #ffebee; border: 2px solid #f44336; border-radius: 4px; padding: 12px; margin: 10px 0;">
                            <strong style="color: #c62828; font-size: 14px;">⚠️ WALLET MISMATCH DETECTED!</strong><br>
                            <div style="margin-top: 8px; color: #d32f2f;">
                                This transaction does NOT spend from thread ${entry.sourceThreadId}
                            </div>
                            <div style="margin-top: 8px; font-size: 12px; color: #666;">
                                <div><strong>Expected wallet (where thread exists):</strong></div>
                                <div style="font-family: monospace; font-size: 11px; margin: 2px 0;">${threadWallet}</div>
                                <div style="margin-top: 5px;"><strong>Transaction from wallet:</strong></div>
                                <div style="font-family: monospace; font-size: 11px; margin: 2px 0;">${txFromWallet}</div>
                            </div>
                            <div style="margin-top: 10px; font-size: 11px; color: #666; border-top: 1px solid #ffcdd2; padding-top: 8px;">
                                ⚠️ This transaction cannot be used as it doesn't continue the fund flow from the selected source thread.
                            </div>
                        </div>
                    `;
                    document.getElementById('lookupResult').innerHTML += warningHtml;

                    // Change button appearance to indicate issue
                    document.getElementById('applyTxDataBtn').style.display = 'inline-block';
                    document.getElementById('applyTxDataBtn').style.background = '#f44336';
                    document.getElementById('applyTxDataBtn').textContent = '⚠️ Cannot Apply - Wrong Wallet';
                    document.getElementById('applyTxDataBtn').disabled = false; // Allow click to show detailed error
                } else {
                    // Add success validation message
                    const successHtml = `
                        <div style="background: #e8f5e9; border: 2px solid #4caf50; border-radius: 4px; padding: 12px; margin: 10px 0;">
                            <strong style="color: #2e7d32; font-size: 14px;">✓ Wallet Verification Passed!</strong><br>
                            <div style="margin-top: 8px; color: #388e3c;">
                                Transaction correctly spends from thread ${entry.sourceThreadId}
                            </div>
                            <div style="margin-top: 5px; font-size: 11px; color: #666;">
                                Source wallet matches: ${threadWallet.substring(0, 20)}...
                            </div>
                        </div>
                    `;
                    document.getElementById('lookupResult').innerHTML += successHtml;

                    document.getElementById('applyTxDataBtn').style.display = 'inline-block';
                    document.getElementById('applyTxDataBtn').style.background = '';
                    document.getElementById('applyTxDataBtn').textContent = 'Apply to Entry';
                    document.getElementById('applyTxDataBtn').disabled = false;
                }
            } else {
                // Source thread found but no wallet info - show normal button
                document.getElementById('applyTxDataBtn').style.display = 'inline-block';
                document.getElementById('applyTxDataBtn').textContent = 'Apply to Entry';
            }
        } else {
            // No source thread - show normal button
            document.getElementById('applyTxDataBtn').style.display = 'inline-block';
            document.getElementById('applyTxDataBtn').textContent = 'Apply to Entry';
        }
    } else {
        document.getElementById('applyTxDataBtn').style.display = 'inline-block';
        document.getElementById('applyTxDataBtn').textContent = 'Apply to Entry';
    }
}

function applyTransactionData() {
    if (!currentTxData || !targetEntryContext) return;

    const { hopNumber, entryId } = targetEntryContext;
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop.entries.find(e => e.id === entryId);

    // CRITICAL VALIDATION: Verify the transaction spends from the source thread's wallet
    if (entry.sourceThreadId) {
        // Get the source thread to find its wallet
        const sourceThread = getThreadByNotation(entry.sourceThreadId);
        if (sourceThread && sourceThread.sourceWallet) {
            // Normalize wallet addresses for comparison (lowercase)
            const threadWallet = sourceThread.sourceWallet.toLowerCase();
            const txFromWallet = currentTxData.from.toLowerCase();

            if (threadWallet !== txFromWallet) {
                // Show detailed error with wallet information
                const errorMessage = `❌ WALLET MISMATCH DETECTED!\n\n` +
                    `This transaction DOES NOT spend from the source thread's wallet.\n\n` +
                    `Source Thread: ${entry.sourceThreadId}\n` +
                    `Expected Wallet (where thread exists):\n${threadWallet}\n\n` +
                    `Transaction From Wallet:\n${txFromWallet}\n\n` +
                    `This transaction cannot be used because it doesn't continue the fund flow from thread ${entry.sourceThreadId}.\n\n` +
                    `Possible issues:\n` +
                    `• Wrong transaction hash entered\n` +
                    `• Transaction from a different wallet\n` +
                    `• Incorrect source thread selected\n\n` +
                    `Please verify you have the correct transaction hash or select the appropriate source thread.`;

                alert(errorMessage);

                // Don't apply the data - keep the modal open for correction
                return;
            }

            // Additional validation: Check if amount exceeds available thread amount
            const availableAmount = sourceThread.availableAmount || 0;
            const requestedAmount = parseFloat(currentTxData.amount);

            if (requestedAmount > availableAmount + 0.01) { // Small tolerance for rounding
                const warningMessage = `⚠️ AMOUNT WARNING!\n\n` +
                    `This transaction amount (${requestedAmount} ${currentTxData.currency}) ` +
                    `exceeds the available amount in thread ${entry.sourceThreadId} ` +
                    `(${availableAmount} ${sourceThread.currency}).\n\n` +
                    `Do you want to proceed anyway?\n\n` +
                    `Note: This might indicate:\n` +
                    `• Additional funds were added to this wallet\n` +
                    `• You may need to trace other sources\n` +
                    `• Possible commingling of funds`;

                if (!confirm(warningMessage)) {
                    return;
                }
            }
        }
    }

    // Apply the data to the entry (validation passed)
    entry.txHash = currentTxData.rawHash;
    entry.timestamp = new Date(currentTxData.time).toISOString().slice(0, 16); // Format for datetime-local
    entry.timezone = 'UTC';
    entry.amount = currentTxData.amount.toString();
    entry.currency = currentTxData.currency;
    entry.fromWallet = currentTxData.from;
    entry.toWallet = currentTxData.to;

    // Update the form fields
    document.getElementById(`txHash_${hopNumber}_${entryId}`).value = entry.txHash;
    document.getElementById(`timestamp_${hopNumber}_${entryId}`).value = entry.timestamp;
    document.getElementById(`assignAmount_${hopNumber}_${entryId}`).value = entry.amount;
    document.getElementById(`toWallet_${hopNumber}_${entryId}`).value = entry.toWallet;

    // Note: fromWallet is stored but not displayed in the form
    // It's used internally for transaction tracking

    // Update currency dropdown
    const currencySelect = document.querySelector(`select[onchange*="updateEntry(${hopNumber}, ${entryId}, 'currency'"]`);
    if (currencySelect) {
        // Check if the currency option exists, if not add it
        const optionExists = Array.from(currencySelect.options).some(opt => opt.value === entry.currency);
        if (!optionExists && entry.currency !== 'CUSTOM') {
            const newOption = document.createElement('option');
            newOption.value = entry.currency;
            newOption.textContent = entry.currency;
            currencySelect.appendChild(newOption);
        }
        currencySelect.value = entry.currency;
    }

    saveToStorage();
    closeBlockchainLookupModal();

    let alertMessage = `✅ Transaction data applied successfully!\n\n` +
        `Amount: ${entry.amount} ${entry.currency}\n` +
        `From: ${entry.fromWallet.slice(0, 20)}...\n` +
        `To: ${entry.toWallet.slice(0, 20)}...\n\n` +
        `✓ Wallet validation passed - transaction spends from thread ${entry.sourceThreadId}`;

    if (currentTxData.hasRealTimestamp === false) {
        alertMessage += '\n\n⚠️ WARNING: Could not retrieve actual transaction timestamp. Please manually verify and update the date/time field!';
    }

    alert(alertMessage);
}

// API Settings Management Functions
function openApiSettings() {
    // Load saved settings
    const savedEtherscan = localStorage.getItem('bats_etherscan_api_key');
    const savedBlockchain = localStorage.getItem('bats_blockchain_api_key');
    const savedTrongrid = localStorage.getItem('bats_trongrid_api_key');
    const savedSolscan = localStorage.getItem('bats_solscan_api_key');
    const savedSolanaRpc = localStorage.getItem('bats_solana_rpc_endpoint');
    const savedArkham = localStorage.getItem('bats_arkham_api_key');
    const savedArkhamAutoCheck = localStorage.getItem('bats_arkham_auto_check') !== 'false';
    const savedCorsEnabled = localStorage.getItem('bats_cors_proxy_enabled') === 'true';
    const savedCorsUrl = localStorage.getItem('bats_cors_proxy_url');
    
    // Populate form fields
    document.getElementById('etherscanApiKey').value = savedEtherscan || '';
    document.getElementById('blockchainApiKey').value = savedBlockchain || '';
    document.getElementById('trongridApiKey').value = savedTrongrid || '';
    if (document.getElementById('solscanApiKey')) {
        document.getElementById('solscanApiKey').value = savedSolscan || '';
    }
    document.getElementById('solanaRpcEndpoint').value = savedSolanaRpc || 'https://api.mainnet-beta.solana.com';
    document.getElementById('arkhamApiKey').value = savedArkham || '';
    document.getElementById('arkhamAutoCheck').checked = savedArkhamAutoCheck;
    
    // Show modal
    showModal('apiSettingsModal');
}

function closeApiSettingsModal() {
    hideModal('apiSettingsModal');
}

function saveApiSettings() {
    // Get values from form
    const etherscanKey = document.getElementById('etherscanApiKey').value.trim();
    const blockchainKey = document.getElementById('blockchainApiKey').value.trim();
    const trongridKey = document.getElementById('trongridApiKey').value.trim();
    const solscanKey = document.getElementById('solscanApiKey') ? document.getElementById('solscanApiKey').value.trim() : '';
    const solanaRpc = document.getElementById('solanaRpcEndpoint').value.trim();
    const arkhamKey = document.getElementById('arkhamApiKey').value.trim();
    const arkhamAutoCheck = document.getElementById('arkhamAutoCheck').checked;
    // Disable CORS proxy to avoid CSP issues
    const corsEnabled = false;
    const corsUrl = '';
    
    // Save to localStorage
    if (etherscanKey) localStorage.setItem('bats_etherscan_api_key', etherscanKey);
    else localStorage.removeItem('bats_etherscan_api_key');
    
    if (blockchainKey) localStorage.setItem('bats_blockchain_api_key', blockchainKey);
    else localStorage.removeItem('bats_blockchain_api_key');
    
    if (trongridKey) localStorage.setItem('bats_trongrid_api_key', trongridKey);
    else localStorage.removeItem('bats_trongrid_api_key');

    if (solscanKey) localStorage.setItem('bats_solscan_api_key', solscanKey);
    else localStorage.removeItem('bats_solscan_api_key');

    if (solanaRpc) localStorage.setItem('bats_solana_rpc_endpoint', solanaRpc);
    else localStorage.removeItem('bats_solana_rpc_endpoint');
    
    if (arkhamKey) localStorage.setItem('bats_arkham_api_key', arkhamKey);
    else localStorage.removeItem('bats_arkham_api_key');
    
    localStorage.setItem('bats_arkham_auto_check', arkhamAutoCheck.toString());
    localStorage.setItem('bats_cors_proxy_enabled', corsEnabled.toString());
    
    if (corsUrl) localStorage.setItem('bats_cors_proxy_url', corsUrl);
    else localStorage.removeItem('bats_cors_proxy_url');
    
    // Update blockchain API configurations
    blockchainAPIs.ethereum.apiKey = etherscanKey || null;
    blockchainAPIs.bitcoin.apiKey = blockchainKey || null;
    blockchainAPIs.tron.apiKey = trongridKey || null;
    blockchainAPIs.solana.apiUrl = solanaRpc || 'https://api.mainnet-beta.solana.com';
    
    closeApiSettingsModal();
    alert(' API settings saved successfully!');
}

// Enable/disable CORS proxy URL input based on checkbox
document.addEventListener('DOMContentLoaded', function() {
    // Auto-save CORS settings on init if not already saved
    // Remove any existing CORS proxy settings to avoid CSP issues
    localStorage.removeItem('bats_cors_proxy_enabled');
    localStorage.removeItem('bats_cors_proxy_url');
    
    // Load API settings on startup
    loadApiSettingsOnStartup();
});

function loadApiSettingsOnStartup() {
    // Load saved API keys
    const savedEtherscan = localStorage.getItem('bats_etherscan_api_key');
    const savedBlockchain = localStorage.getItem('bats_blockchain_api_key');
    const savedTrongrid = localStorage.getItem('bats_trongrid_api_key');
    const savedSolanaRpc = localStorage.getItem('bats_solana_rpc_endpoint');
    
    // Update blockchain API configurations
    if (savedEtherscan) blockchainAPIs.ethereum.apiKey = savedEtherscan;
    if (savedBlockchain) blockchainAPIs.bitcoin.apiKey = savedBlockchain;
    if (savedTrongrid) blockchainAPIs.tron.apiKey = savedTrongrid;
    if (savedSolanaRpc) blockchainAPIs.solana.apiUrl = savedSolanaRpc;
}

// PK Converter Functions
function openPKConverter() {
    const modal = document.getElementById('pkConverterModal');
    if (modal) {
        // Force display the modal regardless of parent visibility
        modal.style.display = 'flex';
        modal.style.position = 'fixed';
        modal.style.zIndex = '10001';
        modal.style.top = '0';
        modal.style.left = '0';
        modal.style.width = '100%';
        modal.style.height = '100%';
        modal.style.backgroundColor = 'rgba(0,0,0,0.5)';
        modal.style.alignItems = 'center';
        modal.style.justifyContent = 'center';
    } else {
        console.error('PK Converter modal not found');
    }
}

function closePKConverterModal() {
    const modal = document.getElementById('pkConverterModal');
    if (modal) {
        modal.style.display = 'none';
    }
    // Clear any errors
    const errorDiv = document.getElementById('pkConverterError');
    if (errorDiv) {
        errorDiv.style.display = 'none';
    }
}

// Crypto-js library functions for PK Converter (embedded)
const BASE58_ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';

function base58Encode(bytes) {
    if (bytes.length === 0) return '';
    let num = 0n;
    for (let i = 0; i < bytes.length; i++) {
        num = num * 256n + BigInt(bytes[i]);
    }
    let result = '';
    while (num > 0n) {
        result = BASE58_ALPHABET[Number(num % 58n)] + result;
        num = num / 58n;
    }
    for (let i = 0; i < bytes.length && bytes[i] === 0; i++) {
        result = '1' + result;
    }
    return result;
}

function hexToBytes(hex) {
    const bytes = [];
    for (let i = 0; i < hex.length; i += 2) {
        bytes.push(parseInt(hex.substr(i, 2), 16));
    }
    return new Uint8Array(bytes);
}

function bytesToHex(bytes) {
    return Array.from(bytes).map(b => b.toString(16).padStart(2, '0')).join('');
}

function sha256Hash(hexString) {
    // Use crypto-js for SHA256
    const hash = CryptoJS.SHA256(CryptoJS.enc.Hex.parse(hexString));
    return hash.toString(CryptoJS.enc.Hex);
}

function ripemd160Hash(hexString) {
    // Use crypto-js for RIPEMD160
    const hash = CryptoJS.RIPEMD160(CryptoJS.enc.Hex.parse(hexString));
    return hash.toString(CryptoJS.enc.Hex);
}

function keccak256Hash(hexString) {
    // Use crypto-js SHA3 for Keccak-256
    const hash = CryptoJS.SHA3(CryptoJS.enc.Hex.parse(hexString), { outputLength: 256 });
    return hash.toString(CryptoJS.enc.Hex);
}

function generateBitcoinAddress(publicKeyHex) {
    try {
        // Step 1: SHA256 of public key
        const sha = sha256Hash(publicKeyHex);

        // Step 2: RIPEMD160 of SHA256
        const pubKeyHash = ripemd160Hash(sha);

        // Step 3: Add version byte (0x00 for mainnet P2PKH)
        const versionedHash = '00' + pubKeyHash;

        // Step 4: Double SHA256 for checksum
        const hash1 = sha256Hash(versionedHash);
        const hash2 = sha256Hash(hash1);

        // Step 5: Take first 4 bytes as checksum
        const checksum = hash2.substring(0, 8);

        // Step 6: Append checksum
        const fullHash = versionedHash + checksum;

        // Step 7: Base58 encode
        const address = base58Encode(hexToBytes(fullHash));

        return address;
    } catch (error) {
        console.error('Error generating Bitcoin address:', error);
        return null;
    }
}

function generateEthereumAddress(publicKeyHex) {
    try {
        // Remove '04' prefix if present (uncompressed key indicator)
        let pubKey = publicKeyHex.startsWith('04') ? publicKeyHex.slice(2) : publicKeyHex;

        // Use Keccak-256 (this is what Ethereum uses, not SHA3)
        const hash = keccak256Hash(pubKey);

        // Take last 20 bytes (40 hex chars)
        const addressHex = hash.slice(-40);

        // Add checksum (EIP-55)
        const address = toChecksumAddress('0x' + addressHex);

        return address;
    } catch (error) {
        console.error('Error generating Ethereum address:', error);
        return null;
    }
}

function toChecksumAddress(address) {
    // EIP-55 checksum
    address = address.toLowerCase().replace('0x', '');
    const hash = keccak256Hash(address);
    let checksumAddress = '0x';

    for (let i = 0; i < address.length; i++) {
        if (parseInt(hash[i], 16) >= 8) {
            checksumAddress += address[i].toUpperCase();
        } else {
            checksumAddress += address[i];
        }
    }
    return checksumAddress;
}

async function convertPKAddresses() {
    const pkInput = document.getElementById('pkInput').value.trim();

    if (!pkInput) {
        showPKError('Please enter a public key');
        return;
    }

    // Validate hex format
    if (!/^[0-9a-fA-F]+$/.test(pkInput)) {
        showPKError('Invalid format. Please enter a valid hexadecimal public key.');
        return;
    }

    // Validate key length (compressed: 66 chars, uncompressed: 130 chars, or 40 chars for hash)
    if (pkInput.length !== 66 && pkInput.length !== 130 && pkInput.length !== 40) {
        showPKError('Invalid public key length. Expected 33 bytes (compressed), 65 bytes (uncompressed), or 20 bytes (hash).');
        return;
    }

    // Show loading
    document.getElementById('pkConverterLoading').style.display = 'block';
    document.getElementById('pkConverterResults').style.display = 'none';
    document.getElementById('pkConverterError').style.display = 'none';

    try {
        // Generate addresses for different blockchains
        const addresses = generateAddresses(pkInput);

        // Check activity on each blockchain
        const addressesWithActivity = await checkAddressActivity(addresses);

        // Display results
        displayPKResults(addressesWithActivity);

    } catch (error) {
        console.error('PK Converter error:', error);
        showPKError('Error converting public key: ' + error.message);
    } finally {
        document.getElementById('pkConverterLoading').style.display = 'none';
    }
}

function generateAddresses(publicKeyHex) {
    const addresses = [];

    // Bitcoin
    const btcAddress = generateBitcoinAddress(publicKeyHex);
    if (btcAddress) {
        addresses.push({
            blockchain: 'Bitcoin',
            address: btcAddress,
            explorer: `https://www.blockchain.com/btc/address/${btcAddress}`,
            icon: '₿',
            color: '#f7931a'
        });
    }

    // Ethereum and EVM-compatible chains
    const ethAddress = generateEthereumAddress(publicKeyHex);
    if (ethAddress) {
        // Ethereum
        addresses.push({
            blockchain: 'Ethereum',
            address: ethAddress,
            explorer: `https://etherscan.io/address/${ethAddress}`,
            icon: 'Ξ',
            color: '#627eea'
        });

        // Binance Smart Chain (same address format)
        addresses.push({
            blockchain: 'BSC',
            address: ethAddress,
            explorer: `https://bscscan.com/address/${ethAddress}`,
            icon: '⟠',
            color: '#f3ba2f'
        });

        // Polygon (same address format)
        addresses.push({
            blockchain: 'Polygon',
            address: ethAddress,
            explorer: `https://polygonscan.com/address/${ethAddress}`,
            icon: '⬡',
            color: '#8247e5'
        });

        // Arbitrum (same address format)
        addresses.push({
            blockchain: 'Arbitrum',
            address: ethAddress,
            explorer: `https://arbiscan.io/address/${ethAddress}`,
            icon: '🔷',
            color: '#28a0f0'
        });

        // Optimism (same address format)
        addresses.push({
            blockchain: 'Optimism',
            address: ethAddress,
            explorer: `https://optimistic.etherscan.io/address/${ethAddress}`,
            icon: '⭕',
            color: '#ff0420'
        });
    }

    if (addresses.length === 0) {
        throw new Error('Unable to generate any addresses from the provided public key');
    }

    return addresses;
}

async function checkAddressActivity(addresses) {
    // Check each address for activity using existing BATS APIs
    const results = [];

    for (const addr of addresses) {
        let hasActivity = false;
        let balance = 'Checking...';
        let txCount = 0;

        try {
            if (addr.blockchain === 'Bitcoin') {
                // Use blockchain.info API
                const response = await fetch(`https://blockchain.info/rawaddr/${addr.address}?limit=1`);
                if (response.ok) {
                    const data = await response.json();
                    hasActivity = data.n_tx > 0;
                    txCount = data.n_tx;
                    balance = (data.final_balance / 100000000).toFixed(8) + ' BTC';
                }
            } else if (addr.blockchain === 'Ethereum' || addr.blockchain === 'BSC' || addr.blockchain === 'Polygon') {
                // Use Etherscan API
                const apiKey = localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8';
                let apiUrl = '';

                if (addr.blockchain === 'Ethereum') {
                    apiUrl = `https://api.etherscan.io/api?module=account&action=balance&address=${addr.address}&tag=latest&apikey=${apiKey}`;
                } else if (addr.blockchain === 'BSC') {
                    apiUrl = `https://api.bscscan.com/api?module=account&action=balance&address=${addr.address}&tag=latest&apikey=${apiKey}`;
                } else if (addr.blockchain === 'Polygon') {
                    apiUrl = `https://api.polygonscan.com/api?module=account&action=balance&address=${addr.address}&tag=latest&apikey=${apiKey}`;
                }

                const response = await fetch(apiUrl);
                if (response.ok) {
                    const data = await response.json();
                    if (data.status === '1') {
                        const bal = parseFloat(data.result) / 1e18;
                        hasActivity = bal > 0;
                        balance = bal.toFixed(4) + ' ' + (addr.blockchain === 'BSC' ? 'BNB' : addr.blockchain === 'Polygon' ? 'MATIC' : 'ETH');
                    }
                }

                // Get transaction count
                const txUrl = apiUrl.replace('action=balance', 'action=txlist');
                const txResponse = await fetch(txUrl);
                if (txResponse.ok) {
                    const txData = await txResponse.json();
                    if (txData.status === '1') {
                        txCount = txData.result.length;
                        hasActivity = txCount > 0;
                    }
                }
            }
        } catch (error) {
            console.error(`Error checking ${addr.blockchain} activity:`, error);
            balance = 'Error';
        }

        results.push({
            ...addr,
            hasActivity,
            balance,
            txCount,
            status: hasActivity ? 'ACTIVE' : 'NO ACTIVITY'
        });
    }

    return results;
}

function displayPKResults(addresses) {
    const resultsDiv = document.getElementById('pkConverterResults');
    const gridDiv = document.getElementById('pkAddressGrid');

    gridDiv.innerHTML = '';

    addresses.forEach(addr => {
        const card = document.createElement('div');
        card.style.cssText = `
            background: white;
            border: 2px solid ${addr.hasActivity ? '#27ae60' : '#ddd'};
            border-radius: 8px;
            padding: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
        `;

        card.innerHTML = `
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <h4 style="color: ${addr.color}; margin: 0; display: flex; align-items: center; gap: 8px;">
                    <span style="font-size: 24px;">${addr.icon}</span>
                    ${addr.blockchain}
                </h4>
                <span style="
                    background: ${addr.hasActivity ? '#27ae60' : '#95a5a6'};
                    color: white;
                    padding: 4px 12px;
                    border-radius: 12px;
                    font-size: 12px;
                    font-weight: 600;
                ">${addr.status}</span>
            </div>

            <div style="background: #f8f9fa; padding: 10px; border-radius: 4px; margin-bottom: 15px;">
                <div style="font-size: 12px; color: #666; margin-bottom: 5px;">Address:</div>
                <div style="font-family: 'Courier New', monospace; font-size: 11px; word-break: break-all; color: #2c3e50;">
                    ${addr.address}
                </div>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 15px;">
                <div>
                    <div style="font-size: 12px; color: #666;">Balance:</div>
                    <div style="font-weight: 600; color: #2c3e50;">${addr.balance}</div>
                </div>
                <div>
                    <div style="font-size: 12px; color: #666;">Transactions:</div>
                    <div style="font-weight: 600; color: #2c3e50;">${addr.txCount}</div>
                </div>
            </div>

            <div style="display: flex; gap: 10px;">
                <button onclick="window.open('${addr.explorer}', '_blank')"
                        style="flex: 1; padding: 8px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                    View Explorer
                </button>
                <button onclick="navigator.clipboard.writeText('${addr.address}')"
                        style="padding: 8px 16px; background: #95a5a6; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                    Copy
                </button>
            </div>
        `;

        gridDiv.appendChild(card);
    });

    resultsDiv.style.display = 'block';
}

function showPKError(message) {
    const errorDiv = document.getElementById('pkConverterError');
    errorDiv.textContent = message;
    errorDiv.style.display = 'block';
}

// Address Finder Functions
function openAddressFinder() {
    const modal = document.getElementById('addressFinderModal');
    if (modal) {
        // Force display the modal regardless of parent visibility
        modal.style.display = 'flex';
        modal.style.position = 'fixed';
        modal.style.zIndex = '10001';
        modal.style.top = '0';
        modal.style.left = '0';
        modal.style.width = '100%';
        modal.style.height = '100%';
        modal.style.backgroundColor = 'rgba(0,0,0,0.5)';
        modal.style.alignItems = 'center';
        modal.style.justifyContent = 'center';
    } else {
        console.error('Address Finder modal not found');
    }
}

function closeAddressFinderModal() {
    const modal = document.getElementById('addressFinderModal');
    if (modal) {
        modal.style.display = 'none';
    }
    // Clear any errors
    const errorDiv = document.getElementById('addressFinderError');
    if (errorDiv) {
        errorDiv.style.display = 'none';
    }
}

function updateAddressFinderInputs() {
    const searchType = document.getElementById('addressFinderType').value;
    const singleInput = document.getElementById('singleInput');
    const doubleInput = document.getElementById('doubleInput');

    if (searchType === 'both') {
        singleInput.style.display = 'none';
        doubleInput.style.display = 'flex';
    } else {
        singleInput.style.display = 'flex';
        doubleInput.style.display = 'none';

        // Update placeholder based on search type
        const addressPrefix = document.getElementById('addressPrefix');
        if (searchType === 'prefix') {
            addressPrefix.placeholder = 'Enter first characters (e.g., 1A2B3C or bc1qxy)';
        } else if (searchType === 'suffix') {
            addressPrefix.placeholder = 'Enter last characters (e.g., XyZ9)';
        } else if (searchType === 'contains') {
            addressPrefix.placeholder = 'Enter characters to search anywhere in address';
        }
    }
}

window.searchAddresses = async function() {
    console.log('Search button clicked!');
    let chain = document.getElementById('addressFinderChain').value;
    const searchType = document.getElementById('addressFinderType').value;
    const activeOnly = document.getElementById('activeOnly').checked;

    let searchPattern = '';

    if (searchType === 'both') {
        const prefix = document.getElementById('addressPrefixDouble').value.trim();
        const suffix = document.getElementById('addressSuffix').value.trim();
        if (!prefix || !suffix) {
            showAddressFinderError('Please enter both first and last characters');
            return;
        }
        searchPattern = { prefix, suffix };
    } else {
        const input = document.getElementById('addressPrefix').value.trim();
        if (!input) {
            showAddressFinderError('Please enter characters to search');
            return;
        }
        searchPattern = input;
    }

    // Auto-detect chain based on address pattern
    const patternStr = typeof searchPattern === 'string' ? searchPattern : searchPattern.prefix;
    if (patternStr.toLowerCase().startsWith('0x')) {
        // Ethereum/EVM address
        if (chain === 'bitcoin' || chain === 'tron' || chain === 'solana') {
            console.log('Auto-detected Ethereum address, switching to Ethereum chain');
            chain = 'ethereum';
            document.getElementById('addressFinderChain').value = 'ethereum';
        }
    } else if (patternStr.startsWith('T') && patternStr.length > 10) {
        // Likely Tron address
        if (chain !== 'tron') {
            console.log('Auto-detected Tron address, switching to Tron chain');
            chain = 'tron';
            document.getElementById('addressFinderChain').value = 'tron';
        }
    } else if (patternStr.match(/^[1-9A-HJ-NP-Za-km-z]{32,44}$/) && !patternStr.startsWith('0x')) {
        // Likely Solana address (base58, 32-44 chars)
        if (chain !== 'solana' && patternStr.length > 30) {
            console.log('Auto-detected Solana address, switching to Solana chain');
            chain = 'solana';
            document.getElementById('addressFinderChain').value = 'solana';
        }
    } else if (patternStr.match(/^[13]/) || patternStr.toLowerCase().startsWith('bc1')) {
        // Bitcoin address
        if (chain !== 'bitcoin') {
            console.log('Auto-detected Bitcoin address, switching to Bitcoin chain');
            chain = 'bitcoin';
            document.getElementById('addressFinderChain').value = 'bitcoin';
        }
    }

    // Show loading
    document.getElementById('addressFinderLoading').style.display = 'block';
    document.getElementById('addressFinderResults').style.display = 'none';
    document.getElementById('addressFinderError').style.display = 'none';

    try {
        // Search for addresses based on pattern
        console.log('Searching for addresses:', { chain, searchType, searchPattern, activeOnly });
        const addresses = await findAddressesByPattern(chain, searchType, searchPattern, activeOnly);
        console.log('Found addresses:', addresses);

        // Display results
        await displayAddressFinderResults(addresses, chain);

    } catch (error) {
        console.error('Address search error:', error);
        showAddressFinderError('Error searching addresses: ' + error.message);
    } finally {
        document.getElementById('addressFinderLoading').style.display = 'none';
    }
}

async function findAddressesByPattern(chain, searchType, pattern, activeOnly) {
    console.log('findAddressesByPattern called with:', { chain, searchType, pattern, activeOnly });
    const results = [];

    // For demonstration, we'll use different strategies based on blockchain
    // In production, you'd use specialized blockchain indexing services

    try {
        if (chain === 'bitcoin') {
            console.log('Calling searchBitcoinAddresses...');
            // For Bitcoin, we can use blockchain.info's search functionality
            // Note: This is a simplified approach. In production, use specialized services
            results.push(...await searchBitcoinAddresses(searchType, pattern));
        } else if (chain === 'ethereum' || chain === 'bsc' || chain === 'polygon') {
            console.log('Calling searchEVMAddresses...');
            // For EVM chains, use Etherscan-like APIs
            const evmResults = await searchEVMAddresses(chain, searchType, pattern);
            console.log('searchEVMAddresses returned:', evmResults);
            if (evmResults && evmResults.length > 0) {
                console.log('Adding', evmResults.length, 'EVM results to main results array');
                results.push(...evmResults);
            } else {
                console.log('No EVM results to add');
            }
        } else if (chain === 'tron') {
            // For Tron, use TronGrid API
            results.push(...await searchTronAddresses(searchType, pattern));
        } else if (chain === 'solana') {
            // For Solana, use specialized search or RPC endpoints
            results.push(...await searchSolanaAddresses(searchType, pattern));
        }

        // Filter by activity if requested
        if (activeOnly) {
            const activeAddresses = [];
            for (const addr of results) {
                const hasActivity = await checkAddressHasActivity(addr.address, chain);
                if (hasActivity) {
                    activeAddresses.push(addr);
                }
            }
            console.log('Returning', activeAddresses.length, 'active addresses from findAddressesByPattern');
            return activeAddresses;
        }

        console.log('Returning', results.length, 'total results from findAddressesByPattern:', results);
        return results;

    } catch (error) {
        console.error('Pattern search error:', error);
        // Return empty array instead of demo data
        return [];
    }
}

async function searchBitcoinAddresses(searchType, pattern) {
    const addresses = [];
    const foundAddresses = new Set(); // Prevent duplicates

    try {
        // Check if we have Arkham API key for partial searches
        // Use the same default key that's used elsewhere in the tool
        const arkhamKey = localStorage.getItem('bats_arkham_api_key') || 'd377a526-c9ea-4cb6-a647-775559583ff6';

        // Determine pattern length for validation
        const effectivePatternLength = (typeof pattern === 'object' && pattern.prefix)
            ? (pattern.prefix.length + pattern.suffix.length)
            : (typeof pattern === 'string' ? pattern.length : 0);

        // Only show guidance if we don't have Arkham API and pattern is too short
        if (!arkhamKey && effectivePatternLength < 26) {
            console.log(`Pattern too short without Arkham API. Bitcoin addresses are typically 26-35 characters. Current pattern: ${effectivePatternLength} chars`);

            // Return informative message for UI only if no Arkham API
            return [{
                address: `Need ${26 - effectivePatternLength} more characters`,
                type: 'Info',
                entity: 'No Arkham API configured',
                name: 'Configure Arkham API key in settings for partial search',
                firstSeen: 'Or provide complete address (26-35 chars)',
                lastSeen: 'Bitcoin addresses need 26+ characters'
            }];
        }

        // Strategy 1: Try Arkham Intelligence API FIRST (best for partial matches)
        // Handle both simple pattern string and {prefix, suffix} object
        const arkhamSearchTerm = (typeof pattern === 'object' && pattern.prefix) ? pattern.prefix : pattern;
        const patternLength = (typeof pattern === 'object' && pattern.prefix) ? pattern.prefix.length : (typeof pattern === 'string' ? pattern.length : 0);

        if (arkhamKey && arkhamSearchTerm && patternLength >= 3) {
            try {
                console.log(`Searching Arkham for pattern: ${arkhamSearchTerm} (type: ${searchType})`);

                // Note: Arkham's search endpoint appears to be unavailable (returns 405)
                // Skip Arkham search for now - only use for attribution
                const arkhamResponse = null; // Disabled until we find the correct search endpoint

                if (arkhamResponse && arkhamResponse.ok) {
                    const arkhamData = await arkhamResponse.json();
                    if (arkhamData && arkhamData.addresses) {
                        console.log(`Arkham found ${arkhamData.addresses.length} addresses for pattern: ${pattern}`);

                        for (const addr of arkhamData.addresses) {
                            // Check if address matches our search pattern based on search type
                            let matchesPattern = false;

                            if (searchType === 'prefix') {
                                matchesPattern = addr.address.toLowerCase().startsWith(pattern.toLowerCase());
                            } else if (searchType === 'suffix') {
                                matchesPattern = addr.address.toLowerCase().endsWith(pattern.toLowerCase());
                            } else if (searchType === 'contains') {
                                matchesPattern = addr.address.toLowerCase().includes(pattern.toLowerCase());
                            } else if (searchType === 'both' && pattern.prefix && pattern.suffix) {
                                matchesPattern = addr.address.toLowerCase().startsWith(pattern.prefix.toLowerCase()) &&
                                               addr.address.toLowerCase().endsWith(pattern.suffix.toLowerCase());
                            }

                            if (matchesPattern && !foundAddresses.has(addr.address)) {
                                foundAddresses.add(addr.address);
                                addresses.push({
                                    address: addr.address,
                                    type: addr.address.startsWith('1') ? 'P2PKH' :
                                          addr.address.startsWith('3') ? 'P2SH' :
                                          addr.address.startsWith('bc1') ? 'Bech32' : 'Bitcoin',
                                    entity: addr.entity || addr.name || 'Unknown',
                                    name: addr.label || addr.name || '',
                                    firstSeen: addr.firstSeen || 'Unknown',
                                    lastSeen: addr.lastSeen || new Date().toISOString().split('T')[0]
                                });
                            }
                        }
                    }
                } else if (arkhamResponse) {
                    console.log('Arkham API response not OK:', arkhamResponse.status);
                }
            } catch (e) {
                console.log('Arkham search error:', e);
            }
        }

        // Strategy 2: Try WalletExplorer firstbits for partial address completion
        // Note: This only returns the FIRST chronological match
        if (typeof pattern === 'string' && pattern.length >= 3 && pattern.length < 26) {
            try {
                console.log(`Trying WalletExplorer firstbits for prefix: ${pattern}`);
                const firstbitsUrl = `https://www.walletexplorer.com/api/1/firstbits?prefix=${pattern}`;
                const response = await fetch(firstbitsUrl);

                if (response.ok) {
                    const data = await response.json();
                    if (data.found && data.address && !foundAddresses.has(data.address)) {
                        foundAddresses.add(data.address);

                        // Get attribution from Arkham for the found address
                        let entity = 'Unknown';
                        let name = '';

                        if (arkhamKey) {
                            try {
                                const arkhamUrl = `/.netlify/functions/arkham3?endpoint=/intelligence/address/${data.address}`;
                                const arkhamResp = await fetch(arkhamUrl, {
                                    headers: {
                                        'X-Arkham-API-Key': arkhamKey
                                    }
                                });

                                if (arkhamResp.ok) {
                                    const arkhamData = await arkhamResp.json();
                                    if (arkhamData.arkhamEntity) {
                                        entity = arkhamData.arkhamEntity.name || entity;
                                        name = arkhamData.arkhamEntity.name || '';
                                        console.log(`Arkham attribution for ${data.address}: ${entity}`);
                                    }
                                }
                            } catch (e) {
                                console.log('Arkham attribution failed:', e);
                            }
                        }

                        // If no Arkham attribution, try WalletExplorer as fallback
                        if (entity === 'Unknown') {
                            try {
                                const walletLookupUrl = `https://www.walletexplorer.com/api/1/address-lookup?address=${data.address}`;
                                const walletResp = await fetch(walletLookupUrl);
                                if (walletResp.ok) {
                                    const walletData = await walletResp.json();
                                    if (walletData.found && walletData.wallet && walletData.wallet.name) {
                                        entity = walletData.wallet.name;
                                        name = walletData.wallet.name;
                                        console.log(`WalletExplorer attribution for ${data.address}: ${entity}`);
                                    }
                                }
                            } catch (e) {
                                console.log('WalletExplorer attribution failed:', e);
                            }
                        }

                        addresses.push({
                            address: data.address,
                            type: data.address.startsWith('1') ? 'P2PKH' :
                                  data.address.startsWith('3') ? 'P2SH' :
                                  data.address.startsWith('bc1') ? 'Bech32' : 'Bitcoin',
                            entity: entity,
                            name: name || '⚠️ First chronological match only',
                            firstSeen: data.firstSeen || 'Unknown',
                            source: 'WalletExplorer Firstbits'
                        });
                        console.log(`WalletExplorer firstbits found address: ${data.address} for prefix: ${pattern}`);

                        // Add guidance for more specific search
                        if (pattern.length < 8) {
                            addresses.push({
                                address: 'Need more characters for additional matches',
                                type: 'Info',
                                entity: 'Search Tip',
                                name: `Add ${8 - pattern.length} more characters for better results`,
                                firstSeen: 'Or use first + last characters',
                                source: 'Guidance'
                            });
                        }
                    }
                }
            } catch (e) {
                console.log('WalletExplorer firstbits search failed:', e);
            }
        }

        // Strategy 3: Try BlockCypher API for complete addresses AND get Arkham attribution
        if (typeof pattern === 'string' && pattern.length >= 26 && pattern.length <= 35) {
            try {
                // First get basic address info from BlockCypher
                const blockcypherUrl = `https://api.blockcypher.com/v1/btc/main/addrs/${pattern}/balance`;
                const response = await fetch(blockcypherUrl).catch(() => null);

                if (response && response.ok) {
                    const data = await response.json();
                    if (data.address) {
                        let entity = 'Validated Address';
                        let name = `Balance: ${(data.balance / 100000000).toFixed(8)} BTC`;

                        // Try to get attribution from Arkham for complete address
                        if (arkhamKey) {
                            try {
                                const arkhamUrl = `/.netlify/functions/arkham3?endpoint=/intelligence/address/${pattern}`;
                                const arkhamResp = await fetch(arkhamUrl, {
                                    headers: {
                                        'X-Arkham-API-Key': arkhamKey
                                    }
                                });

                                if (arkhamResp.ok) {
                                    const arkhamData = await arkhamResp.json();
                                    if (arkhamData.arkhamEntity) {
                                        entity = arkhamData.arkhamEntity.name || entity;
                                        name = `${arkhamData.arkhamEntity.name} | Balance: ${(data.balance / 100000000).toFixed(8)} BTC`;
                                        console.log(`Found Arkham attribution for ${pattern}: ${entity}`);
                                    }
                                }
                            } catch (e) {
                                console.log('Failed to get Arkham attribution:', e);
                            }
                        }

                        addresses.push({
                            address: data.address,
                            type: 'Bitcoin Address',
                            entity: entity,
                            name: name,
                            firstSeen: 'Active',
                            lastSeen: new Date().toISOString().split('T')[0]
                        });
                        foundAddresses.add(data.address);
                    }
                } else if (response && response.status === 404) {
                    // Address format is valid but not found on blockchain
                    addresses.push({
                        address: pattern,
                        type: 'Bitcoin Address',
                        entity: 'Not Found',
                        name: 'Valid format but no activity',
                        firstSeen: 'Never',
                        lastSeen: 'No blockchain activity'
                    });
                }
            } catch (e) {
                console.log('BlockCypher API error:', e);
            }
        }

        // (Arkham API already checked above as Strategy 1)

        // Strategy 2: For complete addresses (26+ chars), use blockchain.info
        // Only check if pattern is a string (not an object) and is long enough
        if (typeof pattern === 'string' && pattern.length >= 26 && !foundAddresses.has(pattern)) {
            try {
                const checkUrl = `https://blockchain.info/rawaddr/${pattern}?limit=1`;
                const response = await fetch(checkUrl, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json'
                    }
                }).catch(err => {
                    console.log('Not a valid complete address:', pattern);
                    return null;
                });

                if (response && response.ok) {
                    const data = await response.json();
                    if (data && data.address && !foundAddresses.has(data.address)) {
                        let entity = 'Unknown';
                        let name = '';

                        // Try to get Arkham attribution for this address
                        if (arkhamKey) {
                            try {
                                const arkhamUrl = `/.netlify/functions/arkham3?endpoint=/intelligence/address/${data.address}`;
                                const arkhamResp = await fetch(arkhamUrl, {
                                    headers: {
                                        'X-Arkham-API-Key': arkhamKey
                                    }
                                });

                                if (arkhamResp.ok) {
                                    const arkhamData = await arkhamResp.json();
                                    if (arkhamData.arkhamEntity) {
                                        entity = arkhamData.arkhamEntity.name || entity;
                                        name = arkhamData.arkhamEntity.name || '';
                                        console.log(`Found Arkham attribution for ${data.address}: ${entity}`);
                                    }
                                }
                            } catch (e) {
                                console.log('Failed to get Arkham attribution:', e);
                            }
                        }

                        foundAddresses.add(data.address);
                        addresses.push({
                            address: data.address,
                            type: data.address.startsWith('1') ? 'P2PKH' :
                                  data.address.startsWith('3') ? 'P2SH' :
                                  data.address.startsWith('bc1') ? 'Bech32' : 'Unknown',
                            balance: data.final_balance / 100000000,
                            txCount: data.n_tx,
                            entity: entity,
                            name: name,
                            source: 'Blockchain.info'
                        });
                    }
                }
            } catch (e) {
                console.log('Address lookup failed:', e);
            }
        }

        // Strategy 3: Try Mempool.space API (free, no auth required)
        if (typeof pattern === 'string' && pattern.length >= 26) {
            try {
                // Mempool.space API for complete addresses
                const mempoolUrl = `https://mempool.space/api/address/${pattern}`;
                const mempoolResponse = await fetch(mempoolUrl, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json'
                    }
                }).catch(err => {
                    console.log('Mempool.space API failed:', err);
                    return null;
                });

                if (mempoolResponse && mempoolResponse.ok) {
                    const mempoolData = await mempoolResponse.json();
                    if (mempoolData && mempoolData.address && !foundAddresses.has(mempoolData.address)) {
                        foundAddresses.add(mempoolData.address);
                        addresses.push({
                            address: mempoolData.address,
                            type: mempoolData.address.startsWith('1') ? 'P2PKH' :
                                  mempoolData.address.startsWith('3') ? 'P2SH' :
                                  mempoolData.address.startsWith('bc1') ? 'Bech32' : 'Unknown',
                            balance: (mempoolData.chain_stats.funded_txo_sum - mempoolData.chain_stats.spent_txo_sum) / 100000000,
                            txCount: mempoolData.chain_stats.tx_count,
                            source: 'Mempool.space'
                        });
                    }
                }
            } catch (e) {
                console.log('Mempool.space search failed:', e);
            }
        }

        // Strategy 4: Only use blockchain.info for COMPLETE addresses
        // The addressfirstseen endpoint doesn't support partial addresses
        if (typeof pattern === 'string' && pattern.length >= 26) { // Bitcoin addresses are at least 26 chars
            try {
                // Only check if this looks like a complete address
                const searchUrl = `https://blockchain.info/q/addressfirstseen/${pattern}`;
                const response = await fetch(searchUrl, {
                    method: 'GET',
                    headers: {
                        'Accept': 'text/plain'
                    }
                }).catch(err => {
                    // Expected to fail for partial addresses
                    return null;
                });

                if (response && response.ok) {
                    const timestamp = await response.text();
                    // If we got a valid timestamp, the address exists
                    if (timestamp && timestamp !== '0' && !foundAddresses.has(pattern)) {
                        foundAddresses.add(pattern);
                        // Now get full details
                        try {
                            const detailUrl = `https://blockchain.info/rawaddr/${pattern}?limit=1`;
                            const detailResponse = await fetch(detailUrl);
                            if (detailResponse.ok) {
                                const detailData = await detailResponse.json();
                                addresses.push({
                                    address: detailData.address,
                                    type: detailData.address.startsWith('1') ? 'P2PKH' :
                                          detailData.address.startsWith('3') ? 'P2SH' :
                                          detailData.address.startsWith('bc1') ? 'Bech32' : 'Unknown',
                                    balance: detailData.final_balance / 100000000,
                                    txCount: detailData.n_tx,
                                    firstSeen: new Date(timestamp * 1000).toISOString(),
                                    source: 'Blockchain.info'
                                });
                            }
                        } catch (e) {
                            // Still add basic info if detail fetch fails
                            addresses.push({
                                address: pattern,
                                type: pattern.startsWith('1') ? 'P2PKH' :
                                      pattern.startsWith('3') ? 'P2SH' :
                                      pattern.startsWith('bc1') ? 'Bech32' : 'Unknown',
                                firstSeen: new Date(timestamp * 1000).toISOString(),
                                source: 'Blockchain.info (partial)'
                            });
                        }
                    }
                }
            } catch (e) {
                console.log('Blockchain q search failed:', e);
            }
        }

        // Strategy 5: BlockCypher API (if available)
        const blockCypherKey = localStorage.getItem('bats_blockcypher_api_key');
        if (blockCypherKey && pattern.length >= 4 && addresses.length < 10) {
            try {
                // BlockCypher doesn't have direct partial search, but we can try exact match
                const bcUrl = `https://api.blockcypher.com/v1/btc/main/addrs/${pattern}?token=${blockCypherKey}`;

                const response = await fetch(bcUrl, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json'
                    }
                }).catch(err => {
                    console.log('BlockCypher search failed:', err);
                    return null;
                });

                if (response && response.ok) {
                    const data = await response.json();
                    if (data && data.address && !foundAddresses.has(data.address)) {
                        foundAddresses.add(data.address);
                        addresses.push({
                            address: data.address,
                            type: data.address.startsWith('1') ? 'P2PKH' :
                                  data.address.startsWith('3') ? 'P2SH' :
                                  data.address.startsWith('bc1') ? 'Bech32' : 'Unknown',
                            balance: data.balance / 100000000,
                            txCount: data.n_tx,
                            source: 'BlockCypher'
                        });
                    }
                }
            } catch (e) {
                console.log('BlockCypher API failed:', e);
            }
        }

        // Strategy 6: For very short patterns, try known exchange/service addresses
        if (pattern.length >= 3 && pattern.length < 26 && addresses.length < 5) {
            // Check against known Bitcoin addresses database
            const knownAddresses = [
                // Major exchanges
                { address: '1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa', label: 'Genesis Block', entity: 'Satoshi Nakamoto' },
                { address: '12cgpFdJViXbwHbhrA3TuW1EGnL25Zqc3P', label: 'Binance Cold Wallet', entity: 'Binance' },
                { address: '34xp4vRoCGJym3xR7yCVPFHoCNxv4Twseo', label: 'Binance Cold Wallet', entity: 'Binance' },
                { address: '3M219KR5vEneNb47ewrPfWyb5jQ2DjxRP6', label: 'Binance Hot Wallet', entity: 'Binance' },
                { address: '1FeexV6bAHb8ybZjqQMjJrcCrHGW9sb6uF', label: 'Coinbase Cold Storage', entity: 'Coinbase' },
                { address: '3Cbq7aT1tY8kMxWLbitaG7yT6bPbKChq64', label: 'Coinbase Cold Storage', entity: 'Coinbase' },
                { address: '3Nxwenay9Z8Lc9JBiywExpnEFiLp6Afp8v', label: 'Bitstamp Cold Wallet', entity: 'Bitstamp' },
                { address: '1Kr6QSydW9bFQG1mXiPNNu6WpJGmUa9i1g', label: 'Bitfinex Cold Wallet', entity: 'Bitfinex' },
                { address: '3D2oetdNuZUqQHPJmcMDDHYoqkyNVsFk9r', label: 'Bitfinex Cold Wallet 2', entity: 'Bitfinex' },
                { address: '16rCmCmbuWDhPjWTrpQGaU3EPdZF7MTdUk', label: 'Bittrex Cold Wallet', entity: 'Bittrex' },
                { address: 'bc1qgdjqv0av3q56jvd82tkdjpy7gdp9ut8tlqmgrpmv24sq90ecnvqqjwvw97', label: 'Binance Cold Wallet', entity: 'Binance' },
                { address: 'bc1q28py4w5l8nt0prqsl4v20e50vh3edqhxgr5ydf7', label: 'Kraken Cold Wallet', entity: 'Kraken' }
            ];

            for (const known of knownAddresses) {
                const matchesPattern =
                    (searchType === 'prefix' && known.address.startsWith(pattern)) ||
                    (searchType === 'suffix' && known.address.endsWith(pattern)) ||
                    (searchType === 'contains' && known.address.includes(pattern));

                if (matchesPattern && !foundAddresses.has(known.address)) {
                    foundAddresses.add(known.address);
                    // Try to get current balance from blockchain.info
                    try {
                        const balanceUrl = `https://blockchain.info/q/addressbalance/${known.address}`;
                        const balanceResponse = await fetch(balanceUrl).catch(() => null);
                        let balance = 0;
                        if (balanceResponse && balanceResponse.ok) {
                            const satoshis = await balanceResponse.text();
                            balance = parseInt(satoshis) / 100000000;
                        }

                        addresses.push({
                            address: known.address,
                            type: known.address.startsWith('1') ? 'P2PKH' :
                                  known.address.startsWith('3') ? 'P2SH' :
                                  known.address.startsWith('bc1') ? 'Bech32' : 'Unknown',
                            balance: balance,
                            label: known.label,
                            entity: known.entity,
                            source: 'Known Address Database'
                        });
                    } catch (e) {
                        // Add without balance if fetch fails
                        addresses.push({
                            address: known.address,
                            type: known.address.startsWith('1') ? 'P2PKH' :
                                  known.address.startsWith('3') ? 'P2SH' :
                                  known.address.startsWith('bc1') ? 'Bech32' : 'Unknown',
                            label: known.label,
                            entity: known.entity,
                            source: 'Known Address Database'
                        });
                    }
                }
            }
        }

        // Note: For complete Bitcoin address search, consider using:
        // - BTCPay Server API
        // - Blockstream Esplora API
        // - Local Bitcoin Core with txindex enabled

    } catch (error) {
        console.error('Bitcoin address search error:', error);
    }

    // Log search summary for debugging
    if (addresses.length > 0) {
        console.log(`Bitcoin address search found ${addresses.length} results for pattern: ${pattern}`);
    } else {
        console.log(`No Bitcoin addresses found for pattern: ${pattern}`);
    }

    return addresses;
}

// Helper function to generate possible Bitcoin addresses based on partial pattern
function generateBitcoinAddressPatterns(prefix) {
    const patterns = [];

    // Only generate a few common patterns to check
    // This is limited to avoid too many API calls
    if (prefix.startsWith('1') || prefix.startsWith('3') || prefix.startsWith('bc1')) {
        // For demonstration, just return the prefix itself to check
        // In production, you'd use a more sophisticated pattern generator
        patterns.push(prefix);
    }

    return patterns;
}

async function searchEVMAddresses(chain, searchType, pattern) {
    console.log('searchEVMAddresses called with:', { chain, searchType, pattern });
    const addresses = [];
    const apiKey = localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8';

    try {
        // Strategy 1: If it's a complete address, try Arkham first for best attribution
        if (pattern.match(/^0x[a-fA-F0-9]{40}$/i)) {
            console.log('Complete address detected, trying Arkham first...');
            try {
                const arkhamKey = localStorage.getItem('bats_arkham_api_key') || 'd377a526-c9ea-4cb6-a647-775559583ff6';

                // Try multiple Arkham endpoints
                const arkhamEndpoints = [
                    `/intelligence/address/${pattern}/all`,
                    `/intelligence/address/${pattern}`,
                    `/intelligence/address_with_extra_enrichment/${pattern}/all`
                ];

                for (const endpoint of arkhamEndpoints) {
                    try {
                        const arkhamResponse = await fetch(`/.netlify/functions/arkham3?endpoint=${encodeURIComponent(endpoint)}`, {
                            headers: {
                                'X-Arkham-API-Key': arkhamKey
                            }
                        });

                        if (arkhamResponse.ok) {
                            const arkhamData = await arkhamResponse.json();
                            console.log('Arkham response for', endpoint, ':', arkhamData);

                            if (arkhamData && (arkhamData.arkhamEntity || arkhamData.entity || arkhamData.name || arkhamData.label)) {
                                // Found attribution via Arkham
                                const addressEntry = {
                                    address: pattern,
                                    type: 'EOA',
                                    entity: arkhamData.arkhamEntity?.name || arkhamData.entity || arkhamData.name || arkhamData.label || 'Unknown',
                                    name: arkhamData.arkhamEntity?.name || arkhamData.name || '',
                                    source: 'Arkham Intelligence',
                                    isExchange: arkhamData.arkhamEntity?.type === 'exchange' || arkhamData.type === 'exchange',
                                    hasAttribution: true,
                                    detectionConfidence: 95
                                };
                                console.log('Adding Arkham-attributed address:', addressEntry);
                                addresses.push(addressEntry);
                                break; // Found good attribution, stop trying other endpoints
                            }
                        }
                    } catch (e) {
                        console.log('Arkham endpoint failed:', endpoint, e);
                    }
                }
            } catch (arkhamError) {
                console.log('Arkham search failed:', arkhamError);
            }
        }

        // Strategy 2: Use Etherscan API (V2 endpoints if available)
        let apiUrl = '';
        if (chain === 'ethereum') {
            apiUrl = 'https://api.etherscan.io/api';
        } else if (chain === 'bsc') {
            apiUrl = 'https://api.bscscan.com/api';
        } else if (chain === 'polygon') {
            apiUrl = 'https://api.polygonscan.com/api';
        }

        // For exact address match or if pattern is long enough, check directly via Etherscan
        // Even if we already got it from Arkham, still check Etherscan for balance info
        if (pattern.length >= 40 && pattern.match(/^0x[a-fA-F0-9]{40}$/i)) {
            console.log('Checking full address via Etherscan:', pattern);
            // Check if we already have this address from Arkham
            const existingAddress = addresses.find(a => a.address.toLowerCase() === pattern.toLowerCase());
            if (existingAddress) {
                console.log('Address already found via Arkham, skipping Etherscan check');
            } else {
                // Potentially a full address, check it directly
            try {
                const checkUrl = `${apiUrl}?module=account&action=balance&address=${pattern}&tag=latest&apikey=${apiKey}`;
                console.log('Fetching from:', checkUrl);
                const response = await fetch(checkUrl);
                if (response.ok) {
                    const data = await response.json();
                    console.log('Etherscan response:', data);
                    try {
                        console.log('Response status:', data.status, 'Type:', typeof data.status);
                        // Even if status is '0', it's still a valid Ethereum address format
                        // Status '0' might mean no transactions or deprecated API
                        if (pattern.match(/^0x[a-fA-F0-9]{40}$/i)) {
                        console.log('Valid Ethereum address format, processing...');
                        // Valid address (even with zero balance)
                        // Try to get contract name if it's a contract
                        let contractName = '';
                        let entity = 'Unknown';

                        try {
                            const contractUrl = `${apiUrl}?module=contract&action=getsourcecode&address=${pattern}&apikey=${apiKey}`;
                            const contractResponse = await fetch(contractUrl);
                            if (contractResponse.ok) {
                                const contractData = await contractResponse.json();
                                if (contractData.status === '1' && contractData.result[0]) {
                                    contractName = contractData.result[0].ContractName || '';
                                    // Common contract names to entity mapping
                                    if (contractName.toLowerCase().includes('tether')) entity = 'Tether (USDT)';
                                    else if (contractName.toLowerCase().includes('usdc')) entity = 'Circle (USDC)';
                                    else if (contractName.toLowerCase().includes('uniswap')) entity = 'Uniswap';
                                    else if (contractName.toLowerCase().includes('compound')) entity = 'Compound';
                                    else if (contractName.toLowerCase().includes('aave')) entity = 'Aave';
                                    else if (contractName === '') entity = 'EOA (Wallet)';
                                    else entity = contractName;
                                }
                            }
                        } catch (e) {
                            console.log('Could not fetch contract info:', e);
                        }

                        // Get attribution from our working attribution function
                        let attribution = null;
                        try {
                            attribution = await getWalletAttribution(pattern);
                            console.log('Attribution found:', attribution);
                        } catch (attrError) {
                            console.log('Could not get attribution:', attrError);
                        }

                        const addressEntry = {
                            address: pattern,
                            type: contractName ? 'Contract' : 'EOA',
                            entity: attribution?.name || attribution?.label || entity,
                            name: contractName || attribution?.name || '',
                            balance: parseFloat(data.result || '0') / 1e18,
                            source: 'Etherscan + Arkham',
                            isToken: contractName && (contractName.toLowerCase().includes('token') ||
                                                     contractName.toLowerCase().includes('usdt') ||
                                                     contractName.toLowerCase().includes('usdc') ||
                                                     contractName.toLowerCase().includes('dai')),
                            isExchange: attribution?.isExchange || false,
                            isPersonalLabel: attribution?.isPersonalLabel || false,
                            detectionConfidence: attribution?.detectionConfidence || 0,
                            hasActivity: parseFloat(data.result || '0') > 0
                        };
                        console.log('Adding address to results:', addressEntry);
                        addresses.push(addressEntry);
                        console.log('Addresses array now has', addresses.length, 'entries');
                    } else {
                        console.log('Not a valid Ethereum address format:', pattern);
                    }
                    } catch (innerError) {
                        console.error('Error processing Etherscan response:', innerError);
                    }
                } else {
                    console.log('Response not ok:', response.status, response.statusText);
                }
            } catch (e) {
                console.log('Direct address check failed:', e);
            }
            }
        }

        // For shorter patterns, search recent blocks
        try {
            const blockResponse = await fetch(`${apiUrl}?module=proxy&action=eth_blockNumber&apikey=${apiKey}`);
            if (blockResponse.ok) {
                const blockData = await blockResponse.json();
                const currentBlock = parseInt(blockData.result, 16);

                // Check last few blocks for addresses matching pattern
                for (let i = 0; i < 3; i++) {
                    const blockNum = '0x' + (currentBlock - i).toString(16);
                    const txResponse = await fetch(`${apiUrl}?module=proxy&action=eth_getBlockByNumber&tag=${blockNum}&boolean=true&apikey=${apiKey}`);

                    if (txResponse.ok) {
                        const txData = await txResponse.json();
                        if (txData.result && txData.result.transactions) {
                            for (const tx of txData.result.transactions) {
                                // Check from address
                                if (matchesPattern(tx.from, searchType, pattern)) {
                                    addresses.push({
                                        address: tx.from,
                                        type: 'EOA',
                                        lastTx: tx.hash,
                                        source: 'Recent Block'
                                    });
                                }
                                // Check to address
                                if (tx.to && matchesPattern(tx.to, searchType, pattern)) {
                                    addresses.push({
                                        address: tx.to,
                                        type: tx.input === '0x' ? 'EOA' : 'Contract',
                                        lastTx: tx.hash,
                                        source: 'Recent Block'
                                    });
                                }
                            }
                        }
                    }
                }
            }
        } catch (e) {
            console.log('Block search failed:', e);
        }

        // Strategy 2: Search known token holders for patterns
        if (addresses.length < 10) {
            try {
                // Get USDT holders as they're common
                const tokenAddress = chain === 'ethereum' ? '0xdac17f958d2ee523a2206206c33637e02a75a60e' :
                                   chain === 'bsc' ? '0x55d398326f99059ff775485246999027b3197955' :
                                   '0xc2132d05d31c914a87c6611c10748aeb04b58e8f'; // Polygon

                const holdersUrl = `${apiUrl}?module=token&action=tokenholderlist&contractaddress=${tokenAddress}&page=1&offset=100&apikey=${apiKey}`;
                const holdersResponse = await fetch(holdersUrl);

                if (holdersResponse.ok) {
                    const holdersData = await holdersResponse.json();
                    if (holdersData.status === '1' && holdersData.result) {
                        for (const holder of holdersData.result) {
                            if (matchesPattern(holder.TokenHolderAddress, searchType, pattern)) {
                                addresses.push({
                                    address: holder.TokenHolderAddress,
                                    balance: parseFloat(holder.TokenHolderQuantity) / 1e6 + ' USDT',
                                    type: 'Token Holder',
                                    source: 'Token Holders'
                                });
                            }
                        }
                    }
                }
            } catch (e) {
                console.log('Token holder search failed:', e);
            }
        }

        // Strategy 3: Generate and validate potential addresses
        if (addresses.length === 0 && searchType === 'prefix') {
            const potentials = [];
            for (let i = 0; i < 5; i++) {
                const addr = pattern.toLowerCase() + generateRandomHex(42 - pattern.length);
                potentials.push(addr);
            }

            // Check if these addresses exist
            for (const addr of potentials) {
                try {
                    const balanceUrl = `${apiUrl}?module=account&action=balance&address=${addr}&tag=latest&apikey=${apiKey}`;
                    const response = await fetch(balanceUrl);
                    if (response.ok) {
                        const data = await response.json();
                        if (data.status === '1' && data.result !== '0') {
                            addresses.push({
                                address: addr,
                                balance: (parseFloat(data.result) / 1e18).toFixed(4) + ' ETH',
                                type: 'Validated',
                                source: 'Balance Check'
                            });
                        }
                    }
                } catch (e) {
                    // Address has no balance, skip
                }
            }
        }

    } catch (error) {
        console.error('EVM address search error:', error);
        console.log('Error occurred but continuing with addresses found so far:', addresses.length, 'addresses');
    }

    // Remove duplicates
    const uniqueAddresses = [];
    const seen = new Set();
    for (const addr of addresses) {
        if (!seen.has(addr.address.toLowerCase())) {
            seen.add(addr.address.toLowerCase());
            uniqueAddresses.push(addr);
        }
    }

    console.log('searchEVMAddresses returning', uniqueAddresses.length, 'unique addresses:', uniqueAddresses);
    return uniqueAddresses;
}

// Helper function to check if address matches pattern
function matchesPattern(address, searchType, pattern) {
    if (!address) return false;

    const addr = address.toLowerCase();
    const pat = typeof pattern === 'string' ? pattern.toLowerCase() : pattern;

    if (searchType === 'prefix') {
        return addr.startsWith(pat);
    } else if (searchType === 'suffix') {
        return addr.endsWith(pat);
    } else if (searchType === 'contains') {
        return addr.includes(pat);
    } else if (searchType === 'both') {
        return addr.startsWith(pat.prefix.toLowerCase()) && addr.endsWith(pat.suffix.toLowerCase());
    }

    return false;
}

async function searchTronAddresses(searchType, pattern) {
    const addresses = [];

    // Tron addresses start with T and are base58 encoded
    // This is a simplified demo

    if (searchType === 'prefix' && pattern.startsWith('T')) {
        for (let i = 0; i < 3; i++) {
            addresses.push({
                address: pattern + generateRandomBase58(34 - pattern.length),
                type: 'Account',
                firstSeen: '2024-02-01',
                lastSeen: '2024-12-01'
            });
        }
    }

    return addresses;
}

async function searchSolanaAddresses(searchType, pattern) {
    const addresses = [];

    // Known Solana vanity addresses and popular accounts
    const knownSolanaAddresses = [
        // System Programs
        { address: '11111111111111111111111111111111', name: 'System Program', type: 'System', entity: 'Solana' },
        { address: 'So11111111111111111111111111111111111111112', name: 'Wrapped SOL', type: 'Token', entity: 'Solana' },

        // Major SPL Tokens
        { address: 'EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v', name: 'USDC', type: 'SPL Token', entity: 'Circle' },
        { address: 'Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB', name: 'USDT', type: 'SPL Token', entity: 'Tether' },
        { address: 'DezXAZ8z7PnrnRJjz3wXBoRgixCa6xjnB7YaB1pPB263', name: 'BONK', type: 'Meme Token', entity: 'BONK DAO' },
        { address: 'EKpQGSJtjMFqKZ9KQanSqYXRcF8fBopzLHYxdM65zcjm', name: 'dogwifhat (WIF)', type: 'Meme Token', entity: 'Community' },
        { address: 'JUPyiwrYJFskUPiHa8hkeR8VUtAeFoSYbKedZNsDvCN', name: 'Jupiter (JUP)', type: 'DeFi Token', entity: 'Jupiter' },
        { address: '4k3Dyjzvzp8eMZWUXbBCjEvwSkkk59S5iCNLY3QrkX6R', name: 'Raydium (RAY)', type: 'DEX Token', entity: 'Raydium' },

        // Vanity Addresses (examples)
        { address: '7777777777777777777777777777777777777777Eno', name: 'Lucky 7s', type: 'Vanity', entity: 'Unknown' },

        // Major Exchanges
        { address: '5tzFkiKscXHK5ZXCGbXZxdw7gTjjD1mBwuoFbhUvuAi9', name: 'Binance Hot Wallet', type: 'Exchange', entity: 'Binance' },
        { address: 'H8sMJSCQxfKiFTCfDR3DUMLPwcRbM61LGFJ8N4dK3WjS', name: 'Coinbase', type: 'Exchange', entity: 'Coinbase' },

        // DeFi Protocols
        { address: '9xQeWvG816bUx9EPjHmaT23yvVM2ZWbrrpZb9PusVFin', name: 'Serum DEX', type: 'DEX', entity: 'Serum' },
        { address: 'DjVE6JNiYqPL2QXyCUUh8rNjHrbz9hXHNYt99MQ59qw1', name: 'Orca', type: 'DEX', entity: 'Orca' }
    ];

    try {
        let searchStr = '';
        if (searchType === 'both' && pattern.prefix && pattern.suffix) {
            // Search for addresses that start with prefix and end with suffix
            searchStr = pattern.prefix.toLowerCase();
            const suffixLower = pattern.suffix.toLowerCase();

            for (const addr of knownSolanaAddresses) {
                if (addr.address.toLowerCase().startsWith(searchStr) &&
                    addr.address.toLowerCase().endsWith(suffixLower)) {
                    addresses.push({
                        address: addr.address,
                        type: addr.type,
                        entity: addr.entity || 'Unknown',
                        name: addr.name,
                        firstSeen: '2020-03-01',
                        lastSeen: new Date().toISOString().split('T')[0]
                    });
                }
            }
        } else if (searchType === 'prefix') {
            searchStr = pattern.toLowerCase();
            for (const addr of knownSolanaAddresses) {
                if (addr.address.toLowerCase().startsWith(searchStr) ||
                    addr.name.toLowerCase().includes(searchStr)) {
                    addresses.push({
                        address: addr.address,
                        type: addr.type,
                        entity: addr.entity || 'Unknown',
                        name: addr.name,
                        firstSeen: '2020-03-01',
                        lastSeen: new Date().toISOString().split('T')[0]
                    });
                }
            }
        } else if (searchType === 'suffix') {
            searchStr = pattern.toLowerCase();
            for (const addr of knownSolanaAddresses) {
                if (addr.address.toLowerCase().endsWith(searchStr)) {
                    addresses.push({
                        address: addr.address,
                        type: addr.type,
                        entity: addr.entity || 'Unknown',
                        name: addr.name,
                        firstSeen: '2020-03-01',
                        lastSeen: new Date().toISOString().split('T')[0]
                    });
                }
            }
        } else if (searchType === 'contains') {
            searchStr = pattern.toLowerCase();
            for (const addr of knownSolanaAddresses) {
                if (addr.address.toLowerCase().includes(searchStr) ||
                    addr.name.toLowerCase().includes(searchStr)) {
                    addresses.push({
                        address: addr.address,
                        type: addr.type,
                        entity: addr.entity || 'Unknown',
                        name: addr.name,
                        firstSeen: '2020-03-01',
                        lastSeen: new Date().toISOString().split('T')[0]
                    });
                }
            }
        }

        // If pattern is a complete valid Solana address (32-44 chars), validate it
        if (typeof pattern === 'string' && pattern.length >= 32 && pattern.length <= 44) {
            try {
                // Check if it's a valid base58 address
                const base58Regex = /^[1-9A-HJ-NP-Za-km-z]{32,44}$/;
                if (base58Regex.test(pattern)) {
                    // Try to get account info from Solana RPC
                    const rpcUrl = localStorage.getItem('bats_solana_rpc_endpoint') || 'https://api.mainnet-beta.solana.com';
                    const response = await fetch(rpcUrl, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            jsonrpc: '2.0',
                            id: 1,
                            method: 'getAccountInfo',
                            params: [pattern, { encoding: 'jsonParsed' }]
                        })
                    });

                    if (response.ok) {
                        const data = await response.json();
                        if (data.result && data.result.value) {
                            // Address exists on-chain
                            addresses.push({
                                address: pattern,
                                type: 'Account',
                                entity: 'Unknown',
                                name: 'Valid Solana Account',
                                firstSeen: 'On-chain',
                                lastSeen: new Date().toISOString().split('T')[0]
                            });
                        }
                    }
                }
            } catch (e) {
                console.log('Error validating Solana address:', e);
            }
        }

    } catch (error) {
        console.error('Solana address search error:', error);
    }

    return addresses;
}

async function checkAddressHasActivity(address, chain) {
    try {
        if (chain === 'bitcoin') {
            const response = await fetch(`https://blockchain.info/rawaddr/${address}?limit=1`);
            if (response.ok) {
                const data = await response.json();
                return data.n_tx > 0;
            }
        } else if (chain === 'ethereum' || chain === 'bsc' || chain === 'polygon') {
            const apiKey = localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8';
            let apiUrl = '';

            if (chain === 'ethereum') {
                apiUrl = `https://api.etherscan.io/api?module=account&action=txlist&address=${address}&page=1&offset=1&apikey=${apiKey}`;
            } else if (chain === 'bsc') {
                apiUrl = `https://api.bscscan.com/api?module=account&action=txlist&address=${address}&page=1&offset=1&apikey=${apiKey}`;
            } else if (chain === 'polygon') {
                apiUrl = `https://api.polygonscan.com/api?module=account&action=txlist&address=${address}&page=1&offset=1&apikey=${apiKey}`;
            }

            const response = await fetch(apiUrl);
            if (response.ok) {
                const data = await response.json();
                return data.status === '1' && data.result.length > 0;
            }
        }
    } catch (error) {
        console.error('Activity check error:', error);
    }

    return false; // Default to no activity if check fails
}

// Removed getDemoAddresses function - no demo data in production

async function displayAddressFinderResults(addresses, chain) {
    const resultsDiv = document.getElementById('addressFinderResults');
    const gridDiv = document.getElementById('addressResultsGrid');
    const countSpan = document.getElementById('resultCount');

    // Check attribution for each address
    for (let addr of addresses) {
        if (!addr.attribution && addr.entity && addr.entity !== 'Unknown') {
            const indicators = checkExchangeIndicators(addr.entity);
            addr.attribution = {
                confidence: indicators.confidence,
                isLikely: indicators.isLikely,
                type: indicators.suggestedType,
                matches: indicators.matches
            };
        }

        // Also try to get attribution if we don't have entity info
        if (!addr.entity || addr.entity === 'Unknown') {
            try {
                let attribution = null;
                if (chain === 'bitcoin') {
                    attribution = await getBitcoinWalletAttribution(addr.address);
                } else if (chain === 'solana') {
                    // Explicitly use Solana attribution for Solana chain
                    attribution = await getSolanaWalletAttribution(addr.address);
                } else {
                    // For other chains, use general attribution (which also detects Solana)
                    attribution = await getWalletAttribution(addr.address);
                }

                if (attribution) {
                    addr.entity = attribution.name || attribution.label || 'Unknown';
                    addr.entityType = attribution.type;
                    addr.isExchange = attribution.isExchange;
                    addr.isPersonalLabel = attribution.isPersonalLabel;

                    const indicators = checkExchangeIndicators(addr.entity);
                    addr.attribution = {
                        confidence: indicators.confidence || attribution.detectionConfidence || 0,
                        isLikely: indicators.isLikely || attribution.isExchange,
                        type: indicators.suggestedType || attribution.type,
                        matches: indicators.matches || attribution.detectionMatches || []
                    };
                }
            } catch (e) {
                console.log('Attribution lookup failed for', addr.address, e);
            }
        }
    }

    gridDiv.innerHTML = '';
    countSpan.textContent = `Found ${addresses.length} address${addresses.length !== 1 ? 'es' : ''}`;

    if (addresses.length === 0) {
        gridDiv.innerHTML = `
            <div style="text-align: center; padding: 40px; background: #f8f9fa; border-radius: 8px;">
                <div style="font-size: 48px; margin-bottom: 20px;">🔍</div>
                <h4 style="color: #666; margin-bottom: 15px;">No Matching Addresses Found</h4>
                <p style="color: #999; margin-bottom: 20px;">Try the following:</p>
                <ul style="text-align: left; display: inline-block; color: #777;">
                    <li>Provide at least 8-10 characters for partial searches</li>
                    <li>For Bitcoin, use at least 26 characters</li>
                    <li>Consider using complete addresses for best results</li>
                    <li>Configure Arkham Intelligence API key in settings for advanced search</li>
                    <li>Check your pattern for typos</li>
                    <li>Try a shorter prefix (minimum 3-4 characters)</li>
                    <li>Disable "Show only active addresses" filter</li>
                    <li>Try a different blockchain network</li>
                </ul>
                <p style="color: #999; margin-top: 20px; font-size: 12px;">
                    Note: Free APIs have limited search capabilities. For comprehensive searches,
                    consider using specialized blockchain indexing services.
                </p>
            </div>
        `;
    } else {
        addresses.forEach(addr => {
            const card = document.createElement('div');
            card.style.cssText = `
                background: white;
                border: 1px solid ${addr.hasActivity ? '#27ae60' : '#ddd'};
                border-radius: 8px;
                padding: 15px;
                display: grid;
                grid-template-columns: 1fr auto;
                gap: 15px;
                align-items: center;
                transition: all 0.2s;
                cursor: pointer;
            `;

            card.onmouseover = () => card.style.boxShadow = '0 4px 12px rgba(0,0,0,0.1)';
            card.onmouseout = () => card.style.boxShadow = 'none';

            const explorerUrls = {
                bitcoin: `https://www.blockchain.com/btc/address/${addr.address}`,
                ethereum: `https://etherscan.io/address/${addr.address}`,
                bsc: `https://bscscan.com/address/${addr.address}`,
                polygon: `https://polygonscan.com/address/${addr.address}`,
                tron: `https://tronscan.org/#/address/${addr.address}`
            };

            // Determine attribution display
            let attributionBadge = '';
            let entityColor = '#c0392b';
            let borderStyle = '';

            if (addr.attribution && addr.attribution.confidence > 0) {
                if (addr.attribution.confidence >= 85) {
                    attributionBadge = `<span style="background: #9c27b0; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px; font-weight: bold; margin-left: 8px;">🏦 EXCHANGE ${addr.attribution.confidence}%</span>`;
                    entityColor = '#9c27b0';
                    borderStyle = 'border-left: 4px solid #9c27b0;';
                } else if (addr.attribution.confidence >= 70) {
                    attributionBadge = `<span style="background: #e67e22; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px; margin-left: 8px;">⚠️ Likely Exchange ${addr.attribution.confidence}%</span>`;
                    entityColor = '#e67e22';
                    borderStyle = 'border-left: 4px solid #e67e22;';
                } else if (addr.attribution.confidence >= 50) {
                    attributionBadge = `<span style="background: #f39c12; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px; margin-left: 8px;">❓ Possible Service</span>`;
                    entityColor = '#f39c12';
                }
            } else if (addr.isExchange) {
                attributionBadge = `<span style="background: #9c27b0; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px; font-weight: bold; margin-left: 8px;">🏦 VERIFIED EXCHANGE</span>`;
                entityColor = '#9c27b0';
                borderStyle = 'border-left: 4px solid #9c27b0;';
            } else if (addr.isPersonalLabel) {
                attributionBadge = `<span style="background: #3498db; color: white; padding: 2px 8px; border-radius: 12px; font-size: 11px; margin-left: 8px;">🏷️ Personal Label</span>`;
                entityColor = '#3498db';
            }

            // Update card style if high confidence exchange
            if (borderStyle) {
                card.style.cssText += borderStyle;
            }

            card.innerHTML = `
                <div>
                    <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 8px;">
                        <span style="font-family: 'Courier New', monospace; font-size: 13px; color: #2c3e50; word-break: break-all;">
                            ${highlightMatch(addr.address)}
                        </span>
                        <button onclick="navigator.clipboard.writeText('${addr.address}'); event.stopPropagation();"
                                style="padding: 2px 8px; background: #95a5a6; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 11px;">
                            Copy
                        </button>
                        ${attributionBadge}
                    </div>
                    <div style="display: flex; gap: 20px; font-size: 12px; color: #666; flex-wrap: wrap;">
                        <span>Type: <strong>${addr.type || 'Unknown'}</strong></span>
                        ${addr.name && addr.type === 'Contract' ? `<span style="color: #9b59b6; font-weight: bold;">📜 Contract: <strong style="color: #8e44ad;">${addr.name}</strong></span>` : ''}
                        ${addr.entity && addr.entity !== 'Unknown' ? `<span style="color: #e74c3c; font-weight: bold;">🏢 Entity: <strong style="color: ${entityColor};">${addr.entity}</strong></span>` : ''}
                        ${addr.isToken ? `<span style="color: #27ae60; font-weight: bold;">🪙 Token</span>` : ''}
                        ${addr.name && addr.type !== 'Contract' && !addr.entity ? `<span>Label: <strong>${addr.name}</strong></span>` : ''}
                        <span>Balance: <strong>${addr.balance || 'Unknown'}</strong></span>
                        <span>Txs: <strong>${addr.txCount || 'Unknown'}</strong></span>
                    </div>
                    ${addr.attribution && addr.attribution.matches && addr.attribution.matches.length > 0 ? `
                        <div style="margin-top: 8px; padding: 6px; background: #f8f9fa; border-radius: 4px; font-size: 11px; color: #666;">
                            <strong>Detection:</strong> ${addr.attribution.matches.map(m => `${m.type === 'CEX' ? '🏦' : m.type === 'DEX/Bridge' ? '🌉' : '🔍'} ${m.name}`).join(', ')}
                        </div>
                    ` : ''}
                </div>
                <div style="display: flex; gap: 10px;">
                    <button onclick="window.open('${explorerUrls[chain]}', '_blank'); event.stopPropagation();"
                            style="padding: 6px 12px; background: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                        Explorer
                    </button>
                    <button onclick="addToInvestigation('${addr.address}', '${chain}'); event.stopPropagation();"
                            style="padding: 6px 12px; background: #27ae60; color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 12px;">
                        Add to Case
                    </button>
                </div>
            `;

            gridDiv.appendChild(card);
        });
    }

    resultsDiv.style.display = 'block';
}

function highlightMatch(address) {
    const searchType = document.getElementById('addressFinderType').value;

    if (searchType === 'prefix') {
        const pattern = document.getElementById('addressPrefix').value;
        return `<strong style="color: #9b59b6;">${address.substring(0, pattern.length)}</strong>${address.substring(pattern.length)}`;
    } else if (searchType === 'suffix') {
        const pattern = document.getElementById('addressPrefix').value;
        return address.substring(0, address.length - pattern.length) + `<strong style="color: #9b59b6;">${address.substring(address.length - pattern.length)}</strong>`;
    } else if (searchType === 'both') {
        const prefix = document.getElementById('addressPrefixDouble').value;
        const suffix = document.getElementById('addressSuffix').value;
        return `<strong style="color: #9b59b6;">${address.substring(0, prefix.length)}</strong>${address.substring(prefix.length, address.length - suffix.length)}<strong style="color: #9b59b6;">${address.substring(address.length - suffix.length)}</strong>`;
    }

    return address;
}

function addToInvestigation(address, chain) {
    // Add the address to the current investigation
    alert(`Address ${address} would be added to your investigation.\n\nThis feature will integrate with the main B.A.T.S. investigation workflow.`);
    // In production, this would add the address to the victims or traces
}

function searchEntityAddresses(entityName) {
    // Close current modal and search for all addresses belonging to this entity
    console.log('Searching for addresses belonging to entity:', entityName);

    // You could enhance this to:
    // 1. Search Arkham for all addresses with this entity
    // 2. Filter by chain
    // 3. Show results in the same modal

    alert(`This would search for all addresses belonging to:\n${entityName}\n\nThis feature can help identify all wallets controlled by the same entity.`);
}

function showAddressFinderError(message) {
    const errorDiv = document.getElementById('addressFinderError');
    errorDiv.textContent = message;
    errorDiv.style.display = 'block';
}

// Helper functions for generating random characters
function generateRandomChars(length) {
    const chars = 'ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz123456789';
    let result = '';
    for (let i = 0; i < length; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return result;
}

function generateRandomHex(length) {
    const chars = '0123456789abcdef';
    let result = '';
    for (let i = 0; i < length; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return result;
}

function generateRandomBase58(length) {
    const chars = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz';
    let result = '';
    for (let i = 0; i < length; i++) {
        result += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return result;
}

// Attribution API Integration (Arkham & Etherscan)
let currentAttributionData = null;
let pendingAttributionForEntry = null;

// Check Etherscan for attribution/labels
async function checkEtherscanAttribution(address) {
    // Only check Ethereum addresses
    if (!address || !address.startsWith('0x') || address.length !== 42) {
        return null;
    }
    
    try {
        const apiKey = localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8';
        const corsEnabled = localStorage.getItem('bats_cors_proxy_enabled') === 'true';
        const corsProxyUrl = localStorage.getItem('bats_cors_proxy_url') || 'https://cors-anywhere.herokuapp.com/';
        
        // Use Etherscan's address info endpoint
        let url = `https://api.etherscan.io/v2/api?chainid=1&module=account&action=addressinfo&address=${address}&apikey=${apiKey}`;
        if (corsEnabled) {
            url = corsProxyUrl + url;
        }
        
        const response = await fetch(url);
        if (!response.ok) return null;
        
        const data = await response.json();
        
        if (data.status === '1' && data.result) {
            const result = data.result;
            
            // Check if there's a public name tag or label
            if (result.publicTag || result.publicName || (result.labels && result.labels.length > 0)) {
                const attribution = {
                    chain: 'ethereum',
                    source: 'Etherscan',
                    entity: {
                        name: result.publicName || result.publicTag || (result.labels && result.labels[0]) || 'Unknown',
                        type: result.contractCreator ? 'Contract' : 'Address',
                        service: result.publicTag || null,
                        description: result.publicNote || null,
                        website: result.website || null
                    },
                    address: address
                };
                
                return [attribution];
            }
        }
        
        return null;
    } catch (error) {
        console.error('Error checking Etherscan attribution:', error);
        return null;
    }
}

// Combined attribution check (Arkham + Etherscan)
async function checkAllAttributions(address) {
    if (!address || address.trim() === '') return null;
    
    const attributions = [];
    
    // Check both sources in parallel
    const [arkhamData, etherscanData] = await Promise.all([
        checkArkhamAttribution(address),
        checkEtherscanAttribution(address)
    ]);
    
    if (arkhamData) {
        attributions.push(...arkhamData);
    }
    
    if (etherscanData) {
        attributions.push(...etherscanData);
    }
    
    return attributions.length > 0 ? attributions : null;
}

async function checkArkhamAttribution(address) {
    // Use embedded API key or user override
    const apiKey = localStorage.getItem('bats_arkham_api_key') || 'd377a526-c9ea-4cb6-a647-775559583ff6';
    const autoCheck = localStorage.getItem('bats_arkham_auto_check') !== 'false';
    
    if (!autoCheck) {
        return null;
    }
    
    // Validate it's a valid address format (basic check)
    if (!address || address.length < 26) {
        return null;
    }
    
    try {
        // Check if we need CORS proxy
        const corsEnabled = localStorage.getItem('bats_cors_proxy_enabled') === 'true';
        const corsProxyUrl = localStorage.getItem('bats_cors_proxy_url') || 'https://cors-anywhere.herokuapp.com/';
        
        let url = `https://api.arkhamintelligence.com/intelligence/address/${address}/all`;
        if (corsEnabled) {
            url = corsProxyUrl + url;
        }
        
        const response = await fetch(url, {
            method: 'GET',
            headers: {
                'API-Key': apiKey,
                'Accept': 'application/json'
            }
        });
        
        if (!response.ok) {
            if (response.status === 401) {
                console.error('Arkham API: Invalid API key');
            } else if (response.status === 429) {
                console.error('Arkham API: Rate limit exceeded');
            }
            return null;
        }
        
        const data = await response.json();
        
        // Check if there's attribution data
        if (data && Object.keys(data).length > 0) {
            // Process the response to find entities
            const attributions = [];
            
            for (const [chain, addressData] of Object.entries(data)) {
                if (addressData && addressData.arkhamEntity) {
                    attributions.push({
                        chain: chain,
                        source: 'Arkham',
                        entity: addressData.arkhamEntity,
                        address: address
                    });
                }
            }
            
            if (attributions.length > 0) {
                return attributions;
            }
        }
        
        return null;
    } catch (error) {
        console.error('Error checking Arkham attribution:', error);
        return null;
    }
}

function showAttributionModal(attributions, hopNumber, entryId) {
    if (!attributions || attributions.length === 0) return;
    
    // Store for later use
    currentAttributionData = attributions;
    pendingAttributionForEntry = { hopNumber, entryId };
    
    // Build the content
    let content = '<div style="background: #e6f3ff; border: 2px solid #0066cc; border-radius: 8px; padding: 15px; margin-bottom: 20px;">';
    content += '<h4 style="color: #0066cc; margin-bottom: 10px;">Attribution Information Found!</h4>';
    
    attributions.forEach(attr => {
        const entity = attr.entity;
        const sourceColor = attr.source === 'Etherscan' ? '#627eea' : '#0066cc';
        const sourceEmoji = attr.source === 'Etherscan' ? '🔷' : '🔍';
        
        content += `
            <div style="margin: 15px 0; padding: 15px; background: white; border-radius: 6px; border: 1px solid ${sourceColor}20;">
                <div style="display: flex; align-items: start; gap: 15px;">
                    <div style="flex: 1;">
                        <div style="display: flex; align-items: center; gap: 10px; margin-bottom: 10px;">
                            <h5 style="color: #2c3e50; margin: 0; font-size: 18px;">
                                ${entity.name || 'Unknown Entity'}
                            </h5>
                            <span style="background: ${sourceColor}; color: white; padding: 2px 8px; border-radius: 4px; font-size: 11px; font-weight: bold;">
                                ${sourceEmoji} ${attr.source || 'Arkham'}
                            </span>
                        </div>
                        ${entity.type ? `<div style="color: #666; margin-bottom: 5px;"><strong>Type:</strong> ${entity.type}</div>` : ''}
                        ${entity.service ? `<div style="color: #666; margin-bottom: 5px;"><strong>Service:</strong> ${entity.service}</div>` : ''}
                        <div style="color: #666; margin-bottom: 5px;"><strong>Chain:</strong> ${attr.chain}</div>
                        <div style="color: #666; margin-bottom: 5px; font-family: monospace; font-size: 12px;">
                            <strong>Address:</strong> ${attr.address}
                        </div>
                        ${entity.description ? `<div style="color: #666; margin-top: 10px; font-style: italic;">${entity.description}</div>` : ''}
                    </div>
                </div>
                ${entity.website || entity.twitter ? `
                    <div style="margin-top: 10px; padding-top: 10px; border-top: 1px solid #e8f0fe;">
                        ${entity.website ? `<a href="${entity.website}" target="_blank" style="color: #3498db; margin-right: 15px;">🌐 Website</a>` : ''}
                        ${entity.twitter ? `<a href="https://twitter.com/${entity.twitter}" target="_blank" style="color: #3498db;">🐦 Twitter</a>` : ''}
                    </div>
                ` : ''}
            </div>
        `;
    });
    
    content += '</div>';
    content += '<p style="color: #666; font-size: 14px;">Would you like to apply this attribution information to the wallet entry?</p>';
    
    document.getElementById('attributionContent').innerHTML = content;
    showModal('attributionModal');
}

function applyAttribution() {
    if (!currentAttributionData || !pendingAttributionForEntry) return;
    
    const { hopNumber, entryId } = pendingAttributionForEntry;
    
    // Combine all attribution sources into notes
    let attributionNotes = [];
    currentAttributionData.forEach(attr => {
        const entity = attr.entity;
        const source = attr.source || 'Arkham';
        attributionNotes.push(`[${source}] Entity: ${entity.name}${entity.type ? ` (${entity.type})` : ''}${entity.service ? ` - ${entity.service}` : ''}`);
    });
    
    const attributionNote = attributionNotes.join('\n');
    
    // Find the entry and add notes about the attribution
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    if (hop) {
        const entry = hop.entries.find(e => e.id === entryId);
        if (entry) {
            if (entry.notes) {
                entry.notes = attributionNote + '\n' + entry.notes;
            } else {
                entry.notes = attributionNote;
            }
            
            // Update the notes field if it exists
            const notesField = document.querySelector(`textarea[onchange*="updateHopEntry(${hopNumber}, ${entryId}, 'notes'"]`);
            if (notesField) {
                notesField.value = entry.notes;
            }
            
            saveToStorage();
        }
    }
    
    hideModal('attributionModal');
    currentAttributionData = null;
    pendingAttributionForEntry = null;
}

// Wallet Address Autocomplete Functions
let autocompleteTimeout = null;
let currentAutocompleteRequest = null;

function detectBlockchainFromAddress(address) {
    if (!address || address.length < 3) return null;
    
    // Check each blockchain's address pattern
    for (const [chain, config] of Object.entries(blockchainAPIs)) {
        // First check prefixes for quick detection
        if (config.addressPrefixes) {
            for (const prefix of config.addressPrefixes) {
                if (address.startsWith(prefix)) {
                    // For longer prefixes like 'bc1', check if we have enough characters
                    if (prefix.length > 1 && address.length < 10) continue;
                    return chain;
                }
            }
        }
    }
    return null;
}

async function handleWalletAutocomplete(input, hopNumber, entryId) {
    const value = input.value.trim();
    const dropdown = document.getElementById(`autocomplete_${hopNumber}_${entryId}`);
    
    // Clear any pending timeout
    if (autocompleteTimeout) {
        clearTimeout(autocompleteTimeout);
    }
    
    // Hide dropdown if input is too short
    if (value.length < 9) {
        dropdown.style.display = 'none';
        return;
    }
    
    // First check if it matches any existing wallet in UWI
    const existingMatches = (investigation.universalWalletIndex || [])
        .filter(wallet => wallet.address.toLowerCase().startsWith(value.toLowerCase()))
        .slice(0, 5); // Limit to 5 matches
    
    if (existingMatches.length > 0) {
        // Show existing matches immediately
        showAutocompleteResults(dropdown, existingMatches.map(wallet => ({
            address: wallet.address,
            type: 'existing',
            walletInfo: wallet
        })), hopNumber, entryId);
        return;
    }
    
    // Detect blockchain type
    const detectedChain = detectBlockchainFromAddress(value);
    if (!detectedChain) {
        dropdown.style.display = 'none';
        return;
    }
    
    // Show loading state
    dropdown.innerHTML = '<div class="wallet-autocomplete-loading">Searching blockchain...</div>';
    dropdown.style.display = 'block';
    
    // Debounce API calls
    autocompleteTimeout = setTimeout(async () => {
        try {
            const suggestions = await fetchAddressSuggestions(value, detectedChain);
            if (suggestions && suggestions.length > 0) {
                showAutocompleteResults(dropdown, suggestions, hopNumber, entryId);
            } else {
                dropdown.innerHTML = `<div class="wallet-autocomplete-loading">No addresses found starting with "${value}"</div>`;
                setTimeout(() => { dropdown.style.display = 'none'; }, 2000);
            }
        } catch (error) {
            console.error('Autocomplete error:', error);
            dropdown.style.display = 'none';
        }
    }, 300); // 300ms debounce
}

async function fetchAddressSuggestions(partialAddress, blockchain) {
    const config = blockchainAPIs[blockchain];
    if (!config) return [];
    
    try {
        // For now, we'll validate the address format
        // In a real implementation, you'd query blockchain explorers for similar addresses
        // Most blockchains don't offer address autocomplete APIs, so we'll provide format validation
        
        const suggestions = [];
        
        // Check if the partial address could be valid when completed
        if (blockchain === 'bitcoin') {
            // Bitcoin addresses are 26-34 chars for P2PKH/P2SH, 42-62 for Bech32
            if (partialAddress.startsWith('1') || partialAddress.startsWith('3')) {
                // Legacy/SegWit addresses
                if (partialAddress.length >= 26) {
                    suggestions.push({
                        address: partialAddress,
                        type: 'valid',
                        blockchain: 'Bitcoin',
                        note: 'Valid Bitcoin address format'
                    });
                } else {
                    suggestions.push({
                        address: partialAddress + '...',
                        type: 'partial',
                        blockchain: 'Bitcoin',
                        note: `Need ${26 - partialAddress.length} more characters (min 26)`
                    });
                }
            } else if (partialAddress.startsWith('bc1')) {
                // Bech32 addresses
                if (partialAddress.length >= 42) {
                    suggestions.push({
                        address: partialAddress,
                        type: 'valid',
                        blockchain: 'Bitcoin',
                        note: 'Valid Bitcoin Bech32 address format'
                    });
                } else {
                    suggestions.push({
                        address: partialAddress + '...',
                        type: 'partial',
                        blockchain: 'Bitcoin',
                        note: `Need ${42 - partialAddress.length} more characters (min 42)`
                    });
                }
            }
        } else if (blockchain === 'ethereum') {
            // Ethereum addresses are exactly 42 chars (including 0x)
            if (partialAddress.length === 42) {
                suggestions.push({
                    address: partialAddress,
                    type: 'valid',
                    blockchain: 'Ethereum',
                    note: 'Valid Ethereum address format'
                });
            } else if (partialAddress.length < 42) {
                suggestions.push({
                    address: partialAddress + '...',
                    type: 'partial',
                    blockchain: 'Ethereum',
                    note: `Need ${42 - partialAddress.length} more characters (exactly 42)`
                });
            }
        } else if (blockchain === 'tron') {
            // Tron addresses are exactly 34 chars
            if (partialAddress.length === 34) {
                suggestions.push({
                    address: partialAddress,
                    type: 'valid',
                    blockchain: 'Tron',
                    note: 'Valid Tron address format'
                });
            } else if (partialAddress.length < 34) {
                suggestions.push({
                    address: partialAddress + '...',
                    type: 'partial',
                    blockchain: 'Tron',
                    note: `Need ${34 - partialAddress.length} more characters (exactly 34)`
                });
            }
        } else if (blockchain === 'solana') {
            // Solana addresses are 32-44 chars
            if (partialAddress.length >= 32 && partialAddress.length <= 44) {
                suggestions.push({
                    address: partialAddress,
                    type: 'valid',
                    blockchain: 'Solana',
                    note: 'Valid Solana address format'
                });
            } else if (partialAddress.length < 32) {
                suggestions.push({
                    address: partialAddress + '...',
                    type: 'partial',
                    blockchain: 'Solana',
                    note: `Need ${32 - partialAddress.length} more characters (min 32)`
                });
            }
        }
        
        return suggestions;
    } catch (error) {
        console.error('Error fetching address suggestions:', error);
        return [];
    }
}

function showAutocompleteResults(dropdown, results, hopNumber, entryId) {
    dropdown.innerHTML = '';
    dropdown.style.display = 'block';
    
    results.forEach((result, index) => {
        const item = document.createElement('div');
        item.className = 'wallet-autocomplete-item';
        
        if (result.type === 'existing') {
            // Existing wallet from UWI
            item.innerHTML = `
                <div>${result.address}</div>
                <div class="wallet-autocomplete-blockchain">
                    ${result.walletInfo.permanentId} - ${walletTypes[result.walletInfo.permanentType] || result.walletInfo.permanentType}
                </div>
            `;
            item.onclick = () => selectAutocompleteAddress(result.address, hopNumber, entryId);
        } else {
            // Blockchain validation result
            const statusColor = result.type === 'valid' ? '#27ae60' : '#e67e22';
            item.innerHTML = `
                <div style="color: ${statusColor};">${result.address}</div>
                <div class="wallet-autocomplete-blockchain">${result.blockchain} - ${result.note}</div>
            `;
            if (result.type === 'valid') {
                item.onclick = () => selectAutocompleteAddress(result.address, hopNumber, entryId);
            }
        }
        
        dropdown.appendChild(item);
    });
}

function selectAutocompleteAddress(address, hopNumber, entryId) {
    const input = document.getElementById(`toWallet_${hopNumber}_${entryId}`);
    const dropdown = document.getElementById(`autocomplete_${hopNumber}_${entryId}`);
    
    input.value = address;
    dropdown.style.display = 'none';
    
    // Trigger the change event
    updateHopEntry(hopNumber, entryId, 'toWallet', address);
}

// Close autocomplete when clicking outside
document.addEventListener('click', function(event) {
    if (!event.target.matches('input[id^="toWallet_"]')) {
        document.querySelectorAll('.wallet-autocomplete-dropdown').forEach(dropdown => {
            dropdown.style.display = 'none';
        });
    }
});

// Bulk Transaction Modal Functions
function openBulkTransactionModal(victimId) {
    currentBulkVictimId = victimId;
    document.getElementById('bulkTransactionHashes').value = '';
    document.getElementById('bulkProcessingStatus').style.display = 'none';
    document.getElementById('bulkProcessingResults').style.display = 'none';
    document.getElementById('bulkProcessBtn').disabled = false;
    showModal('bulkTransactionModal');
}

function closeBulkTransactionModal() {
    hideModal('bulkTransactionModal');
    currentBulkVictimId = null;
    // Re-render to show the new transactions with correct V-T notation
    renderVictims();
}

async function processBulkTransactions() {
    const hashesText = document.getElementById('bulkTransactionHashes').value.trim();
    if (!hashesText) {
        alert('Please paste transaction hashes first');
        return;
    }
    
    // Parse hashes (one per line)
    const hashes = hashesText.split('\n')
        .map(h => h.trim())
        .filter(h => h.length > 0);
    
    if (hashes.length === 0) {
        alert('No valid transaction hashes found');
        return;
    }
    
    // Disable button and show progress
    document.getElementById('bulkProcessBtn').disabled = true;
    document.getElementById('bulkProcessingStatus').style.display = 'block';
    document.getElementById('bulkProcessingResults').style.display = 'none';
    
    const victim = investigation.victims.find(v => v.id === currentBulkVictimId);
    const results = [];
    const tempTransactions = [];
    
    // Process each hash
    for (let i = 0; i < hashes.length; i++) {
        const hash = hashes[i];
        const progress = ((i + 1) / hashes.length) * 100;
        
        // Update progress
        document.getElementById('bulkProgressFill').style.width = progress + '%';
        document.getElementById('bulkProgressText').textContent = `Processing ${i + 1} of ${hashes.length}...`;
        
        try {
            // Detect blockchain
            const detectedChain = detectBlockchainFromHash(hash);
            if (!detectedChain) {
                results.push({ hash, status: 'error', message: 'Unknown blockchain format' });
                continue;
            }

            console.log(`Processing hash ${i + 1}/${hashes.length}: ${hash} on ${detectedChain}`);

            // Use fetchTransactionData with proper parsing
            const txData = await fetchTransactionData(hash, detectedChain);

            console.log(`Transaction data received for ${hash}:`, txData);

            if (txData) {
                // Handle multiple transfers (token transactions)
                if (txData.multipleTransfers && txData.transfers && txData.transfers.length > 0) {
                    console.log(`Transaction ${hash} has ${txData.transfers.length} transfers`);

                    // For bulk upload, if only one transfer, auto-select it
                    // If multiple, take the first one and note it needs review
                    if (txData.transfers.length === 1) {
                        const transfer = txData.transfers[0];
                        const transaction = {
                            id: 0, // Will be reassigned after sorting
                            txHash: hash,
                            amount: transfer.amount.toString(),
                            currency: transfer.currency || 'Unknown',
                            customCurrency: '',
                            receivingWallet: transfer.to,
                            datetime: txData.time ? new Date(txData.time).toISOString().slice(0, 16) : new Date().toISOString().slice(0, 16),
                            timezone: 'UTC',
                            notes: `From: ${transfer.from}`
                        };

                        tempTransactions.push(transaction);
                        results.push({
                            hash,
                            status: 'success',
                            message: `${transfer.amount} ${transfer.currency} to ${transfer.to.substring(0, 20)}...`,
                            timestamp: txData.time
                        });
                    } else {
                        // Multiple transfers - store for batch selection later
                        results.push({
                            hash,
                            status: 'pending',
                            message: `${txData.transfers.length} transfers - requires selection`,
                            timestamp: txData.time,
                            transfers: txData.transfers,
                            from: txData.from
                        });
                    }
                } else {
                    // Single transfer or ETH transaction
                    const transaction = {
                        id: 0, // Will be reassigned after sorting
                        txHash: hash,
                        amount: (txData.amount || 0).toString(),
                        currency: txData.currency || 'ETH',
                        customCurrency: '',
                        receivingWallet: txData.to || '',
                        datetime: txData.time ? new Date(txData.time).toISOString().slice(0, 16) : new Date().toISOString().slice(0, 16),
                        timezone: 'UTC',
                        notes: txData.from ? `From: ${txData.from}` : ''
                    };

                    tempTransactions.push(transaction);
                    results.push({
                        hash,
                        status: 'success',
                        message: `${txData.amount || 0} ${txData.currency || 'ETH'} to ${(txData.to || '').substring(0, 20)}...`,
                        timestamp: txData.time
                    });
                }
            } else {
                results.push({ hash, status: 'error', message: 'Failed to parse transaction data' });
            }
            
        } catch (error) {
            results.push({ hash, status: 'error', message: error.message });
        }
        
        // Small delay to avoid rate limiting
        await new Promise(resolve => setTimeout(resolve, 500));
    }
    
    // Check if we have any pending multi-transfer transactions
    const pendingMultiTransfers = results.filter(r => r.status === 'pending');

    if (pendingMultiTransfers.length > 0) {
        // Show bulk transfer selection modal
        document.getElementById('bulkProgressText').textContent = 'Select transfers for multi-output transactions...';

        const selectedTransfers = await showBulkTransferSelectionModal(pendingMultiTransfers);

        // Process selected transfers
        selectedTransfers.forEach(selection => {
            const transaction = {
                id: 0,
                txHash: selection.hash,
                amount: selection.transfer.amount.toString(),
                currency: selection.transfer.currency || 'Unknown',
                customCurrency: '',
                receivingWallet: selection.transfer.to,
                datetime: selection.timestamp ? new Date(selection.timestamp).toISOString().slice(0, 16) : new Date().toISOString().slice(0, 16),
                timezone: 'UTC',
                notes: `From: ${selection.transfer.from}`
            };
            tempTransactions.push(transaction);

            // Update result status
            const resultIndex = results.findIndex(r => r.hash === selection.hash);
            if (resultIndex !== -1) {
                results[resultIndex].status = 'success';
                results[resultIndex].message = `${selection.transfer.amount} ${selection.transfer.currency} to ${selection.transfer.to.substring(0, 20)}...`;
            }
        });
    }

    // Add all successful transactions to the victim
    tempTransactions.forEach(tx => {
        victim.transactions.push(tx);
    });

    // Show results
    document.getElementById('bulkProgressText').textContent = 'Complete! Sorting transactions chronologically...';
    showBulkResults(results);
    
    // Save and re-render (which will sort chronologically)
    saveToStorage();
    
    // Give user time to see results before closing
    setTimeout(() => {
        alert(` Processed ${hashes.length} transaction hashes!\n\n${results.filter(r => r.status === 'success').length} successful\n${results.filter(r => r.status === 'error').length} failed\n\nTransactions have been sorted chronologically and V-T notation has been updated.`);
        closeBulkTransactionModal();
    }, 2000);
}

function showBulkResults(results) {
    const resultsList = document.getElementById('bulkResultsList');
    resultsList.innerHTML = results.map(result => {
        const icon = result.status === 'success' ? '✅' :
                     result.status === 'warning' ? '⚠️' :
                     result.status === 'pending' ? '⏳' : '❌';
        const color = result.status === 'success' ? '#27ae60' :
                      result.status === 'warning' ? '#ff9800' :
                      result.status === 'pending' ? '#2196f3' : '#dc3545';
        return `
            <div style="padding: 8px; border-bottom: 1px solid #e0e0e0;">
                <span style="color: ${color};">${icon}</span>
                <span style="font-family: monospace; font-size: 12px;">${result.hash.substring(0, 20)}...</span>
                <span style="color: #666; margin-left: 10px;">${result.message}</span>
            </div>
        `;
    }).join('');

    document.getElementById('bulkProcessingResults').style.display = 'block';
}

// New function to handle bulk transfer selection
async function showBulkTransferSelectionModal(pendingTransfers) {
    return new Promise(resolve => {
        const selectedTransfers = [];
        let currentIndex = 0;

        // Create modal HTML if it doesn't exist
        let modal = document.getElementById('bulkTransferSelectionModal');
        if (!modal) {
            modal = document.createElement('div');
            modal.id = 'bulkTransferSelectionModal';
            modal.className = 'modal';
            modal.style.cssText = 'display: none; position: fixed; z-index: 10000; left: 0; top: 0; width: 100%; height: 100%; background-color: rgba(0,0,0,0.5);';
            modal.innerHTML = `
                <div class="modal-content" style="background: white; margin: 5% auto; padding: 20px; width: 90%; max-width: 800px; max-height: 80vh; overflow-y: auto; border-radius: 8px;">
                    <h2>Select Transfers for Multi-Output Transactions</h2>
                    <p id="bulkTransferProgress" style="color: #666; margin: 10px 0;"></p>
                    <div id="bulkTransfersList" style="margin: 20px 0;"></div>
                    <div style="display: flex; gap: 10px; justify-content: center; margin-top: 20px;">
                        <button id="bulkTransferSkip" class="btn btn-secondary" style="padding: 10px 20px; background: #6c757d; color: white; border: none; border-radius: 4px; cursor: pointer;">Skip This Transaction</button>
                        <button id="bulkTransferNext" class="btn btn-primary" style="padding: 10px 20px; background: #007bff; color: white; border: none; border-radius: 4px; cursor: pointer;">Confirm Selection</button>
                    </div>
                </div>
            `;
            document.body.appendChild(modal);
        }

        function showNextTransaction() {
            if (currentIndex >= pendingTransfers.length) {
                // All done
                modal.style.display = 'none';
                resolve(selectedTransfers);
                return;
            }

            const tx = pendingTransfers[currentIndex];
            document.getElementById('bulkTransferProgress').textContent =
                `Transaction ${currentIndex + 1} of ${pendingTransfers.length} - ${tx.hash.substring(0, 20)}...`;

            const transfersList = document.getElementById('bulkTransfersList');
            transfersList.innerHTML = '<h3>Select transfers to include:</h3>';

            // Add "Select All" checkbox
            const selectAllDiv = document.createElement('div');
            selectAllDiv.style.cssText = 'margin: 10px 0; padding: 10px; background: #f5f5f5; border-radius: 4px;';
            selectAllDiv.innerHTML = `
                <label style="font-weight: bold; cursor: pointer;">
                    <input type="checkbox" id="bulkSelectAll" checked> Select All
                </label>
            `;
            transfersList.appendChild(selectAllDiv);

            // Add transfer options
            tx.transfers.forEach((transfer, index) => {
                const div = document.createElement('div');
                div.style.cssText = 'padding: 10px; margin: 10px 0; border: 1px solid #ddd; border-radius: 4px;';
                div.innerHTML = `
                    <label style="display: flex; align-items: center; cursor: pointer;">
                        <input type="checkbox" value="${index}" style="margin-right: 10px;" checked>
                        <div style="flex: 1;">
                            <div><strong>${transfer.amount} ${transfer.currency}</strong></div>
                            <div style="font-size: 12px; color: #666;">To: ${transfer.to}</div>
                            <div style="font-size: 12px; color: #666;">From: ${transfer.from}</div>
                        </div>
                    </label>
                `;
                transfersList.appendChild(div);
            });

            document.getElementById('bulkSelectAll').onchange = function(e) {
                const checkboxes = transfersList.querySelectorAll('input[type="checkbox"]:not(#bulkSelectAll)');
                checkboxes.forEach(cb => cb.checked = e.target.checked);
            };
        }

        document.getElementById('bulkTransferNext').onclick = function() {
            const tx = pendingTransfers[currentIndex];
            const checkboxes = document.getElementById('bulkTransfersList').querySelectorAll('input[type="checkbox"]:not(#bulkSelectAll):checked');

            checkboxes.forEach(cb => {
                const index = parseInt(cb.value);
                selectedTransfers.push({
                    hash: tx.hash,
                    transfer: tx.transfers[index],
                    timestamp: tx.timestamp
                });
            });

            currentIndex++;
            showNextTransaction();
        };

        document.getElementById('bulkTransferSkip').onclick = function() {
            currentIndex++;
            showNextTransaction();
        };

        // Show modal and start with first transaction
        modal.style.display = 'block';
        showNextTransaction();
    });
}

async function fetchTransactionData(hash, blockchain) {
    const config = blockchainAPIs[blockchain];
    // Disable CORS proxy to avoid CSP issues - APIs should handle CORS natively
    const corsEnabled = false;
    const corsProxyUrl = '';

    // Try primary and fallback URLs
    const urlsToTry = [config.apiUrl, ...(config.fallbackUrls || [])];

    for (let apiUrl of urlsToTry) {
        try {
            // Add a small delay to prevent extension interference
            await new Promise(resolve => setTimeout(resolve, 100));
            let data;
            let url;
            let tokenData = null; // Define tokenData at this scope
            
            if (blockchain === 'bitcoin') {
                url = apiUrl + hash;
                if (config.apiKey) url += `?api_key=${config.apiKey}`;
                if (corsEnabled) url = corsProxyUrl + url;

                const response = await fetch(url).catch(err => {
                    console.warn(`Bitcoin fetch failed for ${url}:`, err);
                    return null;
                });
                if (!response || !response.ok) continue;
                data = await response.json();
                
            } else if (['ethereum', 'base', 'arbitrum', 'optimism', 'polygon', 'bsc'].includes(blockchain)) {
                // Handle all EVM chains
                const apiKey = localStorage.getItem('bats_etherscan_api_key') || config.apiKey || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8';

                // First get the basic transaction
                url = `${apiUrl}${hash}&apikey=${apiKey}`;
                if (corsEnabled) url = corsProxyUrl + url;

                const response = await fetch(url).catch(err => {
                    console.warn(`${blockchain} fetch failed for ${url}:`, err);
                    return null;
                });
                if (!response || !response.ok) continue;
                data = await response.json();
                if (!data.result || data.result === null) continue;

                // Also check for token transfers
                tokenData = null; // Use the outer scope tokenData, don't redeclare
                try {
                    const tokenUrl = corsEnabled ?
                        corsProxyUrl + `${config.tokenApiUrl}${hash}&apikey=${apiKey}` :
                        `${config.tokenApiUrl}${hash}&apikey=${apiKey}`;

                    const tokenResponse = await fetch(tokenUrl).catch(err => {
                        console.warn(`Token fetch failed:`, err);
                        return null;
                    });
                    if (tokenResponse && tokenResponse.ok) {
                        tokenData = await tokenResponse.json();
                        console.log('Receipt/Token data received:', tokenData);

                        // Check if Etherscan returned an error
                        if (tokenData && tokenData.status === '0' && tokenData.message === 'NOTOK') {
                            console.error('Etherscan API error:', tokenData.result);
                            throw new Error(tokenData.result);
                        }
                    }
                } catch (err) {
                    console.log('No token transfers found');
                }

            } else if (blockchain === 'tron') {
                url = apiUrl + hash;
                const headers = config.apiKey ? { 'TRON-PRO-API-KEY': config.apiKey } : {};
                if (corsEnabled) url = corsProxyUrl + url;
                
                const response = await fetch(url, { headers });
                if (!response.ok) continue;
                data = await response.json();
                
            } else if (blockchain === 'solana') {
                url = apiUrl;
                if (corsEnabled) url = corsProxyUrl + url;
                
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        jsonrpc: '2.0',
                        id: 1,
                        method: 'getTransaction',
                        params: [hash, { encoding: 'json', maxSupportedTransactionVersion: 0 }]
                    })
                });
                if (!response.ok) continue;
                data = await response.json();
                if (data.error) continue;
            }
            
            // Parse and return the data (pass tokenData for all EVM chains)
            const evmChains = ['ethereum', 'base', 'arbitrum', 'optimism', 'polygon', 'bsc'];
            const txData = evmChains.includes(blockchain) ?
                config.parseResponse(data, tokenData, null, config) :
                config.parseResponse(data);
            if (txData) {
                txData.blockchain = config.name;
                return txData;
            }
            
        } catch (error) {
            console.error(`Failed with ${apiUrl}:`, error);
            // Continue to next URL
        }
    }
    
    return null;
}

// Individual blockchain lookup functions for hop transactions
async function lookupEthereumTransaction(txHash, chainName = null) {
    // If no chain specified, detect it or default to ethereum
    if (!chainName) {
        chainName = detectBlockchainFromHash(txHash) || 'ethereum';
    }
    // Use global blockchainAPIs
    const config = window.blockchainAPIs[chainName] || window.blockchainAPIs.ethereum;
    if (!config) {
        throw new Error(`Configuration not found for chain: ${chainName}`);
    }
    // Disable CORS proxy to avoid CSP issues - APIs should handle CORS natively
    const corsEnabled = false;
    const corsProxyUrl = '';
    const apiKey = config.apiKey || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8';
    
    // Build array of URLs to try (primary + fallbacks)
    const urlsToTry = [config.apiUrl, ...(config.fallbackUrls || [])];
    
    for (let apiUrl of urlsToTry) {
        try {
            // First get the basic transaction
            let url = `${apiUrl}${txHash}&apikey=${apiKey}`;
            if (corsEnabled) url = corsProxyUrl + url;

            // Use shorter timeout for each attempt
            const response = await fetchWithTimeout(url,
                apiUrl.includes('alchemy') ? {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        jsonrpc: '2.0',
                        method: 'eth_getTransactionByHash',
                        params: [txHash],
                        id: 1
                    })
                } : {},
                8000, 1);

            if (!response.ok) {
                throw new Error(`HTTP ${response.status}`);
            }

            const data = await response.json();

            // Check if we got valid data
            if (!data || (!data.result && !data.hash && !data.txhash)) {
                throw new Error('Invalid response format');
            }
            
            // Also check for token transfers
            let tokenData = null;
            try {
                const tokenUrl = corsEnabled ? 
                    corsProxyUrl + `${config.tokenApiUrl}${txHash}&apikey=${apiKey}` :
                    `${config.tokenApiUrl}${txHash}&apikey=${apiKey}`;
                
                const tokenResponse = await fetchWithTimeout(tokenUrl);
                tokenData = await tokenResponse.json();
            } catch (err) {
                console.log('No token transfers found');
            }
            
            // Get block timestamp
            let blockTimestamp = null;
            if (data.result && data.result.blockNumber) {
                try {
                    const blockUrl = corsEnabled ?
                        corsProxyUrl + `${config.blockApiUrl}${data.result.blockNumber}&boolean=true&apikey=${apiKey}` :
                        `${config.blockApiUrl}${data.result.blockNumber}&boolean=true&apikey=${apiKey}`;
                    
                    const blockResponse = await fetch(blockUrl);
                    if (blockResponse.ok) {
                        const blockData = await blockResponse.json();
                        if (blockData && blockData.result && blockData.result.timestamp) {
                            blockTimestamp = parseInt(blockData.result.timestamp, 16) * 1000;
                            console.log('Got block timestamp:', new Date(blockTimestamp).toISOString());
                        }
                    }
                } catch (err) {
                    console.log('Failed to fetch block timestamp:', err);
                }
            }
            
            // Parse the response with blockTimestamp
            const txData = config.parseResponse(data, tokenData, blockTimestamp, config);
            if (txData) {
                txData.blockchain = config.name;
                txData.rawHash = txHash;

                // Check if destination is an exchange/VASP
                if (txData.to) {
                    // Pass the chainId for proper multi-chain attribution
                    const chainId = config.chainId || 1;
                    const attribution = await getWalletAttribution(txData.to, chainId);
                    if (attribution) {
                        txData.toWalletAttribution = attribution;
                        txData.isTerminalWallet = true;
                        console.log(`🟣 Terminal wallet detected on chain ${chainId}: ${attribution.name}`);
                    }
                }

                return txData;
            }
        } catch (error) {
            console.error(`Failed with ${apiUrl}:`, error);
        }
    }

    throw new Error('Failed to fetch Ethereum transaction');
}


async function lookupBitcoinTransaction(txHash) {
    const config = window.blockchainAPIs.bitcoin;
    // Disable CORS proxy to avoid CSP issues - APIs should handle CORS natively
    const corsEnabled = false;
    const corsProxyUrl = '';
    
    const urlsToTry = [config.apiUrl, ...(config.fallbackUrls || [])];
    
    for (let apiUrl of urlsToTry) {
        try {
            let url = apiUrl + txHash;
            if (config.apiKey) {
                url += `?api_key=${config.apiKey}`;
            }
            if (corsEnabled) url = corsProxyUrl + url;
            
            const response = await fetch(url);
            if (!response.ok) continue;
            const data = await response.json();
            
            const txData = config.parseResponse(data);
            if (txData) {
                txData.blockchain = config.name;
                txData.rawHash = txHash;
                return txData;
            }
        } catch (error) {
            console.error(`Failed with ${apiUrl}:`, error);
        }
    }
    
    throw new Error('Failed to fetch Bitcoin transaction');
}

async function lookupTronTransaction(txHash) {
    const config = window.blockchainAPIs.tron;
    // Disable CORS proxy to avoid CSP issues - APIs should handle CORS natively
    const corsEnabled = false;
    const corsProxyUrl = '';
    
    const urlsToTry = [config.apiUrl, ...(config.fallbackUrls || [])];
    
    for (let apiUrl of urlsToTry) {
        try {
            let url = apiUrl + txHash;
            const headers = config.apiKey ? { 'TRON-PRO-API-KEY': config.apiKey } : {};
            
            if (corsEnabled) url = corsProxyUrl + url;
            
            const response = await fetch(url, { headers });
            if (!response.ok) continue;
            const data = await response.json();
            
            const txData = config.parseResponse(data);
            if (txData) {
                txData.blockchain = config.name;
                txData.rawHash = txHash;
                return txData;
            }
        } catch (error) {
            console.error(`Failed with ${apiUrl}:`, error);
        }
    }
    
    throw new Error('Failed to fetch Tron transaction');
}

async function lookupSolanaTransaction(txHash) {
    const config = window.blockchainAPIs.solana;

    // Check if we're on a deployed site (Netlify) or local development
    const isNetlifyDeployed = window.location.hostname.includes('batstool.com') ||
                             window.location.hostname.includes('netlify.app');

    // Try using our Netlify proxy first if on deployed site
    if (isNetlifyDeployed) {
        try {
            console.log('Attempting Solana lookup via Netlify proxy...');
            const response = await fetch('/.netlify/functions/solana-proxy', {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    jsonrpc: '2.0',
                    id: 1,
                    method: 'getTransaction',
                    params: [txHash, {
                        encoding: 'jsonParsed',
                        commitment: 'confirmed',
                        maxSupportedTransactionVersion: 0
                    }]
                })
            });

            if (response.ok) {
                const data = await response.json();
                if (!data.error && data.result) {
                    const txData = config.parseResponse(data);
                    if (txData) {
                        txData.blockchain = config.name;
                        txData.rawHash = txHash;
                        console.log('Successfully fetched Solana tx via proxy');
                        return txData;
                    }
                } else if (data.error) {
                    console.log('Solana RPC error:', data.error);
                    throw new Error(data.error.message || 'Transaction not found');
                }
            } else {
                console.log('Proxy response not ok:', response.status);
            }
        } catch (error) {
            console.log('Netlify proxy failed:', error);
            // Don't fallback to direct calls - they'll fail with CORS
            throw new Error(`Solana lookup failed: ${error.message}. Please check the transaction hash.`);
        }
    }

    // For local development, try direct API (will likely fail with CORS but worth trying)
    console.warn('Local development mode - Solana API calls may fail due to CORS');
    const urlsToTry = [config.apiUrl, ...(config.fallbackUrls || [])];

    for (let apiUrl of urlsToTry) {
        try {
            const response = await fetch(apiUrl, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    jsonrpc: '2.0',
                    id: 1,
                    method: 'getTransaction',
                    params: [txHash, {
                        encoding: 'jsonParsed',
                        commitment: 'confirmed',
                        maxSupportedTransactionVersion: 0
                    }]
                })
            });

            if (!response.ok) continue;
            const data = await response.json();
            if (data.error) {
                console.log(`Solana RPC error from ${apiUrl}:`, data.error);
                continue;
            }

            const txData = config.parseResponse(data);
            if (txData) {
                txData.blockchain = config.name;
                txData.rawHash = txHash;
                return txData;
            }
        } catch (error) {
            console.error(`Failed with ${apiUrl}:`, error);
        }
    }

    throw new Error('Failed to fetch Solana transaction');
}

// Victim Transaction Lookup Function
async function lookupHopTransaction(hopNumber, entryId) {
    const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
    const entry = hop?.entries.find(e => e.id === entryId);
    if (!hop || !entry) return;
    
    const txHash = document.getElementById(`txHash_${hopNumber}_${entryId}`)?.value?.trim();
    if (!txHash) {
        alert('Please enter a transaction hash');
        return;
    }
    
    const detectedChain = detectBlockchainFromHash(txHash);
    if (!detectedChain) {
        alert('Cannot determine blockchain from hash format');
        return;
    }
    
    // Show loading indicator
    const button = event.target;
    const originalText = button.textContent;
    button.textContent = '⏳ Looking up...';
    button.disabled = true;
    
    try {
        let txData = null;
        
        switch(detectedChain) {
            case 'ethereum':
                txData = await lookupEthereumTransaction(txHash);
                break;
            case 'bitcoin':
                txData = await lookupBitcoinTransaction(txHash);
                break;
            case 'tron':
                txData = await lookupTronTransaction(txHash);
                break;
            case 'solana':
                txData = await lookupSolanaTransaction(txHash);
                break;
            default:
                throw new Error('Unsupported blockchain');
        }
        
        if (txData) {
            // Handle multiple transfers case (batch transactions)
            if (txData.multipleTransfers) {
                // Show transfer selection modal
                showTransferSelectionForHop(hopNumber, entryId, txData.transfers);
                return;
            }
            
            // Auto-populate hop entry fields
            updateHopEntry(hopNumber, entryId, 'fromWallet', txData.from);
            updateHopEntry(hopNumber, entryId, 'toWallet', txData.to);
            updateHopEntry(hopNumber, entryId, 'amount', txData.amount); // Use 'amount' not 'value'
            updateHopEntry(hopNumber, entryId, 'currency', txData.currency);
            updateHopEntry(hopNumber, entryId, 'timestamp', formatDatetimeLocal(txData.time));
            
            // Update UI fields directly
            const amountField = document.getElementById(`amount_${hopNumber}_${entryId}`);
            if (amountField) amountField.value = txData.amount; // Use 'amount' not 'value'
            
            const currencySelect = document.querySelector(`[onchange*="updateHopEntry(${hopNumber}, ${entryId}, 'currency'"]`);
            if (currencySelect) {
                currencySelect.value = txData.currency;
                // Trigger currency change to update step
                updateHopEntry(hopNumber, entryId, 'currency', txData.currency);
            }
            
            const timestampField = document.getElementById(`timestamp_${hopNumber}_${entryId}`);
            if (timestampField) timestampField.value = formatDatetimeLocal(txData.time);
            
            const toWalletField = document.getElementById(`toWallet_${hopNumber}_${entryId}`);
            if (toWalletField) toWalletField.value = txData.to;
            
            // Update from wallet field if it exists
            const fromWalletField = document.querySelector(`input[onchange*="updateHopEntry(${hopNumber}, ${entryId}, 'fromWallet'"]`);
            if (fromWalletField) fromWalletField.value = txData.from;
            
            let alertMessage = ` Transaction data loaded:\n\nFrom: ${txData.from}\nTo: ${txData.to}\nAmount: ${txData.amount} ${txData.currency}\nTime: ${new Date(txData.time).toLocaleString()}`;
            
            // Add warning if timestamp is not from blockchain
            if (txData.hasRealTimestamp === false) {
                alertMessage += '\n\n⚠️ WARNING: Could not retrieve actual transaction timestamp from blockchain. Please manually verify and update the date/time field!';
            }
            
            alert(alertMessage);
        }
    } catch (error) {
        console.error('Lookup error:', error);
        alert(`ERROR:  Failed to lookup transaction: ${error.message}`);
    } finally {
        button.textContent = originalText;
        button.disabled = false;
    }
}

async function lookupRippleTransaction(txHash) {
    try {
        // Use XRPL public API
        const url = `https://api.xrpscan.com/api/v1/tx/${txHash}`;

        const response = await fetch(url);
        if (!response.ok) {
            // Try alternative API
            const altUrl = `https://data.ripple.com/v2/transactions/${txHash}`;
            const altResponse = await fetch(altUrl);

            if (!altResponse.ok) {
                throw new Error('Transaction not found on Ripple network');
            }

            const altData = await altResponse.json();
            if (altData.transaction) {
                const tx = altData.transaction;
                return {
                    hash: txHash,
                    blockchain: 'Ripple',
                    from: tx.Account || '',
                    to: tx.Destination || '',
                    amount: tx.Amount ? (parseInt(tx.Amount) / 1000000) : 0, // Convert drops to XRP
                    currency: 'XRP',
                    time: tx.date ? new Date(tx.date).getTime() : Date.now(),
                    fee: tx.Fee ? (parseInt(tx.Fee) / 1000000) : 0,
                    rawData: altData
                };
            }
        }

        const data = await response.json();

        // Parse XRPScan API response
        if (data) {
            // Extract payment details
            let amount = 0;
            let currency = 'XRP';
            let toAddress = '';

            if (data.Amount) {
                if (typeof data.Amount === 'string') {
                    amount = parseInt(data.Amount) / 1000000; // Convert drops to XRP
                } else if (data.Amount.value) {
                    amount = parseFloat(data.Amount.value);
                    currency = data.Amount.currency || 'XRP';
                }
            }

            // Get destination address
            toAddress = data.Destination || data.Account || '';

            return {
                hash: txHash,
                blockchain: 'Ripple',
                from: data.Account || '',
                to: toAddress,
                amount: amount,
                currency: currency,
                time: data.date ? new Date(data.date * 1000).getTime() : Date.now(),
                fee: data.Fee ? (parseInt(data.Fee) / 1000000) : 0,
                rawData: data
            };
        }

        throw new Error('Unable to parse Ripple transaction');
    } catch (error) {
        console.error('Ripple lookup error:', error);
        throw error;
    }
}

function showTransferSelectionForHop(hopNumber, entryId, transfers) {
    const modalHTML = `
        <div id="hopTransferModal" class="modal" style="display: block;">
            <div class="modal-content" style="max-width: 700px;">
                <div class="modal-header">
                    <h2>🔀 Multiple Transfers Detected</h2>
                    <p>This transaction contains ${transfers.length} transfers. Select the one to use:</p>
                </div>
                
                <div style="max-height: 400px; overflow-y: auto; margin: 20px 0;">
                    ${transfers.map((transfer, index) => `
                        <div style="background: white; border: 2px solid #e8f0fe; border-radius: 8px; padding: 15px; margin-bottom: 10px; cursor: pointer; transition: all 0.2s;"
                             onmouseover="this.style.borderColor='#3498db'; this.style.transform='translateY(-2px)'"
                             onmouseout="this.style.borderColor='#e8f0fe'; this.style.transform='translateY(0)'"
                             onclick="selectHopTransfer(${hopNumber}, ${entryId}, ${index})">
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                                <div>
                                    <strong>From:</strong><br>
                                    <span style="font-family: monospace; font-size: 12px;">${transfer.from}</span>
                                </div>
                                <div>
                                    <strong>To:</strong><br>
                                    <span style="font-family: monospace; font-size: 12px;">${transfer.to}</span>
                                </div>
                            </div>
                            <div style="margin-top: 10px; font-size: 18px; font-weight: bold; color: #2c3e50;">
                                ${transfer.amount} ${transfer.currency}
                            </div>
                        </div>
                    `).join('')}
                </div>
                
                <div style="text-align: center; margin-top: 20px;">
                    <button class="btn btn-secondary" onclick="closeHopTransferModal()">
                        Cancel
                    </button>
                </div>
            </div>
        </div>
    `;
    
    // Store transfers data for selection
    window.hopTransferData = transfers;
    
    // Create centered modal
    createCenteredModal('hopTransferModal', modalHTML);
}

function selectHopTransfer(hopNumber, entryId, transferIndex) {
    const transfer = window.hopTransferData[transferIndex];
    if (!transfer) return;
    
    // Populate the hop entry with selected transfer
    updateHopEntry(hopNumber, entryId, 'fromWallet', transfer.from);
    updateHopEntry(hopNumber, entryId, 'toWallet', transfer.to);
    updateHopEntry(hopNumber, entryId, 'amount', transfer.amount);
    updateHopEntry(hopNumber, entryId, 'currency', transfer.currency);
    
    // Update UI fields
    const amountField = document.getElementById(`amount_${hopNumber}_${entryId}`);
    if (amountField) amountField.value = transfer.amount;
    
    const toWalletField = document.getElementById(`toWallet_${hopNumber}_${entryId}`);
    if (toWalletField) toWalletField.value = transfer.to;
    
    alert(` Transfer selected:\n\nFrom: ${transfer.from}\nTo: ${transfer.to}\nAmount: ${transfer.amount} ${transfer.currency}`);
    
    closeHopTransferModal();
}

function closeHopTransferModal() {
    const modal = document.getElementById('hopTransferModal');
    if (modal) modal.remove();
    window.hopTransferData = null;
}

async function lookupVictimTransaction(victimId, transactionId) {
    const txHashInputElement = document.getElementById(`txHash_victim_${victimId}_${transactionId}`);
    const txHash = txHashInputElement.value.trim();

    if (!txHash) {
        alert('Please paste a transaction hash first');
        return;
    }

    // Check if user selected a specific chain
    const chainSelector = document.getElementById(`chain_victim_${victimId}_${transactionId}`);
    let detectedChain = chainSelector && chainSelector.value ? chainSelector.value : detectBlockchainFromHash(txHash);

    if (!detectedChain) {
        alert('Unable to detect blockchain. Please select a chain from the dropdown.');
        return;
    }
    
    // Show loading state - find the button that was clicked
    const lookupBtn = document.querySelector(`button[onclick*="lookupVictimTransaction(${victimId}, ${transactionId})"]`);
    const originalText = lookupBtn.textContent;
    lookupBtn.textContent = '⏳ Loading...';
    lookupBtn.disabled = true;
    
    try {
        const config = blockchainAPIs[detectedChain];
        const corsEnabled = localStorage.getItem('bats_cors_proxy_enabled') === 'true';
        const corsProxyUrl = localStorage.getItem('bats_cors_proxy_url') || 'https://cors-anywhere.herokuapp.com/';
        
        // Build array of URLs to try (primary + fallbacks)
        const urlsToTry = [config.apiUrl, ...(config.fallbackUrls || [])];
        let lastError = null;
        let txData = null;
        
        for (let apiUrl of urlsToTry) {
            try {
                let data;
                let url;
                let tokenData = null; // Define tokenData at this scope
                let blockTimestamp = null; // Define blockTimestamp at this scope
                let blockData = null; // Define blockData at this scope
                
                if (detectedChain === 'bitcoin') {
                    url = apiUrl + txHash;
                    if (config.apiKey) {
                        url += `?api_key=${config.apiKey}`;
                    }
                    if (corsEnabled) url = corsProxyUrl + url;
                    
                    const response = await fetch(url);
                    if (!response.ok) throw new Error('Transaction not found');
                    data = await response.json();
                    
                } else if (['ethereum', 'base', 'arbitrum', 'optimism', 'polygon', 'bsc',
                           'avalanche', 'hyperevm', 'linea', 'scroll', 'mantle', 'blast',
                           'zksync', 'gnosis', 'celo', 'moonbeam', 'moonriver', 'fraxtal',
                           'taiko', 'arbitrumnova', 'bittorrent', 'opbnb'].includes(detectedChain)) {
                    const apiKey = localStorage.getItem('bats_etherscan_api_key') || config.apiKey || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8';
                    
                    // First get the basic transaction
                    url = `${apiUrl}${txHash}&apikey=${apiKey}`;
                    if (corsEnabled) url = corsProxyUrl + url;
                    
                    const response = await fetch(url);
                    if (!response.ok) throw new Error('API request failed');
                    data = await response.json();
                    if (!data.result || data.result === null) throw new Error('Transaction not found');
                    
                    // Get block data for timestamp - but don't let it block token transfers
                    if (data.result && data.result.blockNumber) {
                        try {
                            const blockUrl = corsEnabled ?
                                corsProxyUrl + `${config.blockApiUrl}${data.result.blockNumber}&boolean=true&apikey=${apiKey}` :
                                `${config.blockApiUrl}${data.result.blockNumber}&boolean=true&apikey=${apiKey}`;
                            
                            const blockResponse = await fetch(blockUrl);
                            if (blockResponse.ok) {
                                const blockData = await blockResponse.json();
                                if (blockData && blockData.result && blockData.result.timestamp) {
                                    blockTimestamp = parseInt(blockData.result.timestamp, 16) * 1000;
                                    console.log('Got block timestamp:', new Date(blockTimestamp).toISOString());
                                }
                            }
                        } catch (err) {
                            console.log('Failed to fetch block timestamp, will proceed without it:', err);
                        }
                    }
                    
                    // Small delay to avoid rate limit
                    if (blockTimestamp) {
                        await new Promise(resolve => setTimeout(resolve, 300));
                    }
                    
                    // Also check for token transfers
                    try {
                        const tokenUrl = corsEnabled ? 
                            corsProxyUrl + `${config.tokenApiUrl}${txHash}&apikey=${apiKey}` :
                            `${config.tokenApiUrl}${txHash}&apikey=${apiKey}`;
                        
                        const tokenResponse = await fetch(tokenUrl);
                        if (tokenResponse.ok) {
                            tokenData = await tokenResponse.json();
                            console.log('Receipt/Token data received:', tokenData);
                            
                            // Check if Etherscan returned an error
                            if (tokenData && tokenData.status === '0' && tokenData.message === 'NOTOK') {
                                console.error('Etherscan API error:', tokenData.result);
                                throw new Error(tokenData.result);
                            }
                        }
                    } catch (err) {
                        console.log('No token transfers found');
                    }
                    
                } else if (detectedChain === 'tron') {
                    url = apiUrl + txHash;
                    if (config.apiKey) {
                        const headers = { 'TRON-PRO-API-KEY': config.apiKey };
                        if (corsEnabled) url = corsProxyUrl + url;
                        
                        const response = await fetch(url, { headers });
                        if (!response.ok) throw new Error('Transaction not found');
                        data = await response.json();
                    } else {
                        if (corsEnabled) url = corsProxyUrl + url;
                        const response = await fetch(url);
                        if (!response.ok) throw new Error('Transaction not found');
                        data = await response.json();
                    }
                    
                } else if (detectedChain === 'solana') {
                    url = apiUrl;
                    if (corsEnabled) url = corsProxyUrl + url;
                    
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            jsonrpc: '2.0',
                            id: 1,
                            method: 'getTransaction',
                            params: [txHash, { encoding: 'json', maxSupportedTransactionVersion: 0 }]
                        })
                    });
                    if (!response.ok) throw new Error('RPC request failed');
                    data = await response.json();
                    if (data.error) throw new Error(data.error.message);
                }
                
                // Parse the response (pass tokenData and blockTimestamp for EVM chains)
                const isEVMChain = ['ethereum', 'base', 'arbitrum', 'optimism', 'polygon', 'bsc',
                               'avalanche', 'hyperevm', 'linea', 'scroll', 'mantle', 'blast',
                               'zksync', 'gnosis', 'celo', 'moonbeam', 'moonriver', 'fraxtal',
                               'taiko', 'arbitrumnova', 'bittorrent', 'opbnb'].includes(detectedChain);
                txData = isEVMChain ?
                    config.parseResponse(data, tokenData, blockTimestamp, config) :
                    config.parseResponse(data);
                
                console.log('Parsed transaction data:', txData);
                
                if (!txData) throw new Error('This is a 0 ETH transaction with no token transfers');
                
                // Check if multiple transfers were detected
                if (txData.multipleTransfers) {
                    console.log('Multiple transfers detected, showing selection modal with', txData.transfers.length, 'transfers');
                    // Store the callback with proper context
                    // Add chain to each transfer
                    const transfersWithChain = txData.transfers.map(t => ({...t, chain: detectedChain}));

                    window.pendingTransferContext = {
                        victimId: victimId,
                        transactionId: transactionId,
                        txHash: txHash,
                        transfers: transfersWithChain,
                        timestamp: txData.time,
                        hasRealTimestamp: txData.hasRealTimestamp
                    };
                    pendingTransferCallback = (selectedTransfer) => {
                        // Apply the selected transfer with timestamp
                        applyTransferToVictim(victimId, transactionId, selectedTransfer, txHash, txData.time, txData.hasRealTimestamp);
                    };
                    showTransferSelectionModal(txData.transfers);
                    lookupBtn.textContent = originalText;
                    lookupBtn.disabled = false;
                    return; // Exit early - will continue after selection
                }
                
                // Success! Break out of the loop
                break;
                
            } catch (error) {
                console.error(`Failed with ${apiUrl}:`, error);
                lastError = error;
                // Continue to next URL
            }
        }
        
        if (!txData) {
            throw lastError || new Error('Failed to fetch transaction');
        }
        
        // Apply the data to the victim transaction
        const victim = investigation.victims.find(v => v.id === victimId);
        const transaction = victim.transactions.find(t => t.id === transactionId);
        
        // Update amount
        document.getElementById(`amount_victim_${victimId}_${transactionId}`).value = txData.amount;
        transaction.amount = txData.amount.toString();
        
        // Update currency
        const currencySelect = document.getElementById(`currency_victim_${victimId}_${transactionId}`);
        if (currencySelect) {
            // Check if the currency exists in the dropdown
            const optionExists = Array.from(currencySelect.options).some(opt => opt.value === txData.currency);
            if (!optionExists && txData.currency !== 'CUSTOM') {
                // Add new currency option if it doesn't exist
                const newOption = document.createElement('option');
                newOption.value = txData.currency;
                newOption.textContent = txData.currency;
                currencySelect.appendChild(newOption);
            }

            currencySelect.value = txData.currency;
            transaction.currency = txData.currency;
        }
        
        // Update receiving wallet (the "to" address is the RED wallet)
        document.getElementById(`receivingWallet_victim_${victimId}_${transactionId}`).value = txData.to;
        transaction.receivingWallet = txData.to;

        // Store the detected chain
        const chainSelector = document.getElementById(`chain_victim_${victimId}_${transactionId}`);
        if (chainSelector && detectedChain) {
            chainSelector.value = detectedChain;
            transaction.chain = detectedChain;
            console.log(`Stored chain '${detectedChain}' for V${victimId}-T${transactionId}`);
        }
        
        // Update datetime with validation
        if (txData.time && !isNaN(txData.time)) {
            const date = new Date(txData.time);
            if (!isNaN(date.getTime())) {
                const dateTimeLocal = date.toISOString().slice(0, 16);
                document.getElementById(`datetime_victim_${victimId}_${transactionId}`).value = dateTimeLocal;
                transaction.datetime = dateTimeLocal;
            } else {
                console.warn('Invalid date from transaction time:', txData.time);
                // Leave datetime empty for manual entry
            }
        } else {
            console.warn('No valid timestamp in transaction data');
            // Leave datetime empty for manual entry
        }
        
        // Set timezone to UTC
        document.getElementById(`timezone_victim_${victimId}_${transactionId}`).value = 'UTC';
        transaction.timezone = 'UTC';
        
        // Add note about the transaction
        const notesInput = document.querySelector(`input[onchange*="updateTransaction(${victimId}, ${transactionId}, 'notes'"]`);
        if (notesInput) {
            notesInput.value = `From: ${txData.from} | ${config.name} transaction`;
            transaction.notes = notesInput.value;
        }
        
        // Save and re-render
        saveToStorage();
        renderVictims();
        
        const timeString = txData.time && !isNaN(txData.time) ? 
            `\nTime: ${new Date(txData.time).toLocaleString()} UTC` : 
            '\nTime: Not available (please enter manually)';
        
        let alertMessage = `✅ Transaction data retrieved successfully!\n\nAmount: ${txData.amount} ${txData.currency}\nFrom: ${txData.from}\nTo (RED Wallet): ${txData.to}${timeString}`;
        
        if (txData.hasRealTimestamp === false) {
            alertMessage += '\n\n⚠️ WARNING: Could not retrieve actual transaction timestamp. Current time was used. Please manually update the date/time field!';
        }
        
        alert(alertMessage);
        
    } catch (error) {
        console.error('Lookup error:', error);
        const errorMsg = error.message || 'Failed to fetch transaction';

        // Check if user entered an address instead of a transaction hash
        if (txHash.startsWith('0x') && txHash.length === 42) {
            alert(`❌ Invalid Input: Wallet Address Detected\n\n` +
                  `You entered a wallet address, not a transaction hash.\n\n` +
                  `What you entered: ${txHash}\n` +
                  `This is a wallet address (42 characters)\n\n` +
                  `What's needed: A transaction hash (66 characters)\n` +
                  `Example: 0x1234...abcd (64 hex characters after 0x)\n\n` +
                  `Please paste the transaction hash, not the wallet address.`);
        }
        // Check if this looks like an EVM transaction hash that failed
        else if (txHash.startsWith('0x') && txHash.length === 66) {
            // This is likely an EVM transaction hash
            const selectedChain = chainSelector && chainSelector.value ? chainSelector.value : null;

            if (!selectedChain || selectedChain === 'ethereum') {
                // User didn't manually select a chain or it defaulted to Ethereum
                alert(`❌ Transaction not found on Ethereum\n\n` +
                      `The transaction hash appears to be from an EVM-compatible blockchain.\n\n` +
                      `⚠️ IMPORTANT: All EVM chains use the same transaction format (0x followed by 64 characters), ` +
                      `so automatic chain detection cannot determine which specific EVM network to search.\n\n` +
                      `The system searched Ethereum by default. If your transaction is on a different EVM chain ` +
                      `(BSC, Polygon, Arbitrum, Base, etc.), please:\n\n` +
                      `1. Select the correct chain from the dropdown menu\n` +
                      `2. Try the lookup again\n\n` +
                      `Common EVM chains: Ethereum, BSC, Polygon, Arbitrum, Optimism, Base, Avalanche`);
            } else {
                // User selected a specific chain but it still failed
                alert(`❌ Transaction not found on ${selectedChain}\n\n` +
                      `The transaction was not found on the selected chain.\n\n` +
                      `Please verify:\n` +
                      `1. The transaction hash is correct\n` +
                      `2. You've selected the right EVM chain\n` +
                      `3. The transaction has been confirmed on-chain\n\n` +
                      `If unsure, check the source where you obtained this transaction hash ` +
                      `to confirm which blockchain network it's on.`);
            }
        } else if (errorMsg.includes('CORS') || errorMsg.includes('Failed to fetch')) {
            alert(`ERROR:  ${errorMsg}\n\nThe app will retry automatically with different methods.`);
        } else {
            alert(`ERROR:  Failed to fetch transaction: ${errorMsg}`);
        }
    } finally {
        lookupBtn.textContent = originalText;
        lookupBtn.disabled = false;
    }
}
        // Transfer Selection Modal Functions
        function showTransferSelectionModal(transfers) {
            const modal = document.getElementById('transferSelectionModal');
            const transfersList = document.getElementById('transfersList');
            
            // Store transfers globally for filtering
            window.allTransfers = transfers;
            window.filteredTransfers = transfers;
            
            // Populate asset filter dropdown
            const assetFilter = document.getElementById('transferAssetFilter');
            assetFilter.innerHTML = '<option value="">All Assets</option>';
            
            // Get unique assets
            const uniqueAssets = [...new Set(transfers.map(t => t.currency))].sort();
            uniqueAssets.forEach(asset => {
                const option = document.createElement('option');
                option.value = asset;
                option.textContent = asset;
                assetFilter.appendChild(option);
            });
            
            // Clear filters
            document.getElementById('transferAmountFilter').value = '';
            document.getElementById('transferAddressFilter').value = '';
            assetFilter.value = '';
            
            // Render transfers
            renderTransferCards(transfers);
            
            // Update filter info
            updateFilterInfo(transfers.length, transfers.length);
            
            // Show the modal
            modal.classList.add('show');
        }
        
        function renderTransferCards(transfers) {
            const transfersList = document.getElementById('transfersList');
            transfersList.innerHTML = '';
            
            if (transfers.length === 0) {
                transfersList.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;">No transfers match your filters</div>';
                return;
            }
            
            transfers.forEach((transfer, index) => {
                // Find the original index for correct selection
                const originalIndex = window.allTransfers.indexOf(transfer);
                
                const transferCard = document.createElement('div');
                transferCard.className = 'transfer-card';
                transferCard.style.cssText = `
                    background: white;
                    border: 2px solid #e8f0fe;
                    border-radius: 8px;
                    padding: 20px;
                    margin-bottom: 15px;
                    cursor: pointer;
                    transition: all 0.3s ease;
                `;
                
                transferCard.onmouseover = () => {
                    transferCard.style.borderColor = '#3498db';
                    transferCard.style.backgroundColor = '#f0f8ff';
                };
                
                transferCard.onmouseout = () => {
                    transferCard.style.borderColor = '#e8f0fe';
                    transferCard.style.backgroundColor = 'white';
                };
                
                transferCard.innerHTML = `
                    <div style="display: grid; grid-template-columns: 1fr auto; gap: 15px; align-items: start;">
                        <div>
                            <h4 style="margin: 0 0 10px 0; color: #2c3e50;">
                                Transfer ${originalIndex + 1}: <span style="color: #3498db; font-weight: 600;">${formatNumber(transfer.amount)}</span> <span style="color: #27ae60; font-weight: 600;">${transfer.currency}</span>
                            </h4>
                            <div style="font-size: 14px; color: #555;">
                                <div style="margin-bottom: 5px;">
                                    <strong>From:</strong> <span style="font-family: monospace;">${transfer.from}</span>
                                </div>
                                <div style="margin-bottom: 5px;">
                                    <strong>To:</strong> <span style="font-family: monospace;">${transfer.to}</span>
                                </div>
                                <div>
                                    <strong>Token Contract:</strong> <span style="font-family: monospace;">${transfer.contractAddress}</span>
                                </div>
                            </div>
                        </div>
                        <button class="btn btn-confirm" onclick="selectTransfer(${originalIndex})" style="margin-top: 0;">
                            Select This Transfer
                        </button>
                    </div>
                `;
                
                transfersList.appendChild(transferCard);
            });
        }
        
        function filterTransfers() {
            const assetFilter = document.getElementById('transferAssetFilter').value;
            const amountFilter = document.getElementById('transferAmountFilter').value.trim();
            const addressFilter = document.getElementById('transferAddressFilter').value.trim().toLowerCase();
            
            window.filteredTransfers = window.allTransfers.filter(transfer => {
                // Asset filter
                if (assetFilter && transfer.currency !== assetFilter) {
                    return false;
                }
                
                // Amount filter
                if (amountFilter) {
                    const filterAmount = parseFloat(amountFilter);
                    if (!isNaN(filterAmount)) {
                        // Allow for slight variations due to decimal precision
                        if (Math.abs(transfer.amount - filterAmount) > 0.000001) {
                            return false;
                        }
                    }
                }
                
                // Address filter (check both from and to)
                if (addressFilter) {
                    const fromMatch = transfer.from.toLowerCase().includes(addressFilter);
                    const toMatch = transfer.to.toLowerCase().includes(addressFilter);
                    if (!fromMatch && !toMatch) {
                        return false;
                    }
                }
                
                return true;
            });
            
            // Re-render filtered transfers
            renderTransferCards(window.filteredTransfers);
            
            // Update filter info
            updateFilterInfo(window.filteredTransfers.length, window.allTransfers.length);
        }
        
        function clearTransferFilters() {
            document.getElementById('transferAssetFilter').value = '';
            document.getElementById('transferAmountFilter').value = '';
            document.getElementById('transferAddressFilter').value = '';
            window.filteredTransfers = window.allTransfers;
            renderTransferCards(window.allTransfers);
            updateFilterInfo(window.allTransfers.length, window.allTransfers.length);
        }
        
        function updateFilterInfo(shown, total) {
            const infoDiv = document.getElementById('filterResultsInfo');
            if (shown === total) {
                infoDiv.textContent = `Showing all ${total} transfers`;
            } else {
                infoDiv.textContent = `Showing ${shown} of ${total} transfers`;
            }
        }
        
        function closeTransferSelectionModal() {
            const modal = document.getElementById('transferSelectionModal');
            modal.classList.remove('show');
            
            // Clear pending data
            pendingTransfers = null;
            pendingTransferCallback = null;
        }
        
        function selectTransfer(index) {
            if (!window.allTransfers || !pendingTransferCallback) {
                console.error('No pending transfer data');
                return;
            }
            
            const selectedTransfer = window.allTransfers[index];
            
            // Store the callback before closing modal (which clears it)
            const callback = pendingTransferCallback;
            
            // Close the modal
            closeTransferSelectionModal();
            
            // Execute the callback with the selected transfer
            callback(selectedTransfer);
        }
        
        function applyTransferToVictim(victimId, transactionId, transfer, txHash, timestamp, hasRealTimestamp) {
            console.log('Applying transfer to victim:', { victimId, transactionId, transfer, txHash });
            
            // Ensure transfer data is valid
            if (!transfer || !transfer.amount || !transfer.to) {
                console.error('Invalid transfer data:', transfer);
                alert('Error: Invalid transfer data received');
                return;
            }
            
            const victim = investigation.victims.find(v => v.id === victimId);
            if (!victim) {
                console.error('Victim not found:', victimId);
                alert('Error: Victim not found');
                return;
            }
            
            const transaction = victim.transactions.find(t => t.id === transactionId);
            if (!transaction) {
                console.error('Transaction not found:', transactionId);
                alert('Error: Transaction not found');
                return;
            }
            
            // Update transaction hash first
            const txHashField = document.getElementById(`txHash_victim_${victimId}_${transactionId}`);
            if (txHashField && txHash) {
                txHashField.value = txHash;
                transaction.txHash = txHash;
            }
            
            // Update amount
            const amountInput = document.getElementById(`amount_victim_${victimId}_${transactionId}`);
            if (amountInput) {
                amountInput.value = transfer.amount;
                transaction.amount = transfer.amount.toString();
            } else {
                console.error('Amount input not found:', `amount_victim_${victimId}_${transactionId}`);
            }
            
            // Update currency
            const currencySelect = document.getElementById(`currency_victim_${victimId}_${transactionId}`);
            if (!currencySelect) {
                console.error('Currency select not found:', `currency_victim_${victimId}_${transactionId}`);
            } else {
                // If the currency doesn't exist in the select, add it
                const optionExists = Array.from(currencySelect.options).some(opt => opt.value === transfer.currency);
                if (!optionExists && transfer.currency !== 'CUSTOM') {
                    const newOption = document.createElement('option');
                    newOption.value = transfer.currency;
                    newOption.textContent = transfer.currency;
                    currencySelect.appendChild(newOption);
                }
                
                currencySelect.value = transfer.currency;
                transaction.currency = transfer.currency;
            }
            
            // Update receiving wallet (the "to" address is the RED wallet)
            const receivingWalletInput = document.getElementById(`receivingWallet_victim_${victimId}_${transactionId}`);
            if (receivingWalletInput) {
                receivingWalletInput.value = transfer.to;
                transaction.receivingWallet = transfer.to;
            } else {
                console.error('Receiving wallet input not found');
            }

            // Store the detected chain if available
            if (transfer.chain) {
                const chainSelector = document.getElementById(`chain_victim_${victimId}_${transactionId}`);
                if (chainSelector) {
                    chainSelector.value = transfer.chain;
                    transaction.chain = transfer.chain;
                    console.log(`Stored chain '${transfer.chain}' for V${victimId}-T${transactionId} from transfer`);
                }
            }
            
            // Update datetime with transaction timestamp if available
            if (timestamp && !isNaN(timestamp)) {
                const date = new Date(timestamp);
                if (!isNaN(date.getTime())) {
                    const dateTimeLocal = date.toISOString().slice(0, 16);
                    const datetimeInput = document.getElementById(`datetime_victim_${victimId}_${transactionId}`);
                    if (datetimeInput) {
                        datetimeInput.value = dateTimeLocal;
                        transaction.datetime = dateTimeLocal;
                        console.log(`Set transaction datetime to: ${dateTimeLocal}`);
                    }
                    
                    // Show warning if this is not a real timestamp
                    if (!hasRealTimestamp) {
                        setTimeout(() => {
                            alert('⚠️ Transaction timestamp could not be retrieved from the blockchain.\n\nCurrent time has been used as a placeholder.\n\nPlease manually update the date/time field with the correct transaction time.');
                        }, 100);
                    }
                } else {
                    console.warn('Invalid timestamp provided:', timestamp);
                }
            } else {
                console.warn('No timestamp provided for transfer');
                setTimeout(() => {
                    alert('⚠️ No timestamp available for this transaction.\n\nPlease manually enter the date/time.');
                }, 100);
            }
            
            // Set timezone to UTC
            const timezoneSelect = document.getElementById(`timezone_victim_${victimId}_${transactionId}`);
            if (timezoneSelect) {
                timezoneSelect.value = 'UTC';
                transaction.timezone = 'UTC';
            }
            
            // Add note about the transaction
            const notesInput = document.querySelector(`input[onchange*="updateTransaction(${victimId}, ${transactionId}, 'notes'"]`);
            if (notesInput) {
                // Create appropriate note based on currency type
                if (transfer.currency === 'BTC') {
                    notesInput.value = `From: ${transfer.from} | Bitcoin transfer${transfer.outputIndex !== undefined ? ` | Output #${transfer.outputIndex}` : ''}`;
                } else if (transfer.contractAddress) {
                    notesInput.value = `From: ${transfer.from} | ${transfer.currency} token transfer | Contract: ${transfer.contractAddress}`;
                } else {
                    notesInput.value = `From: ${transfer.from} | ${transfer.currency} transfer`;
                }
                transaction.notes = notesInput.value;
            }
            
            // Store the transaction hash
            transaction.txHash = txHash;
            
            // Also update the transaction hash input field
            const txHashElem = document.getElementById(`txHash_victim_${victimId}_${transactionId}`);
            if (txHashElem) {
                txHashElem.value = txHash;
            }
            
            // Save to storage
            saveToStorage();
            
            // Update the workflow steps to reflect progress
            updateWorkflowSteps();
            
            // Show success message
            let alertMessage = `✅ Transaction data retrieved successfully!

Amount: ${formatNumber(transfer.amount)} ${transfer.currency}
From: ${transfer.from}
To (RED Wallet): ${transfer.to}`;
            
            if (!hasRealTimestamp) {
                alertMessage += '\n\n⚠️ WARNING: Could not retrieve actual transaction timestamp. Current time was used. Please manually update the date/time field!';
            }
            
            alert(alertMessage);

            // Log for debugging
            console.log('Transfer applied successfully:', {
                victimId,
                transactionId,
                amount: transfer.amount,
                currency: transfer.currency,
                to: transfer.to
            });

            // Update UI to reflect the changes
            saveToStorage();
            renderVictims();
            updateValidationStatus();
            updateWorkflowSteps();
            updateGenerateRootSection();
        }
        
        // Entity Detection Functions
        async function detectWalletEntity(address, blockchain) {
            const config = blockchainAPIs[blockchain];
            if (!config) return null;
            
            const corsEnabled = localStorage.getItem('bats_cors_proxy_enabled') === 'true';
            const corsProxyUrl = localStorage.getItem('bats_cors_proxy_url') || 'https://cors-anywhere.herokuapp.com/';
            
            try {
                if (blockchain === 'bitcoin' && config.entityApiUrl) {
                    // WalletExplorer API for Bitcoin
                    let url = config.entityApiUrl + address;
                    if (corsEnabled) url = corsProxyUrl + url;
                    
                    const response = await fetch(url);
                    if (response.ok) {
                        const data = await response.json();
                        if (data && data.label && data.label !== 'Unknown') {
                            return {
                                entity: data.label,
                                category: data.category || 'Exchange/Service',
                                confidence: 'high',
                                source: 'WalletExplorer'
                            };
                        }
                    }
                } else if (blockchain === 'ethereum' && config.labelApiUrl) {
                    // Etherscan labels API
                    const apiKey = localStorage.getItem('bats_etherscan_api_key') || config.apiKey || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8';
                    let url = `${config.labelApiUrl}${address}&apikey=${apiKey}`;
                    if (corsEnabled) url = corsProxyUrl + url;
                    
                    const response = await fetch(url);
                    if (response.ok) {
                        const data = await response.json();
                        if (data.status === '1' && data.result) {
                            // Check for name tag (exchange/service label)
                            if (data.result.length > 0) {
                                const labelInfo = data.result[0];
                                if (labelInfo.nameTag && labelInfo.nameTag !== '') {
                                    return {
                                        entity: labelInfo.nameTag,
                                        category: 'Exchange/Service',
                                        confidence: 'high',
                                        source: 'Etherscan'
                                    };
                                }
                            }
                        }
                    }
                }
                
                // Check against known exchange patterns
                const knownPatterns = checkKnownExchangePatterns(address, blockchain);
                if (knownPatterns) {
                    return knownPatterns;
                }
                
            } catch (error) {
                console.error('Entity detection error:', error);
            }
            
            return null;
        }
        
        function checkKnownExchangePatterns(address, blockchain) {
            // Common exchange address patterns and known addresses
            const knownExchanges = {
                bitcoin: {
                    // Binance cold wallets often start with bc1q
                    patterns: [
                        { prefix: '3BMEX', entity: 'BitMEX', category: 'Exchange' },
                        { prefix: '3JZq4atUahhuA9rLhX', entity: 'Bitfinex', category: 'Exchange' },
                        { prefix: '1NDyJtNTjmwk5xPNhjgAMu4HDHigtobu1s', entity: 'Binance', category: 'Exchange' }
                    ],
                    addresses: {
                        '1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa': { entity: 'Genesis Block', category: 'Historical' },
                        '12cgpFdJViXbwHbhrA3TuW1EGnL25Zqc3P': { entity: 'Binance Cold Wallet', category: 'Exchange' }
                    }
                },
                ethereum: {
                    addresses: {
                        '0x3f5ce5fbfe3e9af3971dd833d26ba9b5c936f0be': { entity: 'Binance', category: 'Exchange' },
                        '0xd551234ae421e3bcba99a0da6d736074f22192ff': { entity: 'Binance 2', category: 'Exchange' },
                        '0x564286362092d8e7936f0549571a803b203aaced': { entity: 'Binance 3', category: 'Exchange' },
                        '0x28c6c06298d514db089934071355e5743bf21d60': { entity: 'Binance 14', category: 'Exchange' },
                        '0x21a31ee1afc51d94c2efccaa2092ad1028285549': { entity: 'Binance 15', category: 'Exchange' },
                        '0xdfd5293d8e347dfe59e90efd55b2956a1343963d': { entity: 'Binance 16', category: 'Exchange' },
                        '0x56eddb7aa87536c09ccc2793473599fd21a8b17f': { entity: 'Binance 17', category: 'Exchange' },
                        '0x9696f59e4d72e237be84ffd425dcad154bf96976': { entity: 'Binance 18', category: 'Exchange' },
                        '0x4e9ce36e442e55ecd9025b9a6e0d88485d628a67': { entity: 'Binance US', category: 'Exchange' },
                        '0xbe0eb53f46cd790cd13851d5eff43d12404d33e8': { entity: 'Binance 7', category: 'Exchange' },
                        '0x876eabf441b2ee5b5b0554fd502a8e0600950cfa': { entity: 'Bitfinex', category: 'Exchange' },
                        '0xc6bed363b30df7f35b601a5547fe56cd31ec63da': { entity: 'Bitfinex 2', category: 'Exchange' },
                        '0x29728d0efd284d85187362faa2d4d76c2cfc2612': { entity: 'Bitfinex 3', category: 'Exchange' },
                        '0xe92d1a43df510f82c66382592a047d288f85226f': { entity: 'Bitfinex 4', category: 'Exchange' },
                        '0x8103683202aa8da10536036edef04cdd865c225e': { entity: 'Bitfinex 5', category: 'Exchange' },
                        '0xab7c74abc0c4d48d1bdad5dcb26153fc8780f83e': { entity: 'Bitfinex MultiSig', category: 'Exchange' },
                        '0x6262998ced04146fa42253a5c0af90ca02dfd2a3': { entity: 'Crypto.com', category: 'Exchange' },
                        '0x46340b20830761efd32832a74d7169b29feb9758': { entity: 'Crypto.com 2', category: 'Exchange' },
                        '0x71660c4005ba85c37ccec55d0c4493e66fe775d3': { entity: 'Coinbase 1', category: 'Exchange' },
                        '0x503828976d22510aad0201ac7ec88293211d23da': { entity: 'Coinbase 2', category: 'Exchange' },
                        '0xddfabcdc4d8ffc6d5beaf154f18b778f892a0740': { entity: 'Coinbase 3', category: 'Exchange' },
                        '0x3cd751e6b0078be393132286c442345e5dc49699': { entity: 'Coinbase 4', category: 'Exchange' },
                        '0xb5d85cbf7cb3ee0d56b3bb207d5fc4b82f43f511': { entity: 'Coinbase 5', category: 'Exchange' },
                        '0xeb2629a2734e272bcc07bda959863f316f4bd4cf': { entity: 'Coinbase 6', category: 'Exchange' },
                        '0xa090e606e30bd747d4e6245a1517ebe430f0057e': { entity: 'Coinbase Miscellaneous', category: 'Exchange' },
                        '0x6cc5f688a315f3dc28a7781717a9a798a59fda7b': { entity: 'OKEx', category: 'Exchange' },
                        '0x236f9f97e0e62388479bf9e5ba4889e46b0273c3': { entity: 'OKEx 2', category: 'Exchange' },
                        '0xa7efae728d2936e78bda97dc267687568dd593f3': { entity: 'OKEx 3', category: 'Exchange' },
                        '0x2c8fbb630289363ac80705a1a61273f76fd5a161': { entity: 'Poloniex', category: 'Exchange' },
                        '0x32be343b94f860124dc4fee278fdcbd38c102d88': { entity: 'Poloniex', category: 'Exchange' },
                        '0x209c4784ab1e8183cf58ca33cb740efbf3fc18ef': { entity: 'Poloniex 2', category: 'Exchange' },
                        '0xb794f5ea0ba39494ce839613fffba74279579268': { entity: 'Poloniex 3', category: 'Exchange' },
                        '0x0a869d79a7052c7f1b55a8ebabbea3420f0d1e13': { entity: 'KuCoin', category: 'Exchange' },
                        '0x2b5634c42055806a59e9107ed44d43c426e58258': { entity: 'KuCoin 2', category: 'Exchange' },
                        '0x689c56aef474df92d44a1b70850f808488f9769c': { entity: 'KuCoin 3', category: 'Exchange' },
                        '0xa1d8d972560c2f8144af871db508f0b0b10a3fbf': { entity: 'KuCoin 4', category: 'Exchange' },
                        '0x4ad64983349c49defe8d7a4686202d24b25d0ce8': { entity: 'KuCoin 5', category: 'Exchange' },
                        '0x1692e170361cefd1eb7240ec13d048fd9af6d667': { entity: 'KuCoin 6', category: 'Exchange' },
                        '0xd6216fc19db775df9774a6e33526131da7d19a2c': { entity: 'KuCoin 7', category: 'Exchange' },
                        '0xe59cd29be3be4461d79c0881d238cbe87d64595a': { entity: 'Kraken', category: 'Exchange' },
                        '0x43984d578803891dfa9706bdeee6078d80cfc79e': { entity: 'Kraken 2', category: 'Exchange' },
                        '0x66c57bf505a85a74609d2c83e94aabb26d691e41': { entity: 'Kraken 3', category: 'Exchange' },
                        '0xda9dfa130df4de4673b89022ee50ff26f6ea73cf': { entity: 'Kraken 4', category: 'Exchange' },
                        '0xa83b11093c858c86321fbc4c20fe82cdbd58e09e': { entity: 'Kraken 5', category: 'Exchange' },
                        '0x0a98fb70939162725ae66e626fe4b52cff62c2e5': { entity: 'Gate.io', category: 'Exchange' },
                        '0xf56e08ee4e8ac390c28bba0431c22e6c1cb54529': { entity: 'Gate.io 2', category: 'Exchange' },
                        '0x7793cd85c11a924478d358d49b05b37e91b5810f': { entity: 'Gate.io 3', category: 'Exchange' },
                        '0x1c4b70a3968436b9a0a9cf5205c787eb81bb558c': { entity: 'Gate.io 4', category: 'Exchange' },
                        '0xd793281182a0e3e023116004778f45c29fc14f19': { entity: 'Gate.io 5', category: 'Exchange' },
                        '0x9f5ca0012b9b72e8f3db57092a6f26bf4f13dc69': { entity: 'Gate.io 6', category: 'Exchange' },
                        '0xc882b111a75c0c657fc507c04fbfcd2cc984f071': { entity: 'Gate.io 7', category: 'Exchange' }
                    }
                }
            };
            
            const lowerAddress = address.toLowerCase();
            
            // Check exact matches
            if (knownExchanges[blockchain] && knownExchanges[blockchain].addresses) {
                const match = knownExchanges[blockchain].addresses[lowerAddress];
                if (match) {
                    return {
                        entity: match.entity,
                        category: match.category,
                        confidence: 'high',
                        source: 'Known Address Database'
                    };
                }
            }
            
            // Check patterns
            if (knownExchanges[blockchain] && knownExchanges[blockchain].patterns) {
                for (const pattern of knownExchanges[blockchain].patterns) {
                    if (address.startsWith(pattern.prefix)) {
                        return {
                            entity: pattern.entity,
                            category: pattern.category,
                            confidence: 'medium',
                            source: 'Address Pattern Match'
                        };
                    }
                }
            }
            
            return null;
        }
        
        // Update wallet classification based on entity
        function updateWalletClassificationFromEntity(entityData, walletType) {
            if (!entityData) return walletType;
            
            // If it's an exchange, mark as purple
            if (entityData.category === 'Exchange' || entityData.category === 'Exchange/Service') {
                return 'purple';
            }
            
            // Keep original classification if no exchange detected
            return walletType;
        }
        
        // Check wallet entity when address is entered
        async function checkWalletEntity(address, hopNumber, entryId) {
            if (!address || address.trim() === '') return;
            
            // Detect blockchain from address
            let detectedBlockchain = null;
            for (const [blockchain, config] of Object.entries(blockchainAPIs)) {
                if (config.addressPattern && config.addressPattern.test(address)) {
                    detectedBlockchain = blockchain;
                    break;
                }
            }
            
            if (!detectedBlockchain) return;
            
            // Show loading state
            const entityInfoDiv = document.getElementById(`entityInfo_${hopNumber}_${entryId}`);
            if (entityInfoDiv) {
                entityInfoDiv.style.display = 'block';
                entityInfoDiv.innerHTML = '<div style="text-align: center;">🔍 Checking wallet entity...</div>';
            }
            
            try {
                const entityData = await detectWalletEntity(address, detectedBlockchain);
                
                if (entityData) {
                    // Display entity information
                    if (entityInfoDiv) {
                        entityInfoDiv.innerHTML = `
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <strong>🏢 Entity Detected:</strong> ${entityData.entity}<br>
                                    <small>Category: ${entityData.category} | Confidence: ${entityData.confidence} | Source: ${entityData.source}</small>
                                </div>
                                <div>
                                    ${entityData.category === 'Exchange' || entityData.category === 'Exchange/Service' ? 
                                        '<span style="background: #9b59b6; color: white; padding: 4px 12px; border-radius: 4px; font-weight: bold;">PURPLE</span>' : 
                                        ''}
                                </div>
                            </div>
                        `;
                        
                        // Auto-update wallet type if it's an exchange
                        if (entityData.category === 'Exchange' || entityData.category === 'Exchange/Service') {
                            const walletTypeSelect = document.querySelector(`select[onchange*="updateHopEntryWalletType(${hopNumber}, ${entryId}"]`);
                            if (walletTypeSelect && walletTypeSelect.value !== 'purple') {
                                walletTypeSelect.value = 'purple';
                                updateHopEntryWalletType(hopNumber, entryId, 'purple');
                                
                                // Add note about auto-classification
                                entityInfoDiv.innerHTML += `
                                    <div style="margin-top: 10px; padding: 8px; background: rgba(255,255,255,0.5); border-radius: 4px; font-size: 12px;">
                                        ✅ Wallet automatically classified as PURPLE (Exchange)
                                    </div>
                                `;
                                
                                // Show terminal wallet notification
                                showTerminalWalletNotification(entityData, address, hopNumber, entryId);
                            }
                        }
                    }
                } else {
                    // No entity found
                    if (entityInfoDiv) {
                        entityInfoDiv.style.display = 'none';
                    }
                }
            } catch (error) {
                console.error('Entity detection error:', error);
                if (entityInfoDiv) {
                    entityInfoDiv.style.display = 'none';
                }
            }
        }
        
        // File system save functionality
        async function saveAndCaptureFilePath() {
            try {
                // Check if File System Access API is available
                if ('showSaveFilePicker' in window) {
                    const options = {
                        types: [{
                            description: 'BATS Investigation Files',
                            accept: { 'application/json': ['.bats'] }
                        }],
                        suggestedName: `BATS_${investigation.caseId || 'Investigation'}_${new Date().toISOString().split('T')[0]}.bats`
                    };
                    
                    // Show save file picker
                    fileHandle = await window.showSaveFilePicker(options);
                    
                    // Create the file content
                    const fileData = JSON.stringify(investigation, null, 2);
                    
                    // Write the file
                    const writable = await fileHandle.createWritable();
                    await writable.write(fileData);
                    await writable.close();
                    
                    // Capture file path info
                    savedFilePath = fileHandle.name;
                    isFileSystemAvailable = true;
                    
                    // Update UI
                    document.getElementById('saveRequiredMessage').style.display = 'none';
                    document.getElementById('generateRootBtn').style.display = 'block';
                    
                    alert(` Investigation saved successfully!\n\nFile: ${savedFilePath}\nLocation: ${fileHandle.name}\n\nAutomatic saving is now enabled!\nYour investigation will be automatically saved to this location after each hop.`);
                    
                } else {
                    // Fallback to regular download
                    const fileData = JSON.stringify(investigation, null, 2);
                    const filename = `BATS_${investigation.caseId || 'Investigation'}_${new Date().toISOString().split('T')[0]}.bats`;
                    
                    const blob = new Blob([fileData], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    // Mark as saved (but without autosave capability)
                    savedFilePath = filename;
                    isFileSystemAvailable = false;
                    
                    // Update UI
                    document.getElementById('saveRequiredMessage').style.display = 'none';
                    document.getElementById('generateRootBtn').style.display = 'block';
                    
                    let helpText = `✅ Investigation saved to Downloads folder!\n\nFile: ${filename}\n\n⚠️ Browser Limitation: `;
                    
                    if (window.location.protocol === 'file:') {
                        helpText += `You're running this tool from a local file (file://), which limits some features.\n\nFor full functionality including custom save locations:\n• Host on a local server (e.g., python -m http.server)\n• Use a tool like Live Server in VS Code\n• Upload to a web server with HTTPS\n• Or continue with manual saves to Downloads folder`;
                    } else {
                        helpText += `Your browser doesn't support the File System API.\n\nFor custom save locations, use:\n• Chrome 86+ or Edge 86+ (Chromium-based)\n• Opera 72+\n• Make sure you're on HTTPS`;
                    }
                    
                    alert(helpText);
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    // User cancelled the save dialog
                    return;
                }
                console.error('Save error:', error);
                alert('ERROR:  Error saving file: ' + error.message);
            }
        }
        
        // Autosave function for hops
        async function autosaveInvestigation() {
            if (!isFileSystemAvailable || !fileHandle) {
                console.log('Autosave not available - no file handle');
                return;
            }
            
            try {
                const fileData = JSON.stringify(investigation, null, 2);
                const writable = await fileHandle.createWritable();
                await writable.write(fileData);
                await writable.close();
                
                // Show subtle save indicator
                showAutosaveIndicator();
                
            } catch (error) {
                console.error('Autosave error:', error);
                // Don't alert on every autosave failure, just log it
            }
        }
        
        function showAutosaveIndicator() {
            // Create or update autosave indicator
            let indicator = document.getElementById('autosaveIndicator');
            if (!indicator) {
                indicator = document.createElement('div');
                indicator.id = 'autosaveIndicator';
                indicator.style.cssText = `
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    background: #27ae60;
                    color: white;
                    padding: 10px 20px;
                    border-radius: 20px;
                    font-size: 14px;
                    z-index: 1000;
                    opacity: 0;
                    transition: opacity 0.3s ease;
                    pointer-events: none;
                `;
                document.body.appendChild(indicator);
            }
            
            indicator.textContent = '✓ Autosaved';
            indicator.style.opacity = '1';
            
            setTimeout(() => {
                indicator.style.opacity = '0';
            }, 2000);
        }

        // Helper function for proper decimal rounding to avoid floating point errors
        function roundAmount(amount, decimals = 8) {
            // Round to 8 decimal places by default - important for high value crypto
            // where even small decimals can represent significant value
            const factor = Math.pow(10, decimals);
            return Math.round((amount + Number.EPSILON) * factor) / factor;
        }

        // Comprehensive list of known exchange and service indicators
        function getExchangeIndicators() {
            return {
                exchanges: [
                    // Major CEXs
                    'binance', 'coinbase', 'kraken', 'crypto.com', 'kucoin', 'okx', 'okex',
                    'huobi', 'bitfinex', 'bitstamp', 'gemini', 'ftx', 'gate.io', 'mexc',
                    'bybit', 'bitget', 'bitmart', 'probit', 'lbank', 'xt.com', 'bingx',
                    'poloniex', 'upbit', 'bithumb', 'coinone', 'korbit', 'bitflyer',
                    'liquid', 'bitbank', 'zaif', 'btcbox', 'hotbit', 'ascendex', 'bitmax',
                    'phemex', 'deribit', 'bitmex', 'bittrex', 'hitbtc', 'whitebit',
                    'coinsbit', 'p2pb2b', 'latoken', 'vindax', 'digifinex', 'bigone',
                    'indodax', 'wazirx', 'coindcx', 'zebpay', 'btc-alpha', 'cex.io',
                    'exmo', 'yobit', 'cryptopia', 'mercatox', 'bleutrade', 'c-cex',
                    'nova exchange', 'trade satoshi', 'stocks.exchange', 'crex24',
                    'stex', 'finexbox', 'graviex', 'coineal', 'biki', 'mxc', 'bhex',
                    'hoo', 'bibox', 'bit-z', 'coinbene', 'zbg', 'coinw', 'bw.com',
                    'oceanex', 'vcc', 'coinex', 'catex', 'bitforex', 'fcoin', 'coinall',
                    'b2bx', 'rightbtc', 'cobinhood', 'kuna', 'tidex', 'blokmy',
                    'tokenomy', 'bitso', 'volabit', 'bitflip', 'kriptomat', 'paymium',
                    'therocktrading', 'bit2me', 'bitvavo', 'bl3p', 'btcdirect', 'litebit',
                    'anycoin', 'coinmama', 'coinhouse', 'paybis', 'bitpanda', 'bitbay',
                    'zonda', 'coinfinity', 'coinfinity', 'bitcoin.de', 'bitkub', 'satang',
                    'zipmex', 'tokocrypto', 'pintu', 'rekeningku', 'triv', 'uphold',
                    'voyager', 'blockfi', 'celsius', 'nexo', 'crypto.com app', 'swissborg',
                    'youhodler', 'blockchain.com', 'exodus', 'atomic wallet', 'trust wallet',
                    'abra', 'edge', 'breadwallet', 'bitcoin.com', 'paxful', 'localbitcoins',
                    'bisq', 'hodlhodl', 'agoradesk', 'robosats', 'peachbitcoin'
                ],
                dexBridges: [
                    // DEXs and Bridges
                    'uniswap', 'sushiswap', 'pancakeswap', '1inch', 'curve', 'balancer',
                    'quickswap', 'spookyswap', 'spiritswap', 'traderjoe', 'raydium',
                    'orca', 'serum', 'osmosis', 'thorchain', 'anyswap', 'multichain',
                    'synapse', 'stargate', 'hop protocol', 'across', 'celer', 'connext',
                    'nomad', 'wormhole', 'portal', 'allbridge', 'chainport', 'poly network',
                    'ren', 'badger', 'thorswap', 'maya protocol', 'chainflip', 'squid',
                    'axelar', 'layerzero', 'debridge', 'li.fi', 'socket', 'bungee',
                    'rango', 'xy finance', 'o3swap', 'rubic', 'paraswap', 'matcha',
                    'cowswap', 'kyberswap', '0x', 'airswap', 'tokenlon', 'dodo',
                    'bancor', 'kyber', 'loopring', 'idex', 'ddex', 'radar relay',
                    'paradex', 'etherdelta', 'forkdelta', 'token store', 'oasis',
                    'deversifi', 'nash', 'dydx', 'perpetual protocol', 'gmx', 'gains',
                    'kwenta', 'polynomial', 'lyra', 'hegic', 'opyn', 'ribbon',
                    'friktion', 'katana', 'zeta', 'drift', 'mango', 'jupiter'
                ],
                keywords: [
                    // General keywords
                    'deposit', 'withdrawal', 'hot wallet', 'cold wallet', 'cold storage',
                    'exchange', 'cex', 'dex', 'swap', 'bridge', 'cross-chain',
                    'liquidity pool', 'lp', 'amm', 'automated market maker',
                    'treasury', 'reserve', 'custodial', 'custody', 'escrow',
                    'otc', 'over the counter', 'desk', 'market maker', 'mm'
                ],
                services: [
                    // Other services
                    'tornado cash', 'tornado', 'mixer', 'tumbler', 'coinjoin',
                    'wasabi', 'samourai', 'blender', 'bitcoinfog', 'helix',
                    'chipmixer', 'bitcoin laundry', 'bitmix', 'cryptomixer',
                    'coinomize', 'anonymix', 'privcoin', 'bitcoin blender'
                ]
            };
        }

        // Check if a label suggests it might be an exchange/service
        function checkExchangeIndicators(labelName) {
            if (!labelName) return { isLikely: false, confidence: 0, matches: [] };

            const indicators = getExchangeIndicators();
            const labelLower = labelName.toLowerCase();
            const matches = [];
            let confidence = 0;

            // Check exact exchange matches
            for (const exchange of indicators.exchanges) {
                if (labelLower.includes(exchange)) {
                    matches.push({ type: 'CEX', name: exchange, confidence: 90 });
                    confidence = Math.max(confidence, 90);
                }
            }

            // Check DEX/Bridge matches
            for (const dex of indicators.dexBridges) {
                if (labelLower.includes(dex)) {
                    matches.push({ type: 'DEX/Bridge', name: dex, confidence: 85 });
                    confidence = Math.max(confidence, 85);
                }
            }

            // Check keyword matches
            for (const keyword of indicators.keywords) {
                if (labelLower.includes(keyword)) {
                    matches.push({ type: 'Keyword', name: keyword, confidence: 70 });
                    confidence = Math.max(confidence, 70);
                }
            }

            // Check mixer/tumbler services
            for (const service of indicators.services) {
                if (labelLower.includes(service)) {
                    matches.push({ type: 'Mixer', name: service, confidence: 95 });
                    confidence = Math.max(confidence, 95);
                }
            }

            return {
                isLikely: confidence >= 70,
                confidence: confidence,
                matches: matches,
                suggestedType: matches.length > 0 ? matches[0].type : null
            };
        }

        // General notification function
        function showNotification(message, type = 'info', duration = 3000) {
            let notification = document.getElementById('notification');
            if (!notification) {
                notification = document.createElement('div');
                notification.id = 'notification';
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    padding: 15px 25px;
                    border-radius: 8px;
                    font-size: 14px;
                    z-index: 10001;
                    opacity: 0;
                    transition: opacity 0.3s ease;
                    pointer-events: auto;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                    max-width: 400px;
                    word-wrap: break-word;
                `;
                document.body.appendChild(notification);
            }

            // Set color based on type
            const colors = {
                success: '#27ae60',
                error: '#e74c3c',
                warning: '#f39c12',
                info: '#3498db'
            };

            notification.style.background = colors[type] || colors.info;
            notification.style.color = 'white';
            notification.innerHTML = message; // Use innerHTML to support HTML content
            notification.style.opacity = '1';

            // Clear any existing timeout
            if (notification.hideTimeout) {
                clearTimeout(notification.hideTimeout);
            }

            notification.hideTimeout = setTimeout(() => {
                notification.style.opacity = '0';
            }, duration);
        }
        
        // Show terminal wallet notification
        function showTerminalWalletNotification(entityData, address, hopNumber, entryId) {
            // Create overlay
            const overlay = document.createElement('div');
            overlay.className = 'terminal-notification-overlay';
            overlay.onclick = () => closeTerminalNotification();
            
            // Create notification
            const notification = document.createElement('div');
            notification.className = 'terminal-notification';
            notification.innerHTML = `
                <div style="background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%); color: white; padding: 25px; border-radius: 12px 12px 0 0;">
                    <h2 style="margin: 0; font-size: 24px; display: flex; align-items: center; gap: 10px;">
                        VASP: Exchange Detected - Terminal Wallet
                    </h2>
                </div>
                
                <div style="padding: 30px;">
                    <div style="background: #f3e6ff; border: 2px solid #9b59b6; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
                        <h3 style="color: #9b59b6; margin: 0 0 10px 0;">${entityData.entity}</h3>
                        <p style="margin: 0; color: #555; font-size: 14px;">
                            <strong>Address:</strong> <code style="background: #fff; padding: 2px 6px; border-radius: 3px;">${address.substring(0, 20)}...${address.substring(address.length - 10)}</code><br>
                            <strong>Confidence:</strong> ${entityData.confidence.toUpperCase()}<br>
                            <strong>Source:</strong> ${entityData.source}
                        </p>
                    </div>
                    
                    <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
                        <h4 style="color: #856404; margin: 0 0 10px 0;">⚠️ Important: Terminal Wallet Considerations</h4>
                        <ul style="margin: 0; padding-left: 20px; color: #666;">
                            <li>This appears to be an <strong>exchange deposit address</strong></li>
                            <li>Funds sent here are typically <strong>commingled</strong> with other users' funds</li>
                            <li>You may need to <strong>serve legal process</strong> to the exchange for further tracing</li>
                            <li>Consider this a <strong>potential endpoint</strong> for this trace thread</li>
                        </ul>
                    </div>
                    
                    <div style="display: flex; gap: 15px; justify-content: center;">
                        <button class="btn btn-confirm" onclick="markAsTerminal(${hopNumber}, ${entryId})" style="background: #9b59b6; padding: 12px 30px; font-size: 16px;">
                            ✓ Mark as Terminal & Continue
                        </button>
                        <button class="btn btn-secondary" onclick="closeTerminalNotification()" style="padding: 12px 30px; font-size: 16px;">
                            Continue Tracing
                        </button>
                    </div>
                    
                    <p style="text-align: center; margin-top: 20px; color: #666; font-size: 12px;">
                        Tip: You can always change the classification later if needed
                    </p>
                </div>
            `;
            
            // Add to page
            document.body.appendChild(overlay);
            document.body.appendChild(notification);
        }
        
        function closeTerminalNotification() {
            const overlay = document.querySelector('.terminal-notification-overlay');
            const notification = document.querySelector('.terminal-notification');
            if (overlay) overlay.remove();
            if (notification) notification.remove();
        }
        
        function markAsTerminal(hopNumber, entryId) {
            // The wallet is already marked as purple, just close the notification
            closeTerminalNotification();
            
            // Optionally add a note about terminal status
            const hop = investigation.hops.find(h => h.hopNumber === hopNumber);
            if (hop) {
                const entry = hop.entries.find(e => e.id === entryId);
                if (entry) {
                    const currentNotes = entry.notes || '';
                    const terminalNote = 'TERMINAL: Exchange deposit - may require legal process for further tracing';
                    if (!currentNotes.includes('TERMINAL')) {
                        entry.notes = currentNotes ? `${currentNotes} | ${terminalNote}` : terminalNote;
                        saveToStorage();
                        renderHops();
                    }
                }
            }
        }
        
        // Welcome Screen and Onboarding Functions
        function checkOnboardingState() {
            const hasBasicInfo = investigation.caseId || investigation.investigator || investigation.caseType;
            const hasVictims = investigation.victims && investigation.victims.length > 0;
            const allTabs = document.querySelectorAll('.tab-content');
            const navTabs = document.querySelectorAll('.nav-tab');

            // Update tab states based on progress
            if (hasBasicInfo || hasVictims) {
                updateTabStates();
            } else {
                // Disable tabs except victims when no data
                navTabs.forEach((tab, index) => {
                    // Skip home button (index 0) and victims tab
                    if (index > 1) {
                        tab.style.opacity = '0.5';
                        tab.style.cursor = 'not-allowed';
                        tab.onclick = (e) => {
                            e.preventDefault();
                            alert('Please complete the victim transactions first before accessing this section.');
                        };
                    }
                });
            }
        }
        
        function updateTabStates() {
            const navTabs = document.querySelectorAll('.nav-tab');
            const hasVictims = investigation.victims && investigation.victims.length > 0;
            const hasRootTotal = investigation.rootTotalConfirmed;
            const hasHops = investigation.hops && investigation.hops.length > 0;
            
            navTabs.forEach((tab, index) => {
                const tabText = tab.textContent;
                
                // Always enable victims tab
                if (tabText.includes('Victims')) {
                    tab.style.opacity = '1';
                    tab.style.cursor = 'pointer';
                    tab.onclick = () => switchTab('victims');
                }
                // Enable traces tab only after root total confirmed
                else if (tabText.includes('Trace')) {
                    if (hasRootTotal) {
                        tab.style.opacity = '1';
                        tab.style.cursor = 'pointer';
                        tab.onclick = () => switchTab('traces');
                    } else {
                        tab.style.opacity = '0.5';
                        tab.style.cursor = 'not-allowed';
                        tab.onclick = (e) => {
                            e.preventDefault();
                            alert('Please confirm your root total before starting trace documentation.');
                        };
                    }
                }
                // Enable wallet indexes after some traces
                else if (tabText.includes('Wallet')) {
                    if (hasHops) {
                        tab.style.opacity = '1';
                        tab.style.cursor = 'pointer';
                        tab.onclick = () => switchTab('walletindexes');
                    } else {
                        tab.style.opacity = '0.5';
                        tab.style.cursor = 'not-allowed';
                        tab.onclick = (e) => {
                            e.preventDefault();
                            alert('Start documenting traces to build wallet indexes.');
                        };
                    }
                }
                // Enable summary after traces
                else if (tabText.includes('Summary')) {
                    if (hasHops) {
                        tab.style.opacity = '1';
                        tab.style.cursor = 'pointer';
                        tab.onclick = () => switchTab('summary');
                    } else {
                        tab.style.opacity = '0.5';
                        tab.style.cursor = 'not-allowed';
                        tab.onclick = (e) => {
                            e.preventDefault();
                            alert('Complete some trace documentation before accessing the summary.');
                        };
                    }
                }
            });
        }
        
        // Flow Diagram Functions
        function generateFlowDiagram() {
            // Check if the enhanced flow diagram function exists
            if (typeof generateHopCentricDAG === 'function') {
                // Use the new enhanced DAG visualization
                generateHopCentricDAG(investigation);
                return;
            }

            // Fallback to simple visualization if enhanced version not loaded
            const svg = document.getElementById('flowDiagramSVG');
            svg.innerHTML = ''; // Clear existing content

            if (!investigation.hops || investigation.hops.length === 0) {
                svg.innerHTML = '<text x="50%" y="50%" text-anchor="middle" fill="#999">No trace data available</text>';
                return;
            }

            // Configuration
            const walletColumnWidth = 200;
            const hopLaneWidth = 250;
            const nodeRadius = 20;
            const verticalSpacing = 80;
            const topMargin = 60;
            const bottomMargin = 100;
            const leftMargin = 20;

            // Calculate dimensions
            const numHops = investigation.hops.length;
            const totalWidth = leftMargin + walletColumnWidth + (numHops * hopLaneWidth) + 50;

            // Calculate total height needed
            let yPosition = topMargin + 40; // Start position after titles
            const walletPositions = new Map();

            // Map all wallet positions
            investigation.victims.forEach((victim, idx) => {
                const walletId = `V${victim.id}`;
                walletPositions.set(walletId, yPosition);
                yPosition += verticalSpacing;
            });

            // Add spacing between victims and other wallets
            yPosition += 30;

            // Map all unique wallets from hops
            const processedWallets = new Set();
            investigation.hops.forEach(hop => {
                hop.entries.filter(e => !e.isWriteoff).forEach(entry => {
                    const walletKey = `${entry.toWallet}-${entry.toWalletType}`;
                    if (!processedWallets.has(walletKey)) {
                        processedWallets.add(walletKey);
                        walletPositions.set(walletKey, yPosition);
                        yPosition += verticalSpacing;
                    }
                });
            });

            const totalHeight = yPosition + bottomMargin;
            
            // Set SVG dimensions
            svg.setAttribute('width', totalWidth);
            svg.setAttribute('height', totalHeight);
            svg.setAttribute('viewBox', `0 0 ${totalWidth} ${totalHeight}`);
            
            // Draw hop lanes (colored backgrounds)
            for (let i = 0; i < numHops; i++) {
                const laneX = leftMargin + walletColumnWidth + (i * hopLaneWidth);
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', laneX);
                rect.setAttribute('y', 0);
                rect.setAttribute('width', hopLaneWidth);
                rect.setAttribute('height', totalHeight);
                rect.setAttribute('class', `flow-hop-lane flow-hop-lane-${(i % 5) + 1}`);
                svg.appendChild(rect);
                
                // Hop title
                const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                title.setAttribute('x', laneX + hopLaneWidth / 2);
                title.setAttribute('y', 30);
                title.setAttribute('text-anchor', 'middle');
                title.setAttribute('class', 'flow-hop-title');
                title.textContent = `HOP ${i + 1}`;
                svg.appendChild(title);
            }
            
            // Draw all wallets on the left side
            const walletData = [];
            
            // Draw victim wallets (RED)
            investigation.victims.forEach(victim => {
                const walletId = `V${victim.id}`;
                const y = walletPositions.get(walletId);
                const totalAmount = victim.transactions.reduce((sum, t) => sum + parseFloat(t.amount || 0), 0);
                
                // Red circle
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', leftMargin + walletColumnWidth / 2);
                circle.setAttribute('cy', y);
                circle.setAttribute('r', nodeRadius);
                circle.setAttribute('class', 'flow-wallet-node');
                circle.setAttribute('fill', '#e74c3c');
                circle.onclick = () => showWalletDetails({
                    address: victim.transactions[0]?.receivingWallet || 'Unknown',
                    type: 'victim',
                    notation: `V-${victim.id}`
                });
                svg.appendChild(circle);
                
                // Wallet number inside circle
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', leftMargin + walletColumnWidth / 2);
                label.setAttribute('y', y + 5);
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('class', 'flow-wallet-label');
                label.textContent = victim.id;
                svg.appendChild(label);
                
                // Wallet address to the right of circle
                const addressText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                addressText.setAttribute('x', leftMargin + walletColumnWidth / 2 + nodeRadius + 10);
                addressText.setAttribute('y', y + 5);
                addressText.setAttribute('text-anchor', 'start');
                addressText.setAttribute('font-size', '11px');
                addressText.setAttribute('fill', '#666');
                const address = victim.transactions[0]?.receivingWallet || 'Unknown';
                addressText.textContent = address.length > 20 ? address.substring(0, 8) + '...' + address.slice(-6) : address;
                svg.appendChild(addressText);
                
                walletData.push({
                    id: walletId,
                    x: leftMargin + walletColumnWidth / 2,
                    y: y,
                    amount: totalAmount,
                    type: 'victim'
                });
            });
            
            // Draw hop wallets
            const walletsByAddress = new Map();
            investigation.hops.forEach(hop => {
                hop.entries.filter(e => !e.isWriteoff).forEach(entry => {
                    const walletKey = `${entry.toWallet}-${entry.toWalletType}`;
                    if (!walletsByAddress.has(walletKey)) {
                        const y = walletPositions.get(walletKey);
                        
                        // Wallet circle
                        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        circle.setAttribute('cx', leftMargin + walletColumnWidth / 2);
                        circle.setAttribute('cy', y);
                        circle.setAttribute('r', nodeRadius);
                        circle.setAttribute('class', 'flow-wallet-node');
                        circle.setAttribute('fill', getWalletColor(entry.toWalletType));
                        circle.onclick = () => showWalletDetails({
                            address: entry.toWallet,
                            type: entry.toWalletType,
                            notation: entry.notation
                        });
                        svg.appendChild(circle);
                        
                        // Wallet notation inside circle
                        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        label.setAttribute('x', leftMargin + walletColumnWidth / 2);
                        label.setAttribute('y', y + 5);
                        label.setAttribute('text-anchor', 'middle');
                        label.setAttribute('class', 'flow-wallet-label');
                        // Extract number from notation (e.g., "V1-T1-H1" -> "1")
                        const hopNum = entry.notation ? entry.notation.split('-H')[1] : '';
                        label.textContent = hopNum || '';
                        svg.appendChild(label);
                        
                        // Wallet entity name if known
                        if (entry.entityName) {
                            const entityText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            entityText.setAttribute('x', leftMargin + walletColumnWidth / 2 + nodeRadius + 10);
                            entityText.setAttribute('y', y + 5);
                            entityText.setAttribute('text-anchor', 'start');
                            entityText.setAttribute('font-size', '11px');
                            entityText.setAttribute('fill', '#666');
                            entityText.setAttribute('font-weight', 'bold');
                            entityText.textContent = entry.entityName;
                            svg.appendChild(entityText);
                        }
                        
                        walletsByAddress.set(walletKey, {
                            x: leftMargin + walletColumnWidth / 2,
                            y: y,
                            type: entry.toWalletType,
                            notation: entry.notation
                        });
                    }
                });
            });
            
            // Draw connections and amounts
            const hopSums = [];
            
            investigation.hops.forEach((hop, hopIndex) => {
                const laneX = leftMargin + walletColumnWidth + (hopIndex * hopLaneWidth);
                const laneCenterX = laneX + hopLaneWidth / 2;
                
                hop.entries.forEach(entry => {
                    if (entry.isWriteoff) {
                        // Track writeoffs separately for display
                        if (!hopSums[hopIndex]) hopSums[hopIndex] = { total: 0, writeoffs: 0 };
                        hopSums[hopIndex].writeoffs += parseFloat(entry.amount || 0);
                        return;
                    }
                    
                    // Initialize hop sum if needed
                    if (!hopSums[hopIndex]) hopSums[hopIndex] = { total: 0, writeoffs: 0 };
                    
                    // Find source wallet position
                    let sourceY;
                    if (entry.sourceThread) {
                        // Check if it's from a victim
                        const victimMatch = entry.sourceThread.match(/V-(\d+)/);
                        if (victimMatch) {
                            sourceY = walletPositions.get(`V${victimMatch[1]}`);
                        } else {
                            // Find the source hop entry
                            for (let i = hopIndex - 1; i >= 0; i--) {
                                const sourceHop = investigation.hops[i];
                                const sourceEntry = sourceHop.entries.find(e => e.notation === entry.sourceThread);
                                if (sourceEntry) {
                                    const sourceKey = `${sourceEntry.toWallet}-${sourceEntry.toWalletType}`;
                                    sourceY = walletPositions.get(sourceKey);
                                    break;
                                }
                            }
                        }
                    }
                    
                    // Find destination wallet position
                    const destKey = `${entry.toWallet}-${entry.toWalletType}`;
                    const destY = walletPositions.get(destKey);
                    
                    if (sourceY && destY) {
                        // Draw straight line
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', leftMargin + walletColumnWidth / 2 + nodeRadius);
                        line.setAttribute('y1', sourceY);
                        line.setAttribute('x2', laneCenterX);
                        line.setAttribute('y2', destY);
                        line.setAttribute('class', 'flow-connection-line');
                        svg.appendChild(line);
                        
                        // Add amount text on the line
                        const amountText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        amountText.setAttribute('x', laneCenterX - 10);
                        amountText.setAttribute('y', destY - 5);
                        amountText.setAttribute('text-anchor', 'end');
                        amountText.setAttribute('class', 'flow-thread-amount');
                        amountText.textContent = formatCurrency(parseFloat(entry.amount || 0));
                        svg.appendChild(amountText);
                    }
                    
                    // Add to hop sum
                    hopSums[hopIndex].total += parseFloat(entry.amount || 0);
                });
                
                // Draw sum at bottom of hop lane
                const sumData = hopSums[hopIndex] || { total: 0, writeoffs: 0 };
                const sumText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                sumText.setAttribute('x', laneCenterX);
                sumText.setAttribute('y', totalHeight - 30);
                sumText.setAttribute('text-anchor', 'middle');
                sumText.setAttribute('class', 'flow-sum-text');
                sumText.textContent = formatCurrency(sumData.total);
                svg.appendChild(sumText);
                
                // Show writeoffs if any
                if (sumData.writeoffs > 0) {
                    const writeoffText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    writeoffText.setAttribute('x', laneCenterX);
                    writeoffText.setAttribute('y', totalHeight - 10);
                    writeoffText.setAttribute('text-anchor', 'middle');
                    writeoffText.setAttribute('font-size', '12px');
                    writeoffText.setAttribute('fill', '#666');
                    writeoffText.textContent = `(${formatCurrency(sumData.writeoffs)}) WO`;
                    svg.appendChild(writeoffText);
                }
                
                // Add "SUM:" label
                const sumLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                sumLabel.setAttribute('x', laneCenterX);
                sumLabel.setAttribute('y', totalHeight - 50);
                sumLabel.setAttribute('text-anchor', 'middle');
                sumLabel.setAttribute('font-size', '14px');
                sumLabel.setAttribute('fill', '#666');
                sumLabel.textContent = 'SUM:';
                svg.appendChild(sumLabel);
            });
        }
        
        // DUPLICATE FUNCTION REMOVED - Using the global version at line 9714
        /*function getWalletColor(type) {
            const colors = {
                'victim': '#e74c3c',
                'red': '#e74c3c',
                'purple': '#9b59b6',
                'blue': '#3498db',
                'green': '#27ae60',
                'unknown': '#95a5a6'
            };
            return colors[type] || colors.unknown;
        }*/
        
        
        function showWalletDetails(walletData) {
            alert(`Wallet: ${walletData.address || 'Unknown'}\nType: ${walletData.type}\nNotation: ${walletData.notation || 'N/A'}`);
        }
        
        // Generate BATS Training Example Visualization
        function generateBATSTrainingExample() {
            const svg = document.getElementById('flowDiagramSVG');
            svg.innerHTML = ''; // Clear existing content
            
            // Configuration
            const walletColumnWidth = 250;
            const hopLaneWidth = 300;
            const nodeRadius = 25;
            const verticalSpacing = 100;
            const topMargin = 80;
            const bottomMargin = 120;
            const leftMargin = 20;
            
            // Example data structure
            const exampleData = {
                victims: [
                    { id: 1, wallet: '0xVictim1...ABC', amount: 50000, label: 'Exchange Hack Victim' },
                    { id: 2, wallet: '0xVictim2...DEF', amount: 75000, label: 'DeFi Protocol Hack' },
                    { id: 3, wallet: '0xVictim3...GHI', amount: 25000, label: 'Phishing Victim' }
                ],
                hops: [
                    {
                        number: 1,
                        entries: [
                            { from: 'V1', to: '0xHub1...123', amount: 50000, type: 'purple', label: 'Hub Wallet', notation: 'V1-T1-H1' },
                            { from: 'V2', to: '0xHub1...123', amount: 75000, type: 'purple', label: 'Hub Wallet', notation: 'V2-T1-H1' },
                            { from: 'V3', to: '0xCold1...456', amount: 25000, type: 'gray', label: 'Cold Storage', notation: 'V3-T1-H1' }
                        ]
                    },
                    {
                        number: 2,
                        entries: [
                            { from: 'V1-T1-H1', to: '0xExchange1...789', amount: 45000, type: 'blue', label: 'Binance', notation: 'V1-T1-H2', entity: true },
                            { from: 'V1-T1-H1', to: '0xMixer...ABC', amount: 5000, type: 'red', label: 'Mixer', notation: 'V1-T1-H2', writeoff: true },
                            { from: 'V2-T1-H1', to: '0xExchange2...DEF', amount: 70000, type: 'blue', label: 'Coinbase', notation: 'V2-T1-H2', entity: true },
                            { from: 'V2-T1-H1', to: '0xUnknown...123', amount: 5000, type: 'red', label: 'Unknown', notation: 'V2-T1-H2', writeoff: true }
                        ]
                    },
                    {
                        number: 3,
                        entries: [
                            { from: 'V1-T1-H2', to: '0xExchange3...GHI', amount: 40000, type: 'blue', label: 'Kraken', notation: 'V1-T1-H3', entity: true },
                            { from: 'V1-T1-H2', to: '0xCold2...JKL', amount: 5000, type: 'gray', label: 'Cold Storage', notation: 'V1-T1-H3' },
                            { from: 'V2-T1-H2', to: '0xExchange3...GHI', amount: 70000, type: 'blue', label: 'Kraken', notation: 'V2-T1-H3', entity: true }
                        ]
                    }
                ]
            };
            
            // Calculate dimensions
            const numHops = exampleData.hops.length;
            const totalWidth = leftMargin + walletColumnWidth + (numHops * hopLaneWidth) + 50;
            const totalHeight = topMargin + (8 * verticalSpacing) + bottomMargin;
            
            // Set SVG dimensions
            svg.setAttribute('width', totalWidth);
            svg.setAttribute('height', totalHeight);
            svg.setAttribute('viewBox', `0 0 ${totalWidth} ${totalHeight}`);
            
            // Add title
            const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            title.setAttribute('x', totalWidth / 2);
            title.setAttribute('y', 30);
            title.setAttribute('text-anchor', 'middle');
            title.setAttribute('font-size', '24px');
            title.setAttribute('font-weight', 'bold');
            title.setAttribute('fill', '#2c3e50');
            title.textContent = 'BATS Training Example - Multiple Principles';
            svg.appendChild(title);
            
            // Draw hop lanes
            for (let i = 0; i < numHops; i++) {
                const laneX = leftMargin + walletColumnWidth + (i * hopLaneWidth);
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', laneX);
                rect.setAttribute('y', 50);
                rect.setAttribute('width', hopLaneWidth);
                rect.setAttribute('height', totalHeight - 70);
                rect.setAttribute('class', `flow-hop-lane flow-hop-lane-${(i % 5) + 1}`);
                svg.appendChild(rect);
                
                // Hop title
                const hopTitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                hopTitle.setAttribute('x', laneX + hopLaneWidth / 2);
                hopTitle.setAttribute('y', 75);
                hopTitle.setAttribute('text-anchor', 'middle');
                hopTitle.setAttribute('class', 'flow-hop-title');
                hopTitle.textContent = `HOP ${i + 1}`;
                svg.appendChild(hopTitle);
            }
            
            // Draw victim wallets
            let yPosition = topMargin + 50;
            exampleData.victims.forEach((victim, idx) => {
                // Red circle
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', leftMargin + 40);
                circle.setAttribute('cy', yPosition);
                circle.setAttribute('r', nodeRadius);
                circle.setAttribute('class', 'flow-wallet-node');
                circle.setAttribute('fill', '#e74c3c');
                svg.appendChild(circle);
                
                // Victim number
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', leftMargin + 40);
                label.setAttribute('y', yPosition + 5);
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('fill', 'white');
                label.setAttribute('font-weight', 'bold');
                label.textContent = victim.id;
                svg.appendChild(label);
                
                // Description
                const desc = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                desc.setAttribute('x', leftMargin + 75);
                desc.setAttribute('y', yPosition + 5);
                desc.setAttribute('font-size', '12px');
                desc.setAttribute('fill', '#666');
                desc.textContent = victim.label;
                svg.appendChild(desc);
                
                yPosition += verticalSpacing;
            });
            
            // Add legend
            const legendY = yPosition + 20;
            const legendItems = [
                { color: '#e74c3c', label: 'RED - Victim/High Risk' },
                { color: '#9b59b6', label: 'PURPLE - Hub Wallet' },
                { color: '#3498db', label: 'BLUE - Exchange/Service' },
                { color: '#95a5a6', label: 'GRAY - Cold Storage' }
            ];
            
            legendItems.forEach((item, idx) => {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', leftMargin + 40);
                circle.setAttribute('cy', legendY + (idx * 30));
                circle.setAttribute('r', 10);
                circle.setAttribute('fill', item.color);
                svg.appendChild(circle);
                
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', leftMargin + 60);
                text.setAttribute('y', legendY + (idx * 30) + 5);
                text.setAttribute('font-size', '12px');
                text.setAttribute('fill', '#2c3e50');
                text.textContent = item.label;
                svg.appendChild(text);
            });
            
            // Draw hop wallets and connections
            const walletPositions = new Map();
            let currentY = topMargin + 50;
            
            // Position all wallets
            exampleData.hops.forEach((hop, hopIdx) => {
                const uniqueWallets = new Map();
                hop.entries.forEach(entry => {
                    if (!entry.writeoff && !uniqueWallets.has(entry.to)) {
                        uniqueWallets.set(entry.to, { type: entry.type, label: entry.label, entity: entry.entity });
                    }
                });
                
                uniqueWallets.forEach((wallet, address) => {
                    if (!walletPositions.has(address)) {
                        walletPositions.set(address, { y: currentY, ...wallet });
                        currentY += verticalSpacing * 0.8;
                    }
                });
            });
            
            // Draw wallet nodes
            walletPositions.forEach((wallet, address) => {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', leftMargin + walletColumnWidth - 50);
                circle.setAttribute('cy', wallet.y);
                circle.setAttribute('r', nodeRadius);
                circle.setAttribute('class', 'flow-wallet-node');
                circle.setAttribute('fill', getWalletColor(wallet.type));
                svg.appendChild(circle);
                
                // Wallet type icon/number
                const icon = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                icon.setAttribute('x', leftMargin + walletColumnWidth - 50);
                icon.setAttribute('y', wallet.y + 5);
                icon.setAttribute('text-anchor', 'middle');
                icon.setAttribute('fill', 'white');
                icon.setAttribute('font-weight', 'bold');
                icon.textContent = wallet.entity ? 'E' : wallet.type === 'gray' ? 'C' : 'H';
                svg.appendChild(icon);
                
                // Wallet label
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', leftMargin + walletColumnWidth - 15);
                label.setAttribute('y', wallet.y + 5);
                label.setAttribute('font-size', '12px');
                label.setAttribute('fill', '#2c3e50');
                label.setAttribute('font-weight', wallet.entity ? 'bold' : 'normal');
                label.textContent = wallet.label;
                svg.appendChild(label);
            });
            
            // Draw connections and amounts
            exampleData.hops.forEach((hop, hopIdx) => {
                const laneX = leftMargin + walletColumnWidth + (hopIdx * hopLaneWidth);
                const laneCenterX = laneX + hopLaneWidth / 2;
                let hopTotal = 0;
                let hopWriteoffs = 0;
                
                hop.entries.forEach(entry => {
                    let sourceY;
                    
                    // Find source position
                    if (entry.from.startsWith('V')) {
                        const victimId = parseInt(entry.from.substring(1));
                        sourceY = topMargin + 50 + ((victimId - 1) * verticalSpacing);
                    } else {
                        // Find from previous hop
                        for (let i = hopIdx - 1; i >= 0; i--) {
                            const prevHop = exampleData.hops[i];
                            const prevEntry = prevHop.entries.find(e => e.notation === entry.from);
                            if (prevEntry) {
                                sourceY = walletPositions.get(prevEntry.to)?.y;
                                break;
                            }
                        }
                    }
                    
                    if (entry.writeoff) {
                        hopWriteoffs += entry.amount;
                        
                        // Draw writeoff notation
                        const writeoffText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        writeoffText.setAttribute('x', laneCenterX);
                        writeoffText.setAttribute('y', sourceY);
                        writeoffText.setAttribute('text-anchor', 'middle');
                        writeoffText.setAttribute('font-size', '12px');
                        writeoffText.setAttribute('fill', '#e74c3c');
                        writeoffText.setAttribute('font-weight', 'bold');
                        writeoffText.textContent = `Write-off: ${formatCurrency(entry.amount)} (${entry.label})`;
                        svg.appendChild(writeoffText);
                    } else {
                        hopTotal += entry.amount;
                        const destY = walletPositions.get(entry.to)?.y;
                        
                        if (sourceY && destY) {
                            // Draw line
                            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                            line.setAttribute('x1', entry.from.startsWith('V') ? leftMargin + 65 : leftMargin + walletColumnWidth - 25);
                            line.setAttribute('y1', sourceY);
                            line.setAttribute('x2', laneCenterX);
                            line.setAttribute('y2', destY);
                            line.setAttribute('class', 'flow-connection-line');
                            svg.appendChild(line);
                            
                            // Amount on line
                            const amountText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            amountText.setAttribute('x', laneCenterX - 10);
                            amountText.setAttribute('y', destY - 5);
                            amountText.setAttribute('text-anchor', 'end');
                            amountText.setAttribute('class', 'flow-thread-amount');
                            amountText.textContent = formatCurrency(entry.amount);
                            svg.appendChild(amountText);
                        }
                    }
                });
                
                // Draw hop totals
                const sumY = totalHeight - 60;
                const sumText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                sumText.setAttribute('x', laneCenterX);
                sumText.setAttribute('y', sumY);
                sumText.setAttribute('text-anchor', 'middle');
                sumText.setAttribute('class', 'flow-sum-text');
                sumText.textContent = formatCurrency(hopTotal);
                svg.appendChild(sumText);
                
                if (hopWriteoffs > 0) {
                    const writeoffSumText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    writeoffSumText.setAttribute('x', laneCenterX);
                    writeoffSumText.setAttribute('y', sumY + 20);
                    writeoffSumText.setAttribute('text-anchor', 'middle');
                    writeoffSumText.setAttribute('font-size', '12px');
                    writeoffSumText.setAttribute('fill', '#e74c3c');
                    writeoffSumText.textContent = `WO: (${formatCurrency(hopWriteoffs)})`;
                    svg.appendChild(writeoffSumText);
                }
                
                // Sum label
                const sumLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                sumLabel.setAttribute('x', laneCenterX);
                sumLabel.setAttribute('y', sumY - 20);
                sumLabel.setAttribute('text-anchor', 'middle');
                sumLabel.setAttribute('font-size', '14px');
                sumLabel.setAttribute('fill', '#666');
                sumLabel.textContent = 'SUM:';
                svg.appendChild(sumLabel);
            });
            
            // Add explanatory notes
            const notesY = totalHeight - 30;
            const notes = [
                'Hub Wallets (Purple): Consolidate funds from multiple sources',
                'Cold Storage (Gray): Long-term storage, harder to trace',
                'Exchanges (Blue): Known entities, potential recovery points',
                'Write-offs (Red): Lost/untraceable funds, reduce ART'
            ];
            
            notes.forEach((note, idx) => {
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', leftMargin);
                text.setAttribute('y', notesY + (idx * 15));
                text.setAttribute('font-size', '11px');
                text.setAttribute('fill', '#666');
                text.textContent = `• ${note}`;
                svg.appendChild(text);
            });
        }
        
        function exportFlowDiagram(format) {
            const svg = document.getElementById('flowDiagramSVG');
            
            if (format === 'svg') {
                const svgData = new XMLSerializer().serializeToString(svg);
                const blob = new Blob([svgData], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `BATS_Flow_${investigation.caseId || 'Diagram'}.svg`;
                a.click();
                URL.revokeObjectURL(url);
            } else if (format === 'png') {
                // Convert SVG to PNG
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                const svgData = new XMLSerializer().serializeToString(svg);
                const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
                const url = URL.createObjectURL(svgBlob);
                
                img.onload = function() {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                    
                    canvas.toBlob(function(blob) {
                        const a = document.createElement('a');
                        a.href = URL.createObjectURL(blob);
                        a.download = `BATS_Flow_${investigation.caseId || 'Diagram'}.png`;
                        a.click();
                    });
                    
                    URL.revokeObjectURL(url);
                };
                
                img.src = url;
            }
        }
        
        function printFlowDiagram() {
            window.print();
        }
        
        // Function to show landing page
        function showLandingPage() {
            // Hide entire app container
            const appContainer = document.querySelector('.container');
            if (appContainer) {
                appContainer.style.display = 'none';
            }

            // Show landing page container
            const landingContainer = document.getElementById('landingPageContainer');
            if (landingContainer) {
                landingContainer.style.display = 'block';
            }

            // Keep modals accessible
            const pkModal = document.getElementById('pkConverterModal');
            if (pkModal) {
                pkModal.style.position = 'fixed';
                pkModal.style.zIndex = '10001';
            }
            const addressModal = document.getElementById('addressFinderModal');
            if (addressModal) {
                addressModal.style.position = 'fixed';
                addressModal.style.zIndex = '10001';
            }
        }

        function showAppUI() {
            // Hide landing page container
            const landingContainer = document.getElementById('landingPageContainer');
            if (landingContainer) {
                landingContainer.style.display = 'none';
            }

            // Show app container
            const appContainer = document.querySelector('.container');
            if (appContainer) {
                appContainer.style.display = 'block';
            }

            // Show investigation tracker
            const tracker = document.querySelector('.investigation-step-tracker');
            if (tracker) tracker.style.display = 'block';

            // Show nav tabs
            const navTabs = document.getElementById('mainNavTabs');
            if (navTabs) navTabs.style.display = 'flex';

            // Show case details sidebar
            const sidebar = document.querySelector('.case-details-sidebar');
            if (sidebar) sidebar.style.display = 'block';

            // Show action bar
            const actionBar = document.querySelector('div[style*="Undo"]');
            if (actionBar && actionBar.parentElement) {
                actionBar.parentElement.style.display = 'flex';
            }
        }

        // Legacy function to show welcome screen
        function showWelcomeScreen() {
            showLandingPage();
        }
        
        // Quick start from welcome screen
        function quickStartInvestigation() {
            const caseId = document.getElementById('welcomeCaseId').value.trim();
            const investigator = document.getElementById('welcomeInvestigator').value.trim();
            const caseType = document.getElementById('welcomeCaseType').value;
            
            if (!caseId || !investigator || !caseType) {
                // Highlight missing fields
                if (!caseId) document.getElementById('welcomeCaseId').style.borderColor = '#e74c3c';
                if (!investigator) document.getElementById('welcomeInvestigator').style.borderColor = '#e74c3c';
                if (!caseType) document.getElementById('welcomeCaseType').style.borderColor = '#e74c3c';
                
                alert('Please fill in all required fields');
                return;
            }
            
            // Get synopsis value
            const caseSynopsis = document.getElementById('welcomeCaseSynopsis').value.trim();
            
            // Save to investigation object
            investigation.caseId = caseId;
            investigation.investigator = investigator;
            investigation.caseType = caseType;
            investigation.caseSynopsis = caseSynopsis;
            investigation.setupComplete = true;
            
            // Update main form fields
            document.getElementById('caseId').value = caseId;
            document.getElementById('investigator').value = investigator;
            document.getElementById('caseType').value = caseType;
            document.getElementById('caseSynopsis').value = caseSynopsis;
            
            // Save to storage
            saveToStorage();
            
            // Hide welcome screen
            document.getElementById('landingPageContainer').style.display = 'none';
            
            // Switch to victims tab
            switchTab('victims');
            
            // Auto-collapse setup card
            setTimeout(() => {
                const setupContent = document.getElementById('setupContent');
                if (setupContent && setupContent.style.display !== 'none') {
                    toggleSetupCard();
                }
                
                // Focus on add victim button
                const addVictimBtn = document.querySelector('button[onclick="addVictim()"]');
                if (addVictimBtn) {
                    addVictimBtn.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    // Add pulsing animation
                    addVictimBtn.style.animation = 'pulse 2s infinite';
                    addVictimBtn.style.boxShadow = '0 0 20px rgba(255, 152, 0, 0.5)';
                }
            }, 300);
        }
        
        // Skip welcome screen
        function skipWelcome() {
            document.getElementById('landingPageContainer').style.display = 'none';
            switchTab('victims');
        }

        function startBATSDocumentation() {
            // Navigate to the app URL instead of trying to initialize here
            // This ensures a clean separation between landing page and app
            const currentUrl = new URL(window.location.href);
            currentUrl.searchParams.set('app', 'true');
            window.location.href = currentUrl.toString();
        }

        function returnToLanding() {
            if (confirm('Return to landing page? Your work is auto-saved.')) {
                // Navigate back to the landing page by removing the app parameter
                const currentUrl = new URL(window.location.href);
                currentUrl.searchParams.delete('app');
                window.location.href = currentUrl.toString();
            }
        }

        function showQuickStartGuide() {
            alert('B.A.T.S. Quick Start Guide\n\n' +
                  '1. V-T-H Notation:\n' +
                  '   V = Victim identifier (V1, V2, etc.)\n' +
                  '   T = Transaction number (T1, T2, etc.)\n' +
                  '   H = Hop level (H1, H2, etc.)\n\n' +
                  '2. ART System:\n' +
                  '   Track Available Running Total at each hop\n' +
                  '   Document amounts traced vs. remaining\n\n' +
                  '3. Documentation Requirements:\n' +
                  '   - Screenshot all transactions\n' +
                  '   - Note timestamps and fees\n' +
                  '   - Document wallet attributions\n' +
                  '   - Maintain chain of custody\n\n' +
                  'For full training, open the B.A.T.S. Training page from the utility tools.');
        }
        
        function startInvestigation() {
            // Check if case details are filled
            const caseId = document.getElementById('caseId').value;
            const investigator = document.getElementById('investigator').value;
            const caseType = document.getElementById('caseType').value;
            
            if (!caseId || !investigator || !caseType) {
                alert('Please fill in the case details in the left sidebar first:\n- Case ID\n- Investigator Name\n- Case Type');
                
                // Highlight the fields
                if (!caseId) document.getElementById('caseId').style.borderColor = '#e74c3c';
                if (!investigator) document.getElementById('investigator').style.borderColor = '#e74c3c';
                if (!caseType) document.getElementById('caseType').style.borderColor = '#e74c3c';
                
                // Reset field highlighting after 3 seconds
                setTimeout(() => {
                    document.getElementById('caseId').style.borderColor = '';
                    document.getElementById('investigator').style.borderColor = '';
                    document.getElementById('caseType').style.borderColor = '';
                }, 3000);
                
                return;
            }
            
            // Hide welcome screen and show victims tab
            document.getElementById('landingPageContainer').style.display = 'none';
            switchTab('victims');
            
            // Focus on add victim button
            setTimeout(() => {
                const addVictimBtn = document.querySelector('button[onclick="addVictim()"]');
                if (addVictimBtn) {
                    addVictimBtn.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    addVictimBtn.style.animation = 'pulse 2s infinite';
                }
            }, 300);
        }

        // Save case details from Case Details tab
        function saveCaseDetails() {
            const caseId = document.getElementById('caseId').value.trim();
            const investigator = document.getElementById('investigator').value.trim();
            const caseType = document.getElementById('caseType').value;
            const caseSynopsis = document.getElementById('caseSynopsis').value.trim();

            // Validate required fields
            if (!caseId || !investigator || !caseType) {
                alert('Please fill in all required fields (Case ID, Investigator, and Case Type)');
                return;
            }

            // Update investigation object
            investigation.caseId = caseId;
            investigation.investigator = investigator;
            investigation.caseType = caseType;
            investigation.caseSynopsis = caseSynopsis;

            // Mark as complete if all required fields are filled
            if (caseId && investigator && caseType) {
                investigation.setupComplete = true;
            }

            // Save to storage
            saveToStorage();

            // Show success message with next step
            alert('✅ Case details saved successfully!\n\nClick "Next: Add Victims" to continue your investigation.');

            // Update stats
            updateCaseStats();

            // Show the next step button
            showNextStepButton();
        }
        
        // Check if setup is complete
        function isSetupComplete() {
            // First check the saved state
            if (investigation.setupComplete) {
                return true;
            }
            
            // Otherwise check current form values
            const caseId = document.getElementById('caseId').value;
            const investigator = document.getElementById('investigator').value;
            const caseType = document.getElementById('caseType').value;
            const caseSynopsis = document.getElementById('caseSynopsis').value;
            
            return caseId && investigator && caseType && caseSynopsis;
        }
        
        // Update case statistics
        function updateCaseStats() {
            const statsContainer = document.getElementById('caseStats');
            if (!statsContainer) return;
            
            const totalVictims = investigation.victims.length;
            const totalTransactions = investigation.victims.reduce((sum, v) => sum + v.transactions.length, 0);
            const totalHops = investigation.hops.length;
            const totalWallets = investigation.universalWalletIndex.length;
            
            // Calculate total traced amounts
            let totalTracedAmounts = {};
            investigation.victims.forEach(victim => {
                victim.transactions.forEach(tx => {
                    const currency = tx.customCurrency || tx.currency;
                    totalTracedAmounts[currency] = (totalTracedAmounts[currency] || 0) + parseFloat(tx.amount || 0);
                });
            });
            
            // Format amounts
            const amountsHtml = Object.entries(totalTracedAmounts)
                .map(([currency, amount]) => `<div>${formatCurrencyAmount(amount, currency)}</div>`)
                .join('');
            
            statsContainer.innerHTML = `
                <div style="background: #f8f9fa; border: 2px solid #3498db; padding: 20px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 2rem; font-weight: bold; color: #2c3e50;">${totalVictims}</div>
                    <div style="color: #7f8c8d;">Victims</div>
                </div>
                <div style="background: #f8f9fa; border: 2px solid #3498db; padding: 20px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 2rem; font-weight: bold; color: #2c3e50;">${totalTransactions}</div>
                    <div style="color: #7f8c8d;">Transactions</div>
                </div>
                <div style="background: #f8f9fa; border: 2px solid #3498db; padding: 20px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 2rem; font-weight: bold; color: #2c3e50;">${totalHops}</div>
                    <div style="color: #7f8c8d;">Hops Traced</div>
                </div>
                <div style="background: #f8f9fa; border: 2px solid #3498db; padding: 20px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 2rem; font-weight: bold; color: #2c3e50;">${totalWallets}</div>
                    <div style="color: #7f8c8d;">Wallets Tracked</div>
                </div>
                <div style="background: #e8f4f8; border: 2px solid #3498db; padding: 20px; border-radius: 8px; text-align: center; grid-column: span 2;">
                    <div style="font-size: 1.2rem; font-weight: bold; color: #2c3e50;">Total Traced:</div>
                    <div style="color: #3498db;">${amountsHtml || 'No amounts traced yet'}</div>
                </div>
            `;
        }
        
        // Helper function to toggle setup card (kept for compatibility)
        function toggleSetupCard() {
            // No longer needed since setup card is in its own tab
        }
        
        // Helper function to update setup card (kept for compatibility)
        function updateSetupCard() {
            // No longer needed since setup card is in its own tab
        }
        
        // Helper function to validate and proceed (kept for compatibility)
        function validateAndProceedSetup() {
            // This functionality is now handled by saveCaseDetails()
            saveCaseDetails();
            switchTab('victims');
            
            // Show success message
            setTimeout(() => {
                alert(' Investigation setup complete!\n\nNow add victim transactions to begin your investigation.');
            }, 100);
        }
        
        // Function to show next step button after saving case details
        function showNextStepButton() {
            const nextStepContainer = document.getElementById('nextStepContainer');
            if (nextStepContainer) {
                nextStepContainer.style.display = 'block';
                // Add pulsing animation to draw attention
                const nextButton = nextStepContainer.querySelector('button');
                if (nextButton) {
                    nextButton.style.animation = 'pulse 2s infinite';
                }
            }
        }

        // Make functions globally accessible
        window.validateAndProceedSetup = validateAndProceedSetup;
        window.saveCaseDetails = saveCaseDetails;
        window.updateCaseStats = updateCaseStats;
        window.showNextStepButton = showNextStepButton;
        window.lookupWizardTransaction = lookupWizardTransaction;
        window.selectWizardTransfer = selectWizardTransfer;

        // Define removeTransaction function if it doesn't exist
        function removeTransaction(victimId, transactionId) {
            const victim = investigation.victims.find(v => v.id === victimId);
            if (!victim) return;

            // Filter out the transaction
            victim.transactions = victim.transactions.filter(t => t.id !== transactionId);

            // Save and re-render
            saveToStorage();
            renderVictims();
            updateValidationStatus();
            updateWorkflowSteps();
        }

        // Expose victim-related functions globally so onclick handlers work
        window.addVictim = addVictim;
        window.completeVictim = completeVictim;
        window.reopenVictim = reopenVictim;
        window.removeVictim = removeVictim;
        window.addTransaction = addTransaction;
        window.updateTransaction = updateTransaction;
        window.removeTransaction = removeTransaction;
        window.fixVictimTransactionOrder = fixVictimTransactionOrder;
        window.openBulkTransactionModal = openBulkTransactionModal;
        window.updateTransactionCurrency = updateTransactionCurrency;

        // Expose wizard and PIFO functions
        window.applyPIFOAllocation = applyPIFOAllocation;
        window.applyPIFOToWizard = applyPIFOToWizard;
        window.lookupSwapTransaction = lookupSwapTransaction;
        window.toggleSwapThread = toggleSwapThread;
        window.updateSwapThreadAmount = updateSwapThreadAmount;
        window.setMaxSwapAmount = setMaxSwapAmount;
        window.setSwapType = setSwapType;
        window.swapWizardNext = swapWizardNext;
        window.swapWizardBack = swapWizardBack;
        window.closeSwapWizard = closeSwapWizard;
        window.showSwapWizardStep = showSwapWizardStep;
        window.createSwapEntry = createSwapEntry;
        window.setAllocationMode = setAllocationMode;
        window.applyMatchingAllocation = applyMatchingAllocation;
        window.updateWizardAllocation = updateWizardAllocation;
        window.setWizardMaxAllocation = setWizardMaxAllocation;

        // Expose hop management functions
        window.closeHopAndProceed = closeHopAndProceed;
        window.completeHopAndProceed = completeHopAndProceed;
        window.checkForUnaccountedThreads = checkForUnaccountedThreads;
        window.proceedToNextHop = proceedToNextHop;
        window.showThreadReviewModal = showThreadReviewModal;
        window.showNotification = showNotification;
        window.logBridgeOutput = logBridgeOutput;
        window.confirmBridgeOutput = confirmBridgeOutput;
        window.lookupBridgeDestTransaction = lookupBridgeDestTransaction;
        window.showBridgeTransferSelection = showBridgeTransferSelection;
        window.showBridgeTransferSelectionModal = showBridgeTransferSelectionModal;
        window.selectBridgeTransfer = selectBridgeTransfer;
        window.selectBridgeTransferFromModal = selectBridgeTransferFromModal;
        window.filterBridgeTransfers = filterBridgeTransfers;
        window.filterBridgeTransfersModal = filterBridgeTransfersModal;
        window.clearBridgeFilters = clearBridgeFilters;
        window.clearBridgeTransferFilters = clearBridgeTransferFilters;
        window.renderBridgeTransferCards = renderBridgeTransferCards;
        window.renderBridgeTransferModalCards = renderBridgeTransferModalCards;
        window.removeHopEntry = removeHopEntry;
        window.addNewHop = addNewHop;

        // Add event listeners to setup fields
        document.addEventListener('DOMContentLoaded', function() {
            // Load existing values if they exist
            if (investigation.caseId) document.getElementById('caseId').value = investigation.caseId;
            if (investigation.investigator) document.getElementById('investigator').value = investigation.investigator;
            if (investigation.caseType) document.getElementById('caseType').value = investigation.caseType;

            // If case details are already complete, show the next step button
            if (investigation.setupComplete) {
                setTimeout(() => {
                    showNextStepButton();
                }, 500);
            }
            if (investigation.caseSynopsis) document.getElementById('caseSynopsis').value = investigation.caseSynopsis;
            
            // Update card appearance on load
            updateSetupCard();
        });

        // ============================================
        // GRAPH VISUALIZATION SYSTEM
        // ============================================

        let graphState = {
            zoom: 1,
            translateX: 0,
            translateY: 0,
            isDragging: false,
            dragStartX: 0,
            dragStartY: 0,
            showLabels: true,
            showAmounts: true,
            nodes: [],
            edges: [],
            selectedNode: null,
            collapsedHops: new Set(),  // Track which hops are collapsed
            detailLevel: 'medium',      // 'overview', 'medium', 'detailed'
            textNotes: [],              // Array of text notes on the graph
            nextNoteId: 1               // ID counter for notes
        };

        // Initialize the graph visualization
        function initializeGraphVisualization() {
            console.log('Initializing graph visualization...');

            // Build graph data from investigation
            buildGraphData();

            // Render the graph
            renderGraph();

            // Setup event handlers
            setupGraphInteraction();

            // Update statistics
            updateGraphStatistics();

            // Fit to screen initially
            setTimeout(fitToScreen, 100);
        }

        // Build T-account DAG - ONLY show receiving wallets per hop
        function buildGraphData() {
            graphState.nodes = [];
            graphState.edges = [];
            graphState.hopLayers = [];
            let nodeId = 0;

            // Track wallet nodes by address and hop for connection
            const walletNodeMap = {};

            // Create Hop 0 - Victim RED wallets (receiving wallets)
            const hop0Nodes = [];

            // Add victim RED wallet nodes (these are the initial receiving wallets)
            investigation.victims?.forEach(victim => {
                victim.transactions?.forEach(tx => {
                    const nodeKey = `hop0_${tx.receivingWallet}`;

                    // Check if this wallet already exists in hop 0
                    let node = walletNodeMap[nodeKey];
                    if (!node) {
                        node = {
                            id: nodeKey,
                            uniqueId: nodeId++,
                            label: getWalletLabel(tx.receivingWallet, 'red'),
                            type: 'red',
                            wallet: tx.receivingWallet,
                            hopNumber: 0,
                            threads: [],
                            totalIn: 0,
                            totalOut: 0,
                            currency: tx.currency,
                            x: 0,
                            y: 0
                        };
                        graphState.nodes.push(node);
                        hop0Nodes.push(node);
                        walletNodeMap[nodeKey] = node;
                    }

                    // Add thread and amount to this wallet
                    node.threads.push(`V${victim.id}-T${tx.id}`);
                    node.totalIn += parseFloat(tx.amount);
                    node.totalOut += parseFloat(tx.amount);
                });
            });

            graphState.hopLayers.push({
                hopNumber: 0,
                nodes: hop0Nodes,
                artIn: {},
                artOut: {},
                title: 'Victims (RED Wallets)'
            });

            // Track terminal wallets separately
            const terminalNodes = [];

            // Process each hop - ONLY create nodes for receiving wallets
            investigation.hops?.forEach(hop => {
                const hopNodes = [];
                const hopArtIn = {};
                const hopArtOut = {};

                hop.entries?.forEach(entry => {
                    if (entry.entryType === 'trace') {
                        // Check if this is a terminal wallet
                        if (entry.isTerminalWallet) {
                            // Create terminal wallet node in special terminal column
                            const terminalNodeKey = `terminal_${entry.toWallet}`;

                            let terminalNode = walletNodeMap[terminalNodeKey];
                            if (!terminalNode) {
                                terminalNode = {
                                    id: terminalNodeKey,
                                    uniqueId: nodeId++,
                                    label: getWalletLabel(entry.toWallet, 'purple'),
                                    type: 'purple',
                                    wallet: entry.toWallet,
                                    hopNumber: 'terminal', // Special hop number for terminals
                                    isTerminal: true,
                                    exchangeName: entry.exchangeName,
                                    threads: [],
                                    totalIn: 0,
                                    totalOut: 0, // Terminal wallets don't output
                                    currency: entry.currency,
                                    x: 0,
                                    y: 0
                                };
                                graphState.nodes.push(terminalNode);
                                terminalNodes.push(terminalNode);
                                walletNodeMap[terminalNodeKey] = terminalNode;
                            }

                            // Add thread and amount to terminal wallet
                            terminalNode.threads.push(entry.notation || entry.sourceThreadId);
                            terminalNode.totalIn += parseFloat(entry.amount);

                            // Create edge from previous hop to terminal
                            const prevHopNumber = hop.hopNumber - 1;
                            const fromNodeKey = `hop${prevHopNumber}_${entry.fromWallet}`;
                            const fromNode = walletNodeMap[fromNodeKey];

                            if (fromNode) {
                                graphState.edges.push({
                                    from: fromNode.id,
                                    to: terminalNode.id,
                                    amount: parseFloat(entry.amount),
                                    currency: entry.currency,
                                    thread: entry.notation || entry.sourceThreadId,
                                    notes: entry.notes || '',
                                    txHash: entry.txHash,
                                    hopNumber: hop.hopNumber,
                                    isTerminal: true,
                                    color: '#9c27b0' // Purple for terminal edges
                                });
                            }
                        } else {
                            // Regular (non-terminal) wallet node
                            const toNodeKey = `hop${hop.hopNumber}_${entry.toWallet}`;

                            let toNode = walletNodeMap[toNodeKey];
                            if (!toNode) {
                                toNode = {
                                    id: toNodeKey,
                                    uniqueId: nodeId++,
                                    label: getWalletLabel(entry.toWallet, entry.toWalletType),
                                    type: entry.toWalletType || 'black',
                                    wallet: entry.toWallet,
                                    hopNumber: hop.hopNumber,
                                    isTerminal: false,
                                    exchangeName: null,
                                    threads: [],
                                    totalIn: 0,
                                    totalOut: 0,
                                    currency: entry.currency,
                                    x: 0,
                                    y: 0
                                };
                                graphState.nodes.push(toNode);
                                hopNodes.push(toNode);
                                walletNodeMap[toNodeKey] = toNode;
                            }

                            // Add thread and amount to this wallet
                            toNode.threads.push(entry.notation || entry.sourceThreadId);
                            toNode.totalIn += parseFloat(entry.amount);
                            toNode.totalOut += parseFloat(entry.amount);
                        }

                        // Create edge from previous hop's wallet to this wallet
                        // Only create edge for non-terminal wallets (terminal edges are created above)
                        if (!entry.isTerminalWallet) {
                            const prevHopNumber = hop.hopNumber - 1;
                            const fromNodeKey = `hop${prevHopNumber}_${entry.fromWallet}`;
                            const fromNode = walletNodeMap[fromNodeKey];
                            const toNodeKey = `hop${hop.hopNumber}_${entry.toWallet}`;
                            const toNode = walletNodeMap[toNodeKey];

                            if (fromNode && toNode) {
                                graphState.edges.push({
                                    from: fromNode.id,
                                    to: toNode.id,
                                    amount: parseFloat(entry.amount),
                                    currency: entry.currency,
                                    thread: entry.notation || entry.sourceThreadId,
                                    notes: entry.notes || '',
                                    txHash: entry.txHash,
                                    hopNumber: hop.hopNumber,
                                    isTerminal: entry.isTerminalWallet,
                                    color: getThreadColor(entry.notation || entry.sourceThreadId)
                                });
                            }
                        }

                        // Update hop ART
                        const currency = entry.currency;
                        if (!hopArtIn[currency]) hopArtIn[currency] = 0;
                        if (!hopArtOut[currency]) hopArtOut[currency] = 0;
                        hopArtIn[currency] += parseFloat(entry.amount);
                        if (!entry.isTerminalWallet) {
                            hopArtOut[currency] += parseFloat(entry.amount);
                        }
                    } else if (entry.entryType === 'swap') {
                        // Handle swaps specially
                        const swapNodeKey = `hop${hop.hopNumber}_swap_${entry.id}`;
                        const swapNode = {
                            id: swapNodeKey,
                            uniqueId: nodeId++,
                            label: `SWAP ${entry.currency}→${entry.swapDetails?.toCurrency}`,
                            type: 'swap',
                            wallet: entry.fromWallet || entry.toWallet,
                            hopNumber: hop.hopNumber,
                            isSwap: true,
                            thread: entry.notation || entry.sourceThreadId,
                            artIn: parseFloat(entry.amount),
                            artOut: parseFloat(entry.swapDetails?.toAmount || 0),
                            inputCurrency: entry.currency,
                            outputCurrency: entry.swapDetails?.toCurrency,
                            x: 0,
                            y: 0
                        };
                        graphState.nodes.push(swapNode);
                        hopNodes.push(swapNode);
                    } else if (entry.entryType === 'writeoff') {
                        // Handle writeoffs
                        const writeoffNodeKey = `hop${hop.hopNumber}_writeoff_${entry.id}`;
                        const writeoffNode = {
                            id: writeoffNodeKey,
                            uniqueId: nodeId++,
                            label: `WRITE-OFF (${entry.category})`,
                            type: 'writeoff',
                            hopNumber: hop.hopNumber,
                            thread: entry.notation || entry.sourceThreadId,
                            artIn: parseFloat(entry.amount),
                            artOut: 0,
                            currency: entry.currency,
                            x: 0,
                            y: 0
                        };
                        graphState.nodes.push(writeoffNode);
                        hopNodes.push(writeoffNode);
                    }
                });

                graphState.hopLayers.push({
                    hopNumber: hop.hopNumber,
                    nodes: hopNodes,
                    artIn: hopArtIn,
                    artOut: hopArtOut,
                    title: `Hop ${hop.hopNumber}`,
                    completed: hop.completed
                });
            });

            // Add terminal wallet column if there are any terminals
            if (terminalNodes.length > 0) {
                graphState.hopLayers.push({
                    hopNumber: 'terminal',
                    nodes: terminalNodes,
                    artIn: {}, // Will be calculated from incoming edges
                    artOut: {}, // Terminal wallets have no output
                    title: 'TERMINAL WALLETS',
                    isTerminal: true
                });
            }

            // Connect hops - find connections between layers
            for (let i = 0; i < graphState.hopLayers.length - 1; i++) {
                const currentLayer = graphState.hopLayers[i];
                const nextLayer = graphState.hopLayers[i + 1];

                currentLayer.nodes.forEach(fromNode => {
                    if (fromNode.artOut > 0) {
                        // Find matching wallet in next layer
                        nextLayer.nodes.forEach(toNode => {
                            if (toNode.isSource && toNode.wallet === fromNode.wallet && !fromNode.isTerminal) {
                                // Create inter-hop connection
                                graphState.edges.push({
                                    from: fromNode.id,
                                    to: toNode.id,
                                    amount: fromNode.artOut,
                                    currency: fromNode.currency || 'USDT',
                                    thread: fromNode.thread,
                                    hopNumber: i,
                                    isInterHop: true,
                                    color: '#888',
                                    dashArray: '5,5'
                                });
                            }
                        });
                    }
                });
            }

            // Apply T-account DAG layout
            applyTAccountDAGLayout();
        }

        // Get color for thread
        function getThreadColor(thread) {
            if (!thread) return '#555';
            // Generate consistent color based on thread ID
            const colors = ['#e74c3c', '#3498db', '#2ecc71', '#f39c12', '#9b59b6', '#1abc9c'];
            let hash = 0;
            for (let i = 0; i < thread.length; i++) {
                hash = thread.charCodeAt(i) + ((hash << 5) - hash);
            }
            return colors[Math.abs(hash) % colors.length];
        }

        // Get wallet label from Universal Wallet Index (RED 1, BLACK 2, etc.)
        function getWalletLabel(address, type) {
            // First check Universal Wallet Index for the permanent ID
            const walletEntry = investigation.universalWalletIndex?.find(w => w.address === address);
            if (walletEntry?.permanentId) {
                // Use the permanent ID (e.g., "BLACK 2", "RED 1", "YELLOW 3")
                return walletEntry.permanentId;
            }

            // If not in UWI but we know the type, generate a temporary friendly name
            if (type) {
                // Count existing wallets of this type to generate number
                const existingCount = (investigation.universalWalletIndex || [])
                    .filter(w => w.permanentType === type).length;
                return `${type.toUpperCase()} ${existingCount + 1}`;
            }

            // Fallback to shortened address
            return address.substring(0, 6) + '...' + address.substring(address.length - 4);
        }

        // Apply T-account DAG layout with MUCH better spacing
        function applyTAccountDAGLayout() {
            const container = document.getElementById('graphContainer');
            // Make canvas MUCH larger to prevent overlap
            const width = Math.max(container ? container.offsetWidth : 1200, graphState.hopLayers.length * 500);
            const height = Math.max(container ? container.offsetHeight : 700, 2400);

            // Set SVG viewBox to match the larger size
            const svg = document.getElementById('investigationGraph');
            if (svg) {
                svg.setAttribute('viewBox', `0 0 ${width} ${height}`);
                svg.setAttribute('width', width);
                svg.setAttribute('height', height);
            }

            // Position nodes with MUCH more spacing
            const layerWidth = Math.max(500, width / (graphState.hopLayers.length || 1));
            const nodeHeight = 100;  // Increased from 60
            const nodeSpacing = 120;  // Increased from 20
            const groupSpacing = 180; // Space between node groups
            const layerPadding = 150;

            graphState.hopLayers.forEach((layer, layerIndex) => {
                const x = layerWidth * layerIndex + layerWidth / 2;

                // Group nodes by type with logical flow pattern
                const nodeGroups = {
                    sources: layer.nodes.filter(n => n.isSource),      // Incoming from previous hop
                    regular: layer.nodes.filter(n => !n.isSource && !n.isTerminal && !n.isSwap && n.type !== 'writeoff'),
                    swaps: layer.nodes.filter(n => n.isSwap),          // Currency conversions
                    terminals: layer.nodes.filter(n => n.isTerminal),   // Exchanges (endpoints)
                    writeoffs: layer.nodes.filter(n => n.type === 'writeoff') // Lost funds
                };

                // Calculate total height with group spacing
                let totalHeight = layerPadding * 2;
                Object.values(nodeGroups).forEach(group => {
                    if (group.length > 0) {
                        totalHeight += group.length * nodeHeight + (group.length - 1) * nodeSpacing + groupSpacing;
                    }
                });

                // Start from top with padding
                let currentY = layerPadding;

                // Place nodes with clear vertical pattern
                // SOURCES (incoming connections) - aligned left
                if (nodeGroups.sources.length > 0) {
                    nodeGroups.sources.forEach(node => {
                        node.x = x - 60;  // Left alignment for T-account
                        node.y = currentY;
                        currentY += nodeHeight + nodeSpacing;
                    });
                    currentY += groupSpacing;
                }

                // REGULAR TRACES - center aligned
                if (nodeGroups.regular.length > 0) {
                    nodeGroups.regular.forEach(node => {
                        node.x = x;
                        node.y = currentY;
                        currentY += nodeHeight + nodeSpacing;
                    });
                    currentY += groupSpacing;
                }

                // SWAPS - center with emphasis
                if (nodeGroups.swaps.length > 0) {
                    nodeGroups.swaps.forEach(node => {
                        node.x = x;
                        node.y = currentY;
                        currentY += nodeHeight + nodeSpacing;
                    });
                    currentY += groupSpacing;
                }

                // TERMINALS (exchanges) - aligned right
                if (nodeGroups.terminals.length > 0) {
                    nodeGroups.terminals.forEach(node => {
                        node.x = x + 60;  // Right alignment for endpoints
                        node.y = currentY;
                        currentY += nodeHeight + nodeSpacing;
                    });
                    currentY += groupSpacing;
                }

                // WRITEOFFS - aligned right
                if (nodeGroups.writeoffs.length > 0) {
                    nodeGroups.writeoffs.forEach(node => {
                        node.x = x + 60;  // Right alignment for exits
                        node.y = currentY;
                        currentY += nodeHeight + nodeSpacing;
                    });
                }
            });
        }

        // Render the graph with hop shading and T-account structure
        function renderGraph() {
            const svg = document.getElementById('investigationGraph');
            const content = document.getElementById('graphContent');

            // Clear existing content
            while (content.firstChild) {
                content.removeChild(content.firstChild);
            }

            // Draw hop backgrounds with CLEAR alternating colors
            if (graphState.hopLayers) {
                const container = document.getElementById('graphContainer');
                const totalWidth = Math.max(container ? container.offsetWidth : 1200, graphState.hopLayers.length * 500);
                const layerWidth = totalWidth / graphState.hopLayers.length;
                const containerHeight = Math.max(container ? container.offsetHeight : 700, 2400);

                graphState.hopLayers.forEach((layer, index) => {
                    const xStart = index * layerWidth;
                    const xCenter = xStart + layerWidth / 2;

                    // Create CLEARLY VISIBLE alternating backgrounds
                    const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                    rect.setAttribute('x', xStart);
                    rect.setAttribute('y', 0);
                    rect.setAttribute('width', layerWidth);
                    rect.setAttribute('height', containerHeight);
                    // Strong alternating white and light blue
                    rect.setAttribute('fill', index % 2 === 0 ? '#ffffff' : '#e1f5fe');
                    rect.setAttribute('opacity', '1');
                    rect.setAttribute('stroke', '#0288d1');
                    rect.setAttribute('stroke-width', '2');
                    content.appendChild(rect);

                    // Add hop title at top
                    const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    title.setAttribute('x', xCenter);
                    title.setAttribute('y', 35);
                    title.setAttribute('text-anchor', 'middle');
                    title.setAttribute('font-size', '20');
                    title.setAttribute('font-weight', 'bold');
                    title.setAttribute('fill', '#0288d1');
                    title.setAttribute('font-family', 'Arial, sans-serif');
                    // Special title for terminal column
                    if (layer.isTerminal) {
                        title.textContent = 'TERMINAL WALLETS';
                        title.setAttribute('fill', '#9c27b0'); // Purple for terminals
                    } else {
                        title.textContent = layer.hopNumber === 0 ? 'VICTIMS' : `HOP ${layer.hopNumber}`;
                    }
                    content.appendChild(title);

                    // Get ART at start of hop (what's coming IN to this hop)
                    let startingART = {};
                    if (layer.hopNumber === 0) {
                        // For victims layer, starting ART is 0, ending is victim amounts
                        investigation.victims?.forEach(victim => {
                            victim.transactions?.forEach(tx => {
                                const currency = tx.currency;
                                if (!startingART[currency]) startingART[currency] = 0;
                                startingART[currency] += parseFloat(tx.amount);
                            });
                        });
                    } else {
                        // For other hops, get from investigation hop data
                        const hopData = investigation.hops?.find(h => h.hopNumber === layer.hopNumber);
                        if (hopData?.artAtStartByCurrency) {
                            startingART = hopData.artAtStartByCurrency;
                        }
                    }

                    // ART at TOP of shaded area (what's available at start)
                    if (Object.keys(startingART).length > 0) {
                        // Background box for better readability
                        const bgRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        bgRect.setAttribute('x', xStart + 10);
                        bgRect.setAttribute('y', 40);
                        bgRect.setAttribute('width', layerWidth - 20);
                        bgRect.setAttribute('height', 25);
                        bgRect.setAttribute('fill', '#e8f5e9');
                        bgRect.setAttribute('rx', '4');
                        bgRect.setAttribute('opacity', '0.9');
                        content.appendChild(bgRect);

                        const artStartText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        artStartText.setAttribute('x', xCenter);
                        artStartText.setAttribute('y', 57);
                        artStartText.setAttribute('text-anchor', 'middle');
                        artStartText.setAttribute('font-size', '13');
                        artStartText.setAttribute('font-weight', 'bold');
                        artStartText.setAttribute('fill', '#2e7d32');
                        artStartText.textContent = '⬇ IN: ' + Object.entries(startingART)
                            .map(([curr, amt]) => `${amt.toLocaleString()} ${curr}`)
                            .join(' | ');
                        content.appendChild(artStartText);
                    }

                    // ART at BOTTOM of shaded area (what's going out)
                    // Need to account for swaps that change currency
                    let endingART = {};
                    if (layer.hopNumber === 0) {
                        // For victims, ending ART equals starting (all goes to Hop 1)
                        endingART = startingART;
                    } else {
                        // Calculate ending ART accounting for traces, swaps, and writeoffs
                        const hopData = investigation.hops?.find(h => h.hopNumber === layer.hopNumber);
                        if (hopData) {
                            // Start with what came in
                            Object.assign(endingART, startingART);

                            hopData.entries?.forEach(entry => {
                                if (entry.entryType === 'swap' && entry.swapDetails) {
                                    // Swap removes from one currency and adds to another
                                    const fromCurrency = entry.currency;
                                    const toCurrency = entry.swapDetails.toCurrency;
                                    const fromAmount = parseFloat(entry.amount);
                                    const toAmount = parseFloat(entry.swapDetails.toAmount || 0);

                                    // Deduct from source currency
                                    if (endingART[fromCurrency]) {
                                        endingART[fromCurrency] -= fromAmount;
                                        if (endingART[fromCurrency] < 0.01) {
                                            delete endingART[fromCurrency];
                                        }
                                    }

                                    // Add to target currency
                                    if (!endingART[toCurrency]) {
                                        endingART[toCurrency] = 0;
                                    }
                                    endingART[toCurrency] += toAmount;
                                } else if (entry.entryType === 'writeoff') {
                                    // Writeoffs remove from ART
                                    const currency = entry.currency;
                                    const amount = parseFloat(entry.amount);
                                    if (endingART[currency]) {
                                        endingART[currency] -= amount;
                                        if (endingART[currency] < 0.01) {
                                            delete endingART[currency];
                                        }
                                    }
                                } else if (entry.entryType === 'trace' && entry.isTerminalWallet) {
                                    // Terminal wallets remove from ART
                                    const currency = entry.currency;
                                    const amount = parseFloat(entry.amount);
                                    if (endingART[currency]) {
                                        endingART[currency] -= amount;
                                        if (endingART[currency] < 0.01) {
                                            delete endingART[currency];
                                        }
                                    }
                                }
                                // Regular traces continue to next hop so ART stays the same
                            });
                        }
                    }

                    if (Object.keys(endingART).length > 0) {
                        // Background box for better readability
                        const bgRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        bgRect.setAttribute('x', xStart + 10);
                        bgRect.setAttribute('y', containerHeight - 35);
                        bgRect.setAttribute('width', layerWidth - 20);
                        bgRect.setAttribute('height', 25);
                        bgRect.setAttribute('fill', '#ffebee');
                        bgRect.setAttribute('rx', '4');
                        bgRect.setAttribute('opacity', '0.9');
                        content.appendChild(bgRect);

                        const artEndText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        artEndText.setAttribute('x', xCenter);
                        artEndText.setAttribute('y', containerHeight - 15);
                        artEndText.setAttribute('text-anchor', 'middle');
                        artEndText.setAttribute('font-size', '13');
                        artEndText.setAttribute('font-weight', 'bold');
                        artEndText.setAttribute('fill', '#c62828');
                        artEndText.textContent = '⬇ OUT: ' + Object.entries(endingART)
                            .map(([curr, amt]) => `${amt.toLocaleString()} ${curr}`)
                            .join(' | ');
                        content.appendChild(artEndText);
                    }

                    // Add validation status indicator
                    const isBalanced = JSON.stringify(startingART) === JSON.stringify(endingART);
                    if (layer.hopNumber > 0 && !isBalanced) {
                        // Show warning if hop is not balanced
                        const warningText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        warningText.setAttribute('x', xCenter);
                        warningText.setAttribute('y', containerHeight / 2);
                        warningText.setAttribute('text-anchor', 'middle');
                        warningText.setAttribute('font-size', '12');
                        warningText.setAttribute('fill', '#ff9800');
                        warningText.setAttribute('font-weight', 'bold');

                        // Calculate difference
                        let differences = [];
                        Object.keys(startingART).forEach(curr => {
                            const inAmt = startingART[curr] || 0;
                            const outAmt = endingART[curr] || 0;
                            if (Math.abs(inAmt - outAmt) > 0.01) {
                                differences.push(`${Math.abs(inAmt - outAmt).toLocaleString()} ${curr}`);
                            }
                        });

                        if (differences.length > 0) {
                            warningText.textContent = '⚠ UNACCOUNTED: ' + differences.join(', ');
                            content.appendChild(warningText);
                        }
                    }
                });
            }

            // Draw edges with thread-specific colors and labeling
            graphState.edges.forEach(edge => {
                const fromNode = graphState.nodes.find(n => n.id === edge.from);
                const toNode = graphState.nodes.find(n => n.id === edge.to);

                if (fromNode && toNode) {
                    // Use path for better curve control
                    const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');

                    // Calculate curve for better visual flow
                    const dx = toNode.x - fromNode.x;
                    const dy = toNode.y - fromNode.y;
                    const dr = Math.sqrt(dx * dx + dy * dy) * 0.1;

                    // Create path with slight curve
                    const d = `M${fromNode.x},${fromNode.y} Q${(fromNode.x + toNode.x) / 2},${(fromNode.y + toNode.y) / 2 + dr} ${toNode.x},${toNode.y}`;
                    path.setAttribute('d', d);
                    path.setAttribute('fill', 'none');
                    path.setAttribute('stroke', edge.color || (edge.isTerminal ? '#9c27b0' : '#2196f3'));
                    path.setAttribute('stroke-width', '3'); // Thick visible lines
                    if (edge.dashArray) {
                        path.setAttribute('stroke-dasharray', edge.dashArray);
                    }
                    path.setAttribute('marker-end', edge.isTerminal ? 'url(#arrowhead-terminal)' : 'url(#arrowhead)');
                    path.setAttribute('opacity', '0.9'); // Much more visible
                    path.style.cursor = 'pointer';

                    content.appendChild(path);

                    // Add click handler for showing notes
                    path.addEventListener('click', (e) => {
                        e.stopPropagation();
                        showTransactionNotes(edge.notes || 'No notes available', e.clientX, e.clientY);
                    });

                    // Add edge label with thread and amount
                    if (graphState.showAmounts && !edge.isInterHop) {
                        const labelGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');

                        // Background for better readability
                        const bgRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                        const labelX = (fromNode.x + toNode.x) / 2;
                        const labelY = (fromNode.y + toNode.y) / 2;

                        bgRect.setAttribute('x', labelX - 70);
                        bgRect.setAttribute('y', labelY - 22);
                        bgRect.setAttribute('width', '140');
                        bgRect.setAttribute('height', '45');
                        bgRect.setAttribute('fill', 'white');
                        bgRect.setAttribute('stroke', edge.color || '#2196f3');
                        bgRect.setAttribute('stroke-width', '2');
                        bgRect.setAttribute('opacity', '0.95');
                        bgRect.setAttribute('rx', '5');
                        labelGroup.appendChild(bgRect);

                        // Thread label - CLEAR and VISIBLE
                        if (edge.thread) {
                            const threadText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            threadText.setAttribute('x', labelX);
                            threadText.setAttribute('y', labelY - 5);
                            threadText.setAttribute('text-anchor', 'middle');
                            threadText.setAttribute('font-size', '14');
                            threadText.setAttribute('fill', edge.color || '#1976d2');
                            threadText.setAttribute('font-weight', 'bold');
                            threadText.setAttribute('font-family', 'Arial, sans-serif');
                            threadText.textContent = edge.thread;
                            labelGroup.appendChild(threadText);
                        }

                        // Amount label - CLEAR and VISIBLE
                        const amountText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        amountText.setAttribute('x', labelX);
                        amountText.setAttribute('y', labelY + 12);
                        amountText.setAttribute('text-anchor', 'middle');
                        amountText.setAttribute('font-size', '13');
                        amountText.setAttribute('fill', '#424242');
                        amountText.setAttribute('font-weight', '600');
                        amountText.setAttribute('font-family', 'Arial, sans-serif');
                        amountText.textContent = `${edge.amount.toLocaleString()} ${edge.currency}`;
                        labelGroup.appendChild(amountText);

                        content.appendChild(labelGroup);
                    }
                }
            });

            // Draw nodes
            graphState.nodes.forEach(node => {
                const g = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                g.setAttribute('transform', `translate(${node.x}, ${node.y})`);
                g.style.cursor = 'pointer';

                // Special shape for swap nodes (diamond/rhombus)
                if (node.isSwap) {
                    const diamond = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    diamond.setAttribute('points', '0,-25 25,0 0,25 -25,0');
                    diamond.setAttribute('fill', '#e17055');
                    diamond.setAttribute('stroke', '#fff');
                    diamond.setAttribute('stroke-width', '2');
                    g.appendChild(diamond);

                    // Add swap text
                    const swapText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    swapText.setAttribute('y', '5');
                    swapText.setAttribute('text-anchor', 'middle');
                    swapText.setAttribute('font-size', '10');
                    swapText.setAttribute('fill', 'white');
                    swapText.setAttribute('font-weight', 'bold');
                    swapText.textContent = '⇄';
                    g.appendChild(swapText);
                } else if (node.type === 'writeoff') {
                    // Special shape for writeoff nodes (triangle)
                    const triangle = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
                    triangle.setAttribute('points', '0,-22 19,11 -19,11');
                    triangle.setAttribute('fill', '#95a5a6');
                    triangle.setAttribute('stroke', '#fff');
                    triangle.setAttribute('stroke-width', '2');
                    g.appendChild(triangle);
                } else {
                    // Regular node circle
                    const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                    circle.setAttribute('r', node.isTerminal ? '35' : '30');
                    circle.setAttribute('fill', getNodeColor(node.type));
                    circle.setAttribute('stroke', '#fff');
                    circle.setAttribute('stroke-width', '3');
                    circle.setAttribute('filter', 'drop-shadow(0 2px 6px rgba(0,0,0,0.3))');

                    // Add glow for terminal nodes
                    if (node.isTerminal) {
                        circle.setAttribute('filter', 'drop-shadow(0 0 10px rgba(108, 92, 231, 0.5))');
                    }

                    g.appendChild(circle);
                }

                // Node label
                if (graphState.showLabels) {
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('y', node.isSwap ? '40' : '35');
                    text.setAttribute('text-anchor', 'middle');
                    text.setAttribute('font-size', node.isSwap ? '11' : '12');
                    text.setAttribute('fill', '#333');
                    text.textContent = node.label;
                    g.appendChild(text);

                    // For swap nodes, show conversion details
                    if (node.isSwap && node.artIn && node.artOut) {
                        const conversionText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        conversionText.setAttribute('y', '55');
                        conversionText.setAttribute('text-anchor', 'middle');
                        conversionText.setAttribute('font-size', '10');
                        conversionText.setAttribute('fill', '#e17055');
                        conversionText.textContent = `${node.artIn.toLocaleString()} → ${node.artOut.toLocaleString()}`;
                        g.appendChild(conversionText);
                    }

                    // Exchange name for terminal nodes
                    if (node.exchangeName) {
                        const exchangeText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        exchangeText.setAttribute('y', '48');
                        exchangeText.setAttribute('text-anchor', 'middle');
                        exchangeText.setAttribute('font-size', '10');
                        exchangeText.setAttribute('fill', '#6c5ce7');
                        exchangeText.setAttribute('font-weight', 'bold');
                        exchangeText.textContent = node.exchangeName;
                        g.appendChild(exchangeText);
                    }
                }

                // Click handler
                g.addEventListener('click', () => showNodeDetails(node));
                g.addEventListener('mouseenter', (e) => showNodeTooltip(e, node));
                g.addEventListener('mouseleave', hideNodeTooltip);

                content.appendChild(g);
            });

            // Draw text notes on top of everything
            graphState.textNotes.forEach(note => {
                const noteGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                noteGroup.setAttribute('transform', `translate(${note.x}, ${note.y})`);

                // Note background
                const bgRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                const textLines = note.text.split('\n');
                const maxLineLength = Math.max(...textLines.map(line => line.length));
                const width = maxLineLength * 8 + 20;
                const height = textLines.length * 20 + 15;

                bgRect.setAttribute('x', '-5');
                bgRect.setAttribute('y', '-15');
                bgRect.setAttribute('width', width);
                bgRect.setAttribute('height', height);
                bgRect.setAttribute('fill', note.backgroundColor || '#fffde7');
                bgRect.setAttribute('stroke', note.color || '#1976d2');
                bgRect.setAttribute('stroke-width', '2');
                bgRect.setAttribute('rx', '5');
                bgRect.setAttribute('opacity', '0.95');
                bgRect.style.cursor = 'pointer';
                noteGroup.appendChild(bgRect);

                // Note text (support multiline)
                textLines.forEach((line, index) => {
                    const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    text.setAttribute('x', '5');
                    text.setAttribute('y', index * 20);
                    text.setAttribute('font-size', note.fontSize || '14');
                    text.setAttribute('fill', note.color || '#1976d2');
                    text.setAttribute('font-family', 'Arial, sans-serif');
                    text.setAttribute('font-weight', '600');
                    text.style.cursor = 'pointer';
                    text.style.userSelect = 'none';
                    text.textContent = line;
                    noteGroup.appendChild(text);
                });

                // Delete button (X)
                const deleteBtn = document.createElementNS('http://www.w3.org/2000/svg', 'g');
                deleteBtn.setAttribute('transform', `translate(${width - 15}, -10)`);
                deleteBtn.style.cursor = 'pointer';

                const deleteBg = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                deleteBg.setAttribute('r', '8');
                deleteBg.setAttribute('fill', '#f44336');
                deleteBg.setAttribute('stroke', '#fff');
                deleteBg.setAttribute('stroke-width', '1');
                deleteBtn.appendChild(deleteBg);

                const deleteX = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                deleteX.setAttribute('y', '3');
                deleteX.setAttribute('text-anchor', 'middle');
                deleteX.setAttribute('fill', 'white');
                deleteX.setAttribute('font-size', '12');
                deleteX.setAttribute('font-weight', 'bold');
                deleteX.textContent = '×';
                deleteBtn.appendChild(deleteX);

                deleteBtn.addEventListener('click', (e) => {
                    e.stopPropagation();
                    deleteTextNote(note.id);
                });
                noteGroup.appendChild(deleteBtn);

                // Double-click to edit
                noteGroup.addEventListener('dblclick', (e) => {
                    e.stopPropagation();
                    editTextNote(note.id);
                });

                content.appendChild(noteGroup);
            });

            // Update transform
            updateGraphTransform();
        }

        // Get node color based on type
        function getNodeColor(type) {
            // Modern Material Design colors
            const colors = {
                'victim': '#f44336',   // Material red 500
                'red': '#f44336',      // Material red 500
                'black': '#424242',    // Material grey 800
                'purple': '#9c27b0',   // Material purple 500
                'gray': '#757575',     // Material grey 600
                'yellow': '#ffc107',   // Material amber 500
                'brown': '#795548',    // Material brown 500
                'green': '#4caf50',    // Material green 500
                'blue': '#2196f3',     // Material blue 500
                'pink': '#e91e63',     // Material pink 500
                'orange': '#ff9800'    // Material orange 500
            };
            return colors[type] || '#95a5a6';
        }

        // Setup graph interaction with notes support
        function setupGraphInteraction() {
            const svg = document.getElementById('investigationGraph');
            const container = document.getElementById('graphContainer');

            // Set cursor for dragging
            svg.style.cursor = 'grab';

            // Pan functionality
            svg.addEventListener('mousedown', startDrag);
            svg.addEventListener('mousemove', drag);
            svg.addEventListener('mouseup', endDrag);
            svg.addEventListener('mouseleave', endDrag);

            // Right-click for adding notes
            svg.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                if (!graphState.isDragging) {
                    addTextNoteAtPosition(e);
                }
            });

            // Zoom with mouse wheel
            container.addEventListener('wheel', (e) => {
                e.preventDefault();
                const delta = e.deltaY > 0 ? 0.9 : 1.1;
                graphState.zoom *= delta;
                graphState.zoom = Math.max(0.1, Math.min(5, graphState.zoom));
                updateGraphTransform();
                updateZoomLevel();
            });
        }

        // Add a text note at the clicked position
        function addTextNoteAtPosition(e) {
            const svg = document.getElementById('investigationGraph');
            const pt = svg.createSVGPoint();
            pt.x = e.clientX;
            pt.y = e.clientY;

            // Transform to SVG coordinates
            const svgP = pt.matrixTransform(svg.getScreenCTM().inverse());
            const x = (svgP.x - graphState.translateX) / graphState.zoom;
            const y = (svgP.y - graphState.translateY) / graphState.zoom;

            // Create note object
            const note = {
                id: graphState.nextNoteId++,
                x: x,
                y: y,
                text: 'Double-click to edit',
                fontSize: 14,
                color: '#1976d2',
                backgroundColor: '#fffde7',
                editing: false
            };

            graphState.textNotes.push(note);
            renderGraph(); // Re-render to show the note

            // Start editing immediately
            setTimeout(() => editTextNote(note.id), 100);
        }

        // Edit a text note
        function editTextNote(noteId) {
            const note = graphState.textNotes.find(n => n.id === noteId);
            if (!note) return;

            const newText = prompt('Edit note text:', note.text);
            if (newText !== null) {
                if (newText.trim() === '') {
                    // Delete empty notes
                    graphState.textNotes = graphState.textNotes.filter(n => n.id !== noteId);
                } else {
                    note.text = newText;
                }
                renderGraph();
            }
        }

        // Delete a text note
        function deleteTextNote(noteId) {
            graphState.textNotes = graphState.textNotes.filter(n => n.id !== noteId);
            renderGraph();
        }

        // Drag functions - allow dragging from anywhere
        function startDrag(e) {
            // Allow dragging unless clicking a button
            if (!e.target.closest('button')) {
                graphState.isDragging = true;
                graphState.dragStartX = e.clientX - graphState.translateX;
                graphState.dragStartY = e.clientY - graphState.translateY;
                document.getElementById('investigationGraph').style.cursor = 'grabbing';
                e.preventDefault(); // Prevent text selection
            }
        }

        function drag(e) {
            if (graphState.isDragging) {
                graphState.translateX = e.clientX - graphState.dragStartX;
                graphState.translateY = e.clientY - graphState.dragStartY;
                updateGraphTransform();
            }
        }

        function endDrag(e) {
            graphState.isDragging = false;
            const svg = document.getElementById('investigationGraph');
            if (svg) svg.style.cursor = 'grab';
        }

        // Update graph transform
        function updateGraphTransform() {
            const content = document.getElementById('graphContent');
            content.setAttribute('transform',
                `translate(${graphState.translateX}, ${graphState.translateY}) scale(${graphState.zoom})`);
        }

        // Zoom controls
        function zoomIn() {
            graphState.zoom *= 1.2;
            graphState.zoom = Math.min(5, graphState.zoom);
            updateGraphTransform();
            updateZoomLevel();
        }

        function zoomOut() {
            graphState.zoom *= 0.8;
            graphState.zoom = Math.max(0.1, graphState.zoom);
            updateGraphTransform();
            updateZoomLevel();
        }

        function resetZoom() {
            graphState.zoom = 1;
            graphState.translateX = 0;
            graphState.translateY = 0;
            updateGraphTransform();
            updateZoomLevel();
        }

        function fitToScreen() {
            if (graphState.nodes.length === 0) return;

            const container = document.getElementById('graphContainer');
            const width = container.offsetWidth;
            const height = container.offsetHeight;

            // Find bounds
            let minX = Infinity, minY = Infinity;
            let maxX = -Infinity, maxY = -Infinity;

            graphState.nodes.forEach(node => {
                minX = Math.min(minX, node.x);
                minY = Math.min(minY, node.y);
                maxX = Math.max(maxX, node.x);
                maxY = Math.max(maxY, node.y);
            });

            const graphWidth = maxX - minX + 100;
            const graphHeight = maxY - minY + 100;

            const scaleX = width / graphWidth;
            const scaleY = height / graphHeight;
            graphState.zoom = Math.min(scaleX, scaleY, 1);

            graphState.translateX = (width - graphWidth * graphState.zoom) / 2 - minX * graphState.zoom + 50 * graphState.zoom;
            graphState.translateY = (height - graphHeight * graphState.zoom) / 2 - minY * graphState.zoom + 50 * graphState.zoom;

            updateGraphTransform();
            updateZoomLevel();
        }

        function updateZoomLevel() {
            const zoomLevel = document.getElementById('zoomLevel');
            if (zoomLevel) {
                zoomLevel.textContent = Math.round(graphState.zoom * 100) + '%';
            }
        }

        // Re-render graph with updated T-account DAG layout
        function refreshGraph() {
            buildGraphData();  // Rebuild with latest data
            renderGraph();
        }

        // Toggle functions
        function toggleLabels() {
            graphState.showLabels = !graphState.showLabels;
            renderGraph();
        }

        function toggleAmounts() {
            graphState.showAmounts = !graphState.showAmounts;
            renderGraph();
        }

        // Search function
        function searchGraph(query) {
            const lowerQuery = query.toLowerCase();

            graphState.nodes.forEach(node => {
                const element = document.querySelector(`[transform*="${node.x}, ${node.y}"]`);
                if (element) {
                    const matches = node.wallet.toLowerCase().includes(lowerQuery) ||
                                   node.label.toLowerCase().includes(lowerQuery) ||
                                   (node.exchangeName && node.exchangeName.toLowerCase().includes(lowerQuery));

                    element.style.opacity = matches || !query ? '1' : '0.2';
                }
            });
        }

        // Show node details
        function showNodeDetails(node) {
            graphState.selectedNode = node;
            const popup = document.getElementById('nodeDetailsPopup');
            const content = document.getElementById('nodeDetailsContent');

            // Build details HTML
            let html = `
                <h4 style="margin: 0 0 10px 0;">${node.label}</h4>
                <div style="font-size: 12px; color: #666;">
                    <p><strong>Type:</strong> ${node.type.toUpperCase()}</p>
                    <p><strong>Address:</strong><br>${node.wallet}</p>
            `;

            if (node.exchangeName) {
                html += `<p><strong>Exchange:</strong> ${node.exchangeName}</p>`;
            }

            if (node.amount) {
                html += `<p><strong>Amount:</strong> ${node.amount.toLocaleString()} ${node.currency}</p>`;
            }

            // Find related transactions
            const relatedEdges = graphState.edges.filter(e => e.from === node.id || e.to === node.id);
            if (relatedEdges.length > 0) {
                html += '<p><strong>Transactions:</strong></p><ul style="margin: 5px 0; padding-left: 20px;">';
                relatedEdges.forEach(edge => {
                    html += `<li>${edge.amount.toLocaleString()} ${edge.currency}</li>`;
                });
                html += '</ul>';
            }

            html += '</div>';
            content.innerHTML = html;

            // Position popup
            popup.style.display = 'block';
            popup.style.left = (node.x * graphState.zoom + graphState.translateX + 30) + 'px';
            popup.style.top = (node.y * graphState.zoom + graphState.translateY - 30) + 'px';

            // Auto-hide after 5 seconds
            setTimeout(() => {
                if (graphState.selectedNode === node) {
                    popup.style.display = 'none';
                    graphState.selectedNode = null;
                }
            }, 5000);
        }

        // Tooltip functions
        function showNodeTooltip(e, node) {
            // Simple tooltip on hover
            const tooltip = document.createElement('div');
            tooltip.id = 'nodeTooltip';
            tooltip.style.cssText = `
                position: absolute;
                background: rgba(0,0,0,0.8);
                color: white;
                padding: 5px 10px;
                border-radius: 4px;
                font-size: 12px;
                pointer-events: none;
                z-index: 1001;
            `;
            tooltip.textContent = `${node.label} (${node.type})`;

            const container = document.getElementById('graphContainer');
            container.appendChild(tooltip);

            tooltip.style.left = (e.offsetX + 10) + 'px';
            tooltip.style.top = (e.offsetY - 30) + 'px';
        }

        function hideNodeTooltip() {
            const tooltip = document.getElementById('nodeTooltip');
            if (tooltip) tooltip.remove();
        }

        // Update statistics
        function updateGraphStatistics() {
            const statsContent = document.getElementById('statsContent');
            if (!statsContent) return;

            const totalNodes = graphState.nodes.length;
            const totalEdges = graphState.edges.length;
            const terminalNodes = graphState.nodes.filter(n => n.isTerminal).length;
            const exchanges = [...new Set(graphState.nodes.filter(n => n.exchangeName).map(n => n.exchangeName))];

            // Calculate total amounts by currency
            const totalsByCurrency = {};
            graphState.edges.forEach(edge => {
                if (!totalsByCurrency[edge.currency]) {
                    totalsByCurrency[edge.currency] = 0;
                }
                totalsByCurrency[edge.currency] += edge.amount;
            });

            statsContent.innerHTML = `
                <div class="stat-card" style="padding: 15px; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                    <h5 style="margin: 0 0 5px 0; color: #6c757d; font-size: 12px;">Total Nodes</h5>
                    <p style="margin: 0; font-size: 24px; font-weight: bold;">${totalNodes}</p>
                </div>
                <div class="stat-card" style="padding: 15px; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                    <h5 style="margin: 0 0 5px 0; color: #6c757d; font-size: 12px;">Total Edges</h5>
                    <p style="margin: 0; font-size: 24px; font-weight: bold;">${totalEdges}</p>
                </div>
                <div class="stat-card" style="padding: 15px; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                    <h5 style="margin: 0 0 5px 0; color: #6c757d; font-size: 12px;">Terminal Wallets</h5>
                    <p style="margin: 0; font-size: 24px; font-weight: bold; color: #6c5ce7;">${terminalNodes}</p>
                </div>
                <div class="stat-card" style="padding: 15px; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                    <h5 style="margin: 0 0 5px 0; color: #6c757d; font-size: 12px;">Exchanges</h5>
                    <p style="margin: 0; font-size: 24px; font-weight: bold;">${exchanges.length}</p>
                </div>
                ${Object.entries(totalsByCurrency).map(([currency, total]) => `
                    <div class="stat-card" style="padding: 15px; background: white; border-radius: 8px; box-shadow: 0 2px 4px rgba(0,0,0,0.1);">
                        <h5 style="margin: 0 0 5px 0; color: #6c757d; font-size: 12px;">Total ${currency}</h5>
                        <p style="margin: 0; font-size: 20px; font-weight: bold;">${total.toLocaleString()}</p>
                    </div>
                `).join('')}
            `;
        }

        // Export functions
        async function exportGraphToPDF() {
            showNotification('Generating comprehensive PDF report...', 'info');

            // Create a printer-friendly HTML document
            const printWindow = window.open('', '_blank');

            if (!printWindow) {
                showNotification('Please allow pop-ups to generate PDF report', 'error');
                return;
            }

            // Calculate investigation statistics
            let totalVictims = investigation.victims?.length || 0;
            let totalTransactions = 0;
            let totalLoss = {};
            let terminalWallets = investigation.terminalWalletIndex || [];

            investigation.victims?.forEach(victim => {
                victim.transactions?.forEach(tx => {
                    totalTransactions++;
                    const currency = tx.currency;
                    const amount = parseFloat(tx.amount);
                    if (!totalLoss[currency]) totalLoss[currency] = 0;
                    totalLoss[currency] += amount;
                });
            });

            // Count hops and entries
            let totalHops = investigation.hops?.length || 0;
            let totalEntries = 0;
            investigation.hops?.forEach(hop => {
                totalEntries += hop.entries?.length || 0;
            });

            // Build the comprehensive PDF report content
            const pdfContent = `<!DOCTYPE html>
<html>
<head>
    <title>BATS Investigation Report - ${investigation.caseId || 'Untitled'}</title>
    <style>
        @media print {
            body { margin: 0; }
            .no-print { display: none; }
            .page-break { page-break-after: always; }
        }
        body {
            font-family: 'Segoe UI', Arial, sans-serif;
            line-height: 1.6;
            color: #333;
            max-width: 8.5in;
            margin: 0 auto;
            padding: 20px;
        }
        .header {
            text-align: center;
            border-bottom: 3px solid #2196f3;
            padding-bottom: 20px;
            margin-bottom: 30px;
        }
        h1 {
            color: #1976d2;
            margin: 10px 0;
            font-size: 28px;
        }
        .subtitle {
            color: #666;
            font-size: 14px;
        }
        .section {
            margin: 30px 0;
            padding: 20px;
            background: #f8f9fa;
            border-left: 4px solid #2196f3;
            border-radius: 4px;
        }
        h2 {
            color: #1976d2;
            margin-top: 30px;
            border-bottom: 2px solid #e0e0e0;
            padding-bottom: 10px;
        }
        .stats-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin: 20px 0;
        }
        .stat-card {
            background: white;
            padding: 15px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            text-align: center;
        }
        .stat-label {
            color: #666;
            font-size: 12px;
            text-transform: uppercase;
        }
        .stat-value {
            font-size: 24px;
            font-weight: bold;
            color: #1976d2;
            margin: 5px 0;
        }
        table {
            width: 100%;
            border-collapse: collapse;
            margin: 20px 0;
            background: white;
        }
        th, td {
            border: 1px solid #ddd;
            padding: 10px;
            text-align: left;
        }
        th {
            background: #2196f3;
            color: white;
            font-weight: bold;
        }
        tr:nth-child(even) {
            background: #f5f5f5;
        }
        .victim-section {
            background: #fff3e0;
            border-left: 4px solid #ff9800;
        }
        .terminal-section {
            background: #f3e5f5;
            border-left: 4px solid #9c27b0;
        }
        .graph-container {
            margin: 30px 0;
            text-align: center;
            padding: 20px;
            background: white;
            border: 1px solid #ddd;
            border-radius: 8px;
        }
        .graph-title {
            font-weight: bold;
            margin-bottom: 10px;
            color: #666;
        }
        #graphImage {
            max-width: 100%;
            height: auto;
            border: 1px solid #ddd;
        }
        .footer {
            margin-top: 40px;
            padding-top: 20px;
            border-top: 2px solid #e0e0e0;
            text-align: center;
            color: #666;
            font-size: 12px;
        }
        .no-print {
            position: fixed;
            top: 10px;
            right: 10px;
            z-index: 1000;
        }
        .print-btn {
            background: #2196f3;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 14px;
            margin: 0 5px;
        }
        .print-btn:hover {
            background: #1976d2;
        }
        .wallet-address {
            font-family: monospace;
            font-size: 11px;
            background: #f5f5f5;
            padding: 2px 4px;
            border-radius: 3px;
            word-break: break-all;
        }
        .amount {
            font-weight: bold;
            color: #2e7d32;
        }
        .warning-box {
            background: #fff3e0;
            border: 1px solid #ff9800;
            border-radius: 4px;
            padding: 15px;
            margin: 20px 0;
        }
        .warning-box strong {
            color: #e65100;
        }
    </style>
</head>
<body>
    <div class="no-print">
        <button class="print-btn" onclick="window.print(); return false;">🖨️ Print / Save as PDF</button>
        <button class="print-btn" onclick="window.close()" style="background: #666;">Close</button>
    </div>

    <div class="header">
        <h1>BLOCKCHAIN INVESTIGATION REPORT</h1>
        <div class="subtitle">B.A.T.S. - Block Audit Tracing Standard</div>
        <div style="margin-top: 10px;">
            <strong>Case ID:</strong> ${investigation.caseId || 'Not Specified'}<br>
            <strong>Case Title:</strong> ${investigation.caseTitle || 'Untitled Investigation'}<br>
            <strong>Investigator:</strong> ${investigation.investigator || 'Not Specified'}<br>
            <strong>Report Generated:</strong> ${new Date().toLocaleString()}
        </div>
    </div>

    <div class="section">
        <h2>📊 Investigation Summary</h2>
        <div class="stats-grid">
            <div class="stat-card">
                <div class="stat-label">Total Victims</div>
                <div class="stat-value">${totalVictims}</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Total Loss</div>
                <div class="stat-value" style="font-size: 18px;">${Object.entries(totalLoss).map(([curr, amt]) =>
                    `${amt.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2})} ${curr}`
                ).join('<br>')}</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Hops Traced</div>
                <div class="stat-value">${totalHops}</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Transactions</div>
                <div class="stat-value">${totalTransactions}</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Trace Entries</div>
                <div class="stat-value">${totalEntries}</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Terminal Wallets</div>
                <div class="stat-value">${terminalWallets.length}</div>
            </div>
        </div>
    </div>

    <div class="section victim-section">
        <h2>👥 Victim Information</h2>
        <table>
            <thead>
                <tr>
                    <th>Victim</th>
                    <th>Total Loss</th>
                    <th>Transactions</th>
                    <th>Initial Receiving Wallet</th>
                </tr>
            </thead>
            <tbody>
                ${investigation.victims?.map(victim => `
                    <tr>
                        <td>${victim.name || 'Unknown'}<br><small>${victim.contactInfo || ''}</small></td>
                        <td class="amount">${victim.totalLoss} ${victim.transactions?.[0]?.currency || ''}</td>
                        <td>${victim.transactions?.length || 0}</td>
                        <td><span class="wallet-address">${victim.transactions?.[0]?.receivingWallet || 'N/A'}</span></td>
                    </tr>
                `).join('') || '<tr><td colspan="4">No victims recorded</td></tr>'}
            </tbody>
        </table>
    </div>

    <div class="graph-container page-break">
        <div class="graph-title">FUND FLOW VISUALIZATION</div>
        <img id="graphImage" src="" alt="Investigation Graph">
    </div>

    ${terminalWallets.length > 0 ? `
    <div class="section terminal-section">
        <h2>🏦 Terminal Wallet Arrivals (Exchanges)</h2>
        <table>
            <thead>
                <tr>
                    <th>Exchange</th>
                    <th>Amount</th>
                    <th>Currency</th>
                    <th>Receiving Wallet</th>
                    <th>Transaction Hash</th>
                    <th>Timestamp</th>
                </tr>
            </thead>
            <tbody>
                ${terminalWallets.map(tw => `
                    <tr>
                        <td><strong>${tw.exchangeName || 'Unknown'}</strong></td>
                        <td class="amount">${tw.amount?.toLocaleString() || '0'}</td>
                        <td>${tw.currency || ''}</td>
                        <td><span class="wallet-address">${tw.toWallet || ''}</span></td>
                        <td><span class="wallet-address">${(tw.txHash || '').substring(0, 20)}...</span></td>
                        <td>${tw.timestamp || ''}</td>
                    </tr>
                `).join('')}
            </tbody>
        </table>
        <div class="warning-box">
            <strong>⚖️ Legal Action Required:</strong> Funds have been traced to identified exchange wallets.
            Legal process (subpoena, court order, or law enforcement request) will be required to freeze
            and recover these assets. Contact legal counsel to initiate appropriate procedures with the exchanges listed above.
        </div>
    </div>
    ` : ''}

    <div class="section">
        <h2>🔍 Transaction Flow Details</h2>
        ${investigation.hops?.map((hop, index) => `
            <h3 style="color: #1976d2;">Hop ${hop.hopNumber}</h3>
            <table>
                <thead>
                    <tr>
                        <th>Type</th>
                        <th>Amount</th>
                        <th>From Wallet</th>
                        <th>To Wallet</th>
                        <th>Notes</th>
                    </tr>
                </thead>
                <tbody>
                    ${hop.entries?.map(entry => `
                        <tr>
                            <td>${entry.entryType?.toUpperCase() || 'TRACE'}</td>
                            <td class="amount">${parseFloat(entry.amount).toLocaleString()} ${entry.currency}</td>
                            <td><span class="wallet-address">${(entry.fromWallet || 'N/A').substring(0, 20)}...</span></td>
                            <td><span class="wallet-address">${(entry.toWallet || 'N/A').substring(0, 20)}...</span></td>
                            <td>${entry.notes || '-'}</td>
                        </tr>
                    `).join('') || '<tr><td colspan="5">No entries</td></tr>'}
                </tbody>
            </table>
        `).join('') || '<p>No hops recorded</p>'}
    </div>

    <div class="footer">
        <p>
            <strong>Generated by B.A.T.S. Tool</strong><br>
            Block Audit Tracing Standard - Version 1.0<br>
            ${new Date().toLocaleDateString()} at ${new Date().toLocaleTimeString()}<br>
            <br>
            <em>This report is for investigative purposes only. All wallet addresses and transaction
            data should be independently verified before taking legal action.</em>
        </p>
    </div>
</body>
</html>`;

            // Write the content to the new window
            printWindow.document.write(pdfContent);
            printWindow.document.close();

            // Add the graph image after a short delay
            setTimeout(() => {
                const svg = document.getElementById('investigationGraph');
                if (svg) {
                    const svgData = new XMLSerializer().serializeToString(svg);
                    const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
                    const url = URL.createObjectURL(svgBlob);

                    const img = new Image();
                    img.onload = function() {
                        // Create canvas to convert SVG to image
                        const canvas = document.createElement('canvas');
                        canvas.width = 1920;
                        canvas.height = 1080;
                        const ctx = canvas.getContext('2d');
                        ctx.fillStyle = 'white';
                        ctx.fillRect(0, 0, canvas.width, canvas.height);
                        ctx.drawImage(img, 0, 0, canvas.width, canvas.height);

                        // Set the image in the print window
                        const graphImg = printWindow.document.getElementById('graphImage');
                        if (graphImg) {
                            graphImg.src = canvas.toDataURL('image/png');
                        }
                        URL.revokeObjectURL(url);
                    };
                    img.src = url;
                }

                showNotification('📄 PDF report opened in new window. Click "Print / Save as PDF" to save.', 'success');
            }, 500);
        }

        function exportGraphToSVG() {
            const originalSvg = document.getElementById('investigationGraph');

            // Clone the SVG to add header
            const svgClone = originalSvg.cloneNode(true);

            // Add header group at the top
            const headerGroup = document.createElementNS('http://www.w3.org/2000/svg', 'g');
            headerGroup.setAttribute('transform', 'translate(0, 0)');

            // Add background rect for header
            const bgRect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
            bgRect.setAttribute('x', '0');
            bgRect.setAttribute('y', '0');
            bgRect.setAttribute('width', '100%');
            bgRect.setAttribute('height', '80');
            bgRect.setAttribute('fill', '#f5f5f5');
            headerGroup.appendChild(bgRect);

            // Add case title
            const caseText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            caseText.setAttribute('x', '20');
            caseText.setAttribute('y', '35');
            caseText.setAttribute('font-family', 'Arial, sans-serif');
            caseText.setAttribute('font-size', '24');
            caseText.setAttribute('font-weight', 'bold');
            caseText.setAttribute('fill', '#333');
            caseText.textContent = `Case: ${investigation.caseId || 'Untitled'}`;
            headerGroup.appendChild(caseText);

            // Add investigator and date
            const infoText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            infoText.setAttribute('x', '20');
            infoText.setAttribute('y', '60');
            infoText.setAttribute('font-family', 'Arial, sans-serif');
            infoText.setAttribute('font-size', '16');
            infoText.setAttribute('fill', '#666');
            infoText.textContent = `Investigator: ${investigation.investigator || 'Not Specified'} | Date: ${new Date().toLocaleDateString()}`;
            headerGroup.appendChild(infoText);

            // Shift existing content down
            const graphContent = svgClone.getElementById('graphContent');
            if (graphContent) {
                const currentTransform = graphContent.getAttribute('transform') || '';
                graphContent.setAttribute('transform', `${currentTransform} translate(0, 80)`);
            }

            // Insert header at the beginning
            svgClone.insertBefore(headerGroup, svgClone.firstChild);

            const svgData = new XMLSerializer().serializeToString(svgClone);
            const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(svgBlob);

            const a = document.createElement('a');
            a.href = url;
            a.download = `BATS_Graph_${investigation.caseId || 'export'}_${new Date().toISOString().split('T')[0]}.svg`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            showNotification('Graph exported as SVG with case metadata', 'success');
        }

        function exportGraphToPNG() {
            const svg = document.getElementById('investigationGraph');
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');

            canvas.width = 1920;
            canvas.height = 1080;

            // White background
            ctx.fillStyle = 'white';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Convert SVG to image
            const svgData = new XMLSerializer().serializeToString(svg);
            const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
            const url = URL.createObjectURL(svgBlob);

            // Add header information to the canvas
            ctx.fillStyle = '#f5f5f5';
            ctx.fillRect(0, 0, canvas.width, 80);
            ctx.fillStyle = '#333';
            ctx.font = 'bold 24px Arial';
            ctx.textAlign = 'left';
            ctx.fillText(`Case: ${investigation.caseId || 'Untitled'}`, 20, 30);
            ctx.font = '16px Arial';
            ctx.fillText(`Investigator: ${investigation.investigator || 'Not Specified'} | Date: ${new Date().toLocaleDateString()}`, 20, 55);

            // Prepare investigation data for embedding
            const investigationData = JSON.stringify({
                version: '1.0',
                exportDate: new Date().toISOString(),
                investigation: investigation
            });

            const img = new Image();
            img.onload = async function() {
                // Draw the graph below the header
                ctx.drawImage(img, 0, 80, canvas.width, canvas.height - 80);

                canvas.toBlob(async function(blob) {
                    try {
                        // Convert blob to array buffer
                        const arrayBuffer = await blob.arrayBuffer();
                        const uint8Array = new Uint8Array(arrayBuffer);

                        // Embed BATS data in PNG metadata
                        const pngWithMetadata = embedBATSData(uint8Array, investigationData);
                        const metadataBlob = new Blob([pngWithMetadata], { type: 'image/png' });

                        const pngUrl = URL.createObjectURL(metadataBlob);
                        const a = document.createElement('a');
                        a.href = pngUrl;
                        a.download = `BATS_Graph_${investigation.caseId || 'export'}_${new Date().toISOString().split('T')[0]}.png`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(pngUrl);
                        URL.revokeObjectURL(url);

                        showNotification('🎉 PNG exported with full investigation embedded! Share this image and recipients can import it back into BATS.', 'success');
                    } catch (error) {
                        console.error('Error embedding metadata:', error);
                        // Fallback to regular export
                        const pngUrl = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = pngUrl;
                        a.download = `BATS_Graph_${investigation.caseId || 'export'}_${new Date().toISOString().split('T')[0]}.png`;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                        URL.revokeObjectURL(pngUrl);
                        URL.revokeObjectURL(url);

                        showNotification('Graph exported as PNG', 'success');
                    }
                });
            };
            img.src = url;
        }

        // Show transaction notes popup
        function showTransactionNotes(notes, x, y) {
            // Remove existing popup if any
            const existing = document.getElementById('transactionNotesPopup');
            if (existing) {
                existing.remove();
            }

            // Create popup
            const popup = document.createElement('div');
            popup.id = 'transactionNotesPopup';
            popup.style.cssText = `
                position: fixed;
                left: ${x + 10}px;
                top: ${y - 30}px;
                background: #333;
                color: white;
                padding: 8px 12px;
                border-radius: 4px;
                font-size: 12px;
                max-width: 300px;
                z-index: 10000;
                box-shadow: 0 2px 8px rgba(0,0,0,0.3);
            `;
            popup.innerHTML = `<strong>Transaction Notes:</strong><br>${notes || 'No notes available'}`;
            document.body.appendChild(popup);

            // Auto-remove after 3 seconds or on click
            setTimeout(() => {
                if (document.getElementById('transactionNotesPopup')) {
                    popup.remove();
                }
            }, 3000);

            popup.addEventListener('click', () => popup.remove());
        }

        // Export format selection dialog
        function showExportOptions() {
            // Remove existing modal if any
            const existingModal = document.getElementById('exportModal');
            if (existingModal) existingModal.remove();
            const existingBackdrop = document.getElementById('exportBackdrop');
            if (existingBackdrop) existingBackdrop.remove();

            const modal = document.createElement('div');
            modal.id = 'exportModal';
            modal.style.cssText = `
                position: fixed;
                top: 50%;
                left: 50%;
                transform: translate(-50%, -50%);
                background: white;
                padding: 20px;
                border-radius: 8px;
                box-shadow: 0 4px 20px rgba(0,0,0,0.2);
                z-index: 10000;
            `;

            modal.innerHTML = `
                <h3 style="margin-top: 0; color: #333;">Select Export Format</h3>
                <div style="display: flex; flex-direction: column; gap: 12px;">

                    <div style="border: 2px solid #ff9800; border-radius: 6px; padding: 12px; background: #fff3e0;">
                        <button onclick="exportGraphToPNG(); document.getElementById('exportModal').remove(); document.getElementById('exportBackdrop').remove();"
                                style="width: 100%; padding: 12px; background: linear-gradient(135deg, #ff9800, #f57c00); color: white; border: none; border-radius: 4px; cursor: pointer; font-size: 16px; font-weight: bold;">
                            🖼️ Export as PNG (Recommended)
                        </button>
                        <div style="margin-top: 10px; padding: 10px; background: #fffbf7; border-radius: 4px;">
                            <div style="display: flex; align-items: center; margin-bottom: 5px;">
                                <span style="font-size: 18px; margin-right: 8px;">🎉</span>
                                <strong style="color: #e65100;">POWERFUL FEATURE:</strong>
                            </div>
                            <ul style="margin: 5px 0 0 20px; padding: 0; font-size: 13px; color: #5d4037; line-height: 1.6;">
                                <li><strong>Complete Data Embedded:</strong> The PNG contains your entire investigation invisibly embedded</li>
                                <li><strong>Share & Recover:</strong> Recipients can import the image back into BATS to continue the investigation</li>
                                <li><strong>Dual Purpose:</strong> Works as both a regular image AND a complete data backup</li>
                                <li><strong>Perfect for:</strong> Email attachments, documentation, and archiving</li>
                            </ul>
                            <div style="margin-top: 8px; padding: 6px; background: #fff8e1; border-left: 3px solid #ffc107; font-size: 12px; color: #6d4c41;">
                                💡 <strong>Tip:</strong> Anyone can view the image normally, but BATS users can extract the full investigation!
                            </div>
                        </div>
                    </div>

                    <div style="border: 1px solid #ddd; border-radius: 6px; padding: 12px; background: #fafafa;">
                        <button onclick="exportGraphToPDF(); document.getElementById('exportModal').remove(); document.getElementById('exportBackdrop').remove();"
                                style="width: 100%; padding: 10px; background: #2196f3; color: white; border: none; border-radius: 4px; cursor: pointer;">
                            📄 Export as PDF Report
                        </button>
                        <p style="margin: 8px 0 0 0; font-size: 12px; color: #666;">
                            <strong>Comprehensive report for case presentation:</strong> Includes investigation summary, victim details, graph visualization, terminal wallet analysis, and all transaction flows. Perfect for court filings and legal proceedings.
                        </p>
                    </div>

                    <div style="border: 1px solid #ddd; border-radius: 6px; padding: 12px; background: #fafafa;">
                        <button onclick="exportGraphToSVG(); document.getElementById('exportModal').remove(); document.getElementById('exportBackdrop').remove();"
                                style="width: 100%; padding: 10px; background: #4caf50; color: white; border: none; border-radius: 4px; cursor: pointer;">
                            🎨 Export as SVG
                        </button>
                        <p style="margin: 8px 0 0 0; font-size: 12px; color: #666;">
                            Scalable vector graphics for editing in design software (visual only, no embedded data)
                        </p>
                    </div>

                    <button onclick="document.getElementById('exportModal').remove(); document.getElementById('exportBackdrop').remove();"
                            style="width: 100%; padding: 10px; background: #666; color: white; border: none; border-radius: 4px; cursor: pointer;">
                        Cancel
                    </button>
                </div>
            `;

            document.body.appendChild(modal);

            // Click outside to close
            const backdrop = document.createElement('div');
            backdrop.id = 'exportBackdrop';
            backdrop.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.5);
                z-index: 9999;
            `;
            backdrop.onclick = () => {
                modal.remove();
                backdrop.remove();
            };
            document.body.appendChild(backdrop);
        }

        // Case Conclusion Dashboard Functions
        function updateCaseConclusionStats() {
            // Update victim count
            const victimCount = investigation.victims ? investigation.victims.length : 0;
            document.getElementById('victimCountStat').textContent = victimCount;

            // Update wallet count
            const walletCount = investigation.universalWalletIndex ? investigation.universalWalletIndex.length : 0;
            document.getElementById('walletCountStat').textContent = walletCount;

            // Update terminal wallet count
            const terminalCount = investigation.terminalWalletIndex ? investigation.terminalWalletIndex.length : 0;
            document.getElementById('terminalCountStat').textContent = terminalCount;

            // Calculate total funds traced
            let fundsTraced = {};
            if (investigation.victims) {
                investigation.victims.forEach(victim => {
                    victim.transactions?.forEach(tx => {
                        const currency = tx.currency === 'CUSTOM' ? tx.customCurrency : tx.currency;
                        if (!fundsTraced[currency]) fundsTraced[currency] = 0;
                        fundsTraced[currency] += parseFloat(tx.amount || 0);
                    });
                });
            }

            // Format funds traced
            const fundsTracedText = Object.entries(fundsTraced)
                .map(([curr, amt]) => `${amt.toFixed(2)} ${curr}`)
                .join(', ') || '0';
            document.getElementById('fundsTracedStat').textContent = fundsTracedText;
        }

        // View Victim Index
        function viewVictimIndex() {
            const modalHTML = `
                <div id="victimIndexModal" class="modal" style="display: block;">
                    <div class="modal-content" style="max-width: 900px; max-height: 90vh; overflow-y: auto;">
                        <div class="modal-header">
                            <h2>🎯 Victim Index</h2>
                            <button class="close-btn" onclick="document.getElementById('victimIndexModal').remove()">×</button>
                        </div>
                        <div style="padding: 20px;">
                            ${generateVictimIndexHTML()}
                        </div>
                        <div class="modal-footer" style="text-align: center; padding: 20px; border-top: 1px solid #eee;">
                            <button class="btn btn-success" onclick="exportVictimIndex()" style="margin-right: 10px;">
                                📊 Export to Excel
                            </button>
                            <button class="btn btn-secondary" onclick="document.getElementById('victimIndexModal').remove()">
                                Close
                            </button>
                        </div>
                    </div>
                </div>
            `;
            createCenteredModal('victimIndexModal', modalHTML);
        }

        // Generate Victim Index HTML
        function generateVictimIndexHTML() {
            if (!investigation.victims || investigation.victims.length === 0) {
                return '<p>No victims recorded in this investigation.</p>';
            }

            let html = '<div style="background: #fff5f5; border: 2px solid #ff6b6b; border-radius: 8px; padding: 20px; margin-bottom: 20px;">';
            html += '<h4 style="color: #ff6b6b; margin-bottom: 15px;">Victim Transaction Summary</h4>';
            html += '<table style="width: 100%; border-collapse: collapse;">';
            html += '<thead><tr style="background: #f8f9fa;">';
            html += '<th style="padding: 10px; border: 1px solid #ddd; text-align: left;">Victim</th>';
            html += '<th style="padding: 10px; border: 1px solid #ddd; text-align: left;">V-T Notation</th>';
            html += '<th style="padding: 10px; border: 1px solid #ddd; text-align: left;">Date</th>';
            html += '<th style="padding: 10px; border: 1px solid #ddd; text-align: right;">Amount</th>';
            html += '<th style="padding: 10px; border: 1px solid #ddd; text-align: left;">To Wallet</th>';
            html += '<th style="padding: 10px; border: 1px solid #ddd; text-align: left;">Transaction Hash</th>';
            html += '</tr></thead><tbody>';

            investigation.victims.forEach((victim, vIndex) => {
                victim.transactions?.forEach((tx, tIndex) => {
                    html += '<tr>';
                    html += `<td style="padding: 10px; border: 1px solid #ddd;">${victim.name || `Victim ${vIndex + 1}`}</td>`;
                    html += `<td style="padding: 10px; border: 1px solid #ddd; font-family: monospace;">V${vIndex + 1}-T${tIndex + 1}</td>`;
                    html += `<td style="padding: 10px; border: 1px solid #ddd;">${tx.date || 'N/A'}</td>`;
                    html += `<td style="padding: 10px; border: 1px solid #ddd; text-align: right;">${tx.amount} ${tx.currency}</td>`;
                    html += `<td style="padding: 10px; border: 1px solid #ddd; font-family: monospace; font-size: 12px;">${tx.toAddress}</td>`;
                    html += `<td style="padding: 10px; border: 1px solid #ddd; font-family: monospace; font-size: 12px;">${tx.hash}</td>`;
                    html += '</tr>';
                });
            });

            html += '</tbody></table></div>';
            return html;
        }

        // Export Victim Index
        function exportVictimIndex() {
            if (!investigation.victims || investigation.victims.length === 0) {
                alert('No victims to export');
                return;
            }

            let csvContent = 'Victim Name,V-T Notation,Date,Amount,Currency,To Wallet,Transaction Hash,Notes\n';

            investigation.victims.forEach((victim, vIndex) => {
                victim.transactions?.forEach((tx, tIndex) => {
                    const victimName = (victim.name || `Victim ${vIndex + 1}`).replace(/"/g, '""');
                    const notation = `V${vIndex + 1}-T${tIndex + 1}`;
                    const date = tx.date || 'N/A';
                    const amount = tx.amount || '0';
                    const currency = tx.currency || '';
                    const toAddress = tx.toAddress || '';
                    const hash = tx.hash || '';
                    const notes = (tx.notes || '').replace(/"/g, '""');

                    csvContent += `"${victimName}","${notation}","${date}","${amount}","${currency}","${toAddress}","${hash}","${notes}"\n`;
                });
            });

            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `Victim_Index_${investigation.caseId}_${new Date().toISOString().split('T')[0]}.csv`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // View Terminal Wallet Index
        function viewTerminalWalletIndex() {
            switchTab('hops');
            setTimeout(() => {
                showAnalysisTools();
                setTimeout(() => {
                    switchAnalysisTab('terminal-summary');
                }, 100);
            }, 100);
        }

        // Export All Indexes as ZIP
        async function exportAllIndexes() {
            // This would require a ZIP library, so for now we'll export them sequentially
            const exports = [
                { name: 'Victim Index', func: exportVictimIndex },
                { name: 'Red Wallet Index', func: exportRedWalletIndexCSV },
                { name: 'Universal Wallet Index', func: exportUniversalWalletIndex },
                { name: 'Terminal Wallet Report', func: exportTerminalWalletReport }
            ];

            const confirmed = confirm('This will download 4 separate files:\n\n' +
                '1. Victim Index (CSV)\n' +
                '2. Red Wallet Index (CSV)\n' +
                '3. Universal Wallet Index (CSV)\n' +
                '4. Terminal Wallet Report (CSV)\n\n' +
                'Continue?');

            if (!confirmed) return;

            // Export each file with a small delay
            for (let i = 0; i < exports.length; i++) {
                setTimeout(() => {
                    exports[i].func();
                }, i * 500); // 500ms delay between each export
            }

            showNotification('All indexes exported successfully!', 'success');
        }

        // Embed BATS data into PNG file using tEXt chunk
        function embedBATSData(pngArray, jsonData) {
            // Create tEXt chunk with BATS data
            const keyword = 'BATS_Investigation';
            const keywordBytes = new TextEncoder().encode(keyword);
            const separator = new Uint8Array([0]); // Null separator
            const textBytes = new TextEncoder().encode(jsonData);

            // Chunk data: keyword + null + text
            const chunkData = new Uint8Array(keywordBytes.length + 1 + textBytes.length);
            chunkData.set(keywordBytes, 0);
            chunkData.set(separator, keywordBytes.length);
            chunkData.set(textBytes, keywordBytes.length + 1);

            // Chunk type: 'tEXt'
            const chunkType = new TextEncoder().encode('tEXt');

            // Length (4 bytes, big-endian)
            const length = new ArrayBuffer(4);
            const lengthView = new DataView(length);
            lengthView.setUint32(0, chunkData.length, false);

            // Calculate CRC32
            const crc = calculateCRC32([...chunkType, ...chunkData]);
            const crcBytes = new ArrayBuffer(4);
            const crcView = new DataView(crcBytes);
            crcView.setUint32(0, crc, false);

            // Find IEND chunk position
            let iendPos = -1;
            for (let i = pngArray.length - 12; i >= 0; i--) {
                if (pngArray[i] === 0x49 && pngArray[i+1] === 0x45 &&
                    pngArray[i+2] === 0x4E && pngArray[i+3] === 0x44) {
                    iendPos = i - 4; // Position before IEND length
                    break;
                }
            }

            if (iendPos === -1) {
                console.error('IEND chunk not found in PNG');
                return pngArray;
            }

            // Create new PNG with custom chunk
            const newPng = new Uint8Array(pngArray.length + 12 + chunkData.length);

            // Copy everything before IEND
            newPng.set(pngArray.slice(0, iendPos), 0);

            // Add our custom tEXt chunk
            let offset = iendPos;
            newPng.set(new Uint8Array(length), offset);
            offset += 4;
            newPng.set(chunkType, offset);
            offset += 4;
            newPng.set(chunkData, offset);
            offset += chunkData.length;
            newPng.set(new Uint8Array(crcBytes), offset);
            offset += 4;

            // Copy IEND chunk
            newPng.set(pngArray.slice(iendPos), offset);

            return newPng;
        }

        // CRC32 calculation for PNG chunks
        function calculateCRC32(bytes) {
            const crcTable = [];
            for (let n = 0; n < 256; n++) {
                let c = n;
                for (let k = 0; k < 8; k++) {
                    c = ((c & 1) ? (0xEDB88320 ^ (c >>> 1)) : (c >>> 1));
                }
                crcTable[n] = c;
            }

            let crc = 0xFFFFFFFF;
            for (let i = 0; i < bytes.length; i++) {
                crc = (crc >>> 8) ^ crcTable[(crc ^ bytes[i]) & 0xFF];
            }
            return (crc ^ 0xFFFFFFFF) >>> 0;
        }

        // Extract BATS data from uploaded PNG
        async function extractBATSDataFromImage(file) {
            return new Promise((resolve, reject) => {
                const reader = new FileReader();
                reader.onload = async (e) => {
                    try {
                        const arrayBuffer = e.target.result;
                        const uint8Array = new Uint8Array(arrayBuffer);

                        // Look for tEXt chunk with BATS_Investigation keyword
                        const keyword = 'BATS_Investigation';
                        const keywordBytes = new TextEncoder().encode(keyword);

                        // Search through PNG chunks
                        let pos = 8; // Skip PNG signature
                        while (pos < uint8Array.length) {
                            // Read chunk length
                            const lengthBytes = uint8Array.slice(pos, pos + 4);
                            const length = new DataView(lengthBytes.buffer, lengthBytes.byteOffset, 4).getUint32(0, false);
                            pos += 4;

                            // Read chunk type
                            const typeBytes = uint8Array.slice(pos, pos + 4);
                            const type = new TextDecoder().decode(typeBytes);
                            pos += 4;

                            // Check if it's a tEXt chunk
                            if (type === 'tEXt') {
                                const chunkData = uint8Array.slice(pos, pos + length);

                                // Check if keyword matches
                                let keywordMatch = true;
                                for (let j = 0; j < keywordBytes.length && j < chunkData.length; j++) {
                                    if (chunkData[j] !== keywordBytes[j]) {
                                        keywordMatch = false;
                                        break;
                                    }
                                }

                                if (keywordMatch) {
                                    // Extract text data (after keyword and null separator)
                                    const textStart = keywordBytes.length + 1;
                                    if (textStart < chunkData.length) {
                                        const textData = chunkData.slice(textStart);
                                        const jsonString = new TextDecoder().decode(textData);

                                        try {
                                            const data = JSON.parse(jsonString);
                                            resolve(data);
                                            return;
                                        } catch (parseError) {
                                            console.error('Failed to parse embedded JSON:', parseError);
                                        }
                                    }
                                }
                            }

                            // Move to next chunk
                            pos += length + 4; // Skip chunk data and CRC

                            // Check for IEND
                            if (type === 'IEND') break;
                        }

                        // No BATS data found
                        resolve(null);
                    } catch (error) {
                        console.error('Error reading PNG:', error);
                        reject(error);
                    }
                };
                reader.readAsArrayBuffer(file);
            });
        }

        // Import graph image with embedded data
        async function importGraphImage(event) {
            const file = event.target.files[0];
            if (!file) return;

            showNotification('Extracting investigation data from image...', 'info');

            try {
                const extractedData = await extractBATSDataFromImage(file);

                if (extractedData && extractedData.investigation) {
                    // Load the investigation
                    investigation = extractedData.investigation;

                    // Update all displays
                    if (typeof updateVictimsDisplay === 'function') updateVictimsDisplay();
                    if (typeof updateCaseDetailsDisplay === 'function') updateCaseDetailsDisplay();

                    // Switch to flow diagram tab to show the graph
                    switchTab('flowdiagram');

                    // Initialize graph visualization after a short delay
                    setTimeout(() => {
                        initializeGraphVisualization();
                    }, 100);

                    showNotification('🎉 Investigation loaded from image successfully!', 'success');
                } else {
                    showNotification('No BATS data found in this image. Please use an image exported from BATS.', 'error');
                }
            } catch (error) {
                console.error('Error extracting data from image:', error);
                showNotification('Failed to extract data from image', 'error');
            }

            // Clear the input for next use
            event.target.value = '';
        }

        function shareGraph() {
            // Create shareable link or copy graph data
            const graphData = {
                investigation: investigation.caseId,
                nodes: graphState.nodes.length,
                edges: graphState.edges.length,
                timestamp: new Date().toISOString()
            };

            const shareText = `BATS Investigation Graph - ${investigation.caseId || 'Untitled'}\n${graphState.nodes.length} nodes, ${graphState.edges.length} edges\nExported: ${new Date().toLocaleString()}`;

            if (navigator.share) {
                navigator.share({
                    title: 'BATS Investigation Graph',
                    text: shareText
                }).catch(err => console.log('Share failed:', err));
            } else {
                navigator.clipboard.writeText(shareText).then(() => {
                    showNotification('Graph summary copied to clipboard', 'success');
                });
            }
        }
    </script>
</body>
</html>