<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>B.A.T.S. - Block Audit Tracing Standard</title>
    <!-- 
    DEPLOYMENT INSTRUCTIONS:
    For full functionality (custom save locations, autosave), serve this file over HTTPS:
    
    Option 1 - Local Development Server:
    - Python: python -m http.server 8000 (then visit http://localhost:8000)
    - Node.js: npx http-server
    - VS Code: Use Live Server extension
    
    Option 2 - Web Hosting:
    - Upload to any HTTPS-enabled web server
    - GitHub Pages (free): https://pages.github.com
    - Netlify Drop (free): https://app.netlify.com/drop
    
    Option 3 - Direct File Access:
    - Open index.html directly in browser
    - Limited functionality: saves only to Downloads folder
    -->
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f0f4f8;
            min-height: 100vh;
            color: #2c3e50;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        .case-details-card {
            background: white;
            border-radius: 8px;
            padding: 25px;
            margin-bottom: 20px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
            border: 1px solid #e8f0fe;
        }

        .case-details-card .form-group {
            margin-bottom: 0;
        }

        .header {
            background: linear-gradient(135deg, #2c3e50 0%, #34495e 100%);
            color: white;
            padding: 30px;
            border-radius: 8px;
            text-align: center;
            margin-bottom: 30px;
            box-shadow: 0 4px 15px rgba(44, 62, 80, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 30px;
        }

        .header-logo {
            width: 168px;
            height: auto;
            flex-shrink: 0;
        }

        .header-content {
            flex: 1;
            text-align: center;
        }

        .header h1 {
            font-size: 2.8rem;
            font-weight: 700;
            margin-bottom: 10px;
            letter-spacing: 2px;
        }

        .header .subtitle {
            font-size: 1.2rem;
            opacity: 0.9;
            font-weight: 300;
        }

        .workflow-steps {
            background: white;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
            border: 1px solid #e8f0fe;
        }

        .steps-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
        }

        .step-item {
            text-align: center;
            padding: 15px;
            border-radius: 8px;
            background: #f8f9fa;
            border: 2px solid #e8f0fe;
            transition: all 0.3s ease;
        }

        .step-item.active {
            background: #e8f5e8;
            border-color: #27ae60;
        }

        .step-item.completed {
            background: #d4edda;
            border-color: #27ae60;
        }

        .step-number {
            background: #3498db;
            color: white;
            width: 30px;
            height: 30px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            margin: 0 auto 10px;
            font-weight: bold;
        }

        .step-item.completed .step-number {
            background: #27ae60;
        }

        .main-content {
            display: block;
            width: 100%;
        }

        .sidebar {
            background: white;
            border-radius: 8px;
            padding: 25px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
            height: fit-content;
            border: 1px solid #e8f0fe;
        }

        .main-panel {
            background: white;
            border-radius: 8px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.08);
            min-height: 600px;
            border: 1px solid #e8f0fe;
            width: 100%;
        }

        .section-title {
            font-size: 1.4rem;
            font-weight: 600;
            margin-bottom: 20px;
            color: #2c3e50;
            border-bottom: 3px solid #3498db;
            padding-bottom: 10px;
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 500;
            color: #34495e;
            font-size: 14px;
        }

        .form-group input,
        .form-group select,
        .form-group textarea {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e8f0fe;
            border-radius: 6px;
            font-size: 14px;
            transition: border-color 0.3s ease;
            background: #fdfdfd;
        }

        .form-group input:focus,
        .form-group select:focus,
        .form-group textarea:focus {
            outline: none;
            border-color: #3498db;
            background: white;
        }

        .datetime-timezone {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .datetime-timezone input {
            flex: 1;
        }

        .datetime-timezone select {
            width: 100px;
            flex-shrink: 0;
        }

        .btn {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 6px;
            cursor: pointer;
            font-weight: 600;
            transition: all 0.3s ease;
            margin-right: 10px;
            margin-bottom: 10px;
            font-size: 14px;
        }

        .btn:hover {
            transform: translateY(-1px);
            box-shadow: 0 4px 12px rgba(52, 152, 219, 0.3);
        }

        .btn-secondary {
            background: linear-gradient(135deg, #95a5a6 0%, #7f8c8d 100%);
        }
        
        .btn-add-transaction {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            color: white;
            font-weight: 600;
            padding: 10px 20px;
            margin-right: 10px;
        }
        
        .btn-add-transaction:hover {
            background: linear-gradient(135deg, #2980b9 0%, #21618c 100%);
            transform: translateY(-1px);
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.3);
        }

        .btn-danger {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }

        .btn-success {
            background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
        }

        .btn-confirm {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
            font-size: 16px;
            padding: 15px 30px;
        }

        .btn-large {
            font-size: 18px;
            padding: 20px 40px;
            margin: 30px 0;
            font-weight: 700;
        }

        .generate-root-section {
            background: linear-gradient(135deg, #e8f5e8 0%, #d4edda 100%);
            border: 3px solid #27ae60;
            border-radius: 12px;
            padding: 30px;
            text-align: center;
            margin-top: 30px;
            box-shadow: 0 4px 15px rgba(39, 174, 96, 0.2);
        }

        .generate-root-section h3 {
            color: #27ae60;
            font-size: 1.5rem;
            margin-bottom: 15px;
        }

        .generate-root-section p {
            color: #2c3e50;
            margin-bottom: 25px;
            font-size: 16px;
            line-height: 1.6;
        }

        .trace-entry {
            background: #fdfdfd;
            border: 2px solid #e8f0fe;
            border-radius: 8px;
            padding: 20px;
            margin-bottom: 20px;
            transition: all 0.3s ease;
        }

        .trace-entry:hover {
            border-color: #3498db;
            box-shadow: 0 4px 15px rgba(52, 152, 219, 0.1);
        }

        .trace-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 15px;
        }

        .trace-notation {
            font-family: 'Courier New', monospace;
            font-weight: bold;
            color: #2c3e50;
            font-size: 1.2rem;
        }

        .validation-panel {
            background: linear-gradient(135deg, #27ae60 0%, #229954 100%);
            color: white;
            padding: 20px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: center;
            font-weight: 500;
        }

        .validation-error {
            background: linear-gradient(135deg, #e74c3c 0%, #c0392b 100%);
        }

        .validation-warning {
            background: linear-gradient(135deg, #f39c12 0%, #e67e22 100%);
        }

        .nav-tabs {
            display: flex;
            margin-bottom: 25px;
            border-bottom: 2px solid #e8f0fe;
        }

        .nav-tab {
            padding: 15px 25px;
            border: none;
            background: none;
            cursor: pointer;
            font-weight: 500;
            color: #7f8c8d;
            border-bottom: 3px solid transparent;
            transition: all 0.3s ease;
            font-size: 14px;
        }

        .nav-tab.active {
            color: #3498db;
            border-bottom-color: #3498db;
        }

        .nav-tab:hover:not(.active) {
            color: #2c3e50;
        }

        .tab-content {
            display: none;
        }

        .tab-content.active {
            display: block !important;
        }

        .summary-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 20px;
            margin: 20px 0;
        }

        /* Dashboard Styles */
        .dashboard-stat {
            background: white;
            border-radius: 6px;
            padding: 20px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: transform 0.2s;
        }

        .dashboard-stat:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }

        .stat-label {
            font-size: 14px;
            color: #7f8c8d;
            margin-bottom: 8px;
            font-weight: 600;
        }

        .stat-value {
            font-size: 28px;
            font-weight: bold;
            color: #2c3e50;
        }

        .progress-bar-container {
            margin-bottom: 15px;
        }

        .progress-bar-label {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            margin-bottom: 5px;
        }

        .progress-bar-bg {
            background: #e0e0e0;
            border-radius: 10px;
            height: 20px;
            overflow: hidden;
        }

        .progress-bar-fill {
            background: linear-gradient(135deg, #3498db 0%, #2980b9 100%);
            height: 100%;
            border-radius: 10px;
            transition: width 0.3s ease;
        }

        .search-highlight {
            background-color: #fff3cd !important;
            border: 2px solid #ffc107 !important;
            animation: highlight-pulse 1s ease-in-out;
        }

        @keyframes highlight-pulse {
            0% { opacity: 0.7; }
            50% { opacity: 1; }
            100% { opacity: 0.7; }
        }

        .analysis-tab-content {
            padding: 20px;
            min-height: 300px;
        }

        .summary-card {
            background: #fdfdfd;
            border-radius: 8px;
            padding: 25px;
            text-align: center;
            border: 2px solid #e8f0fe;
            transition: transform 0.3s ease;
        }

        .summary-card:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 15px rgba(0,0,0,0.1);
        }

        .summary-card h3 {
            color: #3498db;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }

        .summary-card .value {
            font-size: 1.8rem;
            font-weight: bold;
            color: #2c3e50;
        }

        .export-section {
            background: #fdfdfd;
            border-radius: 8px;
            padding: 25px;
            margin-top: 30px;
            border: 2px solid #e8f0fe;
        }

        .modal {
            display: none;
            position: fixed;
            z-index: 1000;
            left: 0;
            top: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0,0,0,0.5);
            align-items: center;
            justify-content: center;
        }
        
        .modal.show {
            display: flex;
        }

        .modal-content {
            background-color: white;
            padding: 30px;
            border-radius: 12px;
            width: 90%;
            max-width: 700px;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
            max-height: 85vh;
            overflow-y: auto;
            position: relative;
        }
        
        /* Wallet Address Autocomplete Styles */
        .wallet-autocomplete-container {
            position: relative;
        }
        
        .wallet-autocomplete-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 1px solid #ddd;
            border-top: none;
            border-radius: 0 0 4px 4px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            display: none;
        }
        
        .wallet-autocomplete-item {
            padding: 10px;
            cursor: pointer;
            border-bottom: 1px solid #f0f0f0;
            font-family: monospace;
            font-size: 13px;
        }
        
        .wallet-autocomplete-item:hover {
            background-color: #f8f9fa;
        }
        
        .wallet-autocomplete-item.selected {
            background-color: #e3f2fd;
        }
        
        .wallet-autocomplete-blockchain {
            font-size: 11px;
            color: #666;
            margin-top: 4px;
            font-family: sans-serif;
        }
        
        .wallet-autocomplete-loading {
            padding: 15px;
            text-align: center;
            color: #666;
            font-size: 13px;
        }

        .modal-header {
            text-align: center;
            margin-bottom: 25px;
        }

        .modal-header h2 {
            color: #2c3e50;
            margin-bottom: 10px;
        }

        .root-total-display {
            background: #e8f5e8;
            border: 2px solid #27ae60;
            border-radius: 8px;
            padding: 20px;
            text-align: center;
            margin: 20px 0;
        }

        .root-total-amount {
            font-size: 2.5rem;
            font-weight: bold;
            color: #27ae60;
            margin: 10px 0;
        }

        .root-explanation {
            background: #f8f9fa;
            border-left: 4px solid #3498db;
            padding: 20px;
            margin: 20px 0;
            border-radius: 0 8px 8px 0;
        }

        .root-explanation h4 {
            color: #2c3e50;
            margin-bottom: 15px;
            font-size: 1.2rem;
        }

        .root-explanation ul {
            color: #34495e;
            line-height: 1.8;
            padding-left: 20px;
        }

        .root-explanation li {
            margin-bottom: 8px;
        }

        .art-display {
            background: #e8f4f8;
            border: 2px solid #3498db;
            border-radius: 6px;
            padding: 10px 15px;
            margin: 10px 0;
            text-align: center;
            font-weight: bold;
            color: #2c3e50;
        }

        .file-input-wrapper {
            position: relative;
            display: inline-block;
            cursor: pointer;
            margin-right: 10px;
        }

        .file-input-wrapper input[type=file] {
            position: absolute;
            left: -9999px;
        }

        .no-traces-message {
            text-align: center;
            padding: 40px;
            color: #7f8c8d;
            background: #f8f9fa;
            border-radius: 8px;
            border: 2px dashed #bdc3c7;
        }

        .custom-currency-input {
            display: none;
        }

        .wallet-display {
            background: #f8f9fa;
            border: 2px solid #e8f0fe;
            border-radius: 6px;
            padding: 10px 15px;
            margin: 10px 0;
            font-weight: bold;
            color: #2c3e50;
        }

        .wallet-display.red { background: #ffe6e6; border-color: #e74c3c; color: #c0392b; }
        .wallet-display.pink { background: #fce4ec; border-color: #e91e63; color: #c2185b; }
        .wallet-display.yellow { background: #fff8e1; border-color: #f1c40f; color: #f39c12; }
        .wallet-display.orange { background: #fff3e0; border-color: #f39c12; color: #e67e22; }
        .wallet-display.black { background: #f5f5f5; border-color: #2c3e50; color: #2c3e50; }
        .wallet-display.brown { background: #efebe9; border-color: #8d6e63; color: #5d4037; }
        .wallet-display.blue { background: #e3f2fd; border-color: #3498db; color: #2980b9; }
        .wallet-display.purple { background: #f3e5f5; border-color: #9b59b6; color: #8e44ad; }
        .wallet-display.gray { background: #f5f5f5; border-color: #95a5a6; color: #7f8c8d; }
        .wallet-display.green { background: #e8f5e8; border-color: #27ae60; color: #229954; }
        
        /* Pulse animation for call-to-action buttons */
        @keyframes pulse {
            0% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(255, 152, 0, 0.7);
            }
            50% {
                transform: scale(1.05);
                box-shadow: 0 0 20px 10px rgba(255, 152, 0, 0);
            }
            100% {
                transform: scale(1);
                box-shadow: 0 0 0 0 rgba(255, 152, 0, 0);
            }
        }

        @media (max-width: 1200px) {
            .main-content {
                grid-template-columns: 1fr;
            }

            .steps-grid {
                grid-template-columns: repeat(3, 1fr);
            }
        }

        @media (max-width: 768px) {
            .steps-grid {
                grid-template-columns: 1fr;
            }

            .datetime-timezone {
                flex-direction: column;
                gap: 5px;
            }

            .datetime-timezone select {
                width: 100%;
            }
        }
        /* =================================
   PART 4: CSS ADDITIONS - Add to your existing <style> section
   ================================= */

/* Enhanced UI Styles for Thread Tracking */
.enhanced-notation {
    background: linear-gradient(135deg, #f8f9fa 0%, #e8f4f8 100%);
    border: 2px solid #3498db;
    border-radius: 8px;
    padding: 15px;
    margin: 10px 0;
    font-family: 'Courier New', monospace;
    min-height: 80px;
}

.source-chain-display {
    background: #e8f4f8;
    border: 1px solid #3498db;
    border-radius: 4px;
    padding: 10px;
    margin: 8px 0;
    font-size: 12px;
}

.thread-tracker {
    background: #fff3cd;
    border: 2px solid #ffc107;
    border-radius: 6px;
    padding: 12px;
    margin: 10px 0;
}

.assignment-preview {
    background: #f8f9fa;
    border: 1px solid #ddd;
    border-radius: 4px;
    padding: 8px;
    margin-top: 5px;
    font-size: 12px;
}

.assignment-preview.valid {
    background: #d4edda;
    border-color: #27ae60;
    color: #155724;
}

.assignment-preview.invalid {
    background: #f8d7da;
    border-color: #dc3545;
    color: #721c24;
}

.convergence-indicator {
    background: #f39c12;
    color: white;
    padding: 2px 8px;
    border-radius: 4px;
    font-size: 11px;
    font-weight: bold;
    display: inline-block;
    margin-left: 8px;
}

/* Part 4 Integration Styles */
.part4-notification {
    background: linear-gradient(135deg, #d1ecf1 0%, #b8daff 100%);
    border: 2px solid #3498db;
    border-radius: 8px;
    padding: 20px;
    margin-bottom: 20px;
    color: #0c5460;
}

.enhanced-validation-panel {
    background: linear-gradient(135deg, #f8f9fa 0%, #e8f4f8 100%);
    border: 2px solid #3498db;
    border-radius: 8px;
    padding: 20px;
    margin: 20px 0;
}

.thread-analysis {
    background: #f8f9fa;
    border: 1px solid #ddd;
    border-radius: 6px;
    padding: 15px;
    margin: 10px 0;
    font-size: 14px;
}

.source-chain-report {
    background: white;
    border: 1px solid #ddd;
    border-radius: 6px;
    padding: 15px;
    margin: 10px 0;
    font-family: 'Courier New', monospace;
    font-size: 12px;
}

/* Collapsible hop and entry animations */
.hop-container {
    transition: all 0.3s ease;
}

.hop-header {
    transition: background-color 0.3s ease;
}

.hop-header:hover {
    filter: brightness(1.1);
}

.entry-collapsed {
    transition: all 0.3s ease;
}

@keyframes pulse {
    0% {
        box-shadow: 0 0 0 0 rgba(39, 174, 96, 0.7);
        transform: scale(1);
    }
    50% {
        box-shadow: 0 0 20px 10px rgba(39, 174, 96, 0);
        transform: scale(1.05);
    }
    100% {
        box-shadow: 0 0 0 0 rgba(39, 174, 96, 0);
        transform: scale(1);
    }
}

/* Terminal Wallet Notification Styles */
.terminal-notification {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: white;
    border-radius: 12px;
    box-shadow: 0 10px 40px rgba(0,0,0,0.3);
    z-index: 10000;
    max-width: 500px;
    animation: slideIn 0.3s ease;
}

@keyframes slideIn {
    from {
        opacity: 0;
        transform: translate(-50%, -45%);
    }
    to {
        opacity: 1;
        transform: translate(-50%, -50%);
    }
}

.terminal-notification-overlay {
    position: fixed;
    top: 0;
    left: 0;
    right: 0;
    bottom: 0;
    background: rgba(0,0,0,0.5);
    z-index: 9999;
    animation: fadeIn 0.3s ease;
}

@keyframes fadeIn {
    from { opacity: 0; }
    to { opacity: 1; }
}

/* Modal Styles */
.modal {
    display: none;
    position: fixed;
    z-index: 1000;
    left: 0;
    top: 0;
    width: 100%;
    height: 100%;
    background-color: rgba(0,0,0,0.5);
    align-items: center;
    justify-content: center;
}

.modal.show {
    display: flex;
}

.modal-content {
    background-color: white;
    margin: auto;
    padding: 0;
    border-radius: 8px;
    box-shadow: 0 4px 20px rgba(0,0,0,0.3);
    position: relative;
    animation: modalSlideIn 0.3s ease;
    max-height: 90vh;
    overflow-y: auto;
}

@keyframes modalSlideIn {
    from {
        transform: translateY(-50px);
        opacity: 0;
    }
    to {
        transform: translateY(0);
        opacity: 1;
    }
}

/* Flow Diagram Styles */
.flow-wallet-node {
    cursor: pointer;
    transition: all 0.2s ease;
    stroke: #333;
    stroke-width: 2;
}

.flow-wallet-node:hover {
    filter: brightness(1.1);
    transform: scale(1.05);
}

.flow-connection-line {
    fill: none;
    stroke-width: 1;
    stroke: #333;
}

.flow-thread-amount {
    font-size: 14px;
    font-weight: 600;
    font-family: 'Courier New', monospace;
    fill: #2c3e50;
    background: white;
    padding: 2px;
}

.flow-hop-lane {
    opacity: 0.3;
}

.flow-hop-lane-1 {
    fill: #FFB6C1;
}

.flow-hop-lane-2 {
    fill: #87CEEB;
}

.flow-hop-lane-3 {
    fill: #98FB98;
}

.flow-hop-lane-4 {
    fill: #DDA0DD;
}

.flow-hop-lane-5 {
    fill: #F0E68C;
}

.flow-hop-title {
    font-size: 18px;
    font-weight: bold;
    fill: #2c3e50;
}

.flow-sum-text {
    font-size: 16px;
    font-weight: bold;
    font-family: 'Courier New', monospace;
    fill: #2c3e50;
}

.flow-wallet-label {
    font-size: 12px;
    font-weight: bold;
    fill: white;
}

@media print {
    #flowDiagramControls {
        display: none !important;
    }
    
    #flowDiagramContainer {
        border: none !important;
        box-shadow: none !important;
    }
}
   </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <div style="background: white; padding: 15px; border-radius: 8px; box-shadow: 0 2px 8px rgba(0, 0, 0, 0.1); margin-right: 30px;">
                <img src="data:image/png;base64,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

" alt="The Block Audit Logo" class="header-logo">
            </div>
            <div class="header-content">
                <h1>B.A.T.S.</h1>
                <div class="subtitle">Block Audit Tracing Standard - Professional Crypto Investigation Documentation</div>
            </div>
            <div style="position: relative;">
                <button onclick="toggleFileMenu()" style="background: #3498db; color: white; padding: 10px 20px; border: none; border-radius: 6px; cursor: pointer; font-size: 16px;">
                     File 
                </button>
                <div id="fileDropdown" style="display: none; position: absolute; right: 0; top: 100%; margin-top: 5px; background: white; border: 1px solid #ddd; border-radius: 6px; box-shadow: 0 4px 12px rgba(0,0,0,0.15); z-index: 1000; min-width: 200px;">
                    <button onclick="saveInvestigation(); toggleFileMenu();" style="display: block; width: 100%; padding: 12px 20px; border: none; background: none; text-align: left; cursor: pointer; font-size: 14px; transition: background 0.2s;" onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background='none'">
                         Save .bats File
                    </button>
                    <button onclick="handleLoadFile(); toggleFileMenu();" style="display: block; width: 100%; padding: 12px 20px; border: none; background: none; text-align: left; cursor: pointer; font-size: 14px; transition: background 0.2s;" onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background='none'">
                         Load .bats File
                    </button>
                    <button onclick="document.getElementById('excelInput').click(); toggleFileMenu();" style="display: block; width: 100%; padding: 12px 20px; border: none; background: none; text-align: left; cursor: pointer; font-size: 14px; transition: background 0.2s;" onmouseover="this.style.background='#f0f0f0'" onmouseout="this.style.background='none'">
                         Import Excel Traces
                    </button>
                </div>
            </div>
        </div>
        
        <!-- Hidden file inputs -->
        <input type="file" id="fileInput" accept=".bats,.json" onchange="loadInvestigation(event)" style="display: none;">
        <input type="file" id="excelInput" accept=".xlsx,.xls,.csv" onchange="importExcelTraces(event)" style="display: none;">

        <!-- Workflow Steps -->
        <div class="workflow-steps">
            <div class="steps-grid">
                <div class="step-item" id="step1">
                    <div class="step-number">1</div>
                    <div><strong>Investigation Setup</strong></div>
                    <div>Case details & investigator info</div>
                </div>
                <div class="step-item" id="step2">
                    <div class="step-number">2</div>
                    <div><strong>Add Victims</strong></div>
                    <div>Document victim transactions</div>
                </div>
                <div class="step-item" id="step3">
                    <div class="step-number">3</div>
                    <div><strong>Confirm Root Total</strong></div>
                    <div>Establish investigation baseline</div>
                </div>
                <div class="step-item" id="step4">
                    <div class="step-number">4</div>
                    <div><strong>Document Traces</strong></div>
                    <div>Record blockchain hops</div>
                </div>
                <div class="step-item" id="step5">
                    <div class="step-number">5</div>
                    <div><strong>Add Write-offs</strong></div>
                    <div>Document abandoned paths</div>
                </div>
                <div class="step-item" id="step6">
                    <div class="step-number">6</div>
                    <div><strong>Validate & Export</strong></div>
                    <div>Generate B.A.T.S. report</div>
                </div>
            </div>
        </div>


        <div class="main-content" style="display: block;">
            <!-- Main Panel -->
            <div class="main-panel" style="margin: 0; width: 100%;">
                <!-- Action Bar -->
                <div style="display: flex; justify-content: space-between; align-items: center; padding: 10px 20px; background: #f8f9fa; border-bottom: 2px solid #e8f0fe;">
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <button id="undoButton" class="btn" onclick="performUndo()" disabled 
                                style="background: #95a5a6; padding: 8px 16px;" 
                                title="No actions to undo">
                             Undo
                        </button>
                        <button class="btn" onclick="showNavigationMenu()" 
                                style="background: #3498db; padding: 8px 16px;">
                             Navigate
                        </button>
                        <a href="training.html" target="_blank" class="btn" 
                           style="background: #27ae60; padding: 8px 16px; text-decoration: none; display: inline-block;">
                             Training Materials
                        </a>
                    </div>
                    <div id="breadcrumbs" style="font-size: 14px; color: #666;">
                        <!-- Breadcrumbs will be dynamically updated -->
                    </div>
                </div>
                
                <div class="nav-tabs">
                    <button class="nav-tab" onclick="switchTab('casedetails')">Case Details</button>
                    <button class="nav-tab active" onclick="switchTab('victims')">Victims & Transactions</button>
                    <button class="nav-tab" onclick="switchTab('traces')">Trace Documentation</button>
                    <button class="nav-tab" onclick="switchTab('walletindexes')">Wallet Indexes</button>
                    <button class="nav-tab" onclick="switchTab('flowdiagram')">Flow Diagram</button>
                    <button class="nav-tab" onclick="switchTab('summary')">Summary & Export</button>
                </div>

                <!-- Welcome Screen -->
                <div id="welcomeScreen" style="display: none; padding: 40px; background: linear-gradient(135deg, #f5f7fa 0%, #c3cfe2 100%); min-height: 600px;">
                    <div style="max-width: 900px; margin: 0 auto;">
                        <div style="text-align: center; margin-bottom: 50px;">
                            <h1 style="color: #2c3e50; font-size: 3.5rem; margin-bottom: 20px; font-weight: 700;">
                                Welcome to B.A.T.S. 
                            </h1>
                            <p style="font-size: 1.4rem; color: #5a6c7d; margin-bottom: 10px;">
                                Block Audit Tracing Standard
                            </p>
                            <p style="font-size: 1.1rem; color: #7f8c8d;">
                                Professional Cryptocurrency Investigation & Recovery Tool
                            </p>
                        </div>
                        
                        <!-- Quick Start Section -->
                        <div style="background: white; border-radius: 20px; padding: 40px; box-shadow: 0 10px 40px rgba(0,0,0,0.1); margin-bottom: 40px;">
                            <h2 style="color: #2c3e50; margin-bottom: 30px; text-align: center;">
                                 Quick Start Your Investigation
                            </h2>
                            
                            <!-- Step Progress Indicator -->
                            <div style="display: flex; justify-content: center; align-items: center; margin-bottom: 40px;">
                                <div style="text-align: center;">
                                    <div style="width: 60px; height: 60px; background: #ff9800; color: white; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 24px; font-weight: bold; margin: 0 auto 10px;">1</div>
                                    <div style="font-weight: 600; color: #e65100;">Setup Case</div>
                                </div>
                                <div style="width: 100px; height: 3px; background: #ddd; margin: 0 20px;"></div>
                                <div style="text-align: center;">
                                    <div style="width: 60px; height: 60px; background: #ddd; color: white; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 24px; font-weight: bold; margin: 0 auto 10px;">2</div>
                                    <div style="font-weight: 600; color: #999;">Add Victims</div>
                                </div>
                                <div style="width: 100px; height: 3px; background: #ddd; margin: 0 20px;"></div>
                                <div style="text-align: center;">
                                    <div style="width: 60px; height: 60px; background: #ddd; color: white; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-size: 24px; font-weight: bold; margin: 0 auto 10px;">3</div>
                                    <div style="font-weight: 600; color: #999;">Trace Funds</div>
                                </div>
                            </div>
                            
                            <!-- Quick Setup Form -->
                            <div style="background: linear-gradient(135deg, #fff5e6 0%, #ffe4cc 100%); border: 2px solid #ff9800; border-radius: 12px; padding: 30px; margin-bottom: 30px;">
                                <h3 style="color: #e65100; margin-bottom: 20px;"> Step 1: Basic Case Information</h3>
                                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                                    <div>
                                        <label style="display: block; font-weight: 600; margin-bottom: 8px; color: #333;">Case ID *</label>
                                        <input type="text" id="welcomeCaseId" placeholder="e.g., CASE-2024-001" style="width: 100%; padding: 12px; border: 2px solid #ff9800; border-radius: 6px; font-size: 16px;">
                                    </div>
                                    <div>
                                        <label style="display: block; font-weight: 600; margin-bottom: 8px; color: #333;">Investigator Name *</label>
                                        <input type="text" id="welcomeInvestigator" placeholder="Your name" style="width: 100%; padding: 12px; border: 2px solid #ff9800; border-radius: 6px; font-size: 16px;">
                                    </div>
                                </div>
                                <div style="margin-bottom: 20px;">
                                    <label style="display: block; font-weight: 600; margin-bottom: 8px; color: #333;">Case Type *</label>
                                    <select id="welcomeCaseType" style="width: 100%; padding: 12px; border: 2px solid #ff9800; border-radius: 6px; font-size: 16px; background: white;">
                                        <option value="">Select case type...</option>
                                        <option value="investment_fraud">Investment Fraud</option>
                                        <option value="ransomware">Ransomware</option>
                                        <option value="romance_scam">Romance Scam</option>
                                        <option value="business_email_compromise">Business Email Compromise</option>
                                        <option value="crypto_theft">Cryptocurrency Theft</option>
                                        <option value="other">Other</option>
                                    </select>
                                </div>
                                <div>
                                    <label style="display: block; font-weight: 600; margin-bottom: 8px; color: #333;">Case Synopsis</label>
                                    <textarea id="welcomeCaseSynopsis" placeholder="Brief description of the case..." style="width: 100%; padding: 12px; border: 2px solid #ff9800; border-radius: 6px; font-size: 16px; min-height: 80px; resize: vertical;"></textarea>
                                </div>
                            </div>
                            
                            <div style="text-align: center;">
                                <button class="btn btn-large" onclick="quickStartInvestigation()" style="background: linear-gradient(135deg, #ff9800 0%, #f57c00 100%); padding: 20px 50px; font-size: 20px;">
                                    Start Investigation 
                                </button>
                                <div style="margin-top: 15px;">
                                    <a href="#" onclick="skipWelcome()" style="color: #666; text-decoration: underline;">Skip and set up manually</a>
                                </div>
                            </div>
                        </div>
                        
                        <!-- Feature Cards -->
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(250px, 1fr)); gap: 20px;">
                            <div style="background: white; padding: 25px; border-radius: 12px; text-align: center; box-shadow: 0 4px 20px rgba(0,0,0,0.08); transition: transform 0.3s;">
                                <div style="font-size: 3rem; margin-bottom: 15px;"></div>
                                <h4 style="color: #2c3e50; margin-bottom: 10px;">Multi-Chain Support</h4>
                                <p style="color: #666; font-size: 0.95rem;">Track stolen funds across Bitcoin, Ethereum, and all ERC-20 tokens seamlessly</p>
                            </div>
                            <div style="background: white; padding: 25px; border-radius: 12px; text-align: center; box-shadow: 0 4px 20px rgba(0,0,0,0.08); transition: transform 0.3s;">
                                <div style="font-size: 3rem; margin-bottom: 15px;"></div>
                                <h4 style="color: #2c3e50; margin-bottom: 10px;">Precision Tracking</h4>
                                <p style="color: #666; font-size: 0.95rem;">Follow every satoshi and wei through complex transaction paths</p>
                            </div>
                            <div style="background: white; padding: 25px; border-radius: 12px; text-align: center; box-shadow: 0 4px 20px rgba(0,0,0,0.08); transition: transform 0.3s;">
                                <div style="font-size: 3rem; margin-bottom: 15px;"></div>
                                <h4 style="color: #2c3e50; margin-bottom: 10px;">Visual Analysis</h4>
                                <p style="color: #666; font-size: 0.95rem;">Generate professional flow diagrams and comprehensive investigation reports</p>
                            </div>
                        </div>
                    </div>
                </div>

                <!-- BATS Info Tab -->
                <div id="batsinfo-tab" class="tab-content">
                    <div class="section-title"> B.A.T.S. Framework Education Center</div>
                    
                    <!-- Key Benefit Highlight -->
                    <div style="background: linear-gradient(135deg, #fff3cd 0%, #ffeaa7 100%); border: 3px solid #fdcb6e; border-radius: 12px; padding: 30px; margin-bottom: 30px; text-align: center;">
                        <h2 style="color: #f39c12; margin-bottom: 15px;"> The Key Benefit of B.A.T.S.</h2>
                        <p style="font-size: 1.3rem; color: #2c3e50; font-weight: 600; margin-bottom: 15px;">
                            Standardized Documentation = Reproducible Results
                        </p>
                        <p style="color: #34495e; font-size: 1.1rem; line-height: 1.6;">
                            Any investigator following the B.A.T.S. methodology will arrive at the same conclusions, creating legally defensible evidence that withstands scrutiny and enables successful asset forfeiture.
                        </p>
                    </div>

                    <!-- Quick Navigation -->
                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 30px;">
                        <button class="btn" style="background: #3498db;" onclick="document.getElementById('batsOverview').scrollIntoView({behavior: 'smooth'})">
                             Overview
                        </button>
                        <button class="btn" style="background: #27ae60;" onclick="document.getElementById('batsMethodology').scrollIntoView({behavior: 'smooth'})">
                             Methodology
                        </button>
                        <button class="btn" style="background: #e74c3c;" onclick="document.getElementById('batsNotation').scrollIntoView({behavior: 'smooth'})">
                             V-T-H Notation
                        </button>
                        <button class="btn" style="background: #9b59b6;" onclick="document.getElementById('batsColors').scrollIntoView({behavior: 'smooth'})">
                             Wallet Colors
                        </button>
                        <button class="btn" style="background: #f39c12;" onclick="document.getElementById('batsGoldenThread').scrollIntoView({behavior: 'smooth'})">
                             Golden Thread
                        </button>
                        <button class="btn" style="background: #1abc9c;" onclick="document.getElementById('batsQuickRef').scrollIntoView({behavior: 'smooth'})">
                             Quick Reference
                        </button>
                    </div>

                    <!-- Overview Section -->
                    <div id="batsOverview" style="background: white; border-radius: 8px; padding: 30px; margin-bottom: 30px; box-shadow: 0 2px 10px rgba(0,0,0,0.08);">
                        <h3 style="color: #2c3e50; margin-bottom: 20px;"> What is B.A.T.S.?</h3>
                        <p style="line-height: 1.8; margin-bottom: 15px;">
                            The <strong>Block Audit Tracing Standard (B.A.T.S.)</strong> is a revolutionary framework for cryptocurrency investigation that transforms blockchain analysis from an art into a science. It provides the mathematical certainty required for successful asset forfeiture cases.
                        </p>
                        <div style="background: #ecf0f1; padding: 20px; border-radius: 8px; margin: 20px 0;">
                            <h4 style="color: #2c3e50; margin-bottom: 15px;">Core Principles:</h4>
                            <ul style="line-height: 1.8;">
                                <li><strong>Mathematical Precision</strong> - Every dollar accounted for</li>
                                <li><strong>Standardized Process</strong> - Consistent methodology across all cases</li>
                                <li><strong>Legal Compliance</strong> - Meets court requirements for asset forfeiture</li>
                                <li><strong>Scope Control</strong> - Prevents investigation creep</li>
                                <li><strong>Complete Documentation</strong> - Full audit trail for legal review</li>
                            </ul>
                        </div>
                        <div style="background: #d5f4e6; padding: 20px; border-radius: 8px; border-left: 4px solid #27ae60;">
                            <p style="margin: 0;">
                                <strong>Remember:</strong> B.A.T.S. ensures that two different investigators analyzing the same case will reach identical conclusions, providing the reproducibility that courts demand.
                            </p>
                        </div>
                    </div>

                    <!-- Methodology Section -->
                    <div id="batsMethodology" style="background: white; border-radius: 8px; padding: 30px; margin-bottom: 30px; box-shadow: 0 2px 10px rgba(0,0,0,0.08);">
                        <h3 style="color: #2c3e50; margin-bottom: 20px;"> The B.A.T.S. Methodology</h3>
                        
                        <div style="margin-bottom: 30px;">
                            <h4 style="color: #27ae60; margin-bottom: 15px;">Step 1: Establish Root Total</h4>
                            <p style="line-height: 1.8; margin-bottom: 10px;">Document all victim losses to create your mathematical baseline. This becomes your Adjusted Root Total (ART) after any justified write-offs.</p>
                            <div style="background: #f8f9fa; padding: 15px; border-radius: 6px; font-family: monospace;">
                                Example: Victim 1 lost $10,000 + Victim 2 lost $5,000 = $15,000 Root Total
                            </div>
                        </div>

                        <div style="margin-bottom: 30px;">
                            <h4 style="color: #27ae60; margin-bottom: 15px;">Step 2: Apply V-T-H Notation</h4>
                            <p style="line-height: 1.8; margin-bottom: 10px;">Assign unique identifiers to every transaction maintaining clear lineage from victims.</p>
                            <div style="background: #f8f9fa; padding: 15px; border-radius: 6px; font-family: monospace;">
                                V1-T1  V1-T1-H1  V1-T1-H2  Terminal Wallet
                            </div>
                        </div>

                        <div style="margin-bottom: 30px;">
                            <h4 style="color: #27ae60; margin-bottom: 15px;">Step 3: Classify Wallets by Color</h4>
                            <p style="line-height: 1.8; margin-bottom: 10px;">Assign permanent colors based on wallet function, not ownership assumptions.</p>
                        </div>

                        <div style="margin-bottom: 30px;">
                            <h4 style="color: #27ae60; margin-bottom: 15px;">Step 4: Validate at Each Hop</h4>
                            <p style="line-height: 1.8; margin-bottom: 10px;">Ensure all thread totals at each hop level sum to your ART. This mathematical validation proves completeness.</p>
                            <div style="background: #fee; padding: 15px; border-radius: 6px; border-left: 4px solid #e74c3c;">
                                <strong>Critical:</strong> If totals don't match, you've missed transactions!
                            </div>
                        </div>

                        <div style="margin-bottom: 30px;">
                            <h4 style="color: #27ae60; margin-bottom: 15px;">Step 5: Document Terminal Points</h4>
                            <p style="line-height: 1.8;">Identify where funds reach exchanges (PURPLE) or cold storage (BLUE) for legal process or monitoring.</p>
                        </div>
                    </div>

                    <!-- V-T-H Notation Section -->
                    <div id="batsNotation" style="background: white; border-radius: 8px; padding: 30px; margin-bottom: 30px; box-shadow: 0 2px 10px rgba(0,0,0,0.08);">
                        <h3 style="color: #2c3e50; margin-bottom: 20px;"> Understanding V-T-H Notation</h3>
                        
                        <div style="background: #e8f5e8; padding: 25px; border-radius: 8px; margin-bottom: 20px;">
                            <h4 style="color: #27ae60; margin-bottom: 15px;">The Formula: V[#]-T[#]-H[#]</h4>
                            <ul style="line-height: 2; font-size: 1.1rem;">
                                <li><strong>V</strong> = Victim number (V1, V2, V3...)</li>
                                <li><strong>T</strong> = Transaction number (T1, T2, T3...)</li>
                                <li><strong>H</strong> = Hop count from victim (H1, H2, H3...)</li>
                            </ul>
                        </div>

                        <div style="margin-bottom: 20px;">
                            <h4 style="color: #3498db; margin-bottom: 15px;">Practical Examples:</h4>
                            <table style="width: 100%; border-collapse: collapse;">
                                <tr style="background: #f8f9fa;">
                                    <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Notation</th>
                                    <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Meaning</th>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #ddd; padding: 12px; font-family: monospace;">V1-T1</td>
                                    <td style="border: 1px solid #ddd; padding: 12px;">First victim's first transaction (at RED wallet)</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #ddd; padding: 12px; font-family: monospace;">V1-T1-H1</td>
                                    <td style="border: 1px solid #ddd; padding: 12px;">One hop away from victim's transaction</td>
                                </tr>
                                <tr>
                                    <td style="border: 1px solid #ddd; padding: 12px; font-family: monospace;">V2-T3-H5</td>
                                    <td style="border: 1px solid #ddd; padding: 12px;">Second victim's third transaction, five hops away</td>
                                </tr>
                            </table>
                        </div>

                        <div style="background: #ffeaa7; padding: 20px; border-radius: 8px; border-left: 4px solid #fdcb6e;">
                            <p style="margin: 0;">
                                <strong>Why This Matters:</strong> V-T-H notation creates an unambiguous audit trail that any investigator can follow, ensuring reproducible results.
                            </p>
                        </div>
                    </div>

                    <!-- Wallet Colors Section -->
                    <div id="batsColors" style="background: white; border-radius: 8px; padding: 30px; margin-bottom: 30px; box-shadow: 0 2px 10px rgba(0,0,0,0.08);">
                        <h3 style="color: #2c3e50; margin-bottom: 20px;"> Wallet Color Classification</h3>
                        
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(300px, 1fr)); gap: 20px;">
                            <div style="background: #ffebee; padding: 20px; border-radius: 8px; border-left: 4px solid #e74c3c;">
                                <h4 style="color: #c0392b; margin-bottom: 10px;"> RED Wallets</h4>
                                <p><strong>Definition:</strong> Victim-facing wallets</p>
                                <p><strong>Rule:</strong> First wallet to receive victim funds</p>
                                <p><strong>Example:</strong> Scammer's receiving address</p>
                            </div>

                            <div style="background: #fff8e1; padding: 20px; border-radius: 8px; border-left: 4px solid #f39c12;">
                                <h4 style="color: #f39c12; margin-bottom: 10px;"> YELLOW Wallets</h4>
                                <p><strong>Definition:</strong> Convergence/hub wallets</p>
                                <p><strong>Rule:</strong> Where multiple victim traces meet</p>
                                <p><strong>Example:</strong> Criminal consolidation wallet</p>
                            </div>

                            <div style="background: #f3e5f5; padding: 20px; border-radius: 8px; border-left: 4px solid #9b59b6;">
                                <h4 style="color: #8e44ad; margin-bottom: 10px;"> PURPLE Wallets</h4>
                                <p><strong>Definition:</strong> Exchange deposit addresses</p>
                                <p><strong>Rule:</strong> Known VASP/exchange wallets</p>
                                <p><strong>Example:</strong> Binance deposit address</p>
                            </div>

                            <div style="background: #e3f2fd; padding: 20px; border-radius: 8px; border-left: 4px solid #3498db;">
                                <h4 style="color: #2980b9; margin-bottom: 10px;"> BLUE Wallets</h4>
                                <p><strong>Definition:</strong> Cold storage wallets</p>
                                <p><strong>Rule:</strong> Long-term holding addresses</p>
                                <p><strong>Example:</strong> Criminal savings wallet</p>
                            </div>

                            <div style="background: #f5f5f5; padding: 20px; border-radius: 8px; border-left: 4px solid #34495e;">
                                <h4 style="color: #2c3e50; margin-bottom: 10px;"> BLACK Wallets</h4>
                                <p><strong>Definition:</strong> Standard intermediary</p>
                                <p><strong>Rule:</strong> Default for unclassified</p>
                                <p><strong>Example:</strong> Pass-through addresses</p>
                            </div>

                            <div style="background: #e8f5e8; padding: 20px; border-radius: 8px; border-left: 4px solid #27ae60;">
                                <h4 style="color: #27ae60; margin-bottom: 10px;"> Remember</h4>
                                <p><strong>Colors are permanent!</strong></p>
                                <p>Once assigned, never change</p>
                                <p>Based on function, not ownership</p>
                            </div>
                        </div>
                    </div>

                    <!-- Golden Thread Section -->
                    <div id="batsGoldenThread" style="background: white; border-radius: 8px; padding: 30px; margin-bottom: 30px; box-shadow: 0 2px 10px rgba(0,0,0,0.08);">
                        <h3 style="color: #2c3e50; margin-bottom: 20px;"> The Golden Thread Principle</h3>
                        
                        <div style="background: linear-gradient(135deg, #ffeaa7 0%, #fab1a0 100%); padding: 25px; border-radius: 8px; margin-bottom: 20px;">
                            <h4 style="color: #2c3e50; margin-bottom: 15px;">Definition</h4>
                            <p style="font-size: 1.1rem; line-height: 1.8;">
                                The unbroken connection between a victim's original funds and any assets ultimately seized by law enforcement. This principle is essential for proving in court that specific seized cryptocurrency originated from criminal activity.
                            </p>
                        </div>

                        <div style="margin-bottom: 20px;">
                            <h4 style="color: #e74c3c; margin-bottom: 15px;">The PIFO Method (Proceeds In First Out)</h4>
                            <p style="line-height: 1.8; margin-bottom: 15px;">
                                When traced funds enter a wallet, the very next outbound transaction contains those funds. Apply this strictly chronologically to maintain the golden thread through commingled funds.
                            </p>
                            <div style="background: #f8f9fa; padding: 20px; border-radius: 8px;">
                                <strong>Example:</strong><br>
                                Wallet has 5 BTC existing balance<br>
                                Victim sends 2 BTC (our traced funds)<br>
                                Next transaction out is 3 BTC<br>
                                 We trace 2 BTC of that 3 BTC transaction
                            </div>
                        </div>

                        <div style="background: #fee; padding: 20px; border-radius: 8px; border-left: 4px solid #e74c3c;">
                            <h4 style="color: #c0392b; margin-bottom: 10px;"> Breaking the Thread</h4>
                            <p style="margin: 0;">
                                The golden thread breaks if you cannot mathematically prove the connection. Common breaks: mixers, privacy coins, or poor documentation. Document these as write-offs.
                            </p>
                        </div>
                    </div>

                    <!-- Quick Reference Section -->
                    <div id="batsQuickRef" style="background: white; border-radius: 8px; padding: 30px; margin-bottom: 30px; box-shadow: 0 2px 10px rgba(0,0,0,0.08);">
                        <h3 style="color: #2c3e50; margin-bottom: 20px;"> Quick Reference Guide</h3>
                        
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(350px, 1fr)); gap: 20px;">
                            <div style="background: #e8f8f5; padding: 20px; border-radius: 8px;">
                                <h4 style="color: #1abc9c; margin-bottom: 15px;"> B.A.T.S. Checklist</h4>
                                <ul style="line-height: 1.8;">
                                    <li> Document all victim transactions</li>
                                    <li> Calculate and confirm root total</li>
                                    <li> Apply V-T-H notation consistently</li>
                                    <li> Classify wallets by color (permanent!)</li>
                                    <li> Validate totals at each hop level</li>
                                    <li> Document all write-offs with justification</li>
                                    <li> Identify terminal wallets (PURPLE/BLUE)</li>
                                    <li> Export comprehensive report</li>
                                </ul>
                            </div>

                            <div style="background: #fef9e7; padding: 20px; border-radius: 8px;">
                                <h4 style="color: #f39c12; margin-bottom: 15px;"> Key Terms</h4>
                                <dl style="line-height: 1.8;">
                                    <dt><strong>ART</strong></dt>
                                    <dd>Adjusted Root Total (after write-offs)</dd>
                                    
                                    <dt><strong>Thread Total</strong></dt>
                                    <dd>Amount being traced at specific hop</dd>
                                    
                                    <dt><strong>Convergence</strong></dt>
                                    <dd>Multiple traces meeting at one wallet</dd>
                                    
                                    <dt><strong>Write-off</strong></dt>
                                    <dd>Documented abandonment of trace</dd>
                                    
                                    <dt><strong>Terminal Wallet</strong></dt>
                                    <dd>Exchange or cold storage endpoint</dd>
                                </dl>
                            </div>
                        </div>

                        <div style="background: #d5f4e6; padding: 20px; border-radius: 8px; margin-top: 20px; text-align: center;">
                            <h4 style="color: #27ae60; margin-bottom: 15px;"> Always Remember</h4>
                            <p style="font-size: 1.2rem; font-weight: 600; margin: 0;">
                                Standardized Process = Reproducible Results = Successful Forfeiture
                            </p>
                        </div>
                    </div>

                    <!-- Getting Started -->
                    <div style="background: linear-gradient(135deg, #a29bfe 0%, #6c5ce7 100%); color: white; padding: 30px; border-radius: 8px; text-align: center;">
                        <h3 style="margin-bottom: 20px;">Ready to Begin?</h3>
                        <p style="font-size: 1.1rem; margin-bottom: 20px;">
                            Now that you understand the B.A.T.S. methodology, start your investigation with confidence!
                        </p>
                        <button class="btn btn-large" style="background: white; color: #6c5ce7;" onclick="switchTab('victims')">
                             Start Investigation
                        </button>
                    </div>
                </div>

                <!-- Case Details Tab -->
                <div id="casedetails-tab" class="tab-content">
                    <div class="section-title"> Case Information & Management</div>
                    
                    <div class="case-details-card" style="max-width: 900px; margin: 0 auto;">
                        <div style="background: linear-gradient(135deg, #f8f9fa 0%, #e9ecef 100%); border-radius: 12px; padding: 30px; margin-bottom: 30px;">
                            <h3 style="color: #2c3e50; margin-bottom: 25px;">Investigation Details</h3>
                            
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                                <div class="form-group">
                                    <label for="caseId">Case ID</label>
                                    <input type="text" id="caseId" placeholder="e.g., CASE-2025-001">
                                </div>
                                <div class="form-group">
                                    <label for="investigator">Investigator</label>
                                    <input type="text" id="investigator" placeholder="Your name">
                                </div>
                            </div>
                            
                            <div class="form-group">
                                <label for="caseType">Case Type</label>
                                <select id="caseType">
                                    <option value="">Select type...</option>
                                    <option value="investment_fraud">Investment Fraud</option>
                                    <option value="ransomware">Ransomware</option>
                                    <option value="romance_scam">Romance Scam</option>
                                    <option value="business_email_compromise">Business Email Compromise</option>
                                    <option value="crypto_theft">Cryptocurrency Theft</option>
                                    <option value="other">Other</option>
                                </select>
                            </div>
                            
                            <div class="form-group">
                                <label for="caseSynopsis">Case Synopsis</label>
                                <textarea id="caseSynopsis" rows="5" placeholder="Briefly describe the circumstances that led to the victim's asset loss (e.g., investment platform, romance scam details, ransomware attack, etc.)" style="width: 100%; padding: 12px; border: 2px solid #e8f0fe; border-radius: 6px; resize: vertical;"></textarea>
                                <div style="font-size: 12px; color: #666; margin-top: 5px;">This will be included in the final report</div>
                            </div>
                            
                            <div style="text-align: center; margin-top: 30px;">
                                <button class="btn btn-confirm" onclick="saveCaseDetails()" style="padding: 15px 40px; font-size: 18px;">
                                     Save Case Details
                                </button>
                            </div>
                        </div>
                        
                        <!-- Investigation Statistics -->
                        <div style="background: white; border-radius: 12px; padding: 30px; box-shadow: 0 2px 10px rgba(0,0,0,0.08);">
                            <h3 style="color: #2c3e50; margin-bottom: 25px;"> Investigation Progress</h3>
                            <div id="caseStats" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 20px;">
                                <!-- Stats will be populated dynamically -->
                            </div>
                        </div>
                    </div>
                </div>

                <!-- Victims Tab -->
                <div id="victims-tab" class="tab-content">
                    <div class="section-title">Step 2: Victim Transactions</div>
                    
                    <!-- Enhanced Instructions -->
                    <div id="victimInstructions" style="background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%); border: 2px solid #2196f3; border-radius: 12px; padding: 25px; margin-bottom: 30px;">
                        <h3 style="color: #1976d2; margin-bottom: 15px;"> Document All Victim Transactions</h3>
                        <p style="color: #2c3e50; margin-bottom: 15px;">
                            Enter ALL transactions where victims sent assets to scammer-controlled wallets. This creates the foundation for your entire investigation.
                        </p>
                        <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                            <div style="background: white; padding: 15px; border-radius: 6px;">
                                <strong style="color: #1976d2;">Required Information:</strong>
                                <ul style="margin: 10px 0 0 20px; color: #555;">
                                    <li>Transaction hash</li>
                                    <li>Amount & currency</li>
                                    <li>Date & time (UTC)</li>
                                    <li>Receiving (RED) wallet</li>
                                </ul>
                            </div>
                            <div style="background: white; padding: 15px; border-radius: 6px;">
                                <strong style="color: #27ae60;">Pro Tips:</strong>
                                <ul style="margin: 10px 0 0 20px; color: #555;">
                                    <li>Use API lookup to auto-fill</li>
                                    <li>Paste multiple hashes at once</li>
                                    <li>V-T notation auto-assigns</li>
                                    <li>Save regularly (.bats file)</li>
                                </ul>
                            </div>
                        </div>
                    </div>
                    
                    <div id="victimsList"></div>
                    <button class="btn" onclick="addVictim()" style="font-size: 1.1rem; padding: 12px 30px;">+ Add New Victim</button>
                    
                    <!-- Generate Root Total Section -->
                    <div id="generateRootSection" style="display: none;">
                        <div class="generate-root-section">
                            <h3> Ready to Generate Root Total?</h3>
                            <p>You've entered victim transaction data. The next step is to establish your investigation baseline by generating and confirming your Root Total.</p>
                            <div id="saveRequiredMessage" style="display: none; background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 20px; margin: 20px 0;">
                                <h4 style="color: #856404; margin: 0 0 10px 0;"> Save Required to Continue</h4>
                                <p style="color: #666; margin-bottom: 15px;">
                                    Before proceeding, you must save your investigation file. This will enable automatic saving at each hop.
                                </p>
                                <button class="btn btn-confirm" onclick="saveAndCaptureFilePath()" style="background: #ffc107; color: #333; padding: 10px 30px;">
                                     Save Investigation and Calculate ART
                                </button>
                            </div>
                            <button class="btn btn-confirm btn-large" id="generateRootBtn" onclick="generateRootTotal()" style="display: none;">
                                 Generate Root Total & Begin Tracing
                            </button>
                        </div>
                    </div>
                    
                    <!-- Next Step Button -->
                    <div style="margin-top: 30px; padding: 20px; background: #f8f9fa; border-radius: 8px; border: 2px solid #3498db; text-align: center;">
                        <h4 style="color: #2c3e50; margin-bottom: 15px;">Ready for the Next Step?</h4>
                        <p style="color: #666; margin-bottom: 20px;">Once you've added all victim transactions, proceed to wallet indexes to understand your wallet classifications.</p>
                        <button class="btn btn-confirm" onclick="switchTab('walletindexes')" style="background: #3498db; color: white; padding: 12px 30px; font-size: 16px;">
                             Next: Review Wallet Indexes 
                        </button>
                    </div>
                </div>

                <!-- Wallet Indexes Tab -->
                <div id="walletindexes-tab" class="tab-content">
                    <div class="section-title">Wallet Indexes</div>
                    
                    <!-- Dropdown selector for different indexes -->
                    <div style="margin-bottom: 20px;">
                        <label style="font-weight: bold; margin-right: 10px;">Select Index:</label>
                        <select id="walletIndexSelector" onchange="switchWalletIndex(this.value)" style="padding: 8px 15px; border: 2px solid #3498db; border-radius: 4px; font-size: 16px;">
                            <option value="universal">Universal Wallet Index (All Wallets)</option>
                            <option value="red">Red Wallet Index (Victim-Facing)</option>
                            <option value="purple">Purple Wallet Index (Exchanges)</option>
                            <option value="blue">Blue Wallet Index (Cold Storage)</option>
                        </select>
                    </div>
                    
                    <!-- Universal Wallet Index -->
                    <div id="universalWalletIndexContent" class="wallet-index-content">
                        <div style="background: #e8f4f8; border: 2px solid #3498db; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
                            <h4 style="color: #2c3e50; margin-bottom: 15px;"> About the Universal Wallet Index</h4>
                            <p style="color: #2c3e50; margin-bottom: 10px;">This index catalogs all wallets involved in your investigation with their permanent classifications. Use this to:</p>
                            <ul style="color: #2c3e50; margin-left: 20px;">
                                <li>Maintain consistent wallet identification across your investigation</li>
                                <li>Document wallet classifications per BATP color system</li>
                                <li>Add notes about wallet behavior, exchange identifications, or other findings</li>
                                <li>Provide technical appendix for legal proceedings</li>
                            </ul>
                        </div>
                        <div id="universalWalletIndexList"></div>
                        <button class="btn" onclick="addManualWallet()">+ Add Manual Wallet Entry</button>
                        <button class="btn btn-success" onclick="exportWalletIndex('universal')"> Export Universal Index to Excel</button>
                        <button class="btn btn-primary" onclick="openApiSettings()"> API Settings</button>
                    </div>
                    
                    <!-- Red Wallet Index -->
                    <div id="redWalletIndexContent" class="wallet-index-content" style="display: none;">
                        <div style="background: #ffe4e4; border: 2px solid #dc3545; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
                            <h4 style="color: #dc3545; margin-bottom: 15px;"> About the Red Wallet Index</h4>
                            <p style="color: #2c3e50; margin-bottom: 10px;">This index summarizes all victim deposits to RED wallets (victim-facing wallets). Use this reference throughout your investigation to:</p>
                            <ul style="color: #2c3e50; margin-left: 20px;">
                                <li>Quickly reference victim loss amounts and dates</li>
                                <li>Identify which wallets received initial victim funds</li>
                                <li>Add investigative notes and findings for each deposit</li>
                                <li>Cross-reference with blockchain analysis tools</li>
                            </ul>
                        </div>
                        <div id="redWalletIndexList"></div>
                        <button class="btn btn-success" onclick="exportWalletIndex('red')"> Export Red Index to Excel</button>
                    </div>
                    
                    <!-- Purple Wallet Index -->
                    <div id="purpleWalletIndexContent" class="wallet-index-content" style="display: none;">
                        <div style="background: #f3e5ff; border: 2px solid #6f42c1; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
                            <h4 style="color: #6f42c1; margin-bottom: 15px;"> About the Purple Wallet Index</h4>
                            <p style="color: #2c3e50; margin-bottom: 10px;">This index lists all PURPLE wallets (exchanges/VASPs) identified in your investigation. Use this for:</p>
                            <ul style="color: #2c3e50; margin-left: 20px;">
                                <li>Compiling exchange addresses for legal service requests</li>
                                <li>Tracking which exchanges received traced funds</li>
                                <li>Documenting exchange identification methodology</li>
                                <li>Preparing subpoena/warrant applications</li>
                            </ul>
                        </div>
                        <div id="purpleWalletIndexList"></div>
                        <button class="btn btn-success" onclick="exportWalletIndex('purple')"> Export Purple Index to Excel</button>
                    </div>
                    
                    <!-- Blue Wallet Index -->
                    <div id="blueWalletIndexContent" class="wallet-index-content" style="display: none;">
                        <div style="background: #e3f2fd; border: 2px solid #2196f3; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
                            <h4 style="color: #2196f3; margin-bottom: 15px;"> About the Blue Wallet Index</h4>
                            <p style="color: #2c3e50; margin-bottom: 10px;">This index tracks all BLUE wallets (cold storage) where funds remain stationary. Use this for:</p>
                            <ul style="color: #2c3e50; margin-left: 20px;">
                                <li>Monitoring cold storage wallets for future movement</li>
                                <li>Recording amounts held in cold storage at trace completion</li>
                                <li>Setting up blockchain alerts for fund movement</li>
                                <li>Documenting temporary trace endpoints</li>
                            </ul>
                        </div>
                        <div id="blueWalletIndexList"></div>
                        <button class="btn btn-success" onclick="exportWalletIndex('blue')"> Export Blue Index to Excel</button>
                    </div>
                    
                    <!-- Next Step Button -->
                    <div style="margin-top: 30px; padding: 20px; background: #f8f9fa; border-radius: 8px; border: 2px solid #e74c3c; text-align: center;">
                        <h4 style="color: #2c3e50; margin-bottom: 15px;">Ready to Begin Tracing?</h4>
                        <p style="color: #666; margin-bottom: 20px;">Now that you understand your wallet classifications, start documenting the cryptocurrency trace through hops.</p>
                        <button class="btn btn-confirm" onclick="switchTab('traces')" style="background: #e74c3c; color: white; padding: 12px 30px; font-size: 16px;">
                             Next: Begin Trace Documentation 
                        </button>
                    </div>
                </div>

                <!-- Traces Tab -->
                <div id="traces-tab" class="tab-content">
                    <div class="section-title">Step 4: Trace Documentation</div>
                    
                    <!-- Investigation Dashboard -->
                    <div id="investigationDashboard" style="background: #f8f9fa; border: 2px solid #3498db; border-radius: 8px; padding: 20px; margin-bottom: 30px;">
                        <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px;">
                            <h3 style="color: #2c3e50; margin: 0;"> Investigation Dashboard</h3>
                            <button class="btn btn-sm" onclick="toggleDashboard()" id="dashboardToggle">Hide Dashboard</button>
                        </div>
                        
                        <div id="dashboardContent">
                            <!-- Quick Stats -->
                            <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px; margin-bottom: 20px;">
                                <div class="dashboard-stat">
                                    <div class="stat-label">Total Victims</div>
                                    <div class="stat-value" id="dashStatVictims">0</div>
                                </div>
                                <div class="dashboard-stat">
                                    <div class="stat-label">Total Hops</div>
                                    <div class="stat-value" id="dashStatHops">0</div>
                                </div>
                                <div class="dashboard-stat">
                                    <div class="stat-label">Active Threads</div>
                                    <div class="stat-value" id="dashStatThreads">0</div>
                                </div>
                                <div class="dashboard-stat">
                                    <div class="stat-label">Terminal Wallets</div>
                                    <div class="stat-value" id="dashStatTerminal">0</div>
                                </div>
                            </div>
                            
                            <!-- ART Progress -->
                            <div style="background: white; border-radius: 6px; padding: 15px; margin-bottom: 20px;">
                                <h4 style="color: #2c3e50; margin-bottom: 15px;">Available Remaining Total (ART) by Currency</h4>
                                <div id="artProgressBars"></div>
                            </div>
                            
                            <!-- Quick Navigation -->
                            <div style="background: white; border-radius: 6px; padding: 15px;">
                                <h4 style="color: #2c3e50; margin-bottom: 15px;">Quick Navigation</h4>
                                <div style="display: flex; gap: 10px; flex-wrap: wrap;">
                                    <select id="hopJumpMenu" onchange="jumpToHop(this.value)" style="padding: 8px; border: 1px solid #ddd; border-radius: 4px;">
                                        <option value="">Jump to Hop...</option>
                                    </select>
                                    <input type="text" id="globalSearch" placeholder="Search wallets, amounts, hashes..." onkeyup="globalSearchDebounce()" style="padding: 8px; border: 1px solid #ddd; border-radius: 4px; flex: 1; min-width: 200px;">
                                    <button class="btn btn-sm" onclick="showThreadFilter()"> Filter Threads</button>
                                    <button class="btn btn-sm" onclick="showAnalysisTools()"> Analysis Tools</button>
                                    <button class="btn btn-sm" onclick="exportInvestigation()"> Export</button>
                                    <button class="btn btn-sm" onclick="document.getElementById('importFile').click()"> Import</button>
                                    <input type="file" id="importFile" accept=".json" style="display: none;" onchange="importInvestigation(event)">
                                </div>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Pagination Controls -->
                    <div id="paginationControls" style="display: none; margin-bottom: 20px; text-align: center;">
                        <button class="btn btn-sm" onclick="changeHopPage(-1)" id="prevPageBtn"> Previous</button>
                        <span id="pageInfo" style="margin: 0 20px; font-weight: bold;"></span>
                        <button class="btn btn-sm" onclick="changeHopPage(1)" id="nextPageBtn">Next </button>
                        <select id="hopsPerPage" onchange="updateHopsPerPage()" style="margin-left: 20px; padding: 5px;">
                            <option value="10">10 hops per page</option>
                            <option value="20" selected>20 hops per page</option>
                            <option value="50">50 hops per page</option>
                            <option value="all">Show all</option>
                        </select>
                    </div>
                    
                    <div id="hopsList"></div>
                    <button class="btn" onclick="addNewHop()" id="addHopBtn"> Start Next Hop</button>
                    
                    <!-- Complete Investigation Section -->
                    <div id="completeInvestigationSection" style="display: none;">
                        <div style="background: linear-gradient(135deg, #e8f5e8 0%, #d4edda 100%); border: 3px solid #27ae60; border-radius: 12px; padding: 30px; text-align: center; margin-top: 30px; box-shadow: 0 4px 15px rgba(39, 174, 96, 0.2);">
                            <h3 style="color: #27ae60; font-size: 1.5rem; margin-bottom: 15px;"> Investigation Complete</h3>
                            <p style="color: #2c3e50; margin-bottom: 25px; font-size: 16px; line-height: 1.6;">
                                All trace paths have been documented and validated. Review your final thread values below.
                            </p>
                            <div id="finalThreadSummary" style="background: white; border-radius: 8px; padding: 20px; margin: 20px 0; border: 2px solid #27ae60;"></div>
                            <div style="display: flex; gap: 15px; justify-content: center; flex-wrap: wrap;">
                                <button class="btn btn-success btn-large" onclick="exportReport()">
                                     Export B.A.T.S. Report
                                </button>
                                <button class="btn btn-secondary" onclick="exportJSON()">
                                     Export JSON Data
                                </button>
                                <button class="btn" onclick="exportCSV()">
                                     Export CSV
                                </button>
                                <button class="btn btn-confirm" onclick="saveInvestigation()">
                                     Save Investigation and Calculate ART
                                </button>
                            </div>
                        </div>
                    </div>
                    
                    <!-- Next Step Button -->
                    <div style="margin-top: 30px; padding: 20px; background: #f8f9fa; border-radius: 8px; border: 2px solid #9b59b6; text-align: center;">
                        <h4 style="color: #2c3e50; margin-bottom: 15px;">Visualize Your Investigation</h4>
                        <p style="color: #666; margin-bottom: 20px;">Create a visual flow diagram of your cryptocurrency trace to better understand fund movement patterns.</p>
                        <button class="btn btn-confirm" onclick="switchTab('flowdiagram')" style="background: #9b59b6; color: white; padding: 12px 30px; font-size: 16px;">
                             Next: Generate Flow Diagram 
                        </button>
                    </div>
                </div>

                <!-- Flow Diagram Tab -->
                <div id="flowdiagram-tab" class="tab-content">
                    <div class="section-title">Visual Flow Diagram</div>
                    
                    <div id="flowDiagramControls" style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                        <button class="btn btn-secondary" onclick="generateFlowDiagram()" style="margin-right: 10px;">
                             Generate/Refresh Diagram
                        </button>
                        <button class="btn" onclick="exportFlowDiagram('svg')" style="margin-right: 10px;">
                             Export SVG
                        </button>
                        <button class="btn" onclick="exportFlowDiagram('png')" style="margin-right: 10px;">
                             Export PNG
                        </button>
                        <button class="btn" onclick="printFlowDiagram()" style="margin-right: 10px;">
                             Print
                        </button>
                        <button class="btn btn-success" onclick="generateBATSTrainingExample()" style="margin-left: 20px;">
                             Show Training Example
                        </button>
                    </div>
                    
                    <div id="flowDiagramContainer" style="background: white; border: 1px solid #e8f0fe; border-radius: 8px; padding: 20px; min-height: 600px; overflow: auto;">
                        <svg id="flowDiagramSVG" width="100%" height="100%">
                            <!-- Flow diagram will be generated here -->
                        </svg>
                    </div>
                    
                    <!-- Next Step Button -->
                    <div style="margin-top: 30px; padding: 20px; background: #f8f9fa; border-radius: 8px; border: 2px solid #27ae60; text-align: center;">
                        <h4 style="color: #2c3e50; margin-bottom: 15px;">Complete Your Investigation</h4>
                        <p style="color: #666; margin-bottom: 20px;">Review your investigation summary and export your final B.A.T.S. report for legal proceedings.</p>
                        <button class="btn btn-confirm" onclick="switchTab('summary')" style="background: #27ae60; color: white; padding: 12px 30px; font-size: 16px;">
                             Next: Generate Summary & Export 
                        </button>
                    </div>
                </div>

                <!-- Summary Tab -->
                <div id="summary-tab" class="tab-content">
                    <div class="section-title">Step 6: Investigation Summary</div>
                    <div id="summaryContent"></div>
                    
                    <div class="export-section">
                        <div class="section-title">Export Options</div>
                        <button class="btn btn-success" onclick="exportReport()"> Export B.A.T.S. Report</button>
                        <button class="btn btn-secondary" onclick="exportJSON()"> Export JSON Data</button>
                        <button class="btn" onclick="exportCSV()"> Export CSV</button>
                        <button class="btn" onclick="openApiSettings()" style="background: #95a5a6;"> API Settings</button>
                    </div>
                    
                    <!-- Investigation Complete Message -->
                    <div style="margin-top: 30px; padding: 20px; background: linear-gradient(135deg, #e8f5e8 0%, #d4edda 100%); border-radius: 8px; border: 2px solid #27ae60; text-align: center;">
                        <h4 style="color: #27ae60; margin-bottom: 15px;"> Investigation Complete!</h4>
                        <p style="color: #2c3e50; margin-bottom: 20px;">
                            Congratulations! You have successfully completed your B.A.T.S. cryptocurrency investigation. 
                            Your report is ready for legal proceedings and regulatory compliance.
                        </p>
                        <p style="color: #666; font-size: 14px;">
                            Remember to save your investigation file regularly and keep backup copies of all exported reports.
                        </p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <!-- Root Total Confirmation Modal -->
    <div id="rootTotalModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2> Confirm Investigation Root Total</h2>
                <p>Review your baseline before beginning trace documentation</p>
            </div>
            
            <!-- Root Total Explanation -->
            <div class="root-explanation">
                <h4> What is a Root Total?</h4>
                <ul>
                    <li><strong>Investigation Baseline:</strong> The total amount of confirmed victim losses</li>
                    <li><strong>Mathematical Foundation:</strong> All traced amounts must sum back to this total</li>
                    <li><strong>Golden Thread:</strong> Ensures complete accounting and prevents scope creep</li>
                    <li><strong>Legal Requirement:</strong> Essential for asset forfeiture case integrity</li>
                </ul>
            </div>

            <!-- Transaction Breakdown -->
            <div id="rootTotalBreakdown"></div>
            
            <!-- Root Total Display -->
            <div class="root-total-display">
                <div style="font-size: 1.2rem; margin-bottom: 10px;"> Total Root Amount</div>
                <div id="totalRootAmount" class="root-total-amount">$0</div>
                <div style="font-size: 0.9rem; color: #666; margin-top: 10px;">
                    This becomes your Adjusted Root Total (ART) for validation
                </div>
            </div>
            
            <div style="text-align: center; margin-top: 30px;">
                <button class="btn btn-confirm btn-large" onclick="confirmAndProceed()">
                     Confirm Root Total & Start Tracing
                </button>
                <button class="btn btn-secondary" onclick="closeModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Convergence Modal -->
    <div id="convergenceModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2>Record Convergence</h2>
                <p>Select multiple traces that are merging at a single wallet</p>
            </div>
            <div id="convergenceTraceSelection"></div>
            <div class="form-group">
                <label>Resulting Notation</label>
                <input type="text" id="convergenceNotation" placeholder="e.g., V1-T1(3)-H6 or V1,V2-T1-H4">
            </div>
            <div class="form-group">
                <label>Resulting Hop Level</label>
                <input type="number" id="convergenceHopLevel" readonly>
            </div>
            <div class="form-group">
                <label>Total Amount</label>
                <input type="number" id="convergenceAmount" readonly>
            </div>
            <div style="text-align: center; margin-top: 25px;">
                <button class="btn btn-confirm" onclick="createConvergenceTrace()"> Create Merged Trace</button>
                <button class="btn btn-secondary" onclick="closeConvergenceModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Asset Conversion Modal -->
    <div id="assetConversionModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2> Asset Conversion Documentation</h2>
                <p>Document the cryptocurrency conversion process</p>
            </div>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                <div class="form-group">
                    <label>Original Currency (From Source Thread)</label>
                    <select id="conversionFromCurrency" disabled style="background: #f8f9fa;">
                        <option value="">Not Set</option>
                        <option value="USD">US Dollar</option>
                        <option value="BTC">Bitcoin</option>
                        <option value="ETH">Ethereum</option>
                        <option value="USDT">Tether</option>
                        <option value="USDC">USD Coin</option>
                        <option value="TRX">TRON</option>
                        <option value="SOL">Solana</option>
                        <option value="ADA">Cardano</option>
                        <option value="DAI">DAI</option>
                        <option value="BNB">BNB</option>
                        <option value="CUSTOM">Custom Currency</option>
                    </select>
                    <div style="font-size: 11px; color: #666; margin-top: 5px;">
                        Currency is inherited from the selected source thread
                    </div>
                </div>
                <div class="form-group">
                    <label>Converted To Currency</label>
                    <select id="conversionToCurrency">
                        <option value="USD">US Dollar</option>
                        <option value="BTC">Bitcoin</option>
                        <option value="ETH">Ethereum</option>
                        <option value="USDT">Tether</option>
                        <option value="USDC">USD Coin</option>
                        <option value="TRX">TRON</option>
                        <option value="SOL">Solana</option>
                        <option value="ADA">Cardano</option>
                        <option value="DAI">DAI</option>
                        <option value="BNB">BNB</option>
                        <option value="CUSTOM">Custom Currency</option>
                    </select>
                </div>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                <div class="form-group" id="customFromCurrencyGroup" style="display: none;">
                    <label>Custom Original Currency</label>
                    <input type="text" id="conversionFromCurrencyCustom" placeholder="e.g., DOGE, SHIB">
                </div>
                <div class="form-group" id="customToCurrencyGroup" style="display: none;">
                    <label>Custom Converted Currency</label>
                    <input type="text" id="conversionToCurrencyCustom" placeholder="e.g., DOGE, SHIB">
                </div>
            </div>

            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 20px; margin-bottom: 20px;">
                <div class="form-group">
                    <label>Original Amount</label>
                    <input type="number" step="0.01" id="conversionFromAmount" placeholder="Amount sent">
                </div>
                <div class="form-group">
                    <label>Converted Amount</label>
                    <input type="number" step="0.01" id="conversionToAmount" placeholder="Amount received">
                </div>
            </div>

            <div class="form-group">
                <label>Conversion Platform/Service</label>
                <input type="text" id="conversionPlatform" placeholder="e.g., Uniswap, PancakeSwap, Bridge Protocol">
            </div>

            <div class="form-group">
                <label>Conversion Notes</label>
                <textarea id="conversionNotes" rows="3" placeholder="Additional details about the conversion process, fees, slippage, etc."></textarea>
            </div>
            
            <div style="text-align: center; margin-top: 25px;">
                <button class="btn btn-confirm" onclick="confirmAssetConversion()"> Document Conversion</button>
                <button class="btn btn-secondary" onclick="closeAssetConversionModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Smart Allocation Modal -->
    <div id="smartAllocationModal" class="modal">
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-header">
                <h2> Smart Amount Allocation</h2>
                <p>Automatically distribute amounts across multiple source threads</p>
            </div>
            
            <div style="background: #e8f5e8; border: 2px solid #27ae60; border-radius: 8px; padding: 20px; margin: 20px 0;">
                <h4 style="color: #27ae60; margin-bottom: 15px;">How it works:</h4>
                <p style="margin-bottom: 10px;">Enter the total amount you need to allocate, and the system will automatically:</p>
                <ol style="margin-left: 20px; color: #2c3e50;">
                    <li>Use available source threads in chronological order</li>
                    <li>Deplete each source before moving to the next</li>
                    <li>Show you exactly how the amount will be distributed</li>
                </ol>
                <div style="margin-top: 15px; padding: 15px; background: white; border-radius: 6px; font-family: monospace; font-size: 12px;">
                    <div style="margin-bottom: 5px;"><strong>Example:</strong> You need 20 BTC</div>
                    <div style="margin-bottom: 3px;"> Source 1: V1-T1 has 10 BTC  Use all 10 BTC</div>
                    <div style="margin-bottom: 3px;"> Source 2: V1-T2 has 15 BTC  Use 10 BTC (5 BTC remains)</div>
                    <div style="color: #27ae60; font-weight: bold;"> Total allocated: 20 BTC</div>
                </div>
            </div>
            
            <div style="margin-bottom: 20px;">
                <h4 style="color: #2c3e50; margin-bottom: 15px;">Target Amount:</h4>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="number" 
                           id="smartAllocationTargetAmount"
                           step="0.00000001" 
                           placeholder="Enter amount to allocate"
                           style="flex: 1; padding: 12px; border: 2px solid #27ae60; border-radius: 6px; font-size: 16px;">
                    <select id="smartAllocationTargetCurrency" 
                            style="padding: 12px; border: 2px solid #27ae60; border-radius: 6px; font-size: 16px;">
                        <option value="">Select currency...</option>
                    </select>
                </div>
            </div>
            
            <div id="smartAllocationAvailableSources" style="margin-bottom: 20px; display: none;">
                <h4 style="color: #2c3e50; margin-bottom: 15px;">Available Source Threads:</h4>
                <div id="availableSourcesList" style="max-height: 200px; overflow-y: auto;"></div>
            </div>
            
            <div id="smartAllocationPreview" style="display: none;">
                <h4 style="color: #2c3e50; margin-bottom: 15px;">Allocation Preview:</h4>
                <div id="allocationPreviewContent"></div>
            </div>
            
            <div id="smartAllocationError" style="display: none; background: #fee; border: 1px solid #c00; border-radius: 6px; padding: 15px; margin: 20px 0; color: #c00;">
            </div>
            
            <div style="text-align: center; margin-top: 25px;">
                <button class="btn btn-confirm" id="confirmSmartAllocation" onclick="confirmSmartAllocation()" style="display: none;">
                     Apply Allocation
                </button>
                <button class="btn btn-secondary" onclick="closeSmartAllocationModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Excel Import Modal -->
    <div id="excelImportModal" class="modal">
        <div class="modal-content">
            <div class="modal-header">
                <h2> Import Excel Traces</h2>
                <p>Import blockchain traces from your analysis software</p>
            </div>
            
            <div style="background: #e8f4f8; border: 2px solid #3498db; border-radius: 8px; padding: 20px; margin: 20px 0;">
                <h4 style="color: #2c3e50; margin-bottom: 15px;"> Required Excel Format</h4>
                <div style="font-family: monospace; font-size: 12px; background: white; padding: 15px; border-radius: 6px;">
                    <div style="font-weight: bold; margin-bottom: 8px; color: #666;">
                        Hop_Notation | Wallet_Address | Wallet_ID | Amount | Currency
                    </div>
                    <div style="margin-bottom: 4px;">V1-T1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| bc1q...abc&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| RED1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 5000&nbsp;&nbsp;&nbsp;| USD</div>
                    <div style="margin-bottom: 4px;">V1-T1-H1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 1A2B...def&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| BLACK1&nbsp;&nbsp;&nbsp;&nbsp;| 5000&nbsp;&nbsp;&nbsp;| USD</div>
                    <div style="margin-bottom: 4px;">V1-T1-H2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 3CdE...ghi&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| BLUE1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 4950&nbsp;&nbsp;&nbsp;| USD</div>
                    <div>V2-T1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| bc1q...xyz&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| RED2&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;| 2500&nbsp;&nbsp;&nbsp;| BTC</div>
                </div>
                <div style="margin-top: 15px; font-size: 14px; color: #2c3e50;">
                    <strong>Supported Wallet IDs:</strong> RED1, BLACK1, BLUE1, PURPLE1, YELLOW1, ORANGE1, BROWN1, PINK1, GRAY1, GREEN1
                </div>
            </div>
            
            <div id="importPreview" style="display: none;">
                <h4 style="color: #2c3e50; margin-bottom: 15px;"> Import Preview</h4>
                <div id="importSummary" style="background: #f8f9fa; padding: 15px; border-radius: 6px; margin-bottom: 15px;"></div>
                <div id="importErrors" style="display: none;"></div>
            </div>
            
            <div style="text-align: center; margin-top: 25px;">
                <button class="btn btn-confirm" id="confirmImportBtn" onclick="confirmExcelImport()" style="display: none;">
                     Import Investigation
                </button>
                <button class="btn btn-secondary" onclick="closeExcelImportModal()">Cancel</button>
            </div>
        </div>
    </div>

    <!-- Bulk Transaction Modal -->
    <div id="bulkTransactionModal" class="modal">
        <div class="modal-content" style="max-width: 900px;">
            <div class="modal-header">
                <h2> Bulk Add Transactions</h2>
                <p>Paste multiple transaction hashes (one per line) to add them all at once. They will be automatically sorted by date.</p>
            </div>
            
            <div style="margin: 20px 0;">
                <label style="display: block; font-weight: bold; margin-bottom: 10px;">Transaction Hashes:</label>
                <textarea id="bulkTransactionHashes" 
                          placeholder="Paste transaction hashes here, one per line&#10;&#10;Example:&#10;0x123abc...&#10;0x456def...&#10;0x789ghi..."
                          style="width: 100%; height: 200px; padding: 10px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace; font-size: 13px;"></textarea>
                
                <div style="margin-top: 15px; padding: 15px; background: #e8f4f8; border: 1px solid #3498db; border-radius: 6px;">
                    <h4 style="color: #2c3e50; margin-bottom: 10px;"> How it works:</h4>
                    <ul style="margin: 0; padding-left: 20px; color: #34495e;">
                        <li>Paste all transaction hashes at once</li>
                        <li>Click "Process Transactions" to fetch all data</li>
                        <li>Transactions will be automatically sorted by date</li>
                        <li>V-T notation will be assigned in chronological order</li>
                        <li>Failed lookups will be created as empty transactions for manual entry</li>
                    </ul>
                </div>
                
                <div id="bulkProcessingStatus" style="margin-top: 15px; display: none;">
                    <div style="padding: 10px; background: #f8f9fa; border-radius: 4px;">
                        <div id="bulkProgressBar" style="background: #e0e0e0; height: 20px; border-radius: 10px; overflow: hidden;">
                            <div id="bulkProgressFill" style="background: #3498db; height: 100%; width: 0%; transition: width 0.3s;"></div>
                        </div>
                        <div id="bulkProgressText" style="text-align: center; margin-top: 10px; font-size: 14px; color: #666;">Processing...</div>
                    </div>
                </div>
                
                <div id="bulkProcessingResults" style="margin-top: 15px; display: none;">
                    <h4>Processing Results:</h4>
                    <div id="bulkResultsList" style="max-height: 300px; overflow-y: auto; border: 1px solid #ddd; border-radius: 4px; padding: 10px; background: #f8f9fa;"></div>
                </div>
            </div>
            
            <div style="text-align: center; margin-top: 25px;">
                <button class="btn btn-confirm" onclick="processBulkTransactions()" id="bulkProcessBtn">
                     Process Transactions
                </button>
                <button class="btn btn-secondary" onclick="closeBulkTransactionModal()">
                    Cancel
                </button>
            </div>
        </div>
    </div>

    <!-- Transfer Selection Modal -->
    <div id="transferSelectionModal" class="modal">
        <div class="modal-content" style="max-width: 900px;">
            <div class="modal-header">
                <h2> Select Transfer</h2>
                <p>This transaction contains multiple token transfers. Please select the one that belongs to your victim:</p>
            </div>
            
            <!-- Filter Section -->
            <div style="background: #f8f9fa; padding: 15px; border-radius: 8px; margin: 15px 0;">
                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr auto; gap: 10px; align-items: end;">
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: 500;">Filter by Asset:</label>
                        <select id="transferAssetFilter" 
                               style="width: 100%; padding: 8px; border: 2px solid #e8f0fe; border-radius: 6px;"
                               onchange="filterTransfers()">
                            <option value="">All Assets</option>
                        </select>
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: 500;">Filter by Amount:</label>
                        <input type="text" id="transferAmountFilter" placeholder="e.g., 1000 or 1000.50" 
                               style="width: 100%; padding: 8px; border: 2px solid #e8f0fe; border-radius: 6px;"
                               oninput="filterTransfers()">
                    </div>
                    <div>
                        <label style="display: block; margin-bottom: 5px; font-weight: 500;">Filter by Address:</label>
                        <input type="text" id="transferAddressFilter" placeholder="To or From address" 
                               style="width: 100%; padding: 8px; border: 2px solid #e8f0fe; border-radius: 6px;"
                               oninput="filterTransfers()">
                    </div>
                    <button class="btn btn-secondary" onclick="clearTransferFilters()" style="padding: 8px 15px;">
                        Clear
                    </button>
                </div>
                <div id="filterResultsInfo" style="margin-top: 10px; font-size: 14px; color: #666;"></div>
            </div>
            
            <div id="transfersList" style="margin: 20px 0; max-height: 400px; overflow-y: auto;">
                <!-- Transfers will be populated here -->
            </div>
            
            <div style="text-align: center; margin-top: 25px;">
                <button class="btn btn-secondary" onclick="closeTransferSelectionModal()">
                    Cancel
                </button>
            </div>
        </div>
    </div>

    <!-- API Settings Modal -->
    <div id="apiSettingsModal" class="modal">
        <div class="modal-content" style="max-width: 800px;">
            <div class="modal-header">
                <h2> Blockchain API Settings</h2>
                <p>Configure API keys for enhanced reliability and higher rate limits</p>
            </div>
            
            <div style="background: #e8f4f8; border: 2px solid #3498db; border-radius: 8px; padding: 20px; margin: 20px 0;">
                <h4 style="color: #2c3e50; margin-bottom: 15px;"> Why Use API Keys?</h4>
                <ul style="margin-left: 20px; color: #34495e;">
                    <li>Higher rate limits (more lookups per day)</li>
                    <li>More reliable service</li>
                    <li>Access to additional features</li>
                    <li>All services offer FREE tiers</li>
                </ul>
            </div>
            
            <div style="margin: 20px 0;">
                <h4>API Key Configuration</h4>
                
                <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 6px;">
                    <label style="display: block; font-weight: bold; margin-bottom: 5px;">
                        Ethereum - Etherscan API Key
                    </label>
                    <input type="text" id="etherscanApiKey" placeholder="Your Etherscan API key" 
                           style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace;">
                    <div style="font-size: 12px; color: #666; margin-top: 5px;">
                        Get free key at: <a href="https://etherscan.io/apis" target="_blank" style="color: #3498db;">https://etherscan.io/apis</a>
                    </div>
                </div>
                
                <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 6px;">
                    <label style="display: block; font-weight: bold; margin-bottom: 5px;">
                        Bitcoin - Blockchain.com API Key (Optional)
                    </label>
                    <input type="text" id="blockchainApiKey" placeholder="Your Blockchain.com API key (optional)" 
                           style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace;">
                    <div style="font-size: 12px; color: #666; margin-top: 5px;">
                        Works without key, but get one for higher limits at: <a href="https://www.blockchain.com/api" target="_blank" style="color: #3498db;">https://www.blockchain.com/api</a>
                    </div>
                </div>
                
                <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 6px;">
                    <label style="display: block; font-weight: bold; margin-bottom: 5px;">
                        Tron - TronGrid API Key (Optional)
                    </label>
                    <input type="text" id="trongridApiKey" placeholder="Your TronGrid API key (optional)" 
                           style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace;">
                    <div style="font-size: 12px; color: #666; margin-top: 5px;">
                        Works without key, but get one for stability at: <a href="https://www.trongrid.io/" target="_blank" style="color: #3498db;">https://www.trongrid.io/</a>
                    </div>
                </div>
                
                <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 6px;">
                    <label style="display: block; font-weight: bold; margin-bottom: 5px;">
                        Solana RPC Endpoint
                    </label>
                    <input type="text" id="solanaRpcEndpoint" placeholder="https://api.mainnet-beta.solana.com" 
                           value="https://api.mainnet-beta.solana.com"
                           style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace;">
                    <div style="font-size: 12px; color: #666; margin-top: 5px;">
                        Default public RPC or use: <a href="https://www.helius.dev/" target="_blank" style="color: #3498db;">Helius</a>, 
                        <a href="https://www.quicknode.com/" target="_blank" style="color: #3498db;">QuickNode</a>
                    </div>
                </div>
                
                <div style="margin-bottom: 20px; padding: 15px; background: #fff3cd; border: 2px solid #ffc107; border-radius: 6px;">
                    <h5 style="color: #856404; margin-bottom: 10px;"> Security Note</h5>
                    <p style="font-size: 13px; color: #856404; margin: 0;">
                        API keys are stored locally in your browser only. They are never sent to any server except the official blockchain APIs.
                        For production use, consider using a backend proxy for additional security.
                    </p>
                </div>
                
                <div style="margin-bottom: 20px; padding: 15px; background: #e8f5e8; border: 2px solid #27ae60; border-radius: 6px;">
                    <h5 style="color: #27ae60; margin-bottom: 10px;"> CORS Proxy Option</h5>
                    <label style="display: block; margin-bottom: 5px;">
                        <input type="checkbox" id="enableCorsProxy" style="margin-right: 8px;">
                        Enable CORS Proxy (helps bypass browser restrictions)
                    </label>
                    <input type="text" id="corsProxyUrl" placeholder="https://cors-anywhere.herokuapp.com/" 
                           value="https://cors-anywhere.herokuapp.com/"
                           style="width: 100%; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-family: monospace; margin-top: 8px;"
                           disabled>
                    <div style="font-size: 12px; color: #666; margin-top: 5px;">
                        <strong>Public CORS Proxies:</strong><br>
                         <code>https://cors-anywhere.herokuapp.com/</code> (requires activation at <a href="https://cors-anywhere.herokuapp.com/corsdemo" target="_blank">corsdemo</a>)<br>
                         <code>https://proxy.cors.sh/</code> (alternative)<br>
                         <code>https://corsproxy.io/?</code> (another alternative)<br>
                        <br>
                        <strong>For Production Use:</strong> Deploy your own proxy using:
                        <a href="https://github.com/Rob--W/cors-anywhere" target="_blank" style="color: #3498db;">CORS Anywhere</a> or
                        <a href="https://www.npmjs.com/package/cors-proxy-server" target="_blank" style="color: #3498db;">cors-proxy-server</a>
                    </div>
                </div>
            </div>
            
            <div style="text-align: center; margin-top: 25px;">
                <button class="btn btn-confirm" onclick="saveApiSettings()">
                     Save Settings
                </button>
                <button class="btn btn-secondary" onclick="closeApiSettingsModal()">
                    Cancel
                </button>
            </div>
        </div>
    </div>

    <!-- Blockchain Lookup Modal -->
    <div id="blockchainLookupModal" class="modal">
        <div class="modal-content" style="max-width: 700px;">
            <div class="modal-header">
                <h2> Blockchain Transaction Lookup</h2>
                <p>Automatically fetch transaction details from the blockchain</p>
            </div>
            
            <div style="margin: 20px 0;">
                <div class="form-group" style="margin-bottom: 15px;">
                    <label>Select Blockchain</label>
                    <select id="chainSelector" style="width: 100%; padding: 12px; border: 2px solid #3498db; border-radius: 6px; font-size: 14px;" onchange="updateChainDisplay()">
                        <option value="">Auto-detect from transaction hash</option>
                        <option value="bitcoin">Bitcoin</option>
                        <option value="ethereum">Ethereum</option>
                        <option value="base">Base</option>
                        <option value="arbitrum">Arbitrum</option>
                        <option value="optimism">Optimism</option>
                        <option value="polygon">Polygon</option>
                        <option value="bsc">BNB Chain</option>
                        <option value="tron">Tron</option>
                        <option value="solana">Solana</option>
                    </select>
                </div>
                <div class="form-group">
                    <label>Transaction Hash</label>
                    <input type="text" id="txHashInput" placeholder="Enter transaction hash..." 
                           style="width: 100%; padding: 12px; border: 2px solid #3498db; border-radius: 6px; font-family: monospace; font-size: 14px;"
                           onkeyup="detectBlockchainFromHash(this.value)">
                    <div id="detectedBlockchain" style="margin-top: 10px; font-size: 14px; color: #666;"></div>
                </div>
                
                <div id="lookupError" style="display: none; background: #fee; border: 1px solid #c00; border-radius: 6px; padding: 15px; margin: 20px 0; color: #c00;"></div>
                <div id="lookupLoading" style="display: none; text-align: center; margin: 20px 0;">
                    <div style="font-size: 24px; margin-bottom: 10px;"></div>
                    <div>Fetching transaction data...</div>
                </div>
                
                <div id="lookupResult" style="display: none; margin-top: 20px;">
                    <h4 style="color: #2c3e50; margin-bottom: 15px;">Transaction Details</h4>
                    <div id="txDetailsDisplay" style="background: #f8f9fa; padding: 15px; border-radius: 6px;"></div>
                </div>
            </div>
            
            <div style="text-align: center; margin-top: 25px;">
                <button class="btn btn-primary" onclick="lookupTransaction()" id="lookupBtn">
                     Lookup Transaction
                </button>
                <button class="btn btn-confirm" id="applyTxDataBtn" onclick="applyTransactionData()" style="display: none;">
                     Apply to Entry
                </button>
                <button class="btn btn-secondary" onclick="openApiSettings()" style="background: #95a5a6;">
                     API Settings
                </button>
                <button class="btn btn-secondary" onclick="closeBlockchainLookupModal()">Cancel</button>
            </div>
        </div>
    </div>

    <script>
        // HTTPS Enforcement and Security Check
        (function() {
            // List of trusted domains (add your domains here)
            const trustedDomains = [
                'batstool.com',
                'www.batstool.com',
                'netlify.app',
                'localhost',
                '127.0.0.1'
            ];
            
            // Check if current domain is trusted
            const currentHost = window.location.hostname;
            const isTrusted = trustedDomains.some(domain => 
                currentHost === domain || currentHost.endsWith('.' + domain)
            );
            
            // Check if we're running on HTTP (not HTTPS or file://)
            if (window.location.protocol === 'http:' && currentHost !== 'localhost' && currentHost !== '127.0.0.1') {
                // Only redirect to HTTPS for trusted domains
                if (isTrusted) {
                    window.location.href = 'https:' + window.location.href.substring(5);
                    return; // Stop execution
                } else {
                    console.warn(' Running on HTTP. For security, please use HTTPS.');
                }
            }
            
            // Security warning for file:// protocol
            if (window.location.protocol === 'file:') {
                console.warn(' Running from file:// protocol. Some features may be limited. For full functionality, serve over HTTPS.');
            }
        })();

        // Global state
        let investigation = {
            caseId: '',
            investigator: '',
            caseType: '',
            caseSynopsis: '',
            setupComplete: false,
            victims: [],
            hops: [],
            conversions: [],
            redWalletIndex: [],
            universalWalletIndex: [],
            rootTotalConfirmed: false,
            confirmedRootTotal: 0,
            confirmedRootTotalsByCurrency: {},
            currentART: {},
            created: new Date().toISOString(),
            availableThreads: {},           
            threadAssignments: {},          
            sourceChainData: {},
            enhancedNotationEnabled: true,
            validationHistory: [],
            lastValidationTimestamp: null,
            threadValidationErrors: [],
            sourceChainReports: [],
            integrationVersion: '4.0'
        };
        
        // Undo system
        let undoHistory = [];
        const MAX_UNDO_HISTORY = 20;
        
        // File system integration
        let savedFilePath = null;
        let isFileSystemAvailable = false;
        let fileHandle = null;
        
        // Blockchain API Integration
        let targetEntryContext = null;
        let currentTxData = null;
        let currentBulkVictimId = null;
        let pendingTransfers = null;
        let pendingTransferCallback = null;
        
        // Shared EVM chain response parser
        const parseEVMResponse = (data, receiptData, blockTimestamp) => {
            // This is the same parser used for all EVM chains
            // Check if we have a token transfer in the receipt logs
            if (receiptData && receiptData.result && receiptData.result.logs && receiptData.result.logs.length > 0) {
                console.log('Checking receipt logs for token transfers:', receiptData.result.logs);
                
                // Look for Transfer events (topic0 = 0xddf252ad...)
                const transferTopic = '0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef';
                const transferLogs = receiptData.result.logs.filter(log => 
                    log.topics && log.topics[0] === transferTopic && log.topics.length >= 3
                );
                
                console.log(`Found ${transferLogs.length} token transfers in this transaction`);
                
                if (transferLogs.length > 0) {
                    // Always show selection modal when token transfers exist
                    console.log('Token transfers detected - user selection required');
                    
                    // Parse all transfers for selection
                    const transfers = transferLogs.map(log => {
                            const from = '0x' + log.topics[1].slice(26);
                            const to = '0x' + log.topics[2].slice(26);
                            const value = log.data;
                            const contractAddress = log.address;
                            
                            // Convert amount
                            let amount = 0;
                            try {
                                const amountBN = parseInt(value, 16);
                                const decimals = contractAddress.toLowerCase() === '0xdac17f958d2ee523a2206206994597c13d831ec7' || 
                                               contractAddress.toLowerCase() === '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48' ? 6 : 18;
                                amount = amountBN / Math.pow(10, decimals);
                            } catch (e) {
                                console.error('Error parsing amount:', e);
                            }
                            
                            // Get token symbol
                            const knownTokens = {
                                '0xdac17f958d2ee523a2206206994597c13d831ec7': 'USDT',
                                '0xa0b86991c6218b36c1d19d4a2e9eb0ce3606eb48': 'USDC',
                                '0x6b175474e89094c44da98b954eedeac495271d0f': 'DAI',
                                '0x2260fac5e5542a773aa44fbcfedf7c193bc2c599': 'WBTC',
                                '0x514910771af9ca656af840dff83e8264ecf986ca': 'LINK'
                            };
                            
                            const currency = knownTokens[contractAddress.toLowerCase()] || 'Token';
                            
                            return {
                                from: from,
                                to: to,
                                amount: amount,
                                currency: currency,
                                contractAddress: contractAddress,
                                rawData: log
                            };
                        });
                    
                    // Use block timestamp if available, otherwise current time
                    let timestamp = blockTimestamp || Date.now();
                    const hasRealTimestamp = !!blockTimestamp;
                    if (!blockTimestamp) {
                        console.warn('No block timestamp available for token transfers');
                    }
                    
                    // Only add the ETH transaction if it has value > 0
                    const tx = data.result;
                    if (tx && parseInt(tx.value, 16) > 0) {
                        transfers.unshift({
                            from: tx.from,
                            to: tx.to,
                            amount: parseInt(tx.value, 16) / 1e18,
                            currency: 'ETH',
                            contractAddress: 'Native ETH Transfer',
                            rawData: tx
                        });
                    }
                    
                    // Always return multiple transfers to show selection modal
                    return {
                        multipleTransfers: true,
                        transfers: transfers,
                        transaction: data.result,
                        time: timestamp,
                        hasRealTimestamp: hasRealTimestamp
                    };
                }
            }
            // Otherwise use regular ETH transaction
            else if (data.result) {
                const tx = data.result;
                
                // Skip 0 ETH transactions when there are no token transfers
                const ethAmount = parseInt(tx.value, 16) / 1e18;
                if (ethAmount === 0) {
                    console.log('Skipping 0 ETH transaction with no token transfers');
                    return null;
                }
                
                // Use block timestamp if available, otherwise current time
                let timestamp = blockTimestamp || Date.now();
                const hasRealTimestamp = !!blockTimestamp;
                if (!blockTimestamp) {
                    console.warn('No block timestamp available for ETH transaction');
                }
                
                return {
                    time: timestamp,
                    amount: ethAmount,
                    currency: 'ETH',
                    from: tx.from,
                    to: tx.to,
                    fee: tx.gasPrice && tx.gas ? 
                        parseInt(tx.gasPrice, 16) * parseInt(tx.gas, 16) / 1e18 : 0,
                    hasRealTimestamp: hasRealTimestamp
                };
            }
            return null;
        };
        
        // Blockchain API configurations
        const blockchainAPIs = {
            bitcoin: {
                name: 'Bitcoin',
                hashPattern: /^[13][a-km-zA-HJ-NP-Z1-9]{25,34}$|^bc1[a-z0-9]{39,59}$/,
                addressPattern: /^([13][a-km-zA-HJ-NP-Z1-9]{25,34}|bc1[a-z0-9]{39,59})$/,
                addressPrefixes: ['1', '3', 'bc1'],
                txPattern: /^[a-f0-9]{64}$/i,
                apiUrl: 'https://blockchain.info/rawtx/',
                addressApiUrl: 'https://blockchain.info/rawaddr/',
                entityApiUrl: 'https://www.walletexplorer.com/api/1/address-lookup?address=',
                apiKey: null,
                fallbackUrls: [
                    'https://api.blockcypher.com/v1/btc/main/txs/',
                    'https://mempool.space/api/tx/'
                ],
                parseResponse: (data) => {
                    if (data.hash) {
                        // blockchain.info format
                        const firstInput = data.inputs[0];
                        const firstOutput = data.outputs[0];
                        
                        // Validate timestamp
                        const timestamp = data.time ? data.time * 1000 : Date.now();
                        
                        return {
                            time: timestamp,
                            amount: firstOutput.value / 100000000,
                            currency: 'BTC',
                            from: firstInput.prev_out ? firstInput.prev_out.addr : 'Unknown',
                            to: firstOutput.addr || 'Unknown',
                            fee: data.fee ? data.fee / 100000000 : null
                        };
                    } else if (data.tx_hash) {
                        // blockcypher format
                        let timestamp;
                        try {
                            timestamp = new Date(data.received).getTime();
                            if (isNaN(timestamp)) timestamp = Date.now();
                        } catch (e) {
                            timestamp = Date.now();
                        }
                        
                        return {
                            time: timestamp,
                            amount: data.outputs[0].value / 100000000,
                            currency: 'BTC',
                            from: data.inputs[0].addresses ? data.inputs[0].addresses[0] : 'Unknown',
                            to: data.outputs[0].addresses ? data.outputs[0].addresses[0] : 'Unknown',
                            fee: data.fees ? data.fees / 100000000 : null
                        };
                    }
                    return null;
                }
            },
            ethereum: {
                name: 'Ethereum',
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                chainId: 1, // Ethereum mainnet
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=1&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=1&module=proxy&action=eth_getTransactionReceipt&txhash=',
                txReceiptUrl: 'https://api.etherscan.io/v2/api?chainid=1&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=1&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=1&module=account&action=txlist&address=',
                labelApiUrl: 'https://api.etherscan.io/v2/api?chainid=1&module=account&action=addressinfo&address=',
                apiKey: '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                fallbackUrls: [
                    // Removed Ropsten as it no longer exists
                    // Blockchair doesn't support transaction lookup by hash in this format
                ],
                parseResponse: parseEVMResponse
            },
            base: {
                name: 'Base',
                chainId: 8453,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=8453&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=8453&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=8453&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=8453&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            arbitrum: {
                name: 'Arbitrum',
                chainId: 42161,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=42161&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=42161&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=42161&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=42161&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            optimism: {
                name: 'Optimism',
                chainId: 10,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=10&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=10&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=10&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=10&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            polygon: {
                name: 'Polygon',
                chainId: 137,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=137&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=137&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=137&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=137&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            bsc: {
                name: 'BNB Chain',
                chainId: 56,
                hashPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPattern: /^0x[a-fA-F0-9]{40}$/,
                addressPrefixes: ['0x'],
                txPattern: /^0x[a-fA-F0-9]{64}$/,
                apiUrl: 'https://api.etherscan.io/v2/api?chainid=56&module=proxy&action=eth_getTransactionByHash&txhash=',
                tokenApiUrl: 'https://api.etherscan.io/v2/api?chainid=56&module=proxy&action=eth_getTransactionReceipt&txhash=',
                blockApiUrl: 'https://api.etherscan.io/v2/api?chainid=56&module=proxy&action=eth_getBlockByNumber&tag=',
                addressApiUrl: 'https://api.etherscan.io/v2/api?chainid=56&module=account&action=txlist&address=',
                apiKey: localStorage.getItem('bats_etherscan_api_key') || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8',
                parseResponse: parseEVMResponse
            },
            tron: {
                name: 'Tron',
                hashPattern: /^T[a-zA-Z0-9]{33}$/,
                addressPattern: /^T[a-zA-Z0-9]{33}$/,
                addressPrefixes: ['T'],
                txPattern: /^[a-f0-9]{64}$/i,
                apiUrl: 'https://api.trongrid.io/v1/transactions/',
                addressApiUrl: 'https://api.trongrid.io/v1/accounts/',
                apiKey: null,
                fallbackUrls: [
                    'https://apilist.tronscan.org/api/transaction-info?hash='
                ],
                parseResponse: (data) => {
                    if (data.data && data.data[0]) {
                        const tx = data.data[0];
                        return {
                            time: tx.block_timestamp,
                            amount: (tx.raw_data.contract[0].parameter.value.amount || 0) / 1e6,
                            currency: 'TRX',
                            from: tx.raw_data.contract[0].parameter.value.owner_address,
                            to: tx.raw_data.contract[0].parameter.value.to_address,
                            fee: tx.fee ? tx.fee / 1e6 : null
                        };
                    }
                    return null;
                }
            },
            solana: {
                name: 'Solana',
                hashPattern: /^[1-9A-HJ-NP-Za-km-z]{32,44}$/,
                addressPattern: /^[1-9A-HJ-NP-Za-km-z]{32,44}$/,
                addressPrefixes: ['1', '2', '3', '4', '5', '6', '7', '8', '9', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H'],
                txPattern: /^[1-9A-HJ-NP-Za-km-z]{87,88}$/,
                apiUrl: 'https://api.mainnet-beta.solana.com',
                addressApiUrl: 'https://api.mainnet-beta.solana.com',
                apiKey: null,
                fallbackUrls: [
                    'https://solana-mainnet.g.alchemy.com/v2/demo',
                    'https://rpc.ankr.com/solana'
                ],
                parseResponse: (data) => {
                    if (data.result) {
                        const tx = data.result;
                        const meta = tx.meta;
                        const preBalances = meta.preBalances[0];
                        const postBalances = meta.postBalances[0];
                        const amount = Math.abs(postBalances - preBalances) / 1e9;
                        
                        return {
                            time: tx.blockTime * 1000,
                            amount: amount,
                            currency: 'SOL',
                            from: tx.transaction.message.accountKeys[0],
                            to: tx.transaction.message.accountKeys[1] || 'Unknown',
                            fee: meta.fee / 1e9
                        };
                    }
                    return null;
                }
            }
        };
        
        // Currency decimal place configuration
        const currencyDecimals = {
            'USD': 2,
            'EUR': 2,
            'GBP': 2,
            'CAD': 2,
            'AUD': 2,
            'JPY': 0,  // Japanese Yen typically has no decimal places
            'BTC': 8,  // Bitcoin: 8 decimal places (satoshis)
            'ETH': 18, // Ethereum: 18 decimal places (wei)
            'USDT': 6, // Tether: 6 decimal places
            'USDC': 6, // USD Coin: 6 decimal places
            'DAI': 18, // DAI: 18 decimal places
            'TRX': 6,  // TRON: 6 decimal places
            'SOL': 9,  // Solana: 9 decimal places
            'ADA': 6,  // Cardano: 6 decimal places
            'BNB': 8,  // BNB: 8 decimal places
            'XRP': 6,  // Ripple: 6 decimal places
            'CUSTOM': 8 // Default for custom currencies
        };
        
        // Get decimal places for a currency
        function getCurrencyDecimals(currency) {
            return currencyDecimals[currency] || 8; // Default to 8 if not found
        }
        
        // Get step value for input based on currency
        function getCurrencyStep(currency) {
            const decimals = getCurrencyDecimals(currency);
            if (decimals === 0) return '1';
            return '0.' + '0'.repeat(decimals - 1) + '1';
        }
        
        // Format amount with proper decimal places
        function formatCurrencyAmount(amount, currency, preserveFullPrecision = false) {
            const decimals = getCurrencyDecimals(currency);
            const num = parseFloat(amount);
            if (isNaN(num)) return '0';
            
            // If preserveFullPrecision is true, keep all decimal places
            if (preserveFullPrecision) {
                return num.toFixed(decimals);
            }
            
            // For display, show meaningful decimals (remove trailing zeros)
            if (decimals > 2) {
                // For crypto, show up to decimals places but remove trailing zeros
                return num.toFixed(decimals).replace(/\.?0+$/, '');
            } else {
                // For fiat, always show 2 decimals
                return num.toFixed(decimals);
            }
        }
        
        function saveUndoState(description) {
            // Deep clone the current investigation state
            const state = {
                timestamp: new Date().toISOString(),
                description: description,
                investigation: JSON.parse(JSON.stringify(investigation))
            };
            
            undoHistory.push(state);
            
            // Keep history size manageable
            if (undoHistory.length > MAX_UNDO_HISTORY) {
                undoHistory.shift();
            }
            
            updateUndoButton();
        }
        
        function performUndo() {
            if (undoHistory.length === 0) {
                alert('No actions to undo.');
                return;
            }
            
            const lastState = undoHistory.pop();
            
            // Restore the investigation state
            investigation = JSON.parse(JSON.stringify(lastState.investigation));
            
            // Re-render everything
            renderAll();
            updateUndoButton();
            
            alert(` Undone: ${lastState.description}`);
        }
        
        function updateUndoButton() {
            const undoButton = document.getElementById('undoButton');
            if (undoButton) {
                if (undoHistory.length > 0) {
                    const lastAction = undoHistory[undoHistory.length - 1];
                    undoButton.disabled = false;
                    undoButton.title = `Undo: ${lastAction.description}`;
                } else {
                    undoButton.disabled = true;
                    undoButton.title = 'No actions to undo';
                }
            }
        }
        
        // Navigation functions
        function showNavigationMenu() {
            const menuHTML = `
                <div id="navigationModal" class="modal" style="display: block;">
                    <div class="modal-content" style="max-width: 600px;">
                        <div class="modal-header" style="position: relative;">
                            <h2> Navigate to...</h2>
                            <button class="close-btn" onclick="closeNavigationMenu()" 
                                    style="position: absolute; right: 15px; top: 15px; width: 40px; height: 40px; 
                                           font-size: 28px; background: #e74c3c; color: white; border: none; 
                                           border-radius: 50%; cursor: pointer; display: flex; align-items: center; 
                                           justify-content: center; box-shadow: 0 2px 5px rgba(0,0,0,0.2); 
                                           transition: all 0.3s ease; font-weight: bold;"
                                    onmouseover="this.style.background='#c0392b'; this.style.transform='scale(1.1)'" 
                                    onmouseout="this.style.background='#e74c3c'; this.style.transform='scale(1)'"
                                    title="Close Navigation (ESC)"></button>
                        </div>
                        <div style="max-height: 400px; overflow-y: auto;">
                            <h3 style="margin-top: 20px;">Quick Navigation</h3>
                            <div style="display: grid; gap: 10px; margin-bottom: 20px;">
                                <button class="btn" onclick="navigateTo('victims'); closeNavigationMenu();">
                                     Victims & Transactions
                                </button>
                                <button class="btn" onclick="navigateTo('traces'); closeNavigationMenu();">
                                     Trace Documentation
                                </button>
                            </div>
                            
                            <h3>Hops</h3>
                            ${investigation.hops.length === 0 ? 
                                '<p style="color: #666;">No hops created yet</p>' :
                                investigation.hops.map(hop => `
                                    <div style="background: #f8f9fa; padding: 10px; margin-bottom: 10px; border-radius: 6px;">
                                        <div style="display: flex; justify-content: space-between; align-items: center;">
                                            <strong>Hop ${hop.hopNumber}</strong>
                                            <button class="btn btn-sm" onclick="navigateToHop(${hop.id}); closeNavigationMenu();">
                                                Go to Hop 
                                            </button>
                                        </div>
                                        ${hop.entries.length > 0 ? `
                                            <div style="margin-top: 10px; padding-left: 20px;">
                                                ${hop.entries.map(entry => `
                                                    <div style="display: flex; justify-content: space-between; align-items: center; margin: 5px 0;">
                                                        <span style="font-size: 14px;">
                                                            Entry ${entry.id}: ${entry.notation || 'No notation'} 
                                                            ${parseFloat(entry.amount) > 0 ? `(${entry.amount} ${entry.currency})` : ''}
                                                        </span>
                                                        <button class="btn btn-sm" style="padding: 2px 8px; font-size: 12px;" 
                                                                onclick="navigateToEntry(${hop.id}, ${entry.id}); closeNavigationMenu();">
                                                            Edit 
                                                        </button>
                                                    </div>
                                                `).join('')}
                                            </div>
                                        ` : '<p style="font-size: 14px; color: #666; margin-left: 20px;">No entries yet</p>'}
                                    </div>
                                `).join('')
                            }
                        </div>
                        <div style="padding: 20px; border-top: 2px solid #e8f0fe; text-align: center; background: #f8f9fa;">
                            <button class="btn" onclick="closeNavigationMenu()" 
                                    style="background: #95a5a6; color: white; padding: 10px 30px; font-size: 16px;">
                                Close Navigation
                            </button>
                            <div style="margin-top: 10px; font-size: 12px; color: #666;">
                                Tip: Press ESC to close quickly
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            createCenteredModal('navigationModal', menuHTML);
            
            // Add ESC key listener
            const escHandler = (e) => {
                if (e.key === 'Escape') {
                    closeNavigationMenu();
                    document.removeEventListener('keydown', escHandler);
                }
            };
            document.addEventListener('keydown', escHandler);
        }
        
        function closeNavigationMenu() {
            const modal = document.getElementById('navigationModal');
            if (modal) modal.remove();
        }
        
        function navigateTo(tab) {
            switchTab(tab);
            const tabButton = document.querySelector(`[onclick="switchTab('${tab}')"]`);
            if (tabButton) tabButton.click();
            updateBreadcrumbs();
        }
        
        function navigateToHop(hopId) {
            // Switch to traces tab
            navigateTo('traces');
            
            // Scroll to and highlight the hop
            setTimeout(() => {
                const hopElement = document.querySelector(`#hopContent_${hopId}`);
                if (hopElement) {
                    // Expand the hop if collapsed
                    window.hopCollapseState[hopId] = false;
                    hopElement.style.display = 'block';
                    
                    // Scroll into view
                    hopElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    
                    // Highlight briefly
                    const hopContainer = hopElement.closest('.hop-container');
                    if (hopContainer) {
                        hopContainer.style.transition = 'background-color 0.3s';
                        hopContainer.style.backgroundColor = '#fffbcc';
                        setTimeout(() => {
                            hopContainer.style.backgroundColor = '';
                        }, 2000);
                    }
                }
            }, 100);
        }
        
        function navigateToEntry(hopId, entryId) {
            // First navigate to the hop
            navigateToHop(hopId);
            
            // Then expand and highlight the entry
            setTimeout(() => {
                const entryKey = `${hopId}_${entryId}`;
                
                // Expand the entry
                window.entryCollapseState[entryKey] = false;
                const content = document.getElementById(`entryContent_${entryKey}`);
                const summary = document.getElementById(`entrySummary_${entryKey}`);
                
                if (content && summary) {
                    content.style.display = 'block';
                    summary.style.display = 'none';
                    
                    // Scroll to entry
                    content.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    
                    // Highlight the entry
                    const entryContainer = content.closest('div[style*="background"]');
                    if (entryContainer) {
                        entryContainer.style.transition = 'transform 0.3s, box-shadow 0.3s';
                        entryContainer.style.transform = 'scale(1.02)';
                        entryContainer.style.boxShadow = '0 4px 20px rgba(52, 152, 219, 0.3)';
                        setTimeout(() => {
                            entryContainer.style.transform = '';
                            entryContainer.style.boxShadow = '';
                        }, 2000);
                    }
                }
            }, 200);
        }
        
        function updateBreadcrumbs() {
            const breadcrumbsEl = document.getElementById('breadcrumbs');
            if (!breadcrumbsEl) return;
            
            let breadcrumbs = [];
            
            // Get current tab
            const activeTab = document.querySelector('.nav-tab.active');
            if (activeTab) {
                breadcrumbs.push(activeTab.textContent);
            }
            
            // Add case info if available
            if (investigation.caseId) {
                breadcrumbs.unshift(`Case: ${investigation.caseId}`);
            }
            
            breadcrumbsEl.innerHTML = breadcrumbs.join('  ');
        }
        
        // Reopen a completed hop for editing
        function reopenHop(hopId) {
            const hop = investigation.hops.find(h => h.id === hopId);
            if (!hop) return;
            
            // Check for dependent hops
            const dependentHops = investigation.hops.filter(h => h.hopNumber > hop.hopNumber);
            
            if (dependentHops.length > 0) {
                // Build detailed warning about impacts
                let impactSummary = ` WARNING: Editing Hop ${hop.hopNumber} will impact downstream hops!\n\n`;
                impactSummary += `Affected hops: ${dependentHops.map(h => `Hop ${h.hopNumber}`).join(', ')}\n\n`;
                
                // Check which threads from this hop are used downstream
                const threadsFromThisHop = [];
                hop.entries.forEach(entry => {
                    if (entry.notation && parseFloat(entry.amount) > 0) {
                        const threadId = `${entry.notation}-H${hop.hopNumber}`;
                        threadsFromThisHop.push({
                            threadId: threadId,
                            amount: entry.amount,
                            currency: entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency
                        });
                    }
                });
                
                // Find which downstream entries use these threads
                let affectedEntries = [];
                dependentHops.forEach(downstreamHop => {
                    downstreamHop.entries.forEach(entry => {
                        const usesThreads = threadsFromThisHop.some(thread => 
                            entry.sourceThreadId === thread.threadId ||
                            (entry.multipleSourceThreads && entry.multipleSourceThreads.includes(thread.threadId))
                        );
                        
                        if (usesThreads) {
                            affectedEntries.push({
                                hop: downstreamHop.hopNumber,
                                entry: entry.notation || `Entry ${entry.id}`,
                                amount: entry.amount,
                                currency: entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency
                            });
                        }
                    });
                });
                
                if (affectedEntries.length > 0) {
                    impactSummary += `Entries that will need updating:\n`;
                    affectedEntries.forEach(ae => {
                        impactSummary += ` Hop ${ae.hop}, ${ae.entry}: ${ae.amount} ${ae.currency}\n`;
                    });
                }
                
                impactSummary += `\nChanges to Hop ${hop.hopNumber} may require you to:\n`;
                impactSummary += ` Update thread amounts in downstream hops\n`;
                impactSummary += ` Reassign source threads if entries are removed\n`;
                impactSummary += ` Recalculate ART for all affected hops\n\n`;
                impactSummary += `Do you want to continue?`;
                
                if (!confirm(impactSummary)) {
                    return;
                }
            } else {
                // No downstream hops affected
                if (!confirm(`Are you sure you want to reopen Hop ${hop.hopNumber} for editing?\n\nThis will allow you to add or modify entries.`)) {
                    return;
                }
            }
            
            // Save undo state with full context
            saveUndoState(`Reopen Hop ${hop.hopNumber} for editing`);
            
            // Mark hop as not finalized
            hop.isFinalized = false;
            
            // Mark all downstream hops as needing validation
            dependentHops.forEach(h => {
                h.needsValidation = true;
            });
            
            // Re-render to show edit controls
            renderHops();
            saveToStorage();
            
            // Expand the hop
            window.hopCollapseState[hopId] = false;
            const hopContent = document.getElementById(`hopContent_${hopId}`);
            if (hopContent) {
                hopContent.style.display = 'block';
            }
            
            // Scroll to the hop
            setTimeout(() => {
                const hopContainer = hopContent?.closest('.hop-container');
                if (hopContainer) {
                    hopContainer.scrollIntoView({ behavior: 'smooth', block: 'center' });
                }
            }, 100);
            
            if (dependentHops.length > 0) {
                alert(` Hop ${hop.hopNumber} is now open for editing.\n\n Remember: Changes here will affect Hops ${dependentHops.map(h => h.hopNumber).join(', ')}.\n\nAfter making changes, you'll need to validate and update the downstream hops.`);
            } else {
                alert(` Hop ${hop.hopNumber} is now open for editing.`);
            }
        }
        // Validate and update a hop after upstream changes
        function validateAndUpdateHop(hopId) {
            const hop = investigation.hops.find(h => h.id === hopId);
            if (!hop) return;
            
            // Find the previous hop to check available threads
            const previousHopNumber = hop.hopNumber - 1;
            const availableThreads = getAvailableSourcesForHop(hop.hopNumber, null);
            
            let validationReport = ` Validation Report for Hop ${hop.hopNumber}\n\n`;
            let hasIssues = false;
            let fixableIssues = [];
            
            // Check each entry in this hop
            hop.entries.forEach(entry => {
                if (entry.entryType === 'trace') {
                    let entryIssues = [];
                    
                    // Check single source thread
                    if (entry.sourceThreadId) {
                        const threadAvailable = availableThreads.find(t => t.threadId === entry.sourceThreadId);
                        if (!threadAvailable) {
                            entryIssues.push(`Source thread ${entry.sourceThreadId} no longer exists`);
                            hasIssues = true;
                        } else if (threadAvailable.availableAmount < parseFloat(entry.amount)) {
                            entryIssues.push(`Source thread ${entry.sourceThreadId} only has ${threadAvailable.availableAmount} available (needs ${entry.amount})`);
                            hasIssues = true;
                            fixableIssues.push({
                                entryId: entry.id,
                                issue: 'insufficient_amount',
                                currentAmount: parseFloat(entry.amount),
                                availableAmount: threadAvailable.availableAmount
                            });
                        }
                    }
                    
                    // Check multiple source threads
                    if (entry.multipleSourceThreads && entry.multipleSourceThreads.length > 0) {
                        entry.multipleSourceThreads.forEach(threadId => {
                            const threadAvailable = availableThreads.find(t => t.threadId === threadId);
                            if (!threadAvailable) {
                                entryIssues.push(`Source thread ${threadId} no longer exists`);
                                hasIssues = true;
                            }
                        });
                        
                        // Check individual assignments
                        if (entry.individualSourceAssignments) {
                            Object.entries(entry.individualSourceAssignments).forEach(([threadId, amount]) => {
                                const threadAvailable = availableThreads.find(t => t.threadId === threadId);
                                if (threadAvailable && threadAvailable.availableAmount < amount) {
                                    entryIssues.push(`Thread ${threadId} only has ${threadAvailable.availableAmount} available (assigned ${amount})`);
                                    hasIssues = true;
                                }
                            });
                        }
                    }
                    
                    if (entryIssues.length > 0) {
                        validationReport += `Entry ${entry.notation || entry.id}:\n`;
                        entryIssues.forEach(issue => {
                            validationReport += `   ${issue}\n`;
                        });
                        validationReport += '\n';
                    }
                }
            });
            
            if (!hasIssues) {
                hop.needsValidation = false;
                renderHops();
                saveToStorage();
                alert(` Hop ${hop.hopNumber} validated successfully!\n\nAll source threads are valid and have sufficient amounts.`);
                return;
            }
            
            // Show validation report and options
            validationReport += `\nOptions:\n`;
            validationReport += `1. Manually fix each issue by editing the affected entries\n`;
            validationReport += `2. Auto-adjust amounts to match available threads\n`;
            validationReport += `3. Cancel and leave as-is\n`;
            
            const choice = prompt(validationReport + '\nEnter your choice (1, 2, or 3):');
            
            if (choice === '2') {
                // Auto-adjust amounts
                saveUndoState(`Auto-adjust amounts in Hop ${hop.hopNumber}`);
                
                fixableIssues.forEach(fix => {
                    const entry = hop.entries.find(e => e.id === fix.entryId);
                    if (entry && fix.issue === 'insufficient_amount') {
                        entry.amount = fix.availableAmount.toString();
                    }
                });
                
                hop.needsValidation = false;
                renderHops();
                saveToStorage();
                
                alert(` Hop ${hop.hopNumber} has been auto-adjusted.\n\nAmounts have been reduced to match available thread values.`);
            } else if (choice === '1') {
                // Open hop for manual editing
                reopenHop(hopId);
            }
        }
        
        function initializeCompleteIntegration(data = investigation) {
    console.log('Initializing complete integration...');
    
    // Initialize Phase 3 fields if missing
    if (!data.availableThreads) {
        data.availableThreads = {};
    }
    if (!data.threadAssignments) {
        data.threadAssignments = {};
    }
    if (!data.sourceChainData) {
        data.sourceChainData = {};
    }
    if (data.enhancedNotationEnabled === undefined) {
        data.enhancedNotationEnabled = true;
    }
    
    // Initialize Part 4 fields if missing
    if (!data.validationHistory) {
        data.validationHistory = [];
    }
    if (!data.lastValidationTimestamp) {
        data.lastValidationTimestamp = null;
    }
    if (!data.threadValidationErrors) {
        data.threadValidationErrors = [];
    }
    if (!data.sourceChainReports) {
        data.sourceChainReports = [];
    }
    if (!data.integrationVersion) {
        data.integrationVersion = '4.0';
    }
    
    // Initialize standard fields if missing
    if (!data.conversions) {
        data.conversions = [];
    }
    if (!data.redWalletIndex) {
        data.redWalletIndex = [];
    }
    if (!data.universalWalletIndex) {
        data.universalWalletIndex = [];
    }
    if (!data.confirmedRootTotalsByCurrency) {
        data.confirmedRootTotalsByCurrency = {};
    }
    if (!data.currentART) {
        data.currentART = {};
    }
    if (data.rootTotalConfirmed === undefined) {
        data.rootTotalConfirmed = false;
    }
    if (data.confirmedRootTotal === undefined) {
        data.confirmedRootTotal = 0;
    }
    if (!data.created) {
        data.created = new Date().toISOString();
    }
    
    console.log(' Complete integration initialized');
}
function handleLoadFile() {
    console.log('Load file button clicked');
    const fileInput = document.getElementById('fileInput');
    if (fileInput) {
        console.log('File input found, triggering click');
        fileInput.click();
    } else {
        console.error('File input element not found');
        alert('Error: File input not found. Please refresh the page and try again.');
    }
}
        function validateEnhancedDataStructure() {
    const errors = [];
    
    if (!investigation.availableThreads) {
        errors.push('Missing availableThreads property');
    }
    if (!investigation.threadAssignments) {
        errors.push('Missing threadAssignments property');
    }
    if (!investigation.sourceChainData) {
        errors.push('Missing sourceChainData property');
    }
    
    investigation.hops.forEach((hop, hopIndex) => {
        hop.entries.forEach((entry, entryIndex) => {
            if (!Array.isArray(entry.sourceChain)) {
                errors.push(`Hop ${hopIndex + 1}, Entry ${entryIndex + 1}: Missing or invalid sourceChain`);
            }
            if (typeof entry.displayNotation !== 'string') {
                errors.push(`Hop ${hopIndex + 1}, Entry ${entryIndex + 1}: Missing displayNotation`);
            }
        });
    });
    
    return errors;
}

function renderHopEntry(entry) {
    const isWriteoff = entry.entryType === 'writeoff';
    const isColdStorage = entry.entryType === 'cold_storage';
    const isTrace = entry.entryType === 'trace';
    
    // Get available source threads for this hop - pass null to get all currencies
    const availableSourceThreads = getAvailableSourcesForHop(entry.hopNumber, null);
    
    // Build source options with real-time amounts
    const sourceOptions = availableSourceThreads.map(source => 
        `<option value="${source.threadId}" ${entry.sourceThreadId === source.threadId ? 'selected' : ''}>
            ${source.displayText} - ${source.availableAmount.toLocaleString()} ${source.currency} available
        </option>`
    ).join('');
    
    // Calculate max amount for input field
    let maxAmount = 0;
    if (entry.multipleSourceThreads && entry.multipleSourceThreads.length > 0) {
        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
        entry.multipleSourceThreads.forEach(sourceId => {
            maxAmount += getMaxAssignableAmount(sourceId, currency);
        });
    } else if (entry.sourceThreadId) {
        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
        maxAmount = getMaxAssignableAmount(entry.sourceThreadId, currency);
    }
    
    return `
        <div style="background: ${isColdStorage ? '#e3f2fd' : isWriteoff ? '#f5f5f5' : '#f0f7ff'}; border: 2px solid ${isColdStorage ? '#3498db' : isWriteoff ? '#9e9e9e' : '#b8daff'}; border-radius: 8px; padding: 20px; margin-bottom: 15px; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">
            <div class="trace-header">
                <div>
                    <span class="trace-notation">Entry ${entry.id} - ${entryTypes[entry.entryType]}</span>
                    ${entry.notation ? `<br><small style="color: #666;">${entry.notation}</small>` : ''}
                    ${isColdStorage ? `<br><span style="background: #3498db; color: white; padding: 2px 8px; border-radius: 4px; font-size: 11px;"> BLUE WALLET</span>` : ''}
                    ${parseFloat(entry.amount) > 0 && ['trace', 'writeoff', 'cold_storage', 'vasp_arrival'].includes(entry.entryType) ? 
                        `<br><span style="background: #27ae60; color: white; padding: 2px 8px; border-radius: 4px; font-size: 11px;"> ${parseFloat(entry.amount).toLocaleString()} ${entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency || ''} counted</span>` : 
                        `<br><span style="background: #e74c3c; color: white; padding: 2px 8px; border-radius: 4px; font-size: 11px;"> Entry not counted - ${parseFloat(entry.amount) > 0 ? 'check entry type' : 'add amount'}</span>`}
                </div>
                <button class="btn btn-danger" onclick="removeHopEntry(${entry.hopId}, ${entry.id})">Remove</button>
            </div>
            
            ${isTrace ? `
                <div class="form-group" style="background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%); padding: 20px; border-radius: 8px; border: 2px solid #2196f3; margin-bottom: 15px;">
                    <label style="font-weight: bold; color: #0d47a1; font-size: 16px;"> Transaction Hash (Start Here)</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <input type="text" 
                               id="txHash_${entry.hopId}_${entry.id}"
                               value="${entry.txHash || ''}" 
                               placeholder="Paste transaction hash to auto-fill details"
                               onchange="updateHopEntry(${entry.hopId}, ${entry.id}, 'txHash', this.value)"
                               style="flex: 1; font-size: 16px; padding: 14px; border: 2px solid #2196f3;">
                        <button type="button" 
                                class="btn btn-primary" 
                                onclick="lookupHopTransaction(${entry.hopId}, ${entry.id})"
                                style="background: #2196f3; color: white; padding: 14px 20px; font-size: 16px; font-weight: bold;">
                             Auto-fill
                        </button>
                    </div>
                    <div style="font-size: 12px; color: #0d47a1; margin-top: 8px;">
                        Enter transaction hash above to automatically populate amount, wallets, and timestamp
                    </div>
                </div>
            ` : ''}
            
            <div class="form-group">
                <label>Entry Type</label>
                <select onchange="updateHopEntry(${entry.hopId}, ${entry.id}, 'entryType', this.value)">
                    ${Object.entries(entryTypes).map(([key, value]) => 
                        `<option value="${key}" ${entry.entryType === key ? 'selected' : ''}>${value}</option>`
                    ).join('')}
                </select>
                ${isColdStorage ? `
                    <div style="background: #e8f4f8; border: 1px solid #3498db; border-radius: 4px; padding: 10px; margin-top: 8px; font-size: 12px;">
                        <strong>Cold Storage:</strong> Funds remain in current wallet, classified as BLUE (cold storage). 
                        This accounts for the amount in ART without requiring further tracing.
                    </div>
                ` : ''}
            </div>
            
            ${!isWriteoff ? `
                <div class="form-group">
                    <label>Source Thread Selection ${availableSourceThreads.length > 1 ? '(Multiple allowed)' : ''}</label>
                    ${availableSourceThreads.length > 1 ? `
                        <!-- Multiple Source Thread Selection -->
                        <div style="background: #f8f9fa; border: 1px solid #ddd; border-radius: 4px; padding: 15px;">
                            <div style="margin-bottom: 10px; font-weight: bold;">Select source threads and allocate amounts:</div>
                            ${availableSourceThreads.map(source => {
                                const isSelected = entry.multipleSourceThreads && entry.multipleSourceThreads.includes(source.threadId);
                                const proposedAmount = entry.individualSourceAssignments && entry.individualSourceAssignments[source.threadId] || 0;
                                
                                return `
                                    <div style="margin-bottom: 12px;">
                                        <!-- Source Selection Row -->
                                        <div style="padding: 8px; background: white; border-radius: 3px; border: 1px solid ${isSelected ? '#3498db' : '#ddd'};">
                                            <input type="checkbox" 
                                                value="${source.threadId}" 
                                                ${isSelected ? 'checked' : ''}
                                                onchange="updateMultipleSourceSelection(${entry.hopId}, ${entry.id})"
                                                style="margin-right: 10px; vertical-align: middle;"> 
                                            <span style="font-weight: bold; color: #2c3e50;">${source.displayText} - ${source.availableAmount.toLocaleString()} ${source.currency} available</span>
                                        </div>
                                        
                                        <!-- Amount Input Row (only show if selected) -->
                                        ${isSelected ? `
                                            <div style="margin-top: 6px; margin-left: 30px; display: flex; align-items: center; gap: 8px;">
                                                <span style="font-size: 12px; color: #666; min-width: 80px;">Allocate:</span>
                                                <input type="number" 
                                                    step="${getCurrencyStep(source.currency)}" 
                                                    min="0" 
                                                    max="${source.availableAmount}"
                                                    value="${proposedAmount}"
                                                    style="width: 120px; padding: 4px 6px; border: 1px solid #ddd; border-radius: 3px;"
                                                    onchange="updateIndividualSourceAssignment(${entry.hopId}, ${entry.id}, '${source.threadId}', this.value)"
                                                    placeholder="0.00">
                                                <button type="button" 
                                                        onclick="assignMaxToIndividualSource(${entry.hopId}, ${entry.id}, '${source.threadId}')"
                                                        style="padding: 4px 8px; font-size: 11px; background: #3498db; color: white; border: none; border-radius: 3px; cursor: pointer;">
                                                    Max
                                                </button>
                                                <span style="font-size: 11px; color: #666;">
                                                    (${(source.availableAmount - proposedAmount).toLocaleString()} would remain)
                                                </span>
                                            </div>
                                        ` : ''}
                                    </div>
                                `;
                            }).join('')}
                            
                            <!-- Preview for multiple sources -->
                            <div id="multipleSourcePreview_${entry.hopId}_${entry.id}"></div>
                        </div>
                    ` : `
                        <!-- Single Source Thread Selection -->
                        <select id="sourceSelect_${entry.hopId}_${entry.id}" 
                                onchange="handleSourceSelection(${entry.hopId}, ${entry.id}, this.value)">
                            <option value="">Select source thread...</option>
                            ${sourceOptions}
                        </select>
                        ${entry.sourceThreadId ? `
                            <div style="margin-top: 8px; padding: 10px; background: #e8f4f8; border-radius: 4px;">
                                <strong>Selected:</strong> ${entry.sourceThreadId}<br>
                                <small style="color: #666;">You can allocate any portion of the available amount</small>
                            </div>
                        ` : ''}
                    `}
                </div>
            ` : ''}
            
            ${isTrace && availableSourceThreads.length > 0 ? `
            <!-- Smart Allocation Button -->
            <div class="form-group" style="text-align: center; margin: 20px 0;">
                <button type="button" 
                        class="btn btn-confirm"
                        onclick="openSmartAllocationModal(${entry.hopId}, ${entry.id})"
                        style="background: linear-gradient(135deg, #27ae60 0%, #219a52 100%); padding: 12px 30px;">
                     Smart Amount Allocation
                </button>
                <div style="font-size: 11px; color: #666; margin-top: 8px;">
                    ${availableSourceThreads.length > 1 
                        ? `Automatically distribute amounts across ${availableSourceThreads.length} available source threads`
                        : `Allocate partial or full amount from source thread`
                    }
                </div>
                <div style="background: #e8f5e8; border: 1px solid #27ae60; border-radius: 4px; padding: 8px; margin-top: 8px; font-size: 11px;">
                    <strong> Use this when:</strong> You want to trace a specific total amount and need the tool to automatically 
                    calculate how much to take from each available source thread.
                </div>
            </div>
            ` : ''}
            
            <div class="form-group">
                <label>${isWriteoff ? 'Write-off Amount' : isColdStorage ? 'Cold Storage Amount' : 'Trace Amount'}</label>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="number" step="${getCurrencyStep(entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency)}" 
                           id="assignAmount_${entry.hopId}_${entry.id}"
                           value="${entry.amount || ''}"
                           max="${maxAmount}"
                           onchange="updateAssignmentAmount(${entry.hopId}, ${entry.id}, this.value)">
                    <button type="button" class="btn btn-secondary" 
                            onclick="${isWriteoff ? 'assignMaxWriteoffAmount' : 'assignMaxAmount'}(${entry.hopId}, ${entry.id})"
                            ${!isWriteoff && !entry.sourceThreadId ? 'disabled' : ''}>
                        ${isWriteoff ? 'Balance ART' : 'Max'}
                    </button>
                </div>
                <div style="font-size: 11px; color: #666; margin-top: 5px;">
                    ${isWriteoff ? 'Amount to write off from ART' : isColdStorage ? 'Amount remaining in cold storage' : 'Amount to trace forward'}
                    ${!isWriteoff && !isColdStorage && entry.sourceThreadId && maxAmount > 0 ? 
                        `<br><span style="color: #3498db;"> You can allocate any amount up to ${maxAmount.toLocaleString()} ${entry.currency || 'units'}</span>` : ''
                    }
                    ${!isWriteoff && entry.sourceThreadId ? 
                        `<br><span style="background: #e8f0fe; padding: 4px 8px; border-radius: 3px; display: inline-block; margin-top: 5px;">
                            <strong>Max button:</strong> Quickly allocates ALL available funds from selected source(s). 
                            Use when you want to trace the entire amount forward.
                        </span>` : ''
                    }
                </div>
                <div id="assignmentPreview_${entry.hopId}_${entry.id}" 
                     style="font-size: 12px; margin-top: 5px;"></div>
            </div>

            <div class="form-group">
                <label>Notation Builder</label>
                <div style="display: flex; align-items: center; gap: 5px; font-family: monospace; font-weight: bold;">
                    <span>V</span>
                    <input type="text" style="width: 60px; text-align: center;" 
                           placeholder="1" 
                           value="${entry.victimNumbers || ''}"
                           onchange="updateNotationField(${entry.hopId}, ${entry.id}, 'victims', this.value)">
                    <span>-T</span>
                    <input type="text" style="width: 80px; text-align: center;" 
                           placeholder="1,2,3" 
                           value="${entry.transactionNumbers || ''}"
                           onchange="updateNotationField(${entry.hopId}, ${entry.id}, 'transactions', this.value)">
                    <span>-H${entry.hopNumber}${isWriteoff ? '-WO' : isColdStorage ? '-CS' : ''}</span>
                </div>
                <div style="font-size: 12px; color: #666; margin-top: 5px;">
                    Preview: <span id="notation_preview_${entry.hopId}_${entry.id}" style="font-family: monospace; font-weight: bold;">${entry.notation || 'Enter V and T numbers'}</span>
                </div>
            </div>
            
            <div class="form-group">
                <label>Currency</label>
                <div style="padding: 10px; background: #f8f9fa; border: 1px solid #ddd; border-radius: 4px;">
                    <strong>${entry.currency ? (entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency) : '---'}</strong>
                    ${entry.sourceThreadId ? `
                        <div style="font-size: 11px; color: #666; margin-top: 5px;">
                            Currency inherited from source thread: ${entry.sourceThreadId}
                        </div>
                    ` : `
                        <div style="font-size: 11px; color: #e74c3c; margin-top: 5px;">
                             Select a source thread to set currency
                        </div>
                    `}
                </div>
                ${entry.toWalletType === 'brown' ? `
                    <div style="margin-top: 10px; padding: 10px; background: #fff3cd; border: 1px solid #ffc107; border-radius: 4px;">
                        <strong> Asset Conversion Detected</strong><br>
                        <small>Brown wallet allows currency conversion. Use the conversion modal to change currency.</small>
                    </div>
                ` : ''}
            </div>
            
            ${isTrace ? `
                <div class="form-group">
                    <label>To Wallet Address</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <div class="wallet-autocomplete-container" style="flex: 1;">
                            <input type="text" 
                                   id="toWallet_${entry.hopId}_${entry.id}"
                                   value="${entry.toWallet || ''}" 
                                   placeholder="Select existing or enter new wallet address"
                                   onchange="updateHopEntry(${entry.hopId}, ${entry.id}, 'toWallet', this.value)"
                                   oninput="handleWalletAutocomplete(this, ${entry.hopId}, ${entry.id})"
                                   onblur="checkWalletEntity(this.value, ${entry.hopId}, ${entry.id})"
                                   autocomplete="off"
                                   list="walletList_${entry.hopId}_${entry.id}"
                                   style="width: 100%;">
                            <div id="autocomplete_${entry.hopId}_${entry.id}" class="wallet-autocomplete-dropdown"></div>
                        </div>
                        <datalist id="walletList_${entry.hopId}_${entry.id}">
                            ${(investigation.universalWalletIndex || []).map(wallet => `
                                <option value="${wallet.address}">
                                    ${wallet.permanentId} - ${wallet.address.substring(0, 20)}...
                                </option>
                            `).join('')}
                        </datalist>
                        <button type="button" class="btn btn-secondary" style="padding: 6px 12px; font-size: 12px;"
                                onclick="showWalletSelector(${entry.hopId}, ${entry.id})">
                             Browse
                        </button>
                    </div>
                    <div style="font-size: 11px; color: #666; margin-top: 5px;">
                        Type to search existing wallets or enter a new address
                    </div>
                    <div id="entityInfo_${entry.hopId}_${entry.id}" style="display: none; margin-top: 10px; padding: 10px; background: #f3e6ff; border: 2px solid #9b59b6; border-radius: 4px;">
                        <!-- Entity information will be displayed here -->
                    </div>
                </div>
                <div class="form-group">
                    <label>To Wallet Classification</label>
                    <select onchange="updateHopEntryWalletType(${entry.hopId}, ${entry.id}, this.value)">
                        <option value="">Select classification...</option>
                        ${Object.entries(walletTypes).filter(([key]) => key !== 'red').map(([key, value]) => 
                            `<option value="${key}" ${entry.toWalletType === key ? 'selected' : ''}>${value}</option>`
                        ).join('')}
                    </select>
                </div>
                <!-- Transaction hash moved to top of form -->
                <div class="form-group">
                    <label>Timestamp with Timezone</label>
                    <div class="datetime-timezone">
                        <input type="datetime-local" 
                               id="timestamp_${entry.hopId}_${entry.id}"
                               value="${entry.timestamp || ''}" 
                               onchange="updateHopEntry(${entry.hopId}, ${entry.id}, 'timestamp', this.value)">
                        <select onchange="updateHopEntry(${entry.hopId}, ${entry.id}, 'timezone', this.value)">
                            ${Object.entries(timezones).map(([key, value]) => 
                                `<option value="${key}" ${entry.timezone === key ? 'selected' : ''}>${value}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
            ` : ''}
            
            ${isColdStorage ? `
                <div class="form-group">
                    <label>Current Wallet Address</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <input type="text" 
                               id="toWallet_${entry.hopId}_${entry.id}"
                               list="walletList_${entry.hopId}_${entry.id}"
                               value="${entry.toWallet || entry.fromWallet || ''}" 
                               placeholder="Select existing or enter new wallet address"
                               onchange="updateHopEntry(${entry.hopId}, ${entry.id}, 'toWallet', this.value)"
                               style="flex: 1;">
                        <button type="button" class="btn btn-secondary" style="padding: 6px 12px; font-size: 12px;"
                                onclick="showWalletSelector(${entry.hopId}, ${entry.id})">
                             Browse
                        </button>
                    </div>
                    <div style="font-size: 11px; color: #666; margin-top: 5px;">
                        Wallet where ${formatNumber(entry.amount || '0')} ${entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency} remains in cold storage
                    </div>
                </div>
                <div class="form-group">
                    <label>Cold Storage Classification</label>
                    <select onchange="updateHopEntry(${entry.hopId}, ${entry.id}, 'toWalletType', this.value)">
                        <option value="blue" ${entry.toWalletType === 'blue' ? 'selected' : ''}>BLUE - Cold Storage</option>
                    </select>
                    <div style="font-size: 11px; color: #666; margin-top: 5px;">
                        Cold storage is automatically classified as BLUE wallet type
                    </div>
                </div>
            ` : ''}
            
            ${isWriteoff ? `
                <div class="form-group">
                    <label>Write-off Category</label>
                    <select onchange="updateHopEntry(${entry.hopId}, ${entry.id}, 'category', this.value)">
                        <option value="">Select category...</option>
                        ${Object.entries(writeoffCategories).map(([key, value]) => 
                            `<option value="${key}" ${entry.category === key ? 'selected' : ''}>${value}</option>`
                        ).join('')}
                    </select>
                </div>
                <div class="form-group" style="grid-column: span 2;">
                    <label>Justification</label>
                    <textarea rows="3" placeholder="Detailed explanation for abandoning this trace path..." 
                              onchange="updateHopEntry(${entry.hopId}, ${entry.id}, 'justification', this.value)">${entry.justification || ''}</textarea>
                </div>
            ` : isColdStorage ? `
                <div class="form-group" style="grid-column: span 2;">
                    <label>Cold Storage Notes</label>
                    <textarea rows="2" placeholder="Details about why funds remain in cold storage..." 
                              onchange="updateHopEntry(${entry.hopId}, ${entry.id}, 'notes', this.value)">${entry.notes || ''}</textarea>
                </div>
            ` : `
                <div class="form-group" style="grid-column: span 2;">
                    <label>Notes</label>
                    <textarea rows="2" placeholder="PIFO application, convergence notes, etc." 
                              onchange="updateHopEntry(${entry.hopId}, ${entry.id}, 'notes', this.value)">${entry.notes || ''}</textarea>
                </div>
            `}
            
            <!-- Log Entry Button -->
            <div style="margin-top: 20px; text-align: center; border-top: 2px solid #e8f0fe; padding-top: 20px;">
                <button class="btn btn-confirm" onclick="logAndCollapseEntry(${entry.hopId}, ${entry.id})" 
                        style="padding: 12px 30px; font-size: 16px; background: #27ae60;">
                     Log Entry
                </button>
                <p style="margin-top: 10px; font-size: 12px; color: #666;">
                    This will save and collapse the entry. You can click the header to expand it again.
                </p>
            </div>
        </div>
    `;
}
function initializeEnhancedInvestigation() {
    if (!investigation.availableThreads) {
        investigation.availableThreads = {};
    }
    if (!investigation.threadAssignments) {
        investigation.threadAssignments = {};
    }
    if (!investigation.sourceChainData) {
        investigation.sourceChainData = {};
    }
    if (!investigation.enhancedNotationEnabled) {
        investigation.enhancedNotationEnabled = true;
    }
}

function migrateToEnhancedStructure() {
    initializeEnhancedInvestigation();
    
    investigation.hops.forEach(hop => {
        hop.entries.forEach(entry => {
            if (!entry.sourceChain) entry.sourceChain = [];
            if (!entry.displayNotation) entry.displayNotation = '';
            if (!entry.summaryNotation) entry.summaryNotation = '';
            if (!entry.victimNumbers) entry.victimNumbers = '';
            if (!entry.transactionNumbers) entry.transactionNumbers = '';
            if (!entry.availableSourceAmount) entry.availableSourceAmount = 0;
            if (!entry.sourceThreadId) entry.sourceThreadId = '';
            if (!entry.sourceThreadData) entry.sourceThreadData = null;
            if (!entry.assignmentPercentage) entry.assignmentPercentage = 0;
            if (!entry.generatedNotation) entry.generatedNotation = '';
            if (entry.isConvergence === undefined) entry.isConvergence = false;
            if (!entry.convergenceData) entry.convergenceData = null;
        });
    });
    
    console.log('Investigation migrated to enhanced structure');
    saveToStorage();
}
// =================================
// PHASE 2: CORE THREAD TRACKING FUNCTIONS
// =================================

// 2.1 Build Available Threads Index
function buildAvailableThreadsIndex() {
    investigation.availableThreads = {};
    
    // Start with ALL victim transactions (RED wallets) from ALL victims
    investigation.victims.forEach(victim => {
        victim.transactions.forEach(transaction => {
            if (parseFloat(transaction.amount) > 0 && transaction.receivingWallet) {
                const currency = transaction.currency === 'CUSTOM' ? 
                    transaction.customCurrency : transaction.currency;
                const threadId = `V${victim.id}-T${transaction.id}`;
                
                if (!investigation.availableThreads[currency]) {
                    investigation.availableThreads[currency] = {};
                }
                
                investigation.availableThreads[currency][threadId] = {
                    totalAmount: parseFloat(transaction.amount),
                    availableAmount: parseFloat(transaction.amount),
                    assignments: [],
                    sourceWallet: transaction.receivingWallet,
                    sourceType: 'victim_transaction',
                    hopLevel: 0,
                    createdAt: transaction.datetime || new Date().toISOString(),
                    isActive: true,
                    parentThreads: [],
                    childThreads: [],
                    currency: currency,
                    victimId: victim.id,
                    transactionId: transaction.id
                };
            }
        });
    });
    
    // Process ALL hop entries to update available threads
    investigation.hops.forEach(hop => {
        hop.entries.forEach(entry => {
            if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0 && entry.notation) {
                updateThreadAvailabilityFromHop(entry);
            }
        });
    });
    
    console.log(' Available threads index built for ALL victims:', investigation.availableThreads);
}

// 2.2 Update Thread Availability from Hop Entry
function updateThreadAvailabilityFromHop(entry) {
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    const amount = parseFloat(entry.amount);
    
    if (!investigation.availableThreads[currency]) {
        investigation.availableThreads[currency] = {};
    }
    
    // Create new thread entry for this hop output with hop suffix
    const newThreadId = `${entry.notation}-H${entry.hopNumber}`;
    investigation.availableThreads[currency][newThreadId] = {
        totalAmount: amount,
        availableAmount: amount,
        assignments: [],
        sourceWallet: entry.toWallet,
        sourceType: 'hop_output',
        hopLevel: entry.hopNumber,
        createdAt: entry.timestamp || new Date().toISOString(),
        isActive: true,
        parentThreads: entry.sourceThreadId ? [entry.sourceThreadId] : [],
        childThreads: [],
        currency: currency
    };
    
    // Reduce availability from source thread if specified
    if (entry.sourceThreadId && investigation.availableThreads[currency][entry.sourceThreadId]) {
        const sourceThread = investigation.availableThreads[currency][entry.sourceThreadId];
        sourceThread.availableAmount -= amount;
        sourceThread.assignments.push({
            assignedTo: newThreadId,
            amount: amount,
            timestamp: new Date().toISOString(),
            isActive: true
        });
        
        // Add child reference
        if (!sourceThread.childThreads.includes(newThreadId)) {
            sourceThread.childThreads.push(newThreadId);
        }
    }
}

// REPLACE YOUR EXISTING getAvailableSourcesForHop FUNCTION WITH THIS FIXED VERSION

function getAvailableSourcesForHop(hopNumber, targetCurrency) {
    console.log(` Getting available sources for Hop ${hopNumber}, Currency filter: ${targetCurrency || 'ALL'}`);
    
    buildAvailableThreadsIndex(); // Refresh the index
    
    console.log('Available threads after build:', investigation.availableThreads);
    
    const availableSources = [];
    
    if (hopNumber === 1) {
        // First hop: ALL victim transactions (RED wallets) from ALL victims, ALL currencies
        console.log(` Checking ${investigation.victims.length} victims for available transactions`);
        
        investigation.victims.forEach(victim => {
            victim.transactions.forEach(transaction => {
                console.log(`Checking V${victim.id}-T${transaction.id}: Amount=${transaction.amount}, Wallet=${transaction.receivingWallet}, Currency=${transaction.currency}`);
                
                if (parseFloat(transaction.amount) > 0 && transaction.receivingWallet && transaction.receivingWallet.trim() !== '') {
                    const currency = transaction.currency === 'CUSTOM' ? transaction.customCurrency : transaction.currency;
                    
                    console.log(`Transaction currency: ${currency}, Target filter: ${targetCurrency || 'NONE'}`);
                    
                    // Only filter by currency if targetCurrency is specified
                    if (!targetCurrency || currency === targetCurrency) {
                        const threadId = `V${victim.id}-T${transaction.id}`;
                        
                        // Use the REAL-TIME availability calculation
                        const currentAvailable = getMaxAssignableAmount(threadId, currency);
                        
                        console.log(`Thread ${threadId}: Available ${currentAvailable} ${currency} from real-time calculation`);
                        
                        if (currentAvailable > 0) {
                            const source = {
                                threadId: threadId,
                                displayText: `${threadId} (RED Wallet)`,
                                availableAmount: currentAvailable,
                                currency: currency, // ENSURE CURRENCY IS INCLUDED
                                sourceWallet: transaction.receivingWallet,
                                sourceType: 'victim_transaction',
                                hopLevel: 0
                            };
                            
                            console.log(` Adding source:`, source);
                            availableSources.push(source);
                        } else {
                            console.log(` Skipping ${threadId}: No availability remaining`);
                        }
                    }
                }
            });
        });
    } else {
        // Subsequent hops: ALL outputs from previous hop level across ALL victim paths
        const previousHopNumber = hopNumber - 1;
        console.log(` Checking previous hop ${previousHopNumber} for available sources`);
        
        investigation.hops.forEach(hop => {
            if (hop.hopNumber === previousHopNumber) {
                hop.entries.forEach(entry => {
                    if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0 && entry.notation) {
                        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                        
                        if (!targetCurrency || currency === targetCurrency) {
                            // Use the correct thread ID format with hop suffix
                            const threadId = `${entry.notation}-H${hop.hopNumber}`;
                            const currentAvailable = getMaxAssignableAmount(threadId, currency);
                            
                            if (currentAvailable > 0) {
                                availableSources.push({
                                    threadId: threadId,
                                    displayText: `${threadId}`,
                                    availableAmount: currentAvailable,
                                    currency: currency, // ENSURE CURRENCY IS INCLUDED
                                    sourceWallet: entry.toWallet,
                                    sourceType: 'hop_output',
                                    hopLevel: previousHopNumber
                                });
                            }
                        }
                    }
                });
            }
        });
    }
    
    console.log(` Final available sources (${availableSources.length}):`, availableSources);
    
    return availableSources.sort((a, b) => a.threadId.localeCompare(b.threadId));
}

// 2.4 Get Wallet Type Display Name
function getWalletTypeDisplayName(walletAddress) {
    // Try to find wallet in universal wallet index
    const wallet = investigation.universalWalletIndex?.find(w => w.address === walletAddress);
    if (wallet) {
        return wallet.permanentId;
    }
    
    // Fallback to abbreviated address
    if (walletAddress && walletAddress.length > 10) {
        return walletAddress.substring(0, 6) + '...' + walletAddress.substring(walletAddress.length - 4);
    }
    
    return walletAddress || 'Unknown';
}

// 2.5 Get Maximum Assignable Amount - Function moved to line 6710 with enhanced functionality

// 2.8 Calculate Total Assigned Amount by Currency
function calculateTotalAssignedAmount(currency) {
    let totalAssigned = 0;
    
    if (!investigation.availableThreads[currency]) {
        return 0;
    }
    
    Object.values(investigation.availableThreads[currency]).forEach(thread => {
        thread.assignments.forEach(assignment => {
            if (assignment.isActive) {
                totalAssigned += assignment.amount;
            }
        });
    });
    
    return totalAssigned;
}

// 2.9 Get Thread Chain History
function getThreadChainHistory(threadId, currency) {
    const chain = [];
    
    if (!investigation.availableThreads[currency] || !investigation.availableThreads[currency][threadId]) {
        return chain;
    }
    
    const thread = investigation.availableThreads[currency][threadId];
    chain.push({
        threadId: threadId,
        amount: thread.totalAmount,
        hopLevel: thread.hopLevel,
        sourceType: thread.sourceType
    });
    
    // Trace back through parent threads
    thread.parentThreads.forEach(parentId => {
        const parentChain = getThreadChainHistory(parentId, currency);
        chain.unshift(...parentChain);
    });
    
    return chain;
}

// 2.10 Enhanced getCurrentART with Thread Tracking
function getCurrentARTWithThreads() {
    const artByCurrency = {};
    
    // Start with root totals by currency from victims
    investigation.victims.forEach(victim => {
        victim.transactions.forEach(transaction => {
            if (parseFloat(transaction.amount) > 0) {
                const currency = transaction.currency === 'CUSTOM' ? transaction.customCurrency : transaction.currency;
                if (!artByCurrency[currency]) {
                    artByCurrency[currency] = {
                        rootTotal: 0,
                        writeoffs: 0,
                        adjustedTotal: 0,
                        assignedAmount: 0,
                        unassignedAmount: 0
                    };
                }
                artByCurrency[currency].rootTotal += parseFloat(transaction.amount);
            }
        });
    });
    
    // Subtract write-offs from hop entries by currency
    investigation.hops.forEach(hop => {
        hop.entries.forEach(entry => {
            if (entry.entryType === 'writeoff' && parseFloat(entry.amount) > 0) {
                const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                if (artByCurrency[currency]) {
                    artByCurrency[currency].writeoffs += parseFloat(entry.amount);
                }
            }
        });
    });
    
    // Calculate adjusted totals and assigned amounts
    Object.keys(artByCurrency).forEach(currency => {
        const art = artByCurrency[currency];
        art.adjustedTotal = art.rootTotal - art.writeoffs;
        art.assignedAmount = calculateTotalAssignedAmount(currency);
        art.unassignedAmount = art.adjustedTotal - art.assignedAmount;
    });
    
    return artByCurrency;
}
// =================================
// PHASE 3: ENHANCED UI COMPONENTS
// =================================

// 3.1 Enhanced Notation Field Functions
function updateNotationField(hopId, entryId, field, value) {
    const hop = investigation.hops.find(h => h.id === hopId);
    const entry = hop.entries.find(e => e.id === entryId);
    
    if (field === 'victims') {
        entry.victimNumbers = value;
    } else if (field === 'transactions') {
        entry.transactionNumbers = value;
    }
    
    // Generate the notation preview
    generateNotationPreview(hopId, entryId);
    saveToStorage();
}

function generateNotationPreview(hopId, entryId) {
    const hop = investigation.hops.find(h => h.id === hopId);
    const entry = hop.entries.find(e => e.id === entryId);
    
    if (!entry.victimNumbers || !entry.transactionNumbers) {
        entry.notation = '';
        const previewElement = document.getElementById(`notation_preview_${hopId}_${entryId}`);
        if (previewElement) {
            previewElement.textContent = 'Enter victim and transaction numbers';
        }
        return;
    }
    
    // Generate V-T-H notation with suffix for writeoffs and cold storage
    let notation = `V${entry.victimNumbers}-T${entry.transactionNumbers}-H${entry.hopNumber}`;
    
    // Add suffix based on entry type
    if (entry.entryType === 'writeoff') {
        notation += '-WO';
    } else if (entry.entryType === 'cold_storage') {
        notation += '-CS';
    }
    
    entry.notation = notation;
    entry.generatedNotation = notation;
    
    // Update preview element
    const previewElement = document.getElementById(`notation_preview_${hopId}_${entryId}`);
    if (previewElement) {
        previewElement.textContent = notation;
    }
    
    // If we have source and amount, update the full display notation
    if ((entry.sourceThreadId || (entry.multipleSourceThreads && entry.multipleSourceThreads.length > 0)) && entry.amount) {
        updateFullNotationDisplay(hopId, entryId);
    }
}

// 3.2 Source Selection Handler
function handleSourceSelection(hopId, entryId, sourceThreadId) {
    console.log(` Handling source selection: ${sourceThreadId} for hop ${hopId} entry ${entryId}`);
    
    const hop = investigation.hops.find(h => h.id === hopId);
    const entry = hop.entries.find(e => e.id === entryId);
    
    if (!hop || !entry) {
        console.error(' Could not find hop or entry:', { hopId, entryId });
        return;
    }
    
    // Clear previous assignments
    entry.sourceThreadId = sourceThreadId;
    entry.multipleSourceThreads = [];
    entry.isConvergence = false;
    entry.individualSourceAssignments = {};
    
    if (sourceThreadId) {
        // Get the source thread details to determine its currency
        const availableSources = getAvailableSourcesForHop(hop.hopNumber, null);
        const selectedSource = availableSources.find(s => s.threadId === sourceThreadId);
        
        if (selectedSource) {
            // Auto-update the currency to match the source thread
            const sourceCurrency = selectedSource.currency;
            
            // Check if it's a custom currency
            const isCustomCurrency = !Object.keys(currencies).includes(sourceCurrency);
            
            if (isCustomCurrency) {
                entry.currency = 'CUSTOM';
                entry.customCurrency = sourceCurrency;
            } else {
                entry.currency = sourceCurrency;
                entry.customCurrency = '';
            }
            
            // Update the currency dropdown in the UI
            const currencySelect = document.querySelector(`select[onchange="updateHopEntry(${hopId}, ${entryId}, 'currency', this.value)"]`);
            if (currencySelect) {
                currencySelect.value = entry.currency;
            }
            
            // Show/hide custom currency input if needed
            const customCurrencyDiv = document.getElementById(`customEntryCurrency_${hopId}_${entryId}`);
            if (customCurrencyDiv) {
                if (isCustomCurrency) {
                    customCurrencyDiv.classList.remove('custom-currency-input');
                    const customInput = customCurrencyDiv.querySelector('input');
                    if (customInput) {
                        customInput.value = sourceCurrency;
                    }
                } else {
                    customCurrencyDiv.classList.add('custom-currency-input');
                }
            }
            
            console.log(` Auto-updated currency to: ${sourceCurrency} (${isCustomCurrency ? 'custom' : 'standard'})`);
        }
        
        // Now use the updated currency from the source thread
        const currency = selectedSource.currency;
        const maxAmount = getMaxAssignableAmount(sourceThreadId, currency, entryId, hopId);
        
        console.log(` Max available for ${sourceThreadId}: ${maxAmount} ${currency}`);
        
        // Update max amount for input
        const amountInput = document.getElementById(`assignAmount_${hopId}_${entryId}`);
        if (amountInput) {
            amountInput.max = maxAmount;
            
            // Only auto-fill if current amount exceeds new max (to prevent invalid amounts)
            if (parseFloat(entry.amount) > maxAmount) {
                entry.amount = maxAmount.toString();
                amountInput.value = maxAmount;
            }
            // Don't auto-fill otherwise - let user decide how much to assign
        }
        
        // Update source thread data
        if (investigation.availableThreads[currency] && investigation.availableThreads[currency][sourceThreadId]) {
            entry.sourceThreadData = investigation.availableThreads[currency][sourceThreadId];
            entry.availableSourceAmount = maxAmount;
        }
        
        // Auto-generate notation from source thread
        autoGenerateNotationFromSource(hopId, entryId, sourceThreadId);
        
        updateAssignmentPreview(hopId, entryId);
        updateFullNotationDisplay(hopId, entryId);
    } else {
        // Clear selection
        const amountInput = document.getElementById(`assignAmount_${hopId}_${entryId}`);
        if (amountInput) {
            amountInput.max = 0;
            amountInput.value = '';
        }
        entry.amount = '';
        entry.sourceThreadData = null;
        entry.availableSourceAmount = 0;
        
        clearNotationFields(hopId, entryId);
    }
    
    saveToStorage();
    
    // CRITICAL: Force refresh of ALL entries to show updated availability
    refreshAllSourceAvailability(hopId);
}
function refreshAllSourceAvailability(currentHopId) {
    console.log(` Refreshing source availability for all entries in hop ${currentHopId}`);
    
    // Find the current hop
    const currentHop = investigation.hops.find(h => h.id === currentHopId);
    if (!currentHop) return;
    
    // Update each entry's source dropdown with real-time availability
    currentHop.entries.forEach(entry => {
        if (entry.entryType === 'trace') {
            const sourceSelect = document.getElementById(`sourceSelect_${currentHop.id}_${entry.id}`);
            if (sourceSelect) {
                const selectedValue = sourceSelect.value;
                const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                
                // Get fresh availability data - get all currencies since we auto-set based on selection
                const availableSourceThreads = getAvailableSourcesForHop(currentHop.hopNumber, null);
                
                // Rebuild options with current availability
                let newOptions = '<option value="">Select source thread...</option>';
                availableSourceThreads.forEach(source => {
                    const realTimeAvailable = getMaxAssignableAmount(source.threadId, null);
                    const isSelected = selectedValue === source.threadId ? 'selected' : '';
                    const availabilityText = realTimeAvailable > 0 ? 
                        `${realTimeAvailable.toLocaleString()} ${source.currency} available` : 
                        'FULLY ASSIGNED';
                    const isDisabled = realTimeAvailable <= 0 && selectedValue !== source.threadId ? 'disabled' : '';
                    
                    newOptions += `<option value="${source.threadId}" ${isSelected} ${isDisabled}>
                        ${source.displayText} - ${availabilityText}
                    </option>`;
                });
                
                sourceSelect.innerHTML = newOptions;
                
                // If current selection is now unavailable, show warning
                if (selectedValue && getMaxAssignableAmount(selectedValue, null) <= 0 && entry.amount && parseFloat(entry.amount) > 0) {
                    const warningDiv = document.getElementById(`assignmentPreview_${currentHop.id}_${entry.id}`);
                    if (warningDiv) {
                        warningDiv.innerHTML = '<div style="color: #e74c3c; font-weight: bold;"> Source thread is now fully assigned!</div>';
                    }
                }
            }
        }
    });
}

// 3.3 Assignment Amount Handler
function updateAssignmentAmount(hopId, entryId, amount) {
    const hop = investigation.hops.find(h => h.id === hopId);
    if (!hop) {
        console.error('Hop not found:', hopId);
        return;
    }
    
    const entry = hop.entries.find(e => e.id === entryId);
    if (!entry) {
        console.error('Entry not found:', entryId);
        return;
    }
    
    entry.amount = amount;
    
    if (entry.sourceThreadData) {
        entry.assignmentPercentage = (parseFloat(amount) / entry.sourceThreadData.totalAmount) * 100;
    }
    
    updateAssignmentPreview(hopId, entryId);
    updateFullNotationDisplay(hopId, entryId);
    saveToStorage();
    
    // CRITICAL: Refresh availability after amount changes
    refreshAllSourceAvailability(hopId);
    buildAvailableThreadsIndex(); // Rebuild thread index when amounts change
    
    // Auto-collapse entry if amount is set and valid
    if (parseFloat(amount) > 0) {
        const entryKey = `${hopId}_${entryId}`;
        window.entryCollapseState[entryKey] = true;
        const content = document.getElementById(`entryContent_${entryKey}`);
        const summary = document.getElementById(`entrySummary_${entryKey}`);
        if (content && summary) {
            content.style.display = 'none';
            summary.style.display = 'block';
        }
    }
}

// 3.4 Assignment Preview Updater
function updateAssignmentPreview(hopId, entryId) {
    const hop = investigation.hops.find(h => h.id === hopId);
    const entry = hop.entries.find(e => e.id === entryId);
    const previewElement = document.getElementById(`assignmentPreview_${hopId}_${entryId}`);
    
    if (!previewElement || !entry.sourceThreadId || !entry.amount) {
        if (previewElement) previewElement.innerHTML = '';
        return;
    }
    
    const amount = parseFloat(entry.amount);
    const maxAmount = getMaxAssignableAmount(entry.sourceThreadId, null, entryId, hopId); // Real-time calculation, let it find the currency
    
    // Get the actual currency from the source thread
    let currency = '';
    const availableSources = getAvailableSourcesForHop(hop.hopNumber, null);
    const sourceThread = availableSources.find(s => s.threadId === entry.sourceThreadId);
    if (sourceThread) {
        currency = sourceThread.currency;
    }
    const remaining = maxAmount + amount; // Total available if this assignment wasn't made
    const afterAssignment = remaining - amount;
    
    // Validate assignment with real-time data
    const validation = validateThreadAssignment(entry.sourceThreadId, amount, null, entryId, hopId);
    
    let previewHTML = '';
    if (validation.valid) {
        previewHTML = `
            <div style="color: #27ae60; background: #d4f8d4; padding: 8px; border-radius: 4px; margin-top: 5px;">
                 Assigning ${amount.toLocaleString()} ${currency} from ${entry.sourceThreadId}
                <br><small style="color: #666;">
                    Available before: ${remaining.toLocaleString()} | After: ${afterAssignment.toLocaleString()} ${currency}
                    ${afterAssignment === 0 ? ' (FULLY ALLOCATED)' : ''}
                </small>
            </div>
        `;
        if (entry.assignmentPercentage) {
            previewHTML += `<div style="font-size: 11px; color: #666; margin-top: 3px;">Using ${entry.assignmentPercentage.toFixed(1)}% of source thread</div>`;
        }
    } else {
        previewHTML = `
            <div style="color: #e74c3c; background: #fdf2f2; padding: 8px; border-radius: 4px; margin-top: 5px;">
                 ${validation.error}
                <br><small style="color: #666;">Currently available: ${maxAmount.toLocaleString()} ${currency}</small>
            </div>
        `;
    }
    
    previewElement.innerHTML = previewHTML;
}

// 3.5 Assign Maximum Amount
function assignMaxAmount(hopId, entryId) {
    console.log(` assignMaxAmount called for hop ${hopId}, entry ${entryId}`);
    
    const hop = investigation.hops.find(h => h.id === hopId);
    if (!hop) {
        console.error('Hop not found:', hopId);
        return;
    }
    
    const entry = hop.entries.find(e => e.id === entryId);
    if (!entry) {
        console.error('Entry not found:', entryId);
        return;
    }
    
    console.log('Entry state:', {
        sourceThreadId: entry.sourceThreadId,
        multipleSourceThreads: entry.multipleSourceThreads,
        currentAmount: entry.amount
    })
    
    let maxAmount = 0;
    let currency = '';
    
    // Check if multiple sources are selected
    if (entry.multipleSourceThreads && entry.multipleSourceThreads.length > 0) {
        // First, validate that all sources have the same currency
        const availableSources = getAvailableSourcesForHop(hop.hopNumber, null);
        const currencies = new Set();
        
        entry.multipleSourceThreads.forEach(sourceId => {
            const source = availableSources.find(s => s.threadId === sourceId);
            if (source) {
                currencies.add(source.currency);
            }
        });
        
        if (currencies.size > 1) {
            alert(` Cannot mix different asset types!\n\nSelected threads contain: ${Array.from(currencies).join(', ')}\n\nPlease select threads with the same currency only.`);
            return;
        }
        
        // Calculate total from multiple sources using real-time availability
        entry.multipleSourceThreads.forEach(sourceId => {
            const availableAmount = getMaxAssignableAmount(sourceId, null);
            maxAmount += availableAmount;
            
            // Get currency from source thread
            const source = availableSources.find(s => s.threadId === sourceId);
            if (source && !currency) {
                currency = source.currency;
            }
            
            console.log(`Source ${sourceId}: ${availableAmount} available`);
        });
        console.log(`Total from ${entry.multipleSourceThreads.length} sources: ${maxAmount}`);
    } else if (entry.sourceThreadId) {
        // Single source selected
        maxAmount = getMaxAssignableAmount(entry.sourceThreadId, null, entry.id, entry.hopId);
        
        // Get currency from source thread
        const availableSources = getAvailableSourcesForHop(hop.hopNumber, null);
        const source = availableSources.find(s => s.threadId === entry.sourceThreadId);
        if (source) {
            currency = source.currency;
        }
        
        console.log(`Single source ${entry.sourceThreadId}: ${maxAmount} ${currency} available`);
    } else {
        alert('Please select source thread(s) first.');
        return;
    }
    
    // Update entry amount
    entry.amount = maxAmount.toString();
    
    // Update the input field - force update even if element seems unresponsive
    const amountInput = document.getElementById(`assignAmount_${hopId}_${entryId}`);
    if (amountInput) {
        console.log(`Updating amount input to ${maxAmount}`);
        amountInput.value = maxAmount;
        // Force a change event to ensure updates propagate
        amountInput.dispatchEvent(new Event('change', { bubbles: true }));
    } else {
        console.error(`Could not find amount input: assignAmount_${hopId}_${entryId}`);
    }
    
    // Trigger the amount update handler to ensure all related updates occur
    updateAssignmentAmount(hopId, entryId, maxAmount.toString());
    
    // Update appropriate preview based on source type
    if (entry.multipleSourceThreads && entry.multipleSourceThreads.length > 0) {
        updateMultipleSourcePreview(hopId, entryId);
        updateFullNotationDisplayMultiple(hopId, entryId);
    } else {
        updateAssignmentPreview(hopId, entryId);
        updateFullNotationDisplay(hopId, entryId);
    }
    
    saveToStorage();
}

// 3.6 Full Notation Display Updater
function updateFullNotationDisplay(hopId, entryId) {
    const hop = investigation.hops.find(h => h.id === hopId);
    const entry = hop.entries.find(e => e.id === entryId);
    const previewElement = document.getElementById(`notationPreview_${hopId}_${entryId}`);
    
    if (!previewElement) return;
    
    if (!entry.sourceThreadId || !entry.amount || !entry.notation) {
        previewElement.innerHTML = 'Select source, amount, and complete notation to generate full display';
        return;
    }
    
    const amount = parseFloat(entry.amount);
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    
    // Generate source chain notation
    const sourceChainEntry = {
        sourceNotation: entry.sourceThreadId,
        amount: amount,
        currency: currency,
        percentage: entry.assignmentPercentage || 100
    };
    
    // Create display notation
    const displayNotation = `${entry.sourceThreadId}(${amount.toLocaleString()})  ${entry.notation}`;
    const summaryNotation = `${entry.notation} (${amount.toLocaleString()} ${currency})`;
    
    // Update entry with generated notations
    entry.displayNotation = displayNotation;
    entry.summaryNotation = summaryNotation;
    entry.sourceChain = [sourceChainEntry];
    
    // Update preview display
    previewElement.innerHTML = `
        <div style="margin-bottom: 8px;"><strong>Display:</strong> ${displayNotation}</div>
        <div style="margin-bottom: 8px;"><strong>Summary:</strong> ${summaryNotation}</div>
        <div style="font-size: 11px; color: #666;">Source Chain: ${entry.sourceThreadId}  ${entry.notation}</div>
    `;
}

// 3.7 Enhanced Hop Entry Renderer (replaces renderHopEntry)
function renderEnhancedHopEntry(entry) {
    const isWriteoff = entry.entryType === 'writeoff';
    const isColdStorage = entry.entryType === 'cold_storage';
    
    // Get available source wallets for this hop
    const availableSourceWallets = getAvailableSourcesForHop(entry.hopNumber, entry.currency);
    const sourceOptions = availableSourceWallets.map(source => 
        `<option value="${source.threadId}" ${entry.sourceThreadId === source.threadId ? 'selected' : ''}>
            ${source.displayText} - ${source.availableAmount.toLocaleString()} ${source.currency} available
        </option>`
    ).join('');

    return `
        <div style="background: white; border: 2px solid #e8f0fe; border-radius: 8px; padding: 20px; margin-bottom: 15px;">
            <div class="trace-header">
                <div>
                    <span class="trace-notation">Entry ${entry.id} - ${entryTypes[entry.entryType]}</span>
                    ${entry.notation ? `<br><small style="color: #666;">${entry.notation}</small>` : ''}
                </div>
                <button class="btn btn-danger" onclick="removeHopEntry(${entry.hopId}, ${entry.id})">Remove</button>
            </div>
            
            <div class="form-group">
                <label>Entry Type</label>
                <select onchange="updateHopEntry(${entry.hopId}, ${entry.id}, 'entryType', this.value)">
                    ${Object.entries(entryTypes).map(([key, value]) => 
                        `<option value="${key}" ${entry.entryType === key ? 'selected' : ''}>${value}</option>`
                    ).join('')}
                </select>
            </div>
            
            ${!isWriteoff ? `
                <div class="form-group">
                    <label>Source Thread Selection</label>
                    <select id="sourceSelect_${entry.hopId}_${entry.id}" 
                            onchange="handleSourceSelection(${entry.hopId}, ${entry.id}, this.value)">
                        <option value="">Select source thread...</option>
                        ${sourceOptions}
                    </select>
                    ${entry.sourceThreadId ? `
                        <div style="margin-top: 8px; font-size: 11px; color: #666;">
                            <strong>Source:</strong> ${entry.sourceThreadId}
                        </div>
                    ` : ''}
                </div>
                
               <div class="form-group">
                    <label>New Thread Total</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <input type="number" step="0.01" 
                               id="assignAmount_${entry.hopId}_${entry.id}"
                               value="${entry.amount || ''}"
                               max="${entry.sourceThreadId ? getMaxAssignableAmount(entry.sourceThreadId, entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency) : 0}"
                               onchange="updateAssignmentAmount(${entry.hopId}, ${entry.id}, this.value)">
                        <button type="button" class="btn btn-secondary" 
                                onclick="assignMaxAmount(${entry.hopId}, ${entry.id})"
                                ${!entry.sourceThreadId ? 'disabled' : ''}>Max</button>
                    </div>
                    <div id="assignmentPreview_${entry.hopId}_${entry.id}" 
                         style="font-size: 12px; margin-top: 5px;"></div>
                </div>
            ` : ''}

            <div class="form-group">
                <label>Notation Builder</label>
                <div style="display: flex; align-items: center; gap: 5px; font-family: monospace; font-weight: bold;">
                    <span>V</span>
                    <input type="text" style="width: 60px; text-align: center;" 
                           placeholder="1" 
                           value="${entry.victimNumbers || ''}"
                           onchange="updateNotationField(${entry.hopId}, ${entry.id}, 'victims', this.value)">
                    <span>-T</span>
                    <input type="text" style="width: 80px; text-align: center;" 
                           placeholder="1,2,3" 
                           value="${entry.transactionNumbers || ''}"
                           onchange="updateNotationField(${entry.hopId}, ${entry.id}, 'transactions', this.value)">
                    <span>-H${entry.hopNumber}</span>
                </div>
                <div style="font-size: 12px; color: #666; margin-top: 5px;">
                    Preview: <span id="notation_preview_${entry.hopId}_${entry.id}" style="font-family: monospace; font-weight: bold;">${entry.notation || 'Enter V and T numbers'}</span>
                </div>
            </div>
            
            ${!isWriteoff ? `
                <div class="form-group">
                    <label>Full Notation Display</label>
                    <div id="notationPreview_${entry.hopId}_${entry.id}" 
                         style="font-family: monospace; padding: 10px; background: #f8f9fa; border-radius: 4px; min-height: 60px;">
                        ${entry.displayNotation || 'Complete source selection and notation to generate full display'}
                    </div>
                </div>
            ` : ''}

            <div class="form-group">
                <label>Currency</label>
                <select onchange="updateHopEntry(${entry.hopId}, ${entry.id}, 'currency', this.value)">
                    ${Object.entries(currencies).map(([key, currency]) => 
                        `<option value="${key}" ${entry.currency === key ? 'selected' : ''}>${currency.name}</option>`
                    ).join('')}
                </select>
            </div>
            
            <div class="form-group ${entry.currency === 'CUSTOM' ? '' : 'custom-currency-input'}" 
                 id="customEntryCurrency_${entry.hopId}_${entry.id}">
                <label>Custom Currency Symbol</label>
                <input type="text" value="${entry.customCurrency || ''}" 
                       placeholder="e.g., DOGE, SHIB"
                       onchange="updateHopEntry(${entry.hopId}, ${entry.id}, 'customCurrency', this.value)">
            </div>
            
            ${!isWriteoff && !isColdStorage ? `
                <div class="form-group">
                    <label>To Wallet Address</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <div class="wallet-autocomplete-container" style="flex: 1;">
                            <input type="text" 
                                   id="toWallet_${entry.hopId}_${entry.id}"
                                   value="${entry.toWallet || ''}" 
                                   placeholder="Select existing or enter new wallet address"
                                   onchange="updateHopEntry(${entry.hopId}, ${entry.id}, 'toWallet', this.value)"
                                   oninput="handleWalletAutocomplete(this, ${entry.hopId}, ${entry.id})"
                                   autocomplete="off"
                                   list="walletList_${entry.hopId}_${entry.id}"
                                   style="width: 100%;">
                            <div id="autocomplete_${entry.hopId}_${entry.id}" class="wallet-autocomplete-dropdown"></div>
                        </div>
                        <datalist id="walletList_${entry.hopId}_${entry.id}">
                            ${(investigation.universalWalletIndex || []).map(wallet => `
                                <option value="${wallet.address}">
                                    ${wallet.permanentId} - ${wallet.address.substring(0, 20)}...
                                </option>
                            `).join('')}
                        </datalist>
                        <button type="button" class="btn btn-secondary" style="padding: 6px 12px; font-size: 12px;"
                                onclick="showWalletSelector(${entry.hopId}, ${entry.id})">
                             Browse
                        </button>
                    </div>
                    <div style="font-size: 11px; color: #666; margin-top: 5px;">
                        Type to search existing wallets or enter a new address
                    </div>
                </div>
                <div class="form-group">
                    <label>To Wallet Classification</label>
                    <select onchange="updateHopEntryWalletType(${entry.hopId}, ${entry.id}, this.value)">
                        <option value="">Select classification...</option>
                        ${Object.entries(walletTypes).filter(([key]) => key !== 'red').map(([key, value]) => 
                            `<option value="${key}" ${entry.toWalletType === key ? 'selected' : ''}>${value}</option>`
                        ).join('')}
                    </select>
                </div>
                <div class="form-group">
                    <label>Transaction Hash</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <input type="text" 
                               id="txHash_${entry.hopId}_${entry.id}"
                               value="${entry.txHash || ''}" 
                               placeholder="Blockchain transaction hash"
                               onchange="updateHopEntry(${entry.hopId}, ${entry.id}, 'txHash', this.value)"
                               style="flex: 1;">
                        <button type="button" 
                                class="btn btn-secondary" 
                                onclick="openBlockchainLookup(${entry.hopId}, ${entry.id})"
                                style="background: #3498db; color: white; padding: 8px 15px; font-size: 14px;">
                             Lookup
                        </button>
                    </div>
                </div>
                <div class="form-group">
                    <label>Timestamp with Timezone</label>
                    <div class="datetime-timezone">
                        <input type="datetime-local" 
                               id="timestamp_${entry.hopId}_${entry.id}"
                               value="${entry.timestamp || ''}" 
                               onchange="updateHopEntry(${entry.hopId}, ${entry.id}, 'timestamp', this.value)">
                        <select onchange="updateHopEntry(${entry.hopId}, ${entry.id}, 'timezone', this.value)">
                            ${Object.entries(timezones).map(([key, value]) => 
                                `<option value="${key}" ${entry.timezone === key ? 'selected' : ''}>${value}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
            ` : ''}
            
            ${isWriteoff ? `
                <div class="form-group">
                    <label>Write-off Category</label>
                    <select onchange="updateHopEntry(${entry.hopId}, ${entry.id}, 'category', this.value)">
                        <option value="">Select category...</option>
                        ${Object.entries(writeoffCategories).map(([key, value]) => 
                            `<option value="${key}" ${entry.category === key ? 'selected' : ''}>${value}</option>`
                        ).join('')}
                    </select>
                </div>
                <div class="form-group" style="grid-column: span 2;">
                    <label>Justification</label>
                    <textarea rows="2" placeholder="Detailed explanation for abandoning this trace path..." 
                              onchange="updateHopEntry(${entry.hopId}, ${entry.id}, 'justification', this.value)">${entry.justification || ''}</textarea>
                </div>
            ` : `
                <div class="form-group" style="grid-column: span 2;">
                    <label>Notes</label>
                    <textarea rows="2" placeholder="PIFO application, convergence notes, etc." 
                              onchange="updateHopEntry(${entry.hopId}, ${entry.id}, 'notes', this.value)">${entry.notes || ''}</textarea>
                </div>
            `}
        </div>
    `;
}


// ADD THESE FUNCTIONS TO HANDLE COMMINGLING/MULTIPLE SOURCES

// Enhanced Source Selection Handler for Multiple Sources
function handleMultipleSourceSelection(hopId, entryId, selectedSources) {
    const hop = investigation.hops.find(h => h.id === hopId);
    const entry = hop.entries.find(e => e.id === entryId);
    
    // Store multiple source threads
    entry.multipleSourceThreads = selectedSources;
    entry.isConvergence = selectedSources.length > 1;
    
    if (selectedSources.length > 0) {
        // Calculate total available amount from all selected sources
        let totalAvailable = 0;
        selectedSources.forEach(sourceId => {
            const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
            const maxAmount = getMaxAssignableAmount(sourceId, currency, entry.id, entry.hopId);
            totalAvailable += maxAmount;
        });
        
        // Update max amount for input
        const amountInput = document.getElementById(`assignAmount_${hopId}_${entryId}`);
        if (amountInput) {
            amountInput.max = totalAvailable;
            
            // Auto-fill with total available if no amount set
            if (!entry.amount || parseFloat(entry.amount) === 0) {
                entry.amount = totalAvailable.toString();
                amountInput.value = totalAvailable;
            }
        }
        
        updateMultipleSourcePreview(hopId, entryId);
        updateFullNotationDisplay(hopId, entryId);
    }
    
    saveToStorage();
}

// Update Multiple Source Preview
function updateMultipleSourcePreview(hopId, entryId) {
    const hop = investigation.hops.find(h => h.id === hopId);
    const entry = hop.entries.find(e => e.id === entryId);
    const previewElement = document.getElementById(`multipleSourcePreview_${hopId}_${entryId}`);
    
    if (!previewElement || !entry.multipleSourceThreads || entry.multipleSourceThreads.length === 0) {
        if (previewElement) previewElement.innerHTML = '';
        return;
    }
    
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    let totalAvailable = 0;
    let sourceBreakdown = [];
    
    entry.multipleSourceThreads.forEach(sourceId => {
        const maxAmount = getMaxAssignableAmount(sourceId, currency, entry.id, entry.hopId); // Real-time calculation
        totalAvailable += maxAmount;
        sourceBreakdown.push(`${sourceId}: ${maxAmount.toLocaleString()} ${currency}`);
    });
    
    const amount = parseFloat(entry.amount) || 0;
    const remaining = totalAvailable - amount;
    const validation = validateMultipleSourceAssignment(entry);
    
    let previewHTML = `
        <div style="background: #f8f9fa; border: 1px solid #ddd; border-radius: 4px; padding: 10px; margin-top: 10px;">
            <div style="font-weight: bold; margin-bottom: 8px; color: #2c3e50;">
                ${entry.multipleSourceThreads.length > 1 ? 'Multiple Source Convergence:' : 'Source Selection:'}
            </div>
            ${sourceBreakdown.map(source => `<div style="font-size: 11px; color: #666; margin-bottom: 2px;"> ${source}</div>`).join('')}
            <div style="margin-top: 8px; font-weight: bold; padding-top: 8px; border-top: 1px solid #ddd;">
                Total Available: ${totalAvailable.toLocaleString()} ${currency}
            </div>
            ${amount > 0 ? `
                <div style="color: ${validation.valid ? '#27ae60' : '#e74c3c'}; margin-top: 5px;">
                    ${validation.valid ? '' : ''} Assigning: ${amount.toLocaleString()} ${currency}
                    ${validation.valid && remaining > 0 ? ` (${remaining.toLocaleString()} remaining)` : ''}
                    ${!validation.valid ? `<br><small>${validation.error}</small>` : ''}
                </div>
            ` : ''}
        </div>
    `;
    
    previewElement.innerHTML = previewHTML;
}

// Enhanced Source Selection UI for Commingling
function renderEnhancedSourceSelection(entry) {
    const availableSourceThreads = getAvailableSourcesForHop(entry.hopNumber, null);
    
    // If only one source available, use single selection
    if (availableSourceThreads.length <= 1) {
        const sourceOptions = availableSourceThreads.map(source => 
            `<option value="${source.threadId}" ${entry.sourceThreadId === source.threadId ? 'selected' : ''}>
                ${source.displayText} - ${source.availableAmount.toLocaleString()} ${source.currency} available
            </option>`
        ).join('');
        
        return `
            <div class="form-group">
                <label>Source Thread Selection</label>
                <select id="sourceSelect_${entry.hopId}_${entry.id}" 
                        onchange="handleSourceSelection(${entry.hopId}, ${entry.id}, this.value)">
                    <option value="">Select source thread...</option>
                    ${sourceOptions}
                </select>
            </div>
        `;
    }
    
    // Multiple sources available - show checkboxes for commingling
    return `
        <div class="form-group">
            <label>Source Thread Selection (Multiple sources for commingling)</label>
            <div style="background: #f8f9fa; border: 1px solid #ddd; border-radius: 4px; padding: 15px;">
                <div style="margin-bottom: 10px; font-weight: bold;">Select one or more source threads:</div>
                ${availableSourceThreads.map(source => `
                    <label style="display: block; margin: 8px 0; cursor: pointer;">
                        <input type="checkbox" 
                               value="${source.threadId}" 
                               ${entry.multipleSourceThreads && entry.multipleSourceThreads.includes(source.threadId) ? 'checked' : ''}
                               onchange="updateMultipleSourceSelection(${entry.hopId}, ${entry.id})"> 
                        ${source.displayText} - ${source.availableAmount.toLocaleString()} ${source.currency} available
                    </label>
                `).join('')}
            </div>
            <div id="multipleSourcePreview_${entry.hopId}_${entry.id}"></div>
        </div>
    `;
}

// Update Multiple Source Selection
// REPLACE YOUR updateMultipleSourceSelection FUNCTION WITH THIS FIXED VERSION

function updateMultipleSourceSelection(hopId, entryId) {
    const checkboxes = document.querySelectorAll(`input[type="checkbox"][onchange*="${hopId}, ${entryId}"]`);
    const selectedSources = Array.from(checkboxes)
        .filter(cb => cb.checked)
        .map(cb => cb.value);
    
    const hop = investigation.hops.find(h => h.id === hopId);
    const entry = hop.entries.find(e => e.id === entryId);
    
    // Store multiple source threads
    entry.multipleSourceThreads = selectedSources;
    entry.isConvergence = selectedSources.length > 1;
    
    // Clear single source if multiple are selected
    if (selectedSources.length > 1) {
        entry.sourceThreadId = '';
    } else if (selectedSources.length === 1) {
        entry.sourceThreadId = selectedSources[0];
    }
    
    if (selectedSources.length > 0) {
        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
        
        // Initialize individual assignments for newly selected sources
        if (!entry.individualSourceAssignments) {
            entry.individualSourceAssignments = {};
        }
        
        // Add any new sources with 0 assignment
        selectedSources.forEach(sourceId => {
            if (!(sourceId in entry.individualSourceAssignments)) {
                entry.individualSourceAssignments[sourceId] = 0;
            }
        });
        
        // Remove any unselected sources
        Object.keys(entry.individualSourceAssignments).forEach(sourceId => {
            if (!selectedSources.includes(sourceId)) {
                delete entry.individualSourceAssignments[sourceId];
            }
        });
        
        // Calculate total available and assigned amounts
        let totalAvailable = 0;
        let totalAssigned = 0;
        
        selectedSources.forEach(sourceId => {
            const maxAmount = getMaxAssignableAmount(sourceId, currency, entry.id, entry.hopId);
            totalAvailable += maxAmount;
            totalAssigned += entry.individualSourceAssignments[sourceId] || 0;
        });
        
        console.log(`Total available from ${selectedSources.length} sources: ${totalAvailable} ${currency}`);
        console.log(`Total assigned: ${totalAssigned} ${currency}`);
        
        // Update main amount field with total assigned
        entry.amount = totalAssigned.toString();
        
        // Update max amount for input
        const amountInput = document.getElementById(`assignAmount_${hopId}_${entryId}`);
        if (amountInput) {
            amountInput.max = totalAvailable;
            amountInput.value = totalAssigned;
        }
        
        // AUTO-GENERATE NOTATION FROM MULTIPLE SOURCE THREADS
        autoGenerateNotationFromMultipleSources(hopId, entryId, selectedSources);
        
        // Show the granular control interface immediately
        updateMultipleSourcePreview(hopId, entryId);
        updateFullNotationDisplayMultiple(hopId, entryId);
    } else {
        // No sources selected - clear everything
        const amountInput = document.getElementById(`assignAmount_${hopId}_${entryId}`);
        if (amountInput) {
            amountInput.max = 0;
            amountInput.value = '';
        }
        entry.amount = '';
        entry.multipleSourceThreads = [];
        entry.isConvergence = false;
        entry.sourceThreadId = '';
        entry.individualSourceAssignments = {};
        
        // Clear notation fields
        clearNotationFields(hopId, entryId);
        
        // Clear the preview
        const previewElement = document.getElementById(`multipleSourcePreview_${hopId}_${entryId}`);
        if (previewElement) {
            previewElement.innerHTML = '';
        }
    }
    
    saveToStorage();
    // Don't re-render the entire hop list - this causes entries to collapse while user is working
    // Just update the preview which is sufficient for the user to continue working
    // renderHops();
}
// ALSO ADD THIS NEW FUNCTION TO PROPERLY VALIDATE MULTIPLE SOURCE ASSIGNMENTS

function validateMultipleSourceAssignment(entry) {
    if (!entry.multipleSourceThreads || entry.multipleSourceThreads.length === 0) {
        return { valid: false, error: 'No source threads selected' };
    }
    
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    const amount = parseFloat(entry.amount);
    
    if (isNaN(amount) || amount <= 0) {
        return { valid: false, error: 'Amount must be a positive number' };
    }
    
    // Calculate total available from all selected sources using REAL-TIME calculation
    let totalAvailable = 0;
    entry.multipleSourceThreads.forEach(sourceId => {
        totalAvailable += getMaxAssignableAmount(sourceId, currency);
    });
    
    if (amount > totalAvailable) {
        return { 
            valid: false, 
            error: `Amount ${amount.toLocaleString()} exceeds total available ${totalAvailable.toLocaleString()} ${currency}` 
        };
    }
    
    return { valid: true, totalAvailable: totalAvailable };
}

// UPDATE YOUR updateMultipleSourcePreview FUNCTION WITH THIS IMPROVED VERSION

function updateMultipleSourcePreview(hopId, entryId) {
    const hop = investigation.hops.find(h => h.id === hopId);
    const entry = hop.entries.find(e => e.id === entryId);
    const previewElement = document.getElementById(`multipleSourcePreview_${hopId}_${entryId}`);
    
    if (!previewElement || !entry.multipleSourceThreads || entry.multipleSourceThreads.length === 0) {
        if (previewElement) previewElement.innerHTML = '';
        return;
    }
    
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    
    // Initialize individual assignments if not exists
    if (!entry.individualSourceAssignments) {
        entry.individualSourceAssignments = {};
        entry.multipleSourceThreads.forEach(sourceId => {
            entry.individualSourceAssignments[sourceId] = 0;
        });
    }
    
    let totalAvailable = 0;
    let totalAssigned = 0;
    let sourceInputsHTML = '';
    
    entry.multipleSourceThreads.forEach(sourceId => {
        const maxAmount = getMaxAssignableAmount(sourceId, currency, entry.id, entry.hopId);
        const assignedAmount = entry.individualSourceAssignments[sourceId] || 0;
        const remaining = maxAmount - assignedAmount;
        
        totalAvailable += maxAmount;
        totalAssigned += assignedAmount;
        
        sourceInputsHTML += `
            <div style="display: flex; align-items: center; gap: 10px; margin: 8px 0; padding: 8px; background: white; border-radius: 4px; border: 1px solid #ddd;">
                <div style="flex: 1; font-weight: bold; color: #2c3e50;">
                    ${sourceId}
                </div>
                <div style="display: flex; align-items: center; gap: 5px;">
                    <input type="number" 
                           step="0.01" 
                           min="0" 
                           max="${maxAmount}"
                           value="${assignedAmount}"
                           style="width: 100px; padding: 4px;"
                           onchange="updateIndividualSourceAssignment(${hopId}, ${entryId}, '${sourceId}', this.value)"
                           placeholder="0">
                    <span style="font-size: 11px; color: #666;">/ ${maxAmount.toLocaleString()}</span>
                    <button type="button" 
                            onclick="assignMaxToIndividualSource(${hopId}, ${entryId}, '${sourceId}')"
                            style="padding: 2px 6px; font-size: 11px; background: #95a5a6; color: white; border: none; border-radius: 3px; cursor: pointer;">
                        Max
                    </button>
                </div>
                <div style="font-size: 11px; color: ${remaining === 0 ? '#e74c3c' : '#27ae60'};">
                    ${remaining === 0 ? 'DEPLETED' : `${remaining.toLocaleString()} left`}
                </div>
            </div>
        `;
    });
    
    // Update main amount field with total assigned
    entry.amount = totalAssigned.toString();
    const mainAmountInput = document.getElementById(`assignAmount_${hopId}_${entryId}`);
    if (mainAmountInput) {
        mainAmountInput.value = totalAssigned;
    }
    
    const isValid = totalAssigned <= totalAvailable && totalAssigned > 0;
    
    let previewHTML = `
        <div style="background: #f8f9fa; border: 1px solid #ddd; border-radius: 4px; padding: 15px; margin-top: 10px;">
            <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                <div style="font-weight: bold; color: #2c3e50;">
                    Individual Source Assignments:
                </div>
                <div style="display: flex; gap: 5px;">
                    <button type="button" 
                            onclick="distributeProportionally(${hopId}, ${entryId})"
                            style="padding: 4px 8px; font-size: 11px; background: #3498db; color: white; border: none; border-radius: 3px; cursor: pointer;">
                        Distribute Proportionally
                    </button>
                    <button type="button" 
                            onclick="depleteInOrder(${hopId}, ${entryId})"
                            style="padding: 4px 8px; font-size: 11px; background: #e67e22; color: white; border: none; border-radius: 3px; cursor: pointer;">
                        Deplete In Order
                    </button>
                    <button type="button" 
                            onclick="clearAllAssignments(${hopId}, ${entryId})"
                            style="padding: 4px 8px; font-size: 11px; background: #95a5a6; color: white; border: none; border-radius: 3px; cursor: pointer;">
                        Clear All
                    </button>
                </div>
            </div>
            
            ${sourceInputsHTML}
            
            <div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid #ddd;">
                <div style="display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <strong>Total Available:</strong> ${totalAvailable.toLocaleString()} ${currency}
                    </div>
                    <div style="color: ${isValid ? '#27ae60' : '#e74c3c'}; font-weight: bold;">
                        <strong>Total Assigned:</strong> ${totalAssigned.toLocaleString()} ${currency}
                        ${!isValid && totalAssigned > totalAvailable ? ' (EXCEEDS AVAILABLE!)' : ''}
                        ${totalAssigned === 0 ? ' (No assignments)' : ''}
                    </div>
                </div>
            </div>
        </div>
    `;
    
    previewElement.innerHTML = previewHTML;
}
// Enhanced Full Notation Display for Multiple Sources
function updateFullNotationDisplayMultiple(hopId, entryId) {
    const hop = investigation.hops.find(h => h.id === hopId);
    const entry = hop.entries.find(e => e.id === entryId);
    const previewElement = document.getElementById(`notationPreview_${hopId}_${entryId}`);
    
    if (!previewElement) return;
    
    const amount = parseFloat(entry.amount);
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    
    if (entry.multipleSourceThreads && entry.multipleSourceThreads.length > 1) {
        // Multiple sources - show convergence notation
        const sourceNotations = entry.multipleSourceThreads.map(sourceId => {
            const sourceAmount = getMaxAssignableAmount(sourceId, currency);
            return `${sourceId}(${formatNumber(sourceAmount)})`;
        });
        
        const displayNotation = `${sourceNotations.join(' + ')}  ${entry.notation}`;
        const summaryNotation = `${entry.notation} (${formatNumber(amount)} ${currency} from ${entry.multipleSourceThreads.length} sources)`;
        
        // Update entry with generated notations
        entry.displayNotation = displayNotation;
        entry.summaryNotation = summaryNotation;
        entry.sourceChain = entry.multipleSourceThreads.map(sourceId => ({
            sourceNotation: sourceId,
            amount: getMaxAssignableAmount(sourceId, currency),
            currency: currency,
            percentage: (getMaxAssignableAmount(sourceId, currency) / amount) * 100
        }));
        
        previewElement.innerHTML = `
            <div style="margin-bottom: 8px;"><strong>Display:</strong> ${displayNotation}</div>
            <div style="margin-bottom: 8px;"><strong>Summary:</strong> ${summaryNotation}</div>
            <div style="font-size: 11px; color: #666;">Convergence: ${entry.multipleSourceThreads.join(' + ')}  ${entry.notation}</div>
        `;
    } else if (entry.sourceThreadId) {
        // Single source - use existing logic
        updateFullNotationDisplay(hopId, entryId);
    } else {
        previewElement.innerHTML = 'Select source(s) and complete notation to generate full display';
    }
}
// =================================
// PHASE 1: ENHANCED DATA STRUCTURES
// =================================
        // STEP 4.1: REPLACE YOUR EXISTING entryTypes OBJECT WITH THIS:

const entryTypes = {
    'trace': 'Trace - Continue following funds',
    'writeoff': 'Write-off - Abandon this path',
    'cold_storage': 'Cold Storage - Funds held (BLUE wallet)'
};

        const walletTypes = {
            'red': 'RED - Victim Facing',
            'pink': 'PINK - Dividend/Deception',
            'yellow': 'YELLOW - Hub/Convergence',
            'orange': 'ORANGE - Bitcoin Change',
            'brown': 'BROWN - Asset Conversion',
            'black': 'BLACK - Intermediary',
            'blue': 'BLUE - Cold Storage',
            'purple': 'PURPLE - Exchange Deposit',
            'gray': 'GRAY - Obfuscated/Diluted',
            'green': 'GREEN - Victim Owned'
        };

        const currencies = {
            'USD': { name: 'US Dollar' },
            'BTC': { name: 'Bitcoin' },
            'ETH': { name: 'Ethereum' },
            'USDT': { name: 'Tether' },
            'USDC': { name: 'USD Coin' },
            'TRX': { name: 'TRON' },
            'SOL': { name: 'Solana' },
            'ADA': { name: 'Cardano' },
            'DAI': { name: 'DAI' },
            'BNB': { name: 'BNB' },
            'CUSTOM': { name: 'Custom Currency' }
        };

        const timezones = {
            'UTC': 'UTC',
            'LOCAL': 'Local',
            'EST': 'EST',
            'CST': 'CST',
            'MST': 'MST',
            'PST': 'PST',
            'GMT': 'GMT',
            'CET': 'CET',
            'JST': 'JST'
        };

        const writeoffCategories = {
            'dust': 'Dust - Below threshold',
            'dilution': 'Dilution - Too diluted to trace',
            'obfuscation': 'Obfuscation - Privacy services',
            'operational': 'Operational - Resource constraints'
        };

        // Format number with commas while preserving full decimal precision
        function formatNumber(value) {
            if (!value || isNaN(value)) return '0';
            
            const parts = value.toString().split('.');
            const integerPart = parts[0].replace(/\B(?=(\d{3})+(?!\d))/g, ',');
            
            if (parts.length === 2) {
                return integerPart + '.' + parts[1];
            }
            return integerPart;
        }

        // Toggle file dropdown menu
        function toggleFileMenu() {
            const dropdown = document.getElementById('fileDropdown');
            if (dropdown) {
                dropdown.style.display = dropdown.style.display === 'none' ? 'block' : 'none';
            }
        }

        // Close file dropdown when clicking outside - will be initialized after DOM loads

        // Security Status Display Function
        function displaySecurityStatus() {
            const protocol = window.location.protocol;
            const container = document.querySelector('.container');
            
            if (protocol === 'file:') {
                // Add warning banner for file:// protocol
                const warningBanner = document.createElement('div');
                warningBanner.style.cssText = `
                    background: #fff3cd;
                    border: 2px solid #ffc107;
                    color: #856404;
                    padding: 15px;
                    margin-bottom: 20px;
                    border-radius: 8px;
                    display: flex;
                    align-items: center;
                    gap: 10px;
                `;
                warningBanner.innerHTML = `
                    <span style="font-size: 24px;"></span>
                    <div>
                        <strong>Limited Functionality - File Protocol Detected</strong><br>
                        <small>You're running B.A.T.S. from a local file. For full functionality including custom save locations and API features, please serve this file over HTTPS. 
                        <a href="training.html#deployment" target="_blank" style="color: #856404; text-decoration: underline;">Learn more about deployment options</a></small>
                    </div>
                `;
                container.insertBefore(warningBanner, container.firstChild);
            } else if (protocol === 'https:') {
                // Add secure connection indicator
                const secureIndicator = document.createElement('div');
                secureIndicator.style.cssText = `
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    background: #d4edda;
                    border: 1px solid #c3e6cb;
                    color: #155724;
                    padding: 8px 15px;
                    border-radius: 6px;
                    font-size: 12px;
                    display: flex;
                    align-items: center;
                    gap: 5px;
                    z-index: 1000;
                    opacity: 0.9;
                `;
                secureIndicator.innerHTML = `
                    <span style="color: #28a745;"></span> Secure Connection
                `;
                document.body.appendChild(secureIndicator);
                
                // Auto-hide after 5 seconds
                setTimeout(() => {
                    secureIndicator.style.transition = 'opacity 0.5s';
                    secureIndicator.style.opacity = '0';
                    setTimeout(() => secureIndicator.remove(), 500);
                }, 5000);
            }
        }

        // Make sure these functions are globally accessible
        window.switchTab = switchTab;
        window.toggleFileMenu = toggleFileMenu;

        document.addEventListener('DOMContentLoaded', function() {
    console.log(' Initializing B.A.T.S. application...');
    
    // Display security status
    displaySecurityStatus();
    
    try {
        // Enhanced structure initialization
        initializeCompleteIntegration();
        
        // Build thread tracking index
        buildAvailableThreadsIndex();
        
        // Original initialization
        loadFromStorage();
        renderAll();
        updateWorkflowSteps();
        setupConversionModalListeners();
        
        // Show Victims tab by default to avoid white screen
        switchTab('victims');
        
        // Check onboarding state on load - show welcome for new users
        setTimeout(() => {
            checkOnboardingState();
            
            // If this is a new investigation, show welcome screen
            if (!investigation.caseId && !investigation.victims?.length) {
                showWelcomeScreen();
            }
        }, 100);
        
        // Setup event listeners for case info with better error handling
        const caseIdInput = document.getElementById('caseId');
        const investigatorInput = document.getElementById('investigator');
        const caseTypeInput = document.getElementById('caseType');
        
        if (caseIdInput) {
            caseIdInput.addEventListener('change', function() {
                try {
                    investigation.caseId = this.value;
                    saveToStorage();
                } catch (error) {
                    console.error('Error saving case ID:', error);
                }
            });
        }
        if (investigatorInput) {
            investigatorInput.addEventListener('change', function() {
                try {
                    investigation.investigator = this.value;
                    saveToStorage();
                } catch (error) {
                    console.error('Error saving investigator:', error);
                }
            });
        }
        if (caseTypeInput) {
            caseTypeInput.addEventListener('change', function() {
                try {
                    investigation.caseType = this.value;
                    saveToStorage();
                } catch (error) {
                    console.error('Error saving case type:', error);
                }
            });
        }
        
        // Add case synopsis handler
        const caseSynopsisInput = document.getElementById('caseSynopsis');
        if (caseSynopsisInput) {
            caseSynopsisInput.addEventListener('change', function() {
                try {
                    investigation.caseSynopsis = this.value;
                    saveToStorage();
                } catch (error) {
                    console.error('Error saving case synopsis:', error);
                }
            });
        }
        
        // Close file dropdown when clicking outside
        document.addEventListener('click', function(event) {
            const dropdown = document.getElementById('fileDropdown');
            const fileButton = event.target.closest('button[onclick="toggleFileMenu()"]');
            
            if (dropdown && !fileButton && !dropdown.contains(event.target)) {
                dropdown.style.display = 'none';
            }
        });
        
        console.log(' B.A.T.S. application initialized successfully');
        
    } catch (error) {
        console.error(' Error initializing B.A.T.S. application:', error);
        alert('There was an error initializing the application. Please refresh the page and try again.');
    }
});
function updateFormFieldsFromInvestigation() {
    console.log('Updating form fields from investigation data...');
    
    // Update the form fields
    const caseIdField = document.getElementById('caseId');
    const investigatorField = document.getElementById('investigator');
    const caseTypeField = document.getElementById('caseType');
    const caseSynopsisField = document.getElementById('caseSynopsis');
    
    if (caseIdField) {
        caseIdField.value = investigation.caseId || '';
    }
    if (investigatorField) {
        investigatorField.value = investigation.investigator || '';
    }
    if (caseTypeField) {
        caseTypeField.value = investigation.caseType || '';
    }
    if (caseSynopsisField) {
        caseSynopsisField.value = investigation.caseSynopsis || '';
    }
    
    
    console.log('Form fields updated');
}

        function updateWorkflowSteps() {
            // Reset all steps
            document.querySelectorAll('.step-item').forEach(step => {
                step.classList.remove('completed', 'active');
            });

            // Step 1: Investigation Setup
            const step1 = document.getElementById('step1');
            if (investigation.caseId && investigation.investigator && investigation.caseType) {
                step1.classList.add('completed');
            } else {
                step1.classList.add('active');
                return;
            }

            // Step 2: Add Victims
            const step2 = document.getElementById('step2');
            if (investigation.victims.length > 0) {
                step2.classList.add('completed');
            } else {
                step2.classList.add('active');
                return;
            }

            // Step 3: Confirm Root Total
            const step3 = document.getElementById('step3');
            if (investigation.rootTotalConfirmed) {
                step3.classList.add('completed');
            } else {
                step3.classList.add('active');
                return;
            }

            // Step 4: Document Traces
            const step4 = document.getElementById('step4');
            if (investigation.hops.length > 0) {
                step4.classList.add('completed');
            }
            step4.classList.add('active');

            // Steps 5 & 6 are always available once root total is confirmed
            if (investigation.rootTotalConfirmed) {
                document.getElementById('step5').classList.add('active');
                document.getElementById('step6').classList.add('active');
            }

            // Show/hide generate root total section
            updateGenerateRootSection();
        }

        function updateGenerateRootSection() {
            const generateSection = document.getElementById('generateRootSection');
            const hasTransactions = investigation.victims.some(v => 
                v.transactions.some(t => t.amount && parseFloat(t.amount) > 0)
            );
            
            if (hasTransactions && !investigation.rootTotalConfirmed) {
                generateSection.style.display = 'block';
                
                // Check if file has been saved to show appropriate button
                if (savedFilePath) {
                    document.getElementById('saveRequiredMessage').style.display = 'none';
                    document.getElementById('generateRootBtn').style.display = 'block';
                } else {
                    document.getElementById('saveRequiredMessage').style.display = 'block';
                    document.getElementById('generateRootBtn').style.display = 'none';
                }
            } else {
                generateSection.style.display = 'none';
            }
        }

        function switchWalletIndex(indexType) {
            // Hide all wallet index content
            document.querySelectorAll('.wallet-index-content').forEach(content => {
                content.style.display = 'none';
            });
            
            // Show selected index
            document.getElementById(indexType + 'WalletIndexContent').style.display = 'block';
            
            // Render the appropriate index
            if (indexType === 'universal') {
                renderUniversalWalletIndex();
            } else if (indexType === 'red') {
                renderRedWalletIndex();
            } else if (indexType === 'purple') {
                renderPurpleWalletIndex();
            } else if (indexType === 'blue') {
                renderBlueWalletIndex();
            }
        }

        function switchTab(tabName) {
            // First, ensure all tabs are visible (in case they were hidden)
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.style.display = '';
                tab.classList.remove('active');
            });
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });

            document.getElementById(tabName + '-tab').classList.add('active');
            
            // Find and activate the corresponding nav tab
            const navTab = document.querySelector(`[onclick="switchTab('${tabName}')"]`);
            if (navTab) {
                navTab.classList.add('active');
            }

            if (tabName === 'summary') {
                renderSummary();
            } else if (tabName === 'walletindexes') {
                // Render all wallet indexes
                renderUniversalWalletIndex();
                renderRedWalletIndex();
                renderPurpleWalletIndex();
                renderBlueWalletIndex();
            } else if (tabName === 'victims') {
                renderVictims();
            } else if (tabName === 'casedetails') {
                updateCaseStats();
            } else if (tabName === 'flowdiagram') {
                // Flow diagram will be generated on demand
                // Check if we have data to visualize
                if (investigation.hops && investigation.hops.length > 0) {
                    document.getElementById('flowDiagramControls').style.display = 'block';
                } else {
                    document.getElementById('flowDiagramControls').style.display = 'none';
                    document.getElementById('flowDiagramSVG').innerHTML = '<text x="50%" y="50%" text-anchor="middle" fill="#999">No trace data available. Complete at least one hop to generate flow diagram.</text>';
                }
            }
            
            // Update breadcrumbs
            updateBreadcrumbs();
        }

        function addVictim() {
            const victimId = investigation.victims.length + 1;
            const victim = {
                id: victimId,
                transactions: [{
                    id: 1,
                    amount: '',
                    currency: 'USD',
                    customCurrency: '',
                    receivingWallet: '',
                    datetime: '',
                    timezone: 'UTC',
                    notes: ''
                }]
            };
            investigation.victims.push(victim);
            renderVictims();
            saveToStorage();
            updateWorkflowSteps();
        }

        function addTransaction(victimId) {
            const victim = investigation.victims.find(v => v.id === victimId);
            const transactionId = victim.transactions.length + 1;
            victim.transactions.push({
                id: transactionId,
                txHash: '',
                amount: '',
                currency: 'USD',
                customCurrency: '',
                receivingWallet: '',
                datetime: '',
                timezone: 'UTC',
                notes: ''
            });
            renderVictims();
            saveToStorage();
            updateWorkflowSteps();
        }

        function sortTransactionsChronologically() {
            // Sort all transactions across all victims by datetime
            investigation.victims.forEach(victim => {
                // Sort this victim's transactions by datetime
                victim.transactions.sort((a, b) => {
                    // Handle empty dates - put them at the end
                    if (!a.datetime && !b.datetime) return 0;
                    if (!a.datetime) return 1;
                    if (!b.datetime) return -1;
                    
                    // Convert to comparable dates considering timezone
                    const dateA = new Date(a.datetime + ' ' + (a.timezone || 'UTC'));
                    const dateB = new Date(b.datetime + ' ' + (b.timezone || 'UTC'));
                    
                    return dateA - dateB;
                });
                
                // Re-assign transaction IDs based on new order
                victim.transactions.forEach((transaction, index) => {
                    transaction.id = index + 1;
                });
            });
            
            // Save the reordered data
            saveToStorage();
        }
        
        function fixVictimTransactionOrder(victimId) {
            const victim = investigation.victims.find(v => v.id === victimId);
            if (!victim) return;
            
            // Count transactions with dates
            const transactionsWithDates = victim.transactions.filter(t => t.datetime && t.datetime.trim() !== '').length;
            const totalTransactions = victim.transactions.length;
            
            if (transactionsWithDates === 0) {
                alert('No transactions have dates. Please add dates to transactions before sorting.');
                return;
            }
            
            if (transactionsWithDates < totalTransactions) {
                if (!confirm(`${totalTransactions - transactionsWithDates} transaction(s) are missing dates and will be placed at the end. Continue?`)) {
                    return;
                }
            }
            
            // Save undo state
            saveUndoState(`Fix transaction order for Victim ${victimId}`);
            
            // Sort this victim's transactions by datetime
            victim.transactions.sort((a, b) => {
                // Handle empty dates - put them at the end
                if (!a.datetime && !b.datetime) return 0;
                if (!a.datetime) return 1;
                if (!b.datetime) return -1;
                
                // Convert to UTC timestamps for accurate comparison
                const timestampA = convertToUTC(a.datetime, a.timezone || 'UTC');
                const timestampB = convertToUTC(b.datetime, b.timezone || 'UTC');
                
                return timestampA - timestampB;
            });
            
            // Re-assign transaction IDs based on new order
            victim.transactions.forEach((transaction, index) => {
                transaction.id = index + 1;
            });
            
            // If root total was confirmed, we need to rebuild indexes
            if (investigation.rootTotalConfirmed) {
                buildUniversalWalletIndex();
                buildRedWalletIndex();
                buildAvailableThreadsIndex();
            }
            
            // Re-render
            renderVictims();
            saveToStorage();
            updateWorkflowSteps();
            
            alert(` Transaction order fixed for Victim ${victimId}.\n\nTransactions have been renumbered in chronological order (T1, T2, T3, etc.).`);
        }

        function renderVictims() {
    const container = document.getElementById('victimsList');
    container.innerHTML = '';
    
    // Show/hide instructions based on victim count
    const instructionsDiv = document.getElementById('victimInstructions');
    if (instructionsDiv) {
        if (investigation.victims.length > 0) {
            instructionsDiv.style.display = 'none';
        } else {
            instructionsDiv.style.display = 'block';
        }
    }
    
    // First, sort all transactions chronologically
    sortTransactionsChronologically();

    investigation.victims.forEach(victim => {
        const victimDiv = document.createElement('div');
        victimDiv.className = 'trace-entry';
        
        // Check for chronology errors in this victim's transactions
        const chronologyError = validateTransactionChronology(victim);
        
        // Check if victim is completed (minimized)
        const isMinimized = victim.isCompleted || false;
        
        // Calculate victim total losses
        const totalLosses = victim.transactions.reduce((sum, t) => {
            return sum + (parseFloat(t.amount) || 0);
        }, 0);
        
        // Count valid transactions
        const validTransactions = victim.transactions.filter(t => 
            parseFloat(t.amount) > 0 && t.receivingWallet && t.receivingWallet.trim() !== ''
        ).length;
        
        victimDiv.innerHTML = `
            <div class="trace-header" style="background: ${isMinimized ? '#e8f4f8' : '#f8f9fa'};">
                <h3>Victim ${victim.id} ${isMinimized ? `- ${validTransactions} transactions, Total: ${formatNumber(totalLosses)} ${victim.transactions[0]?.currency || 'USD'}` : ''}</h3>
                <div>
                    ${!isMinimized ? `<button class="btn btn-success" onclick="completeVictim(${victim.id})" 
                        ${validTransactions === 0 ? 'disabled' : ''} 
                        title="${validTransactions === 0 ? 'Add at least one valid transaction first' : 'Complete and minimize this victim'}">
                         Complete
                    </button>` : 
                    `<button class="btn btn-secondary" onclick="reopenVictim(${victim.id})">
                         Edit
                    </button>`}
                    <button class="btn btn-danger" onclick="removeVictim(${victim.id})">Remove</button>
                </div>
            </div>
            ${!isMinimized ? `
                ${chronologyError ? `
                    <div style="background: #f8d7da; color: #721c24; padding: 15px; margin: 10px 0; border-radius: 4px; border: 1px solid #f5c6cb;">
                        <div style="display: flex; justify-content: space-between; align-items: start;">
                            <div style="flex: 1;">
                                <strong> Chronological Order Warning:</strong><br>
                                ${chronologyError.replace(/\n/g, '<br>')}<br><br>
                                <em style="font-size: 12px;">Transactions must be numbered in chronological order for PIFO (Proceeds In First Out) compliance.</em>
                            </div>
                            <button class="btn btn-sm btn-warning" onclick="fixVictimTransactionOrder(${victim.id})" 
                                    style="background: #f39c12; color: white; white-space: nowrap; margin-left: 15px;">
                                 Fix Order
                            </button>
                        </div>
                    </div>
                ` : ''}
                ${victim.transactions.map(transaction => {
                const hasAmount = parseFloat(transaction.amount) > 0;
                const hasWallet = transaction.receivingWallet && transaction.receivingWallet.trim() !== '';
                const isIncomplete = hasAmount && !hasWallet;
                
                return `
                    <div style="background: ${isIncomplete ? '#fff3cd' : 'white'}; padding: 15px; border-radius: 8px; margin-bottom: 10px; border: ${isIncomplete ? '2px solid #ffc107' : '1px solid #e8f0fe'};">
                        ${isIncomplete ? '<div style="color: #856404; font-weight: bold; margin-bottom: 10px;"> Missing receiving wallet address!</div>' : ''}
                        <div class="trace-notation">V${victim.id}-T${transaction.id}</div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 15px; margin-top: 10px;">
                            <div class="form-group" style="grid-column: span 2; background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%); padding: 20px; border-radius: 8px; border: 2px solid #2196f3; margin-bottom: 15px;">
                                <label style="font-weight: bold; color: #0d47a1; font-size: 16px;"> Transaction Hash (Start Here)</label>
                                <div style="display: flex; gap: 10px; align-items: center;">
                                    <input type="text" 
                                           id="txHash_victim_${victim.id}_${transaction.id}"
                                           value="${transaction.txHash || ''}" 
                                           placeholder="Paste transaction hash to auto-fill details"
                                           onchange="updateTransaction(${victim.id}, ${transaction.id}, 'txHash', this.value)"
                                           style="flex: 1; font-size: 16px; padding: 14px; border: 2px solid #2196f3;">
                                    <button type="button" class="btn btn-sm btn-primary" 
                                            onclick="lookupVictimTransaction(${victim.id}, ${transaction.id})"
                                            style="padding: 10px 20px; font-size: 16px; background: #2196f3;">
                                         Lookup
                                    </button>
                                </div>
                                <div style="font-size: 12px; color: #0d47a1; margin-top: 8px;">Paste the transaction hash and click Lookup to automatically fetch transaction details</div>
                            </div>
                            <div class="form-group">
                                <label>Amount</label>
                                <input type="number" 
                                       id="amount_victim_${victim.id}_${transaction.id}"
                                       step="${getCurrencyStep(transaction.currency)}" 
                                       value="${transaction.amount}" 
                                       onchange="updateTransaction(${victim.id}, ${transaction.id}, 'amount', this.value)"
                                       title="${currencies[transaction.currency]?.name || transaction.currency} supports ${getCurrencyDecimals(transaction.currency)} decimal places">
                            </div>
                            <div class="form-group">
                                <label>Currency</label>
                                <select id="currency_victim_${victim.id}_${transaction.id}"
                                        onchange="updateTransactionCurrency(${victim.id}, ${transaction.id}, this.value)">
                                    ${Object.entries(currencies).map(([key, currency]) => 
                                        `<option value="${key}" ${transaction.currency === key ? 'selected' : ''}>${currency.name}</option>`
                                    ).join('')}
                                </select>
                            </div>
                            <div class="form-group" style="grid-column: span 2;">
                                <label style="color: ${isIncomplete ? '#dc3545' : 'inherit'}; font-weight: ${isIncomplete ? 'bold' : 'normal'};">
                                    Receiving Wallet Address (RED Wallet) ${isIncomplete ? '- REQUIRED' : ''}
                                </label>
                                <input type="text" 
                                       id="receivingWallet_victim_${victim.id}_${transaction.id}"
                                       value="${transaction.receivingWallet || ''}" 
                                       placeholder="Wallet address that received victim's funds"
                                       style="border-color: ${isIncomplete ? '#dc3545' : '#e8f0fe'};"
                                       onchange="updateTransaction(${victim.id}, ${transaction.id}, 'receivingWallet', this.value)">
                            </div>
                            <div class="form-group ${transaction.currency === 'CUSTOM' ? '' : 'custom-currency-input'}" 
                                 id="customCurrency_${victim.id}_${transaction.id}">
                                <label>Custom Currency Symbol</label>
                                <input type="text" value="${transaction.customCurrency || ''}" 
                                       placeholder="e.g., DOGE, SHIB"
                                       onchange="updateTransaction(${victim.id}, ${transaction.id}, 'customCurrency', this.value)">
                            </div>
                            <div class="form-group">
                                <label>Date & Time with Timezone</label>
                                <div class="datetime-timezone">
                                    <input type="datetime-local" 
                                           id="datetime_victim_${victim.id}_${transaction.id}"
                                           value="${transaction.datetime}" 
                                           onchange="updateTransaction(${victim.id}, ${transaction.id}, 'datetime', this.value)">
                                    <select id="timezone_victim_${victim.id}_${transaction.id}"
                                            onchange="updateTransaction(${victim.id}, ${transaction.id}, 'timezone', this.value)">
                                        ${Object.entries(timezones).map(([key, value]) => 
                                            `<option value="${key}" ${transaction.timezone === key ? 'selected' : ''}>${value}</option>`
                                        ).join('')}
                                    </select>
                                </div>
                            </div>
                            <div class="form-group" style="grid-column: span 2;">
                                <label>Notes</label>
                                <input type="text" value="${transaction.notes}" 
                                       placeholder="Payment description, method, etc."
                                       onchange="updateTransaction(${victim.id}, ${transaction.id}, 'notes', this.value)">
                            </div>
                        </div>
                    </div>
                `.trim();
            }).join('')}` : ''}
            ${!isMinimized ? `
                <button class="btn btn-add-transaction" onclick="addTransaction(${victim.id})">+ Add Transaction</button>
                <button class="btn btn-secondary" onclick="openBulkTransactionModal(${victim.id})"> Bulk Add Transactions</button>
            ` : `
                <div style="padding: 15px; background: white; border-radius: 6px; margin-top: 10px;">
                    <h4 style="margin-bottom: 10px; color: #2c3e50;">Transaction Summary:</h4>
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr style="background: #f8f9fa;">
                                <th style="padding: 8px; text-align: left; border: 1px solid #ddd;">V-T</th>
                                <th style="padding: 8px; text-align: left; border: 1px solid #ddd;">Date</th>
                                <th style="padding: 8px; text-align: right; border: 1px solid #ddd;">Amount</th>
                                <th style="padding: 8px; text-align: left; border: 1px solid #ddd;">Asset</th>
                            </tr>
                        </thead>
                        <tbody>
                            ${victim.transactions.filter(t => parseFloat(t.amount) > 0).map(transaction => `
                                <tr>
                                    <td style="padding: 8px; border: 1px solid #ddd;">V${victim.id}-T${transaction.id}</td>
                                    <td style="padding: 8px; border: 1px solid #ddd;">${transaction.datetime || 'N/A'}</td>
                                    <td style="padding: 8px; text-align: right; border: 1px solid #ddd;">${formatNumber(transaction.amount)}</td>
                                    <td style="padding: 8px; border: 1px solid #ddd;">${transaction.currency}</td>
                                </tr>
                            `).join('')}
                        </tbody>
                        <tfoot>
                            <tr style="background: #e8f4f8; font-weight: bold;">
                                <td colspan="2" style="padding: 8px; border: 1px solid #ddd;">Total Loss:</td>
                                <td style="padding: 8px; text-align: right; border: 1px solid #ddd;">${formatNumber(totalLosses)}</td>
                                <td style="padding: 8px; border: 1px solid #ddd;">${victim.transactions[0]?.currency || 'USD'}</td>
                            </tr>
                        </tfoot>
                    </table>
                </div>
            `}
        `;
        container.appendChild(victimDiv);
    });
    
    updateGenerateRootSection();
}

        function updateTransactionCurrency(victimId, transactionId, currency) {
            updateTransaction(victimId, transactionId, 'currency', currency);
            
            const customInput = document.getElementById(`customCurrency_${victimId}_${transactionId}`);
            if (currency === 'CUSTOM') {
                customInput.style.display = 'block';
                customInput.classList.remove('custom-currency-input');
            } else {
                customInput.style.display = 'none';
                customInput.classList.add('custom-currency-input');
            }
            
            // Update the amount input step based on new currency
            const amountInput = document.querySelector(`input[onchange*="updateTransaction(${victimId}, ${transactionId}, 'amount'"]`);
            if (amountInput) {
                amountInput.step = getCurrencyStep(currency);
                
                // Show currency info tooltip
                const decimals = getCurrencyDecimals(currency);
                amountInput.title = `${currencies[currency]?.name || currency} supports ${decimals} decimal places`;
            }
        }

        function generateRootTotal() {
    // Check if file has been saved
    if (!savedFilePath) {
        document.getElementById('saveRequiredMessage').style.display = 'block';
        document.getElementById('generateRootBtn').style.display = 'none';
        return;
    }
    
    // NEW VALIDATION: Check for missing wallet addresses before generating root total
    const missingWallets = [];
    investigation.victims.forEach(victim => {
        victim.transactions.forEach(transaction => {
            if (parseFloat(transaction.amount) > 0 && (!transaction.receivingWallet || transaction.receivingWallet.trim() === '')) {
                missingWallets.push(`V${victim.id}-T${transaction.id}`);
            }
        });
    });
    
    if (missingWallets.length > 0) {
        alert(` Cannot generate root total: Missing receiving wallet addresses for the following transactions:\n\n${missingWallets.join(', ')}\n\nPlease add receiving wallet addresses for all transactions with amounts before confirming your root total.`);
        return;
    }
    
    // Check chronological order for each victim
    const chronologyErrors = [];
    investigation.victims.forEach(victim => {
        const error = validateTransactionChronology(victim);
        if (error) {
            chronologyErrors.push(error);
        }
    });
    
    if (chronologyErrors.length > 0) {
        const shouldFix = confirm(` Transaction chronology errors detected!\n\n${chronologyErrors.join('\n\n')}\n\nTransactions must be in chronological order for PIFO compliance.\n\nWould you like to automatically fix the order for all victims?\n\nClick OK to reorder all transactions chronologically.\nClick Cancel to fix manually.`);
        
        if (shouldFix) {
            // Fix order for all victims with errors
            investigation.victims.forEach(victim => {
                const error = validateTransactionChronology(victim);
                if (error) {
                    fixVictimTransactionOrder(victim.id);
                }
            });
            
            // Try to confirm root total again
            setTimeout(() => confirmRootTotal(), 100);
            return;
        } else {
            return;
        }
    }
    
    const totalsByCurrency = {};
    
    // Calculate totals by currency
    investigation.victims.forEach(victim => {
        victim.transactions.forEach(transaction => {
            if (parseFloat(transaction.amount) > 0) {
                const currency = transaction.currency === 'CUSTOM' ? transaction.customCurrency : transaction.currency;
                if (!totalsByCurrency[currency]) {
                    totalsByCurrency[currency] = 0;
                }
                totalsByCurrency[currency] += parseFloat(transaction.amount);
            }
        });
    });
    
    if (Object.keys(totalsByCurrency).length === 0) {
        alert('Please add at least one victim transaction with an amount before generating root total.');
        return;
    }

    // Display totals by currency
    let totalDisplay = '';
    Object.entries(totalsByCurrency).forEach(([currency, amount]) => {
        totalDisplay += `<div style="font-size: 1.8rem; font-weight: bold; color: #27ae60; margin: 10px 0;">${amount.toLocaleString()} ${currency}</div>`;
    });
    
    document.getElementById('totalRootAmount').innerHTML = totalDisplay;
    
    // Add visual progress bars for root total
    let progressBars = '<div style="background: white; padding: 20px; border-radius: 8px; margin: 15px 0; box-shadow: 0 2px 8px rgba(0,0,0,0.1);">';
    progressBars += '<h4 style="margin-bottom: 15px; color: #2c3e50;"> Investigation Progress Overview</h4>';
    progressBars += '<p style="color: #666; margin-bottom: 15px; font-size: 14px;">These bars will track your progress as you trace funds through the investigation.</p>';
    
    Object.entries(totalsByCurrency).forEach(([currency, total]) => {
        progressBars += `
            <div style="margin-bottom: 20px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                    <strong style="font-size: 16px;">${currency}</strong>
                    <span style="font-size: 14px; color: #666;">
                        ${total.toLocaleString()} total
                    </span>
                </div>
                
                <!-- Progress Bar Preview -->
                <div style="position: relative; height: 35px; background: #f5f5f5; border-radius: 20px; overflow: hidden; box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);">
                    <!-- Starting state - all red (unaccounted) -->
                    <div style="position: absolute; left: 0; top: 0; height: 100%; width: 100%; background: #e74c3c;"
                         title="All funds currently unaccounted">
                    </div>
                    
                    <!-- Label -->
                    <div style="position: absolute; width: 100%; height: 100%; display: flex; align-items: center; justify-content: center; pointer-events: none;">
                        <span style="color: white; font-size: 12px; font-weight: bold; text-shadow: 1px 1px 2px rgba(0,0,0,0.3);">
                            100% Unaccounted
                        </span>
                    </div>
                </div>
                
                <!-- Legend Preview -->
                <div style="display: flex; gap: 20px; margin-top: 10px; font-size: 12px; flex-wrap: wrap;">
                    <span style="display: flex; align-items: center; gap: 5px;">
                        <span style="width: 14px; height: 14px; background: #27ae60; border-radius: 3px;"></span>
                        Will show traced funds
                    </span>
                    <span style="display: flex; align-items: center; gap: 5px;">
                        <span style="width: 14px; height: 14px; background: #9b59b6; border-radius: 3px;"></span>
                        Will show exchange/VASP
                    </span>
                    <span style="display: flex; align-items: center; gap: 5px;">
                        <span style="width: 14px; height: 14px; background: #3498db; border-radius: 3px;"></span>
                        Will show cold storage
                    </span>
                    <span style="display: flex; align-items: center; gap: 5px;">
                        <span style="width: 14px; height: 14px; background: #95a5a6; border-radius: 3px;"></span>
                        Will show write-offs
                    </span>
                </div>
            </div>
        `;
    });
    
    progressBars += '</div>';
    
    let breakdown = progressBars;
    breakdown += '<div style="background: #f8f9fa; padding: 20px; border-radius: 8px; margin: 15px 0; border: 1px solid #ddd;">';
    breakdown += '<h4 style="margin-bottom: 15px; color: #2c3e50;"> Transaction Breakdown by Currency:</h4>';
    
    investigation.victims.forEach(victim => {
        breakdown += `<div style="margin-bottom: 15px; padding: 10px; background: white; border-radius: 6px; border-left: 4px solid #3498db;">`;
        breakdown += `<div style="font-weight: bold; color: #2c3e50; margin-bottom: 8px;"> Victim ${victim.id}:</div>`;
        victim.transactions.forEach(transaction => {
            if (parseFloat(transaction.amount) > 0) {
                const currency = transaction.currency === 'CUSTOM' ? transaction.customCurrency : transaction.currency;
                const timeDisplay = transaction.datetime ? 
                    `${transaction.datetime} ${transaction.timezone}` : 
                    'No timestamp';
                breakdown += `<div style="margin-left: 20px; margin-bottom: 5px; color: #34495e;">`;
                breakdown += `<strong>V${victim.id}-T${transaction.id}:</strong> ${parseFloat(transaction.amount).toLocaleString()} ${currency}`;
                breakdown += `<br><small style="color: #7f8c8d;"> ${transaction.receivingWallet}</small>`;
                breakdown += `<br><small style="color: #7f8c8d;"> ${timeDisplay}</small>`;
                if (transaction.notes) {
                    breakdown += `<br><small style="color: #7f8c8d;"> ${transaction.notes}</small>`;
                }
                breakdown += `</div>`;
            }
        });
        breakdown += `</div>`;
    });
    breakdown += '</div>';
    
    document.getElementById('rootTotalBreakdown').innerHTML = breakdown;
    showModal('rootTotalModal');
}

        function confirmAndProceed() {
            try {
                console.log('Starting confirmAndProceed...');
                
                investigation.rootTotalConfirmed = true;
                
                // Store confirmed root totals by currency
                investigation.confirmedRootTotalsByCurrency = {};
                investigation.victims.forEach(victim => {
                    victim.transactions.forEach(transaction => {
                        if (parseFloat(transaction.amount) > 0) {
                            const currency = transaction.currency === 'CUSTOM' ? transaction.customCurrency : transaction.currency;
                            if (!investigation.confirmedRootTotalsByCurrency[currency]) {
                                investigation.confirmedRootTotalsByCurrency[currency] = 0;
                            }
                            investigation.confirmedRootTotalsByCurrency[currency] += parseFloat(transaction.amount);
                        }
                    });
                });
                
                console.log('Root totals by currency:', investigation.confirmedRootTotalsByCurrency);
                
                // Keep legacy confirmedRootTotal for backward compatibility (sum of all)
                investigation.confirmedRootTotal = Object.values(investigation.confirmedRootTotalsByCurrency).reduce((sum, amount) => sum + amount, 0);
                
                // Initialize currentART with the confirmed root totals
                investigation.currentART = {...investigation.confirmedRootTotalsByCurrency};
                
                console.log('Total root amount:', investigation.confirmedRootTotal);
                console.log('Current ART:', investigation.currentART);
                
                // Build Universal Wallet Index and Red Wallet Index from victim transactions
                console.log('Building wallet indexes...');
                buildUniversalWalletIndex();
                buildRedWalletIndex();
                
                // Close modal first
                console.log('Closing modal...');
                closeModal();
                
                // Update various statuses
                console.log('Updating statuses...');
                updateValidationStatus();
                updateWorkflowSteps();
                updateGenerateRootSection();
                saveToStorage();
                
                // Auto-save investigation
                console.log('Auto-saving investigation...');
                saveInvestigation();
            
            // Switch to traces tab
            try {
                switchTab('traces');
                
                // Force re-render hops to show ready state
                renderHops();
                
                // Show success message
                setTimeout(() => {
                    alert(' Root Total Confirmed!\n\nYour investigation baseline has been established. You can now begin tracing funds from the RED wallets.');
                }, 100);
            } catch (error) {
                console.error('Error switching to traces tab:', error);
                alert('Root total confirmed, but there was an error switching tabs. Please manually click on "Trace Documentation" to continue.');
            }
            
            } catch (error) {
                console.error('Error in confirmAndProceed:', error);
                alert(`An error occurred while confirming the root total:\n\n${error.message}\n\nPlease check the console for more details.`);
                
                // Try to save what we can
                try {
                    investigation.rootTotalConfirmed = true;
                    saveToStorage();
                } catch (saveError) {
                    console.error('Error saving after error:', saveError);
                }
            }
        }

        function buildRedWalletIndex() {
            investigation.redWalletIndex = [];
            
            investigation.victims.forEach(victim => {
                victim.transactions.forEach(transaction => {
                    if (parseFloat(transaction.amount) > 0 && transaction.receivingWallet) {
                        const currency = transaction.currency === 'CUSTOM' ? transaction.customCurrency : transaction.currency;
                        
                        // Find corresponding wallet ID from universal index
                        let walletId = '';
                        const universalEntry = investigation.universalWalletIndex.find(w => w.address === transaction.receivingWallet.trim());
                        if (universalEntry) {
                            walletId = universalEntry.permanentId;
                        }
                        
                        const redEntry = {
                            id: investigation.redWalletIndex.length + 1,
                            vtNotation: `V${victim.id}-T${transaction.id}`,
                            walletId: walletId,
                            walletAddress: transaction.receivingWallet.trim(),
                            depositDate: transaction.datetime,
                            timezone: transaction.timezone,
                            amount: parseFloat(transaction.amount),
                            currency: currency,
                            notes: transaction.notes || '',
                            investigativeNotes: '' // For additional investigative findings
                        };
                        
                        investigation.redWalletIndex.push(redEntry);
                    }
                });
            });
        }

        // REPLACE the existing renderRedWalletIndex() function with this:

function renderPurpleWalletIndex() {
    const container = document.getElementById('purpleWalletIndexList');
    
    // Filter only purple wallets from the universal index
    const purpleWallets = (investigation.universalWalletIndex || []).filter(wallet => 
        wallet.permanentType === 'purple'
    );
    
    if (purpleWallets.length === 0) {
        container.innerHTML = `
            <div class="no-traces-message">
                <h3>No Exchange Wallets Identified</h3>
                <p>No PURPLE (exchange) wallets have been identified yet. These are typically identified during trace documentation when funds reach known exchanges.</p>
            </div>
        `;
        return;
    }
    
    let tableHTML = `
        <table style="width: 100%; border-collapse: collapse;">
            <thead>
                <tr style="background: #f8f9fa;">
                    <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Exchange ID</th>
                    <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Exchange Name</th>
                    <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Wallet Address</th>
                    <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">First Seen</th>
                    <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Total Received</th>
                    <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Notes</th>
                </tr>
            </thead>
            <tbody>
    `;
    
    purpleWallets.forEach(wallet => {
        // Calculate total received by this wallet from hop entries
        const receivedAmounts = {};
        investigation.hops.forEach(hop => {
            hop.entries.forEach(entry => {
                if (entry.toWallet === wallet.address && entry.amount) {
                    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                    if (!receivedAmounts[currency]) {
                        receivedAmounts[currency] = 0;
                    }
                    receivedAmounts[currency] += parseFloat(entry.amount);
                }
            });
        });
        
        const totalDisplay = Object.entries(receivedAmounts)
            .map(([currency, amount]) => `${amount.toLocaleString()} ${currency}`)
            .join(', ') || 'No deposits tracked';
        
        tableHTML += `
            <tr>
                <td style="border: 1px solid #ddd; padding: 12px;">
                    <div class="wallet-display purple" style="margin: 0;">${wallet.permanentId}</div>
                </td>
                <td style="border: 1px solid #ddd; padding: 12px;">
                    <input type="text" value="${wallet.exchangeName || ''}" 
                           placeholder="Enter exchange name..."
                           style="width: 100%; padding: 4px; border: 1px solid #ddd; border-radius: 3px;"
                           onchange="updateWalletExchangeName('${wallet.address}', this.value)">
                </td>
                <td style="border: 1px solid #ddd; padding: 12px; font-family: monospace; font-size: 11px;">${wallet.address}</td>
                <td style="border: 1px solid #ddd; padding: 12px;">${wallet.firstSeenHop || 'Unknown'}</td>
                <td style="border: 1px solid #ddd; padding: 12px;">${totalDisplay}</td>
                <td style="border: 1px solid #ddd; padding: 12px;">
                    <textarea placeholder="Legal service notes, subpoena info, etc." 
                              style="width: 100%; min-height: 60px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;"
                              onchange="updateWalletNotes('${wallet.address}', this.value)">${wallet.notes || ''}</textarea>
                </td>
            </tr>
        `;
    });
    
    tableHTML += `
            </tbody>
        </table>
    `;
    
    container.innerHTML = tableHTML;
}

function renderBlueWalletIndex() {
    const container = document.getElementById('blueWalletIndexList');
    
    // Filter only blue wallets from the universal index
    const blueWallets = (investigation.universalWalletIndex || []).filter(wallet => 
        wallet.permanentType === 'blue'
    );
    
    if (blueWallets.length === 0) {
        container.innerHTML = `
            <div class="no-traces-message">
                <h3>No Cold Storage Wallets Identified</h3>
                <p>No BLUE (cold storage) wallets have been identified yet. These are identified when funds remain stationary at the end of a hop.</p>
            </div>
        `;
        return;
    }
    
    let tableHTML = `
        <table style="width: 100%; border-collapse: collapse;">
            <thead>
                <tr style="background: #f8f9fa;">
                    <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Wallet ID</th>
                    <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Wallet Address</th>
                    <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Amount Held</th>
                    <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Last Activity</th>
                    <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Status</th>
                    <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Monitoring Notes</th>
                </tr>
            </thead>
            <tbody>
    `;
    
    blueWallets.forEach(wallet => {
        // Find cold storage entries for this wallet
        const coldStorageAmounts = {};
        let lastActivity = '';
        
        investigation.hops.forEach(hop => {
            hop.entries.forEach(entry => {
                if (entry.entryType === 'cold_storage' && entry.toWallet === wallet.address && entry.amount) {
                    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                    if (!coldStorageAmounts[currency]) {
                        coldStorageAmounts[currency] = 0;
                    }
                    coldStorageAmounts[currency] += parseFloat(entry.amount);
                    
                    if (entry.timestamp) {
                        lastActivity = `${entry.timestamp} ${entry.timezone || 'UTC'}`;
                    }
                }
            });
        });
        
        const amountDisplay = Object.entries(coldStorageAmounts)
            .map(([currency, amount]) => `${amount.toLocaleString()} ${currency}`)
            .join(', ') || 'No amount recorded';
        
        tableHTML += `
            <tr>
                <td style="border: 1px solid #ddd; padding: 12px;">
                    <div class="wallet-display blue" style="margin: 0;">${wallet.permanentId}</div>
                </td>
                <td style="border: 1px solid #ddd; padding: 12px; font-family: monospace; font-size: 11px;">${wallet.address}</td>
                <td style="border: 1px solid #ddd; padding: 12px; font-weight: bold;">${amountDisplay}</td>
                <td style="border: 1px solid #ddd; padding: 12px;">${lastActivity || 'Unknown'}</td>
                <td style="border: 1px solid #ddd; padding: 12px;">
                    <select onchange="updateWalletStatus('${wallet.address}', this.value)"
                            style="width: 100%; padding: 4px; border: 1px solid #ddd; border-radius: 3px;">
                        <option value="monitoring" ${wallet.status === 'monitoring' ? 'selected' : ''}> Monitoring</option>
                        <option value="moved" ${wallet.status === 'moved' ? 'selected' : ''}> Funds Moved</option>
                        <option value="seized" ${wallet.status === 'seized' ? 'selected' : ''}> Seized</option>
                        <option value="abandoned" ${wallet.status === 'abandoned' ? 'selected' : ''}> Abandoned</option>
                    </select>
                </td>
                <td style="border: 1px solid #ddd; padding: 12px;">
                    <textarea placeholder="Movement alerts, monitoring status, etc." 
                              style="width: 100%; min-height: 60px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;"
                              onchange="updateWalletNotes('${wallet.address}', this.value)">${wallet.notes || ''}</textarea>
                </td>
            </tr>
        `;
    });
    
    tableHTML += `
            </tbody>
        </table>
    `;
    
    container.innerHTML = tableHTML;
}

function renderRedWalletIndex() {
    const container = document.getElementById('redWalletIndexList');
    
    if (investigation.redWalletIndex.length === 0) {
        container.innerHTML = `
            <div class="no-traces-message">
                <h3>Red Wallet Index Not Available</h3>
                <p>${!investigation.rootTotalConfirmed ? 
                    'Please complete victim setup to generate the Red Wallet Index. Note: Full functionality requires confirming the root total.' : 
                    'No victim transactions found. Please add victim transactions first.'}</p>
                <button class="btn btn-confirm" onclick="switchTab('victims'); document.querySelector('[onclick=\\"switchTab(\\'victims\\')\\"]').click();"> Back to Victims & Transactions</button>
            </div>
        `;
        return;
    }
    
    // Group red wallet entries by victim
    const entriesByVictim = {};
    investigation.redWalletIndex.forEach(entry => {
        const victimMatch = entry.vtNotation.match(/^V(\d+)/);
        if (victimMatch) {
            const victimId = victimMatch[1];
            if (!entriesByVictim[victimId]) {
                entriesByVictim[victimId] = [];
            }
            entriesByVictim[victimId].push(entry);
        }
    });
    
    let tablesHTML = '';
    
    // Create a table for each victim
    Object.entries(entriesByVictim).forEach(([victimId, entries]) => {
        // Calculate totals for this victim
        const totalsByCurrency = {};
        entries.forEach(entry => {
            if (!totalsByCurrency[entry.currency]) {
                totalsByCurrency[entry.currency] = 0;
            }
            totalsByCurrency[entry.currency] += entry.amount;
        });
        
        const totalsDisplay = Object.entries(totalsByCurrency)
            .map(([currency, amount]) => `${amount.toLocaleString()} ${currency}`)
            .join(' | ');
        
        tablesHTML += `
            <div style="background: white; border-radius: 8px; padding: 20px; margin-bottom: 30px; box-shadow: 0 2px 10px rgba(0,0,0,0.08);">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 20px; padding-bottom: 15px; border-bottom: 2px solid #e8f0fe;">
                    <div>
                        <h3 style="margin: 0; color: #2c3e50; font-size: 1.5rem;"> Victim ${victimId} - Red Wallet Deposits</h3>
                        <div style="margin-top: 8px; color: #666; font-size: 14px;">
                            <strong>Total Deposits:</strong> ${totalsDisplay} | <strong>Transactions:</strong> ${entries.length}
                        </div>
                    </div>
                    <button class="btn btn-success" onclick="exportVictimTableToExcel(${victimId})" style="background: #27ae60;">
                         Export Victim ${victimId} to Excel
                    </button>
                </div>
                
                <table id="victimTable_${victimId}" style="width: 100%; border-collapse: collapse;">
                    <thead>
                        <tr style="background: #f8f9fa;">
                            <th style="border: 1px solid #ddd; padding: 12px; text-align: left; font-weight: bold;">V-T Notation</th>
                            <th style="border: 1px solid #ddd; padding: 12px; text-align: left; font-weight: bold;">Wallet ID</th>
                            <th style="border: 1px solid #ddd; padding: 12px; text-align: left; font-weight: bold;">Deposit Date</th>
                            <th style="border: 1px solid #ddd; padding: 12px; text-align: left; font-weight: bold;">Amount</th>
                            <th style="border: 1px solid #ddd; padding: 12px; text-align: left; font-weight: bold;">Currency</th>
                            <th style="border: 1px solid #ddd; padding: 12px; text-align: left; font-weight: bold;">Wallet Address</th>
                            <th style="border: 1px solid #ddd; padding: 12px; text-align: left; font-weight: bold;">Notes</th>
                        </tr>
                    </thead>
                    <tbody>
                        ${entries.map(entry => {
                            const dateDisplay = entry.depositDate ? 
                                `${entry.depositDate} ${entry.timezone}` : 
                                'Not specified';
                            
                            return `
                                <tr>
                                    <td style="border: 1px solid #ddd; padding: 12px; font-weight: bold; color: #e74c3c;">${entry.vtNotation}</td>
                                    <td style="border: 1px solid #ddd; padding: 12px;">
                                        <div class="wallet-display red" style="margin: 0;">${entry.walletId || 'Not assigned'}</div>
                                    </td>
                                    <td style="border: 1px solid #ddd; padding: 12px; font-size: 12px;">${dateDisplay}</td>
                                    <td style="border: 1px solid #ddd; padding: 12px; font-weight: bold;">${entry.amount.toLocaleString()}</td>
                                    <td style="border: 1px solid #ddd; padding: 12px;">${entry.currency}</td>
                                    <td style="border: 1px solid #ddd; padding: 12px; font-family: monospace; font-size: 11px; word-break: break-all; max-width: 200px;">${entry.walletAddress}</td>
                                    <td style="border: 1px solid #ddd; padding: 12px;">
                                        <div style="margin-bottom: 8px; font-size: 12px; color: #666;">
                                            <strong>Transaction Notes:</strong> ${entry.notes || 'None'}
                                        </div>
                                        <textarea placeholder="Add investigative notes..." 
                                                  style="width: 100%; min-height: 60px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;"
                                                  onchange="updateRedWalletIndexNotes(${entry.id}, this.value)">${entry.investigativeNotes || ''}</textarea>
                                    </td>
                                </tr>
                            `;
                        }).join('')}
                    </tbody>
                </table>
            </div>
        `;
    });
    
    // Add export all button at the top
    const headerHTML = `
        <div style="background: #e8f4f8; border: 2px solid #3498db; border-radius: 8px; padding: 20px; margin-bottom: 20px; text-align: center;">
            <h4 style="color: #2c3e50; margin-bottom: 15px;"> Red Wallet Index - Organized by Victim</h4>
            <p style="color: #2c3e50; margin-bottom: 15px;">Each victim's deposits are shown in separate tables below. Export individual victim data or all data using the buttons.</p>
            <button class="btn btn-success" onclick="exportAllVictimTablesToExcel()" style="background: #27ae60; margin-right: 10px;">
                 Export All Victims to Excel
            </button>
            <button class="btn" onclick="exportRedWalletIndexCSV()" style="background: #3498db;">
                 Export Summary CSV
            </button>
        </div>
    `;
    
    container.innerHTML = headerHTML + tablesHTML;
}

// Helper functions for wallet updates
function updateWalletExchangeName(address, exchangeName) {
    const wallet = investigation.universalWalletIndex.find(w => w.address === address);
    if (wallet) {
        wallet.exchangeName = exchangeName;
        saveToStorage();
    }
}

function updateWalletStatus(address, status) {
    const wallet = investigation.universalWalletIndex.find(w => w.address === address);
    if (wallet) {
        wallet.status = status;
        saveToStorage();
    }
}

// Export wallet index function
function exportWalletIndex(indexType) {
    let wallets = [];
    let filename = '';
    let headers = '';
    
    if (indexType === 'universal') {
        wallets = investigation.universalWalletIndex || [];
        filename = `Universal_Wallet_Index_${investigation.caseId}_${new Date().toISOString().split('T')[0]}.csv`;
        headers = 'Wallet ID,Type,Address,First Seen,Notes\n';
    } else if (indexType === 'red') {
        // Export red wallet index data
        exportRedWalletIndexCSV();
        return;
    } else if (indexType === 'purple') {
        wallets = (investigation.universalWalletIndex || []).filter(w => w.permanentType === 'purple');
        filename = `Purple_Exchange_Wallets_${investigation.caseId}_${new Date().toISOString().split('T')[0]}.csv`;
        headers = 'Exchange ID,Exchange Name,Address,First Seen,Total Received,Notes\n';
    } else if (indexType === 'blue') {
        wallets = (investigation.universalWalletIndex || []).filter(w => w.permanentType === 'blue');
        filename = `Blue_Cold_Storage_Wallets_${investigation.caseId}_${new Date().toISOString().split('T')[0]}.csv`;
        headers = 'Wallet ID,Address,Amount Held,Status,Notes\n';
    }
    
    if (wallets.length === 0) {
        alert('No wallets found in this index.');
        return;
    }
    
    let csvContent = headers;
    
    wallets.forEach(wallet => {
        if (indexType === 'universal') {
            csvContent += `"${wallet.permanentId}","${wallet.permanentType}","${wallet.address}","${wallet.firstSeenHop || 'Unknown'}","${(wallet.notes || '').replace(/"/g, '""')}"\n`;
        } else if (indexType === 'purple') {
            // Calculate total received
            const receivedAmounts = {};
            investigation.hops.forEach(hop => {
                hop.entries.forEach(entry => {
                    if (entry.toWallet === wallet.address && entry.amount) {
                        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                        if (!receivedAmounts[currency]) {
                            receivedAmounts[currency] = 0;
                        }
                        receivedAmounts[currency] += parseFloat(entry.amount);
                    }
                });
            });
            const totalDisplay = Object.entries(receivedAmounts)
                .map(([currency, amount]) => `${amount.toLocaleString()} ${currency}`)
                .join('; ') || 'None';
            
            csvContent += `"${wallet.permanentId}","${wallet.exchangeName || ''}","${wallet.address}","${wallet.firstSeenHop || 'Unknown'}","${totalDisplay}","${(wallet.notes || '').replace(/"/g, '""')}"\n`;
        } else if (indexType === 'blue') {
            // Calculate cold storage amounts
            const coldStorageAmounts = {};
            investigation.hops.forEach(hop => {
                hop.entries.forEach(entry => {
                    if (entry.entryType === 'cold_storage' && entry.toWallet === wallet.address && entry.amount) {
                        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                        if (!coldStorageAmounts[currency]) {
                            coldStorageAmounts[currency] = 0;
                        }
                        coldStorageAmounts[currency] += parseFloat(entry.amount);
                    }
                });
            });
            const amountDisplay = Object.entries(coldStorageAmounts)
                .map(([currency, amount]) => `${amount.toLocaleString()} ${currency}`)
                .join('; ') || 'None';
            
            csvContent += `"${wallet.permanentId}","${wallet.address}","${amountDisplay}","${wallet.status || 'monitoring'}","${(wallet.notes || '').replace(/"/g, '""')}"\n`;
        }
    });
    
    // Download the file
    const blob = new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
}

// ADD these new functions for Excel export functionality:

function exportVictimTableToExcel(victimId) {
    // Get entries for this specific victim
    const victimEntries = investigation.redWalletIndex.filter(entry => 
        entry.vtNotation.startsWith(`V${victimId}-`)
    );
    
    if (victimEntries.length === 0) {
        alert(`No data found for Victim ${victimId}`);
        return;
    }
    
    // Create CSV content
    let csvContent = 'V-T Notation,Wallet ID,Deposit Date,Amount,Currency,Wallet Address,Transaction Notes,Investigative Notes\n';
    
    victimEntries.forEach(entry => {
        const dateDisplay = entry.depositDate ? `${entry.depositDate} ${entry.timezone}` : 'Not specified';
        const walletId = entry.walletId || 'Not assigned';
        const transactionNotes = (entry.notes || '').replace(/"/g, '""');
        const investigativeNotes = (entry.investigativeNotes || '').replace(/"/g, '""');
        
        csvContent += `"${entry.vtNotation}","${walletId}","${dateDisplay}","${entry.amount}","${entry.currency}","${entry.walletAddress}","${transactionNotes}","${investigativeNotes}"\n`;
    });
    
    // Calculate totals for the filename
    const totalsByCurrency = {};
    victimEntries.forEach(entry => {
        if (!totalsByCurrency[entry.currency]) {
            totalsByCurrency[entry.currency] = 0;
        }
        totalsByCurrency[entry.currency] += entry.amount;
    });
    
    const totalsText = Object.entries(totalsByCurrency)
        .map(([currency, amount]) => `${amount.toLocaleString()}${currency}`)
        .join('_');
    
    const filename = `Victim_${victimId}_Red_Wallets_${totalsText}_${investigation.caseId || 'Case'}_${new Date().toISOString().slice(0,10)}.csv`;
    downloadFile(csvContent, filename, 'text/csv');
}
// ADD this function to your JavaScript section:

function exportUniversalWalletIndex() {
    if (!investigation.universalWalletIndex || investigation.universalWalletIndex.length === 0) {
        alert('No universal wallet data to export');
        return;
    }
    
    // Create CSV content with comprehensive wallet data
    let csvContent = 'Wallet ID,Permanent Classification,Current Status,Wallet Address,First Seen,Total Amount,Currencies,Status History,Exposure Chain Summary,Notes\n';
    
    // Sort wallets by type then by ID (same as display)
    const sortedWallets = [...investigation.universalWalletIndex].sort((a, b) => {
        if (a.permanentType !== b.permanentType) {
            const typeOrder = ['red', 'pink', 'yellow', 'orange', 'brown', 'black', 'blue', 'purple', 'gray', 'green'];
            return typeOrder.indexOf(a.permanentType) - typeOrder.indexOf(b.permanentType);
        }
        return a.permanentId.localeCompare(b.permanentId);
    });
    
    sortedWallets.forEach(wallet => {
        // Format currencies as "BTC: 1.5, USD: 5000"
        const currenciesText = Object.entries(wallet.currencies || {})
            .map(([currency, amount]) => `${currency}: ${amount.toLocaleString()}`)
            .join('; ');
        
        // Format status history
        const statusHistory = (wallet.statusHistory || []).join('  ');
        
        // Format exposure chain summary
        const exposureChainSummary = (wallet.exposureChain || [])
            .map(exp => `${exp.notation}(${exp.amount.toLocaleString()} ${exp.currency})`)
            .join('; ');
        
        // Clean and escape text fields
        const walletId = wallet.permanentId || wallet.id || '';
        const permanentClassification = walletTypes[wallet.permanentType] || wallet.permanentType || '';
        const currentStatus = wallet.currentStatus !== wallet.permanentType ? 
            `${walletTypes[wallet.currentStatus] || wallet.currentStatus} (Currently)` : 
            permanentClassification;
        const address = wallet.address || '';
        const firstSeen = wallet.firstSeen || '';
        const totalAmount = wallet.totalAmount ? wallet.totalAmount.toLocaleString() : '0';
        const notes = (wallet.notes || '').replace(/"/g, '""').replace(/\n/g, ' ');
        
        csvContent += `"${walletId}","${permanentClassification}","${currentStatus}","${address}","${firstSeen}","${totalAmount}","${currenciesText}","${statusHistory}","${exposureChainSummary}","${notes}"\n`;
    });
    
    const filename = `Universal_Wallet_Index_${investigation.caseId || 'Case'}_${new Date().toISOString().slice(0,10)}.csv`;
    downloadFile(csvContent, filename, 'text/csv');
}

function exportAllVictimTablesToExcel() {
    if (investigation.redWalletIndex.length === 0) {
        alert('No red wallet data to export');
        return;
    }
    
    // Create comprehensive CSV with victim grouping
    let csvContent = 'Victim ID,V-T Notation,Wallet ID,Deposit Date,Amount,Currency,Wallet Address,Transaction Notes,Investigative Notes\n';
    
    // Group by victim and add victim ID column
    const entriesByVictim = {};
    investigation.redWalletIndex.forEach(entry => {
        const victimMatch = entry.vtNotation.match(/^V(\d+)/);
        if (victimMatch) {
            const victimId = victimMatch[1];
            if (!entriesByVictim[victimId]) {
                entriesByVictim[victimId] = [];
            }
            entriesByVictim[victimId].push(entry);
        }
    });
    
    Object.entries(entriesByVictim).forEach(([victimId, entries]) => {
        entries.forEach(entry => {
            const dateDisplay = entry.depositDate ? `${entry.depositDate} ${entry.timezone}` : 'Not specified';
            const walletId = entry.walletId || 'Not assigned';
            const transactionNotes = (entry.notes || '').replace(/"/g, '""');
            const investigativeNotes = (entry.investigativeNotes || '').replace(/"/g, '""');
            
            csvContent += `"${victimId}","${entry.vtNotation}","${walletId}","${dateDisplay}","${entry.amount}","${entry.currency}","${entry.walletAddress}","${transactionNotes}","${investigativeNotes}"\n`;
        });
    });
    
    const filename = `All_Victims_Red_Wallets_${investigation.caseId || 'Case'}_${new Date().toISOString().slice(0,10)}.csv`;
    downloadFile(csvContent, filename, 'text/csv');
}

function exportRedWalletIndexCSV() {
    // Create summary CSV (original format)
    let csvContent = 'V-T Notation,Wallet ID,Deposit Date,Amount,Currency,Wallet Address,Transaction Notes,Investigative Notes\n';
    
    investigation.redWalletIndex.forEach(entry => {
        const dateDisplay = entry.depositDate ? `${entry.depositDate} ${entry.timezone}` : 'Not specified';
        const walletId = entry.walletId || 'Not assigned';
        const transactionNotes = (entry.notes || '').replace(/"/g, '""');
        const investigativeNotes = (entry.investigativeNotes || '').replace(/"/g, '""');
        
        csvContent += `"${entry.vtNotation}","${walletId}","${dateDisplay}","${entry.amount}","${entry.currency}","${entry.walletAddress}","${transactionNotes}","${investigativeNotes}"\n`;
    });
    
    const filename = `Red_Wallet_Index_Summary_${investigation.caseId || 'Case'}_${new Date().toISOString().slice(0,10)}.csv`;
    downloadFile(csvContent, filename, 'text/csv');
}
        function updateRedWalletIndexNotes(entryId, notes) {
            const entry = investigation.redWalletIndex.find(e => e.id === entryId);
            if (entry) {
                entry.investigativeNotes = notes;
                saveToStorage();
            }
        }

        function buildUniversalWalletIndex() {
            investigation.universalWalletIndex = [];
            const walletMap = new Map();
            const colorCounters = {
                red: 1, pink: 1, yellow: 1, orange: 1, brown: 1,
                black: 1, blue: 1, purple: 1, gray: 1, green: 1
            };
            
            // Start with RED wallets from victim transactions
            investigation.victims.forEach(victim => {
                victim.transactions.forEach(transaction => {
                    if (parseFloat(transaction.amount) > 0 && transaction.receivingWallet) {
                        const address = transaction.receivingWallet.trim();
                        
                        if (!walletMap.has(address)) {
                            const walletEntry = {
                                id: `RED ${colorCounters.red}`,
                                permanentId: `RED ${colorCounters.red}`,
                                address: address,
                                permanentType: 'red',
                                currentStatus: 'red',
                                totalAmount: 0,
                                currencies: {},
                                exposureChain: [],
                                firstSeen: `V${victim.id}-T${transaction.id}`,
                                statusHistory: ['red'],
                                isDestination: false,
                                isSource: true,
                                notes: ''
                            };
                            walletMap.set(address, walletEntry);
                            colorCounters.red++;
                        }
                        
                        const wallet = walletMap.get(address);
                        const currency = transaction.currency === 'CUSTOM' ? transaction.customCurrency : transaction.currency;
                        const amount = parseFloat(transaction.amount);
                        
                        if (!wallet.currencies[currency]) {
                            wallet.currencies[currency] = 0;
                        }
                        wallet.currencies[currency] += amount;
                        wallet.totalAmount += amount;
                        
                        // Add exposure chain
                        wallet.exposureChain.push({
                            notation: `V${victim.id}-T${transaction.id}`,
                            amount: amount,
                            currency: currency,
                            type: 'victim_payment'
                        });
                    }
                });
            });
            
            // Process hop entries to build complete wallet index
            investigation.hops.forEach(hop => {
                hop.entries.forEach(entry => {
                    if (entry.entryType === 'trace' && entry.toWallet && parseFloat(entry.amount) > 0) {
                        const address = entry.toWallet.trim();
                        const walletType = entry.toWalletType || 'black';
                        
                        if (!walletMap.has(address)) {
                            // New wallet - BLUE wallets get temporary classification, others get permanent
                            const permanentType = walletType === 'blue' ? 'temporary' : walletType;
                            const walletId = walletType === 'blue' ? 
                                'BLUE (Temporary)' : 
                                `${permanentType.toUpperCase()} ${colorCounters[permanentType]}`;
                            
                            const walletEntry = {
                                id: walletId,
                                permanentId: walletType === 'blue' ? 'BLUE (Temporary)' : `${permanentType.toUpperCase()} ${colorCounters[permanentType]}`,
                                address: address,
                                permanentType: permanentType,
                                currentStatus: walletType,
                                totalAmount: 0,
                                currencies: {},
                                exposureChain: [],
                                firstSeen: entry.notation,
                                statusHistory: [walletType],
                                isDestination: true,
                                isSource: false,
                                notes: ''
                            };
                            walletMap.set(address, walletEntry);
                            
                            // Only increment counter for permanent types
                            if (walletType !== 'blue') {
                                colorCounters[permanentType]++;
                            }
                        } else {
                            // Existing wallet - check if we need to update permanent classification
                            const wallet = walletMap.get(address);
                            
                            // Special handling for yellow (convergence) and brown (conversion) wallets
                            if ((walletType === 'yellow' || walletType === 'brown') && 
                                wallet.permanentType !== walletType && 
                                wallet.permanentType !== 'red') {
                                // Update permanent classification
                                const oldType = wallet.permanentType;
                                wallet.permanentType = walletType;
                                wallet.permanentId = `${walletType.toUpperCase()} ${colorCounters[walletType]}`;
                                colorCounters[walletType]++;
                                
                                // Add to status history
                                if (!wallet.statusHistory.includes(`Reclassified from ${oldType} to ${walletType}`)) {
                                    wallet.statusHistory.push(`Reclassified from ${oldType} to ${walletType}`);
                                }
                            }
                            
                            // Always update current status
                            if (wallet.currentStatus !== walletType) {
                                wallet.currentStatus = walletType;
                                if (!wallet.statusHistory.includes(walletType)) {
                                    wallet.statusHistory.push(walletType);
                                }
                            }
                        }
                        
                        const wallet = walletMap.get(address);
                        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                        const amount = parseFloat(entry.amount);
                        
                        if (!wallet.currencies[currency]) {
                            wallet.currencies[currency] = 0;
                        }
                        wallet.currencies[currency] += amount;
                        wallet.totalAmount += amount;
                        
                        // Add exposure chain
                        wallet.exposureChain.push({
                            notation: entry.notation,
                            amount: amount,
                            currency: currency,
                            type: 'trace_movement',
                            hopNumber: entry.hopNumber
                        });
                        
                        wallet.isDestination = true;
                    }
                });
            });
            
            // Convert map to array
            investigation.universalWalletIndex = Array.from(walletMap.values());
        }

        function renderUniversalWalletIndex() {
            const container = document.getElementById('universalWalletIndexList');
            
            if (!investigation.universalWalletIndex || investigation.universalWalletIndex.length === 0) {
                container.innerHTML = `
                    <div class="no-traces-message">
                        <h3>Universal Wallet Index Empty</h3>
                        <p>The wallet index will be populated as you add victim transactions and trace hops. You can also manually add wallet entries for reference.</p>
                    </div>
                `;
                return;
            }
            
            // Add export button header
            const headerHTML = `
                <div style="background: #e8f4f8; border: 2px solid #3498db; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <div>
                            <h4 style="color: #2c3e50; margin-bottom: 10px;"> Universal Wallet Index</h4>
                            <p style="color: #2c3e50; margin: 0;">Complete catalog of all wallets with permanent classifications and investigative notes.</p>
                        </div>
                        <button class="btn btn-success" onclick="exportUniversalWalletIndex()" style="background: #27ae60;">
                             Export to Excel
                        </button>
                    </div>
                </div>
            `;
            
            let tableHTML = `
                <div style="background: white; border-radius: 8px; padding: 20px; box-shadow: 0 2px 10px rgba(0,0,0,0.08);">
                    <table style="width: 100%; border-collapse: collapse;">
                        <thead>
                            <tr style="background: #f8f9fa;">
                                <th style="border: 1px solid #ddd; padding: 12px; text-align: left; font-weight: bold;">Wallet ID</th>
                                <th style="border: 1px solid #ddd; padding: 12px; text-align: left; font-weight: bold;">Classification</th>
                                <th style="border: 1px solid #ddd; padding: 12px; text-align: left; font-weight: bold;">Wallet Address</th>
                                <th style="border: 1px solid #ddd; padding: 12px; text-align: left; font-weight: bold;">First Seen</th>
                                <th style="border: 1px solid #ddd; padding: 12px; text-align: left; font-weight: bold;">Notes</th>
                                <th style="border: 1px solid #ddd; padding: 12px; text-align: left; font-weight: bold;">Actions</th>
                            </tr>
                        </thead>
                        <tbody>
            `;
            
            // Sort by wallet type then by ID
            const sortedWallets = [...investigation.universalWalletIndex].sort((a, b) => {
                if (a.permanentType !== b.permanentType) {
                    const typeOrder = ['red', 'pink', 'yellow', 'orange', 'brown', 'black', 'blue', 'purple', 'gray', 'green'];
                    return typeOrder.indexOf(a.permanentType) - typeOrder.indexOf(b.permanentType);
                }
                return a.permanentId.localeCompare(b.permanentId);
            });
            
            sortedWallets.forEach(wallet => {
                const statusIndicator = wallet.currentStatus !== wallet.permanentType ? 
                    ` <span style="background: ${getWalletColor(wallet.currentStatus)}; color: white; padding: 2px 6px; border-radius: 4px; font-size: 11px; margin-left: 8px;">CURRENTLY ${wallet.currentStatus.toUpperCase()}</span>` : '';
                
                tableHTML += `
                    <tr>
                        <td style="border: 1px solid #ddd; padding: 12px;">
                            <div class="wallet-display ${wallet.permanentType}" style="margin: 0;">
                                ${wallet.permanentId}${statusIndicator}
                            </div>
                        </td>
                        <td style="border: 1px solid #ddd; padding: 12px;">
                            ${walletTypes[wallet.permanentType] || wallet.permanentType.toUpperCase()}
                        </td>
                        <td style="border: 1px solid #ddd; padding: 12px; font-family: monospace; font-size: 11px; word-break: break-all; max-width: 250px;">
                            ${wallet.address}
                        </td>
                        <td style="border: 1px solid #ddd; padding: 12px; font-size: 12px;">
                            ${wallet.firstSeen}
                        </td>
                        <td style="border: 1px solid #ddd; padding: 12px;">
                            <textarea placeholder="Add notes about this wallet..." 
                                      style="width: 100%; min-height: 60px; padding: 8px; border: 1px solid #ddd; border-radius: 4px; font-size: 12px;"
                                      onchange="updateUniversalWalletNotes('${wallet.address}', this.value)">${wallet.notes}</textarea>
                        </td>
                        <td style="border: 1px solid #ddd; padding: 12px; text-align: center;">
                            <button class="btn btn-danger" style="padding: 6px 12px; font-size: 12px;" 
                                    onclick="removeWalletFromIndex('${wallet.address}')">Remove</button>
                        </td>
                    </tr>
                `;
            });
            
            tableHTML += `
                        </tbody>
                    </table>
                </div>
            `;
            
            container.innerHTML = headerHTML + tableHTML;
        }

        function updateUniversalWalletNotes(address, notes) {
            const wallet = investigation.universalWalletIndex.find(w => w.address === address);
            if (wallet) {
                wallet.notes = notes;
                saveToStorage();
            }
        }

        function removeWalletFromIndex(address) {
            if (confirm('Are you sure you want to remove this wallet from the index? This will not affect trace data.')) {
                investigation.universalWalletIndex = investigation.universalWalletIndex.filter(w => w.address !== address);
                renderUniversalWalletIndex();
                saveToStorage();
            }
        }

        function addManualWallet() {
            const address = prompt('Enter wallet address:');
            if (!address || !address.trim()) return;
            
            const walletType = prompt('Enter wallet classification (red, black, blue, etc.):');
            if (!walletType || !walletTypes[walletType.toLowerCase()]) {
                alert('Invalid wallet type. Please use: red, pink, yellow, orange, brown, black, blue, purple, gray, green');
                return;
            }
            
            const type = walletType.toLowerCase();
            
            // Check if wallet already exists
            if (investigation.universalWalletIndex.find(w => w.address === address.trim())) {
                alert('This wallet address already exists in the index.');
                return;
            }
            
            // Find next available ID for this type
            const existingIds = investigation.universalWalletIndex
                .filter(w => w.permanentType === type)
                .map(w => parseInt(w.permanentId.split(' ')[1]) || 0);
            const nextId = existingIds.length > 0 ? Math.max(...existingIds) + 1 : 1;
            
            const walletEntry = {
                id: `${type.toUpperCase()} ${nextId}`,
                permanentId: `${type.toUpperCase()} ${nextId}`,
                address: address.trim(),
                permanentType: type,
                currentStatus: type,
                totalAmount: 0,
                currencies: {},
                exposureChain: [],
                firstSeen: 'Manual Entry',
                statusHistory: [type],
                isDestination: false,
                isSource: false,
                notes: ''
            };
            
            investigation.universalWalletIndex.push(walletEntry);
            renderUniversalWalletIndex();
            saveToStorage();
        }

        function getCurrentART() {
            // Calculate ART by currency for the NEXT hop
            const artByCurrency = {};
            
            // If no hops exist, start with root totals
            if (investigation.hops.length === 0) {
                investigation.victims.forEach(victim => {
                    victim.transactions.forEach(transaction => {
                        if (parseFloat(transaction.amount) > 0) {
                            const currency = transaction.currency === 'CUSTOM' ? transaction.customCurrency : transaction.currency;
                            if (!artByCurrency[currency]) {
                                artByCurrency[currency] = 0;
                            }
                            artByCurrency[currency] += parseFloat(transaction.amount);
                        }
                    });
                });
            } else {
                // Get the last hop
                const lastHop = investigation.hops[investigation.hops.length - 1];
                
                // Start with the last hop's starting ART
                const lastHopStartingART = lastHop.artAtStartByCurrency || {};
                Object.entries(lastHopStartingART).forEach(([currency, amount]) => {
                    artByCurrency[currency] = amount;
                });
                
                // Add any new currencies from traces in the last hop
                lastHop.entries.forEach(entry => {
                    if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0) {
                        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                        if (!artByCurrency.hasOwnProperty(currency)) {
                            artByCurrency[currency] = 0;
                        }
                    }
                });
                
                // For each currency, calculate what remains for the next hop
                Object.keys(artByCurrency).forEach(currency => {
                    let tracedAmount = 0;
                    
                    lastHop.entries.forEach(entry => {
                        const entryCurrency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                        if (entryCurrency === currency && parseFloat(entry.amount) > 0) {
                            // All entry types that account for funds reduce ART
                            if (['trace', 'writeoff', 'cold_storage', 'vasp_arrival'].includes(entry.entryType)) {
                                tracedAmount += parseFloat(entry.amount);
                            }
                        }
                    });
                    
                    // What's left for the next hop
                    artByCurrency[currency] = (artByCurrency[currency] || 0) - tracedAmount;
                    
                    // Remove currencies with zero or negative amounts
                    if (artByCurrency[currency] <= 0) {
                        delete artByCurrency[currency];
                    }
                });
                
                // Add amounts from trace outputs that continue to next hop
                lastHop.entries.forEach(entry => {
                    if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0) {
                        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                        if (!artByCurrency[currency]) {
                            artByCurrency[currency] = 0;
                        }
                        artByCurrency[currency] += parseFloat(entry.amount);
                    }
                });
            }
            
            return artByCurrency;
        }

        function getAvailableSourceWallets(hopNumber) {
            if (!investigation.universalWalletIndex) {
                buildUniversalWalletIndex();
            }
            
            if (hopNumber === 1) {
                // First hop: only RED wallets
                return investigation.universalWalletIndex.filter(wallet => wallet.permanentType === 'red');
            } else {
                // Subsequent hops: wallets that were destinations in previous hops
                const previousHopNumber = hopNumber - 1;
                const availableWallets = [];
                
                investigation.hops.forEach(hop => {
                    if (hop.hopNumber === previousHopNumber) {
                        hop.entries.forEach(entry => {
                            if (entry.entryType === 'trace' && entry.toWallet) {
                                const wallet = investigation.universalWalletIndex.find(w => w.address === entry.toWallet);
                                if (wallet && !availableWallets.find(w => w.address === wallet.address)) {
                                    availableWallets.push({
                                        ...wallet,
                                        lastAmount: entry.amount,
                                        lastCurrency: entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency,
                                        lastNotation: entry.notation
                                    });
                                }
                            }
                        });
                    }
                });
                
                return availableWallets;
            }
        }

        function closeModal() {
            hideModal('rootTotalModal');
        }
        
        // Generic modal show/hide functions for centered display
        function showModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.classList.add('show');
            }
        }
        
        function hideModal(modalId) {
            const modal = document.getElementById(modalId);
            if (modal) {
                modal.classList.remove('show');
            }
        }
        
        // Helper to create a modal with proper centered styling
        function createCenteredModal(modalId, content) {
            // Remove existing modal if present
            const existingModal = document.getElementById(modalId);
            if (existingModal) {
                existingModal.remove();
            }
            
            // Create modal with show class for centered display
            let modalHTML = content;
            
            // Replace all variations of modal display styles
            modalHTML = modalHTML.replace(
                /<div id="[^"]*" class="modal" style="display:\s*block[^"]*">/g,
                function(match) {
                    const idMatch = match.match(/id="([^"]*)"/);
                    const modalIdFromMatch = idMatch ? idMatch[1] : modalId;
                    return `<div id="${modalIdFromMatch}" class="modal show">`;
                }
            );
            
            // Add to body
            document.body.insertAdjacentHTML('beforeend', modalHTML);
        }

        function calculateRootTotal() {
            return investigation.victims.reduce((sum, v) => 
                sum + v.transactions.reduce((tSum, t) => tSum + (parseFloat(t.amount) || 0), 0), 0);
        }
        
        // Custom centered alert function
        function showAlert(message, type = 'info') {
            const alertId = 'customAlert_' + Date.now();
            const iconMap = {
                'success': '',
                'error': '',
                'warning': '',
                'info': ''
            };
            
            const alertHTML = `
                <div id="${alertId}" class="modal show">
                    <div class="modal-content" style="max-width: 500px;">
                        <div style="text-align: center; padding: 20px;">
                            <div style="font-size: 48px; margin-bottom: 20px;">${iconMap[type] || iconMap.info}</div>
                            <div style="white-space: pre-wrap; line-height: 1.6; color: #2c3e50;">${message}</div>
                            <button class="btn btn-confirm" onclick="document.getElementById('${alertId}').remove()" 
                                    style="margin-top: 20px; padding: 10px 30px;">
                                OK
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            document.body.insertAdjacentHTML('beforeend', alertHTML);
            
            // Focus the OK button
            setTimeout(() => {
                const okBtn = document.querySelector(`#${alertId} button`);
                if (okBtn) okBtn.focus();
            }, 100);
        }

  
    investigation.hops.push(hop);
    renderHops();
    saveToStorage();
    updateWorkflowSteps();

        function getNextHopNumber() {
            if (investigation.hops.length === 0) {
                return 1;
            }
            
            const maxHop = Math.max(...investigation.hops.map(h => h.hopNumber || 0));
            return maxHop + 1;
        }


// ADD THIS FUNCTION RIGHT AFTER getNextHopNumber():
function addNewHop() {
    console.log(' Adding new hop...');
    
    if (!investigation.rootTotalConfirmed) {
        alert('Please confirm your root total before adding hops.');
        return;
    }
    
    // Validate previous hops are complete (with option to proceed)
    for (let hop of investigation.hops) {
        const validation = typeof validateHopCompletionByCurrency === 'function' ? 
            validateHopCompletionByCurrency(hop.id) : 
            validateHopCompletion(hop.id);
            
        if (!validation.valid && validation.errors && validation.errors.length > 0) {
            const shouldProceed = confirm(
                `Hop ${hop.hopNumber} has validation errors:\n${validation.errors.join('\n')}\n\nDo you want to proceed anyway? This may cause mathematical inconsistencies.`
            );
            if (!shouldProceed) {
                return;
            }
        }
    }
    
    const hopNumber = getNextHopNumber();
    const currentART = getCurrentART();
    
    // Create new hop with proper structure
    const hop = {
        id: investigation.hops.length + 1,
        hopNumber: hopNumber,
        entries: [],
        artAtStartByCurrency: currentART,
        artAtStart: Object.values(currentART).reduce((sum, amount) => sum + amount, 0), // Legacy support
        completed: false
    };
    
    console.log(`Creating hop ${hopNumber} with starting ART:`, currentART);
    
    investigation.hops.push(hop);
    
    // Rebuild thread index after adding hop
    buildAvailableThreadsIndex();
    
    renderHops();
    saveToStorage();
    updateWorkflowSteps();
    
    console.log(` Hop ${hopNumber} created successfully`);
}

// ADD this export function to your JavaScript section:

function exportUniversalWalletIndex() {
    if (!investigation.universalWalletIndex || investigation.universalWalletIndex.length === 0) {
        alert('No universal wallet data to export');
        return;
    }
    
    // Create CSV content with comprehensive wallet data
    let csvContent = 'Wallet ID,Permanent Classification,Current Status,Wallet Address,First Seen,Total Amount,Currencies,Status History,Exposure Chain Summary,Notes\n';
    
    // Sort wallets by type then by ID (same as display)
    const sortedWallets = [...investigation.universalWalletIndex].sort((a, b) => {
        if (a.permanentType !== b.permanentType) {
            const typeOrder = ['red', 'pink', 'yellow', 'orange', 'brown', 'black', 'blue', 'purple', 'gray', 'green'];
            return typeOrder.indexOf(a.permanentType) - typeOrder.indexOf(b.permanentType);
        }
        return a.permanentId.localeCompare(b.permanentId);
    });
    
    sortedWallets.forEach(wallet => {
        // Format currencies as "BTC: 1.5, USD: 5000"
        const currenciesText = Object.entries(wallet.currencies || {})
            .map(([currency, amount]) => `${currency}: ${amount.toLocaleString()}`)
            .join('; ');
        
        // Format status history
        const statusHistory = (wallet.statusHistory || []).join('  ');
        
        // Format exposure chain summary
        const exposureChainSummary = (wallet.exposureChain || [])
            .map(exp => `${exp.notation}(${exp.amount.toLocaleString()} ${exp.currency})`)
            .join('; ');
        
        // Clean and escape text fields
        const walletId = wallet.permanentId || wallet.id || '';
        const permanentClassification = walletTypes[wallet.permanentType] || wallet.permanentType || '';
        const currentStatus = wallet.currentStatus !== wallet.permanentType ? 
            `${walletTypes[wallet.currentStatus] || wallet.currentStatus} (Currently)` : 
            permanentClassification;
        const address = wallet.address || '';
        const firstSeen = wallet.firstSeen || '';
        const totalAmount = wallet.totalAmount ? wallet.totalAmount.toLocaleString() : '0';
        const notes = (wallet.notes || '').replace(/"/g, '""').replace(/\n/g, ' ');
        
        csvContent += `"${walletId}","${permanentClassification}","${currentStatus}","${address}","${firstSeen}","${totalAmount}","${currenciesText}","${statusHistory}","${exposureChainSummary}","${notes}"\n`;
    });
    
    const filename = `Universal_Wallet_Index_${investigation.caseId || 'Case'}_${new Date().toISOString().slice(0,10)}.csv`;
    downloadFile(csvContent, filename, 'text/csv');
}
        // Track collapse state
        window.hopCollapseState = window.hopCollapseState || {};
        window.entryCollapseState = window.entryCollapseState || {};
        
        // Toggle hop collapse state
        function toggleHopCollapse(hopId) {
            window.hopCollapseState[hopId] = !window.hopCollapseState[hopId];
            const content = document.getElementById(`hopContent_${hopId}`);
            const arrow = event.currentTarget.querySelector('span');
            
            if (window.hopCollapseState[hopId]) {
                content.style.display = 'none';
                arrow.style.transform = 'rotate(0deg)';
            } else {
                content.style.display = 'block';
                arrow.style.transform = 'rotate(90deg)';
            }
        }
        
        // Toggle entry collapse state
        function toggleEntryCollapse(entryId) {
            window.entryCollapseState[entryId] = !window.entryCollapseState[entryId];
            const content = document.getElementById(`entryContent_${entryId}`);
            const summary = document.getElementById(`entrySummary_${entryId}`);
            
            if (window.entryCollapseState[entryId]) {
                content.style.display = 'none';
                summary.style.display = 'block';
            } else {
                content.style.display = 'block';
                summary.style.display = 'none';
            }
        }
        
        // Log entry and collapse
        function logAndCollapseEntry(hopId, entryId) {
            // Find the entry
            const hop = investigation.hops.find(h => h.id === hopId);
            const entry = hop.entries.find(e => e.id === entryId);
            
            console.log('Log entry debug:', {
                hopId, entryId,
                sourceThreadId: entry.sourceThreadId,
                multipleSourceThreads: entry.multipleSourceThreads,
                notation: entry.notation,
                victimNumbers: entry.victimNumbers,
                transactionNumbers: entry.transactionNumbers,
                amount: entry.amount,
                currency: entry.currency
            });
            
            // Validate entry has required data
            if (!entry.amount || parseFloat(entry.amount) <= 0) {
                alert('Please enter an amount before logging the entry.');
                return;
            }
            
            // Try to auto-generate notation if missing but source is selected
            if (!entry.notation || entry.notation.trim() === '') {
                if (entry.sourceThreadId) {
                    console.log(' Attempting to auto-generate notation from single source:', entry.sourceThreadId);
                    autoGenerateNotationFromSource(hopId, entryId, entry.sourceThreadId);
                } else if (entry.multipleSourceThreads && entry.multipleSourceThreads.length > 0) {
                    console.log(' Attempting to auto-generate notation from multiple sources:', entry.multipleSourceThreads);
                    autoGenerateNotationFromMultipleSources(hopId, entryId, entry.multipleSourceThreads);
                }
            }
            
            if (!entry.notation || entry.notation.trim() === '') {
                alert('Please enter a notation before logging the entry.\n\nIf you have selected a source thread, the notation should auto-fill. Try manually entering the victim and transaction numbers.');
                return;
            }
            
            // Save undo state before logging
            saveUndoState(`Log entry ${entry.notation} in Hop ${hop.hopNumber}`);
            
            // Save to storage
            saveToStorage();
            
            // Set entry as collapsed
            const entryKey = `${hopId}_${entryId}`;
            window.entryCollapseState[entryKey] = true;
            
            // Update UI to show collapsed state
            const content = document.getElementById(`entryContent_${entryKey}`);
            const summary = document.getElementById(`entrySummary_${entryKey}`);
            
            if (content && summary) {
                content.style.display = 'none';
                summary.style.display = 'block';
            }
            
            // Update the hop to refresh ART calculations
            updateInvestigationCompletionStatus();
            
            // Show success message
            const amount = parseFloat(entry.amount);
            const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
            alert(` Entry logged successfully!\n\n${entry.notation}: ${amount.toLocaleString()} ${currency}`);
        }
        
        // Render collapsible hop entry
        function renderCollapsibleHopEntry(entry, entryIndex) {
            // Initialize collapse state - start expanded for new entries
            const entryKey = `${entry.hopId}_${entry.id}`;
            if (window.entryCollapseState[entryKey] === undefined) {
                window.entryCollapseState[entryKey] = false; // Start expanded
            }
            const isCollapsed = window.entryCollapseState[entryKey];
            
            // Get entry type info
            const entryTypeLabel = entryTypes[entry.entryType] || entry.entryType;
            const amount = parseFloat(entry.amount) || 0;
            const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
            
            // Get hop number and ART amount
            const hop = investigation.hops.find(h => h.id === entry.hopId);
            const hopNumber = hop ? hop.hopNumber : '?';
            
            // Get the ART amount for this currency at this hop
            let artAmount = 0;
            if (hop && hop.artAtStartByCurrency && currency) {
                artAmount = hop.artAtStartByCurrency[currency] || 0;
            }
            
            // Calculate thread number within hop (sequential numbering for entries with notation)
            let threadNumber = null;
            if (entry.notation && parseFloat(entry.amount) > 0) {
                const hopEntriesWithNotation = hop.entries.filter(e => e.notation && parseFloat(e.amount) > 0);
                threadNumber = hopEntriesWithNotation.findIndex(e => e.id === entry.id) + 1;
            }
            
            // Get source thread information
            let sourceThreadsInfo = '';
            if (entry.sourceThreadId) {
                // Single source thread
                const sourceMatch = entry.sourceThreadId.match(/^(V\d+-T\d+)-H(\d+)$/);
                if (sourceMatch) {
                    const [, vtPath, sourceHopNumber] = sourceMatch;
                    sourceThreadsInfo = `from ${vtPath} (H${sourceHopNumber})`;
                }
            } else if (entry.multipleSourceThreads && entry.multipleSourceThreads.length > 0) {
                // Multiple source threads
                const sourceThreads = entry.multipleSourceThreads.map(threadId => {
                    const sourceMatch = threadId.match(/^(V\d+-T\d+)-H(\d+)$/);
                    if (sourceMatch) {
                        const [, vtPath, sourceHopNumber] = sourceMatch;
                        return `${vtPath} (H${sourceHopNumber})`;
                    }
                    return threadId;
                });
                sourceThreadsInfo = `from ${sourceThreads.join(', ')}`;
            }
            
            // Entry background color based on type - thematically consistent
            let entryBgColor = '#f0f7ff'; // Very light blue for regular trace entries
            let entryBorderColor = '#b8daff'; // Soft blue border
            if (entry.entryType === 'writeoff') {
                entryBgColor = '#f5f5f5'; // Light gray for writeoffs (abandoned like gray wallets)
                entryBorderColor = '#9e9e9e'; // Gray border
            } else if (entry.entryType === 'cold_storage' || entry.toWalletType === 'blue') {
                entryBgColor = '#e3f2fd'; // Light blue for cold storage
                entryBorderColor = '#3498db';
            } else if (entry.toWalletType === 'purple') {
                entryBgColor = '#f3e6ff'; // Light purple for exchange deposits
                entryBorderColor = '#9b59b6';
            }
            
            return `
                <div id="entry_${entry.hopId}_${entry.id}" style="background: ${entryBgColor}; border: 2px solid ${entryBorderColor}; border-radius: 8px; margin-bottom: 10px; overflow: hidden;">
                    <div style="padding: ${isCollapsed ? '8px' : '15px'};">
                        <!-- Collapsed state header -->
                        <div id="entrySummary_${entryKey}" style="display: ${isCollapsed ? 'block' : 'none'}; cursor: pointer; background: rgba(255,255,255,0.7); padding: 6px 10px; border-radius: 6px;" onclick="toggleEntryCollapse('${entryKey}')">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <div style="display: flex; align-items: center; gap: 10px;">
                                        <span style="transform: rotate(0deg); transition: transform 0.3s; display: inline-block; font-size: 16px;"></span>
                                        <span style="font-weight: bold; color: #2c3e50;">
                                            Hop ${hopNumber} Entry ${entry.id}${threadNumber ? ` (Thread ${threadNumber})` : ''}
                                        </span>
                                        <span style="color: #7f8c8d; font-size: 12px;">
                                            ${entryTypeLabel}
                                        </span>
                                    </div>
                                    ${sourceThreadsInfo ? `
                                        <div style="margin-left: 26px; margin-top: 4px;">
                                            <span style="color: #666; font-size: 11px; font-style: italic;">
                                                ${sourceThreadsInfo}
                                            </span>
                                        </div>
                                    ` : ''}
                                </div>
                                <div style="text-align: right;">
                                    ${amount > 0 ? `
                                        <span style="font-weight: bold; color: #27ae60;">
                                            ${amount.toLocaleString()} ${currency} / ${artAmount.toLocaleString()} ${currency}
                                        </span>
                                    ` : `
                                        <span style="color: #e74c3c; font-size: 12px;">
                                            Not logged
                                        </span>
                                    `}
                                </div>
                            </div>
                            <!-- Add delete button in collapsed view -->
                            ${!isCollapsed ? `<button class="btn btn-sm btn-danger" style="margin-left: 10px;" onclick="event.stopPropagation(); removeHopEntry(${entry.hopId}, ${entry.id})">Delete</button>` : ''}
                        </div>
                        
                        <!-- Expanded state -->
                        <div id="entryContent_${entryKey}" style="display: ${isCollapsed ? 'none' : 'block'};">
                            <!-- Expanded header - clickable to collapse -->
                            <div style="cursor: pointer; margin-bottom: 10px; background: rgba(255,255,255,0.7); padding: 10px; border-radius: 6px;" onclick="toggleEntryCollapse('${entryKey}')">
                                <div style="display: flex; justify-content: space-between; align-items: center;">
                                    <div>
                                        <div style="display: flex; align-items: center; gap: 10px;">
                                            <span style="transform: rotate(90deg); transition: transform 0.3s; display: inline-block; font-size: 16px;"></span>
                                            <span style="font-weight: bold; color: #2c3e50;">
                                                Hop ${hopNumber} Entry ${entry.id}${threadNumber ? ` (Thread ${threadNumber})` : ''}
                                            </span>
                                            <span style="color: #7f8c8d; font-size: 12px;">
                                                ${entryTypeLabel}
                                            </span>
                                            <span style="color: #666; font-size: 11px;">
                                                (Click to collapse)
                                            </span>
                                        </div>
                                        ${sourceThreadsInfo ? `
                                            <div style="margin-left: 26px; margin-top: 4px;">
                                                <span style="color: #666; font-size: 11px; font-style: italic;">
                                                    ${sourceThreadsInfo}
                                                </span>
                                            </div>
                                        ` : ''}
                                    </div>
                                    <div style="text-align: right;">
                                        ${amount > 0 ? `
                                            <span style="font-weight: bold; color: #27ae60;">
                                                ${amount.toLocaleString()} ${currency} / ART
                                            </span>
                                        ` : `
                                            <span style="color: #e74c3c; font-size: 12px;">
                                                Not logged yet
                                            </span>
                                        `}
                                    </div>
                                </div>
                            </div>
                            <!-- Entry form content - not clickable -->
                            <div style="background: #f8f8f8; padding: 15px; border-radius: 6px; cursor: default;" onclick="event.stopPropagation();">
                                ${renderHopEntry(entry)}
                            </div>
                        </div>
                    </div>
                </div>
            `;
        }
        
        // Pagination variables
        let currentHopPage = 1;
        let hopsPerPage = 20;
        
        // Dashboard Functions
        function updateDashboard() {
            // Update victim count
            document.getElementById('dashStatVictims').textContent = investigation.victims.length;
            
            // Update hop count
            document.getElementById('dashStatHops').textContent = investigation.hops.length;
            
            // Update thread and terminal wallet counts
            const threadStatus = checkAllThreadsTerminated();
            document.getElementById('dashStatThreads').textContent = threadStatus.activeThreads.length;
            document.getElementById('dashStatTerminal').textContent = threadStatus.activeThreads.filter(t => 
                ['gray', 'purple', 'blue'].includes(t.toWalletType)
            ).length;
            
            // Update ART progress bars
            updateARTProgressBars();
            
            // Update hop jump menu
            updateHopJumpMenu();
        }
        
        function updateARTProgressBars() {
            const container = document.getElementById('artProgressBars');
            container.innerHTML = '';
            
            if (!investigation.rootTotalConfirmed) {
                container.innerHTML = '<p style="color: #7f8c8d;">Confirm root total to see ART progress</p>';
                return;
            }
            
            // Get current ART by currency
            const currentART = getCurrentART();
            const rootTotal = investigation.victims.reduce((acc, victim) => {
                victim.transactions.forEach(t => {
                    const currency = t.currency === 'CUSTOM' ? t.customCurrency : t.currency;
                    const amount = parseFloat(t.amount) || 0;
                    if (currency && amount > 0) {
                        acc[currency] = (acc[currency] || 0) + amount;
                    }
                });
                return acc;
            }, {});
            
            // Create progress bars for each currency
            Object.entries(rootTotal).forEach(([currency, total]) => {
                const current = currentART[currency] || 0;
                const traced = total - current;
                const percentage = total > 0 ? (traced / total * 100).toFixed(1) : 0;
                
                const progressBar = `
                    <div class="progress-bar-container">
                        <div class="progress-bar-label">
                            <span><strong>${currency}</strong></span>
                            <span>${traced.toLocaleString()} / ${total.toLocaleString()} (${percentage}%)</span>
                        </div>
                        <div class="progress-bar-bg">
                            <div class="progress-bar-fill" style="width: ${percentage}%"></div>
                        </div>
                    </div>
                `;
                container.innerHTML += progressBar;
            });
        }
        
        function updateHopJumpMenu() {
            const menu = document.getElementById('hopJumpMenu');
            menu.innerHTML = '<option value="">Jump to Hop...</option>';
            
            investigation.hops.forEach(hop => {
                const option = document.createElement('option');
                option.value = hop.id;
                option.textContent = `Hop ${hop.hopNumber}${hop.completed ? ' ' : ''}`;
                menu.appendChild(option);
            });
        }
        
        function toggleDashboard() {
            const content = document.getElementById('dashboardContent');
            const button = document.getElementById('dashboardToggle');
            
            if (content.style.display === 'none') {
                content.style.display = 'block';
                button.textContent = 'Hide Dashboard';
            } else {
                content.style.display = 'none';
                button.textContent = 'Show Dashboard';
            }
        }
        
        function jumpToHop(hopId) {
            if (!hopId) return;
            
            const hopElement = document.querySelector(`[data-hop-id="${hopId}"]`);
            if (hopElement) {
                hopElement.scrollIntoView({ behavior: 'smooth', block: 'start' });
                // Flash the hop for visibility
                hopElement.style.transition = 'background-color 0.3s';
                hopElement.style.backgroundColor = '#fff3cd';
                setTimeout(() => {
                    hopElement.style.backgroundColor = '';
                }, 1000);
            }
        }
        
        let searchTimeout;
        function globalSearchDebounce() {
            clearTimeout(searchTimeout);
            searchTimeout = setTimeout(globalSearch, 300);
        }
        
        function globalSearch() {
            const query = document.getElementById('globalSearch').value.toLowerCase();
            if (!query) {
                // Clear highlights
                document.querySelectorAll('.search-highlight').forEach(el => {
                    el.classList.remove('search-highlight');
                });
                return;
            }
            
            // Search in hops and entries
            let found = false;
            investigation.hops.forEach(hop => {
                hop.entries.forEach(entry => {
                    const searchableText = [
                        entry.toWallet,
                        entry.fromWallet,
                        entry.txHash,
                        entry.amount,
                        entry.notation
                    ].filter(Boolean).join(' ').toLowerCase();
                    
                    if (searchableText.includes(query)) {
                        found = true;
                        // Highlight the entry
                        const entryElement = document.querySelector(`[data-entry-id="${hop.id}-${entry.id}"]`);
                        if (entryElement) {
                            entryElement.classList.add('search-highlight');
                            if (!found) {
                                entryElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                            }
                        }
                    }
                });
            });
        }
        
        function showThreadFilter() {
            // This will be implemented with the visualization tools
            alert('Thread filter coming soon! This will allow you to filter the view to specific V-T threads.');
        }
        
        function showAnalysisTools() {
            const modalHTML = `
                <div id="analysisModal" class="modal" style="display: block;">
                    <div class="modal-content" style="max-width: 800px;">
                        <div class="modal-header">
                            <h2> Investigation Analysis Tools</h2>
                            <button class="close-btn" onclick="closeAnalysisModal()"></button>
                        </div>
                        
                        <div style="padding: 20px;">
                            <div class="nav-tabs">
                                <button class="nav-tab active" onclick="switchAnalysisTab('wallet-frequency')">Wallet Frequency</button>
                                <button class="nav-tab" onclick="switchAnalysisTab('pattern-detection')">Pattern Detection</button>
                                <button class="nav-tab" onclick="switchAnalysisTab('terminal-summary')">Terminal Summary</button>
                            </div>
                            
                            <div id="wallet-frequency-tab" class="analysis-tab-content active">
                                <h3>Wallet Frequency Analysis</h3>
                                <div id="walletFrequencyContent"></div>
                            </div>
                            
                            <div id="pattern-detection-tab" class="analysis-tab-content" style="display: none;">
                                <h3>Transaction Pattern Detection</h3>
                                <div id="patternDetectionContent"></div>
                            </div>
                            
                            <div id="terminal-summary-tab" class="analysis-tab-content" style="display: none;">
                                <h3>Terminal Wallet Summary</h3>
                                <div id="terminalSummaryContent"></div>
                            </div>
                        </div>
                        
                        <div class="modal-footer" style="text-align: center; padding: 20px; border-top: 1px solid #eee;">
                            <button class="btn btn-secondary" onclick="closeAnalysisModal()" style="padding: 10px 30px;">
                                Close Analysis
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            createCenteredModal('analysisModal', modalHTML);
            analyzeInvestigation();
        }
        
        function closeAnalysisModal() {
            const modal = document.getElementById('analysisModal');
            if (modal) modal.remove();
        }
        
        function switchAnalysisTab(tabName) {
            // Hide all tabs
            document.querySelectorAll('.analysis-tab-content').forEach(tab => {
                tab.style.display = 'none';
            });
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });
            
            // Show selected tab
            document.getElementById(`${tabName}-tab`).style.display = 'block';
            event.target.classList.add('active');
        }
        
        function analyzeInvestigation() {
            // Wallet Frequency Analysis
            const walletFrequency = {};
            investigation.hops.forEach(hop => {
                hop.entries.forEach(entry => {
                    if (entry.toWallet) {
                        walletFrequency[entry.toWallet] = (walletFrequency[entry.toWallet] || 0) + 1;
                    }
                });
            });
            
            const frequentWallets = Object.entries(walletFrequency)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);
            
            let walletFreqHTML = '<table style="width: 100%; border-collapse: collapse;">';
            walletFreqHTML += '<tr><th style="text-align: left; padding: 10px; border-bottom: 2px solid #ddd;">Wallet Address</th>';
            walletFreqHTML += '<th style="text-align: right; padding: 10px; border-bottom: 2px solid #ddd;">Appearances</th></tr>';
            
            frequentWallets.forEach(([wallet, count]) => {
                walletFreqHTML += `<tr>
                    <td style="padding: 8px; border-bottom: 1px solid #eee; font-family: monospace; font-size: 12px;">
                        ${wallet.substring(0, 20)}...
                    </td>
                    <td style="padding: 8px; border-bottom: 1px solid #eee; text-align: right;">
                        ${count}
                    </td>
                </tr>`;
            });
            walletFreqHTML += '</table>';
            
            document.getElementById('walletFrequencyContent').innerHTML = walletFreqHTML;
            
            // Pattern Detection
            const patterns = detectPatterns();
            let patternHTML = '<div style="margin-top: 20px;">';
            patterns.forEach(pattern => {
                patternHTML += `<div style="background: #f8f9fa; border-left: 4px solid #3498db; padding: 15px; margin-bottom: 10px;">
                    <strong>${pattern.type}</strong>: ${pattern.description}
                </div>`;
            });
            patternHTML += '</div>';
            
            document.getElementById('patternDetectionContent').innerHTML = patternHTML;
            
            // Terminal Summary
            const terminalWallets = getTerminalWallets();
            let terminalHTML = '<div style="margin-top: 20px;">';
            Object.entries(terminalWallets).forEach(([type, wallets]) => {
                terminalHTML += `<h4>${type} Wallets (${wallets.length})</h4>`;
                terminalHTML += '<ul>';
                wallets.forEach(w => {
                    terminalHTML += `<li style="margin-bottom: 5px;">
                        <strong>${w.wallet}</strong>: ${w.amount.toLocaleString()} ${w.currency}
                    </li>`;
                });
                terminalHTML += '</ul>';
            });
            terminalHTML += '</div>';
            
            document.getElementById('terminalSummaryContent').innerHTML = terminalHTML;
        }
        
        function detectPatterns() {
            const patterns = [];
            
            // Check for round amounts
            let roundAmounts = 0;
            investigation.hops.forEach(hop => {
                hop.entries.forEach(entry => {
                    const amount = parseFloat(entry.amount);
                    if (amount > 0 && amount % 100 === 0) {
                        roundAmounts++;
                    }
                });
            });
            
            if (roundAmounts > 5) {
                patterns.push({
                    type: 'Round Number Preference',
                    description: `${roundAmounts} transactions use round numbers (multiples of 100)`
                });
            }
            
            // Check for time patterns
            const timePatterns = {};
            investigation.victims.forEach(victim => {
                victim.transactions.forEach(t => {
                    if (t.datetime) {
                        const hour = new Date(t.datetime).getHours();
                        timePatterns[hour] = (timePatterns[hour] || 0) + 1;
                    }
                });
            });
            
            const peakHour = Object.entries(timePatterns).sort((a, b) => b[1] - a[1])[0];
            if (peakHour) {
                patterns.push({
                    type: 'Time Pattern',
                    description: `Peak activity at ${peakHour[0]}:00 hours (${peakHour[1]} transactions)`
                });
            }
            
            return patterns;
        }
        
        function getTerminalWallets() {
            const terminals = {
                'Purple (Exchange)': [],
                'Gray (Obfuscated)': [],
                'Blue (Cold Storage)': []
            };
            
            const threadStatus = checkAllThreadsTerminated();
            threadStatus.activeThreads.forEach(thread => {
                if (thread.toWalletType === 'purple') {
                    terminals['Purple (Exchange)'].push({
                        wallet: thread.toWallet,
                        amount: thread.amount,
                        currency: thread.currency
                    });
                } else if (thread.toWalletType === 'gray') {
                    terminals['Gray (Obfuscated)'].push({
                        wallet: thread.toWallet,
                        amount: thread.amount,
                        currency: thread.currency
                    });
                } else if (thread.toWalletType === 'blue') {
                    terminals['Blue (Cold Storage)'].push({
                        wallet: thread.toWallet,
                        amount: thread.amount,
                        currency: thread.currency
                    });
                }
            });
            
            return terminals;
        }
        
        // Export/Import Functions
        function exportInvestigation() {
            const exportData = {
                version: '1.0',
                exportDate: new Date().toISOString(),
                investigation: investigation
            };
            
            const dataStr = JSON.stringify(exportData, null, 2);
            const dataBlob = new Blob([dataStr], { type: 'application/json' });
            const url = URL.createObjectURL(dataBlob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `BATS_Investigation_${investigation.caseId || 'export'}_${new Date().toISOString().split('T')[0]}.json`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
            
            alert(' Investigation exported successfully!');
        }
        
        function importInvestigation(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importData = JSON.parse(e.target.result);
                    
                    if (!importData.investigation) {
                        throw new Error('Invalid file format');
                    }
                    
                    if (confirm(' This will replace your current investigation. Are you sure you want to import?')) {
                        investigation = importData.investigation;
                        
                        // Reset pagination
                        currentHopPage = 1;
                        
                        // Clear collapse states
                        window.hopCollapseState = {};
                        window.entryCollapseState = {};
                        
                        // Save and re-render
                        saveToStorage();
                        location.reload(); // Reload to ensure all UI is properly initialized
                    }
                } catch (error) {
                    alert(' Error importing file: ' + error.message);
                }
            };
            
            reader.readAsText(file);
        }
        
        // Export to CSV for specific data
        function exportToCSV(data, filename) {
            let csv = '';
            
            // Add headers
            const headers = Object.keys(data[0]);
            csv += headers.join(',') + '\n';
            
            // Add data
            data.forEach(row => {
                csv += headers.map(header => {
                    const value = row[header];
                    return typeof value === 'string' && value.includes(',') 
                        ? `"${value}"` 
                        : value;
                }).join(',') + '\n';
            });
            
            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }
        
        // Pagination functions
        function changeHopPage(direction) {
            const totalPages = Math.ceil(investigation.hops.length / hopsPerPage);
            currentHopPage += direction;
            
            if (currentHopPage < 1) currentHopPage = 1;
            if (currentHopPage > totalPages) currentHopPage = totalPages;
            
            renderHops();
        }
        
        function updateHopsPerPage() {
            const select = document.getElementById('hopsPerPage');
            hopsPerPage = select.value === 'all' ? 'all' : parseInt(select.value);
            currentHopPage = 1; // Reset to first page
            renderHops();
        }

        function renderHops() {
            // Initialize collapse state tracking
            window.hopCollapseState = window.hopCollapseState || {};
            window.entryCollapseState = window.entryCollapseState || {};
            
            // Update dashboard
            updateDashboard();
            
            const container = document.getElementById('hopsList');
            container.innerHTML = '';

            if (!investigation.rootTotalConfirmed) {
                container.innerHTML = `
                    <div class="no-traces-message">
                        <h3>Root Total Confirmation Required</h3>
                        <p>Please return to the "Victims & Transactions" tab and confirm your root total before documenting trace hops.</p>
                        <button class="btn btn-confirm" onclick="switchTab('victims'); document.querySelector('[onclick=\\"switchTab(\\'victims\\')\\"]').click();"> Back to Victims & Transactions</button>
                    </div>
                `;
                return;
            }

            if (investigation.hops.length === 0) {
                const currentART = getCurrentART();
                const artDisplay = Object.entries(currentART).map(([currency, amount]) => 
                    `${amount.toLocaleString()} ${currency}`
                ).join(' | ');
                
                container.innerHTML = `
                    <div class="no-traces-message">
                        <h3> Ready to Begin Tracing</h3>
                        <p>Your root total has been confirmed! Start documenting blockchain movements with your first hop.</p>
                        <div class="art-display">Current ART: ${artDisplay}</div>
                        <button class="btn btn-confirm" onclick="addNewHop()" style="margin-top: 20px;"> Start Hop 1</button>
                    </div>
                `;
                return;
            }

            // Pagination logic
            const totalHops = investigation.hops.length;
            const showPagination = totalHops > 10 && hopsPerPage !== 'all';
            document.getElementById('paginationControls').style.display = showPagination ? 'block' : 'none';
            
            let hopsToShow = investigation.hops;
            if (showPagination) {
                const startIndex = (currentHopPage - 1) * hopsPerPage;
                const endIndex = startIndex + hopsPerPage;
                hopsToShow = investigation.hops.slice(startIndex, endIndex);
                
                // Update pagination info
                const totalPages = Math.ceil(totalHops / hopsPerPage);
                document.getElementById('pageInfo').textContent = `Page ${currentHopPage} of ${totalPages} (${totalHops} total hops)`;
                document.getElementById('prevPageBtn').disabled = currentHopPage === 1;
                document.getElementById('nextPageBtn').disabled = currentHopPage === totalPages;
            }
            
            hopsToShow.forEach((hop, hopIndex) => {
                // Get the real hop index for alternating colors
                const realHopIndex = investigation.hops.indexOf(hop);
                const hopDiv = document.createElement('div');
                hopDiv.className = 'hop-container';
                hopDiv.setAttribute('data-hop-id', hop.id);
                
                // Calculate totals by currency for this hop
                const entryTotalsByCurrency = {};
                hop.entries.forEach(entry => {
                    if (parseFloat(entry.amount) > 0) {
                        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                        if (!entryTotalsByCurrency[currency]) {
                            entryTotalsByCurrency[currency] = 0;
                        }
                        // Include all entry types that account for funds
                        if (['trace', 'writeoff', 'cold_storage', 'vasp_arrival'].includes(entry.entryType)) {
                            entryTotalsByCurrency[currency] += parseFloat(entry.amount);
                        }
                    }
                });
                
                // Check if hop is complete (all currencies balance)
                const artAtStart = hop.artAtStartByCurrency || {};
                
                // If artAtStartByCurrency is empty but we have a legacy artAtStart number, calculate it
                if (Object.keys(artAtStart).length === 0 && hop.artAtStart) {
                    // For legacy support - assume USD if only a number is stored
                    artAtStart['USD'] = hop.artAtStart;
                }
                
                let isComplete = hop.completed || false;
                let remainingDisplay = [];
                
                // Only check completion if we have starting ART values
                if (Object.keys(artAtStart).length > 0) {
                    Object.entries(artAtStart).forEach(([currency, startAmount]) => {
                        const tracedAmount = entryTotalsByCurrency[currency] || 0;
                        const remaining = startAmount - tracedAmount;
                        if (Math.abs(remaining) >= 0.01) {
                            remainingDisplay.push(`${remaining.toLocaleString()} ${currency}`);
                        }
                    });
                } else {
                    // If no starting ART is set, the hop cannot be complete
                    remainingDisplay.push('Starting ART not set');
                }
                
                const artStartDisplay = typeof artAtStart === 'object' ? 
                    Object.entries(artAtStart).map(([currency, amount]) => `${amount.toLocaleString()} ${currency}`).join(' | ') :
                    `${artAtStart.toLocaleString()}`;
                
                // Initialize collapse state - completed hops start collapsed
                // Auto-collapse old hops for performance
                if (window.hopCollapseState[hop.id] === undefined) {
                    // Collapse completed hops or hops that are more than 5 positions from the end
                    window.hopCollapseState[hop.id] = isComplete || (investigation.hops.length > 10 && hopIndex < investigation.hops.length - 5);
                }
                const isCollapsed = window.hopCollapseState[hop.id];
                
                // Different background colors for alternating hops
                const hopBgColor = realHopIndex % 2 === 0 ? '#f0f4f8' : '#e8ecf0';
                
                // Count entry summary
                const tracesCount = hop.entries.filter(e => e.entryType === 'trace').length;
                const writeoffsCount = hop.entries.filter(e => e.entryType === 'writeoff').length;
                const totalAccountedDisplay = Object.entries(entryTotalsByCurrency)
                    .map(([curr, amt]) => `${amt.toLocaleString()} ${curr}`)
                    .join(' | ');
                
                hopDiv.innerHTML = `
                    <div class="hop-container" data-hop-id="${hop.id}" style="background: ${hopBgColor}; border-radius: 12px; margin-bottom: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.08); overflow: hidden;">
                        <div class="hop-header" style="background: ${isComplete ? '#27ae60' : '#e67e22'}; color: white; padding: ${isCollapsed ? '12px 20px' : '20px'}; cursor: pointer;" 
                             onclick="toggleHopCollapse(${hop.id})">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div style="display: flex; align-items: center; gap: 15px;">
                                    <span style="font-size: 24px; transform: rotate(${isCollapsed ? '0' : '90'}deg); transition: transform 0.3s;">
                                        
                                    </span>
                                    <div>
                                        <h2 style="margin: 0; font-size: 1.5rem;"> Hop ${hop.hopNumber}</h2>
                                        <div style="font-size: 14px; opacity: 0.9; margin-top: 5px;">
                                            ${isCollapsed ? `${tracesCount} traces, ${writeoffsCount} writeoffs | Total: ${totalAccountedDisplay || '0'}` : `Starting ART: ${artStartDisplay}`}
                                        </div>
                                    </div>
                                </div>
                                <div style="text-align: right;">
                                    <div style="font-weight: bold; font-size: 16px;">
                                        ${hop.needsValidation ? ' Needs Validation' : isComplete ? ' Complete' : ` In Progress`}
                                    </div>
                                    ${hop.needsValidation ? `
                                        <div style="font-size: 12px; color: #e74c3c; margin-top: 5px;">
                                            Upstream changes detected
                                        </div>
                                    ` : ''}
                                    ${!isCollapsed && remainingDisplay.length > 0 && !isComplete ? 
                                        `<div style="font-size: 12px; opacity: 0.9; margin-top: 5px;">Remaining: ${remainingDisplay.join(' | ')}</div>` : ''
                                    }
                                    ${isComplete ? `
                                        <button class="btn btn-sm" onclick="reopenHop(${hop.id})" 
                                                style="margin-top: 8px; background: #3498db; padding: 6px 12px; font-size: 12px;">
                                             Edit Hop
                                        </button>
                                    ` : ''}
                                    ${hop.needsValidation ? `
                                        <button class="btn btn-sm" onclick="validateAndUpdateHop(${hop.id})" 
                                                style="margin-top: 8px; background: #e74c3c; padding: 6px 12px; font-size: 12px;">
                                             Validate & Update
                                        </button>
                                    ` : ''}
                                </div>
                            </div>
                        </div>
                        
                        <div id="hopContent_${hop.id}" style="display: ${isCollapsed ? 'none' : 'block'}; padding: 20px;">
                            ${!isCollapsed ? `
                                <div style="background: white; padding: 15px; border-radius: 8px; margin-bottom: 15px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                                    <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 15px;">
                                        <div>
                                            <strong>Starting ART:</strong><br>
                                            <span style="color: #2c3e50; font-size: 18px;">${artStartDisplay}</span>
                                        </div>
                                        <div>
                                            <strong>Total Accounted:</strong><br>
                                            <span style="color: #27ae60; font-size: 18px;">${totalAccountedDisplay || '0'}</span>
                                        </div>
                                        ${remainingDisplay.length > 0 && !isComplete ? `
                                            <div>
                                                <strong>Remaining:</strong><br>
                                                <span style="color: #e67e22; font-size: 18px;">${remainingDisplay.join(' | ')}</span>
                                            </div>
                                        ` : ''}
                                    </div>
                                    
                                    <!-- Visual ART Progress Bars -->
                                    <div style="margin-top: 20px;">
                                        ${renderARTProgressBars(hop)}
                                    </div>
                                </div>
                            ` : ''}
                            
                            <div id="hopEntries_${hop.id}">
                                ${(hop.entries || []).map((entry, entryIndex) => renderCollapsibleHopEntry(entry, entryIndex)).join('')}
                            </div>
                            
                            ${!isComplete ? `
                                <div style="margin-top: 15px; padding: 20px; background: white; border-radius: 8px; box-shadow: 0 1px 3px rgba(0,0,0,0.1);">
                                    <h4 style="margin-bottom: 15px; color: #2c3e50;">Add New Entry to Hop ${hop.hopNumber}</h4>
                                    <div style="display: flex; gap: 10px; align-items: center; flex-wrap: wrap;">
                                        <button class="btn btn-primary" onclick="showAddEntryWizard(${hop.id})" 
                                                style="padding: 12px 24px; background: #3498db; color: white; font-size: 16px;">
                                             Add New Entry
                                        </button>
                                        <button class="btn btn-confirm" onclick="finalizeHop(${hop.id})" 
                                                style="margin-left: auto; background: #27ae60; padding: 10px 30px;">
                                             Finalize Hop ${hop.hopNumber}
                                        </button>
                                    </div>
                                </div>
                            ` : ''}
                        </div>
                    </div>
                `;
                container.appendChild(hopDiv);
            });
            
            // Update add hop button and complete investigation section visibility
            updateInvestigationCompletionStatus();
        }

// Get starting ART for a specific hop
function getStartingARTForHop(hopId) {
    const hop = investigation.hops.find(h => h.id === hopId);
    if (!hop) return {};
    
    // Use the stored ART at start for this hop
    return hop.artAtStartByCurrency || {};
}

// Render visual ART progress bars
function renderARTProgressBars(hop) {
    // Get ART data for this hop
    const hopIndex = investigation.hops.findIndex(h => h.id === hop.id);
    const startingART = getStartingARTForHop(hop.id);
    
    // Calculate amounts by category for each currency
    const breakdown = {};
    
    // Initialize with starting ART
    Object.entries(startingART).forEach(([currency, amount]) => {
        if (amount > 0) {
            breakdown[currency] = {
                total: amount,
                traced: 0,
                writeoff: 0,
                coldStorage: 0,
                vasp: 0,
                remaining: amount
            };
        }
    });
    
    // Process entries
    if (hop.entries) {
        hop.entries.forEach(entry => {
        const amount = parseFloat(entry.amount) || 0;
        if (amount > 0 && entry.currency) {
            const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
            
            if (!breakdown[currency]) {
                breakdown[currency] = {
                    total: 0,
                    traced: 0,
                    writeoff: 0,
                    coldStorage: 0,
                    vasp: 0,
                    remaining: 0
                };
            }
            
            switch (entry.entryType) {
                case 'trace':
                    // Check if this trace goes to a VASP/exchange (purple wallet)
                    if (entry.toWalletType === 'purple') {
                        breakdown[currency].vasp += amount;
                    } else {
                        breakdown[currency].traced += amount;
                    }
                    breakdown[currency].remaining -= amount;
                    break;
                case 'writeoff':
                    breakdown[currency].writeoff += amount;
                    breakdown[currency].remaining -= amount;
                    break;
                case 'cold_storage':
                    breakdown[currency].coldStorage += amount;
                    breakdown[currency].remaining -= amount;
                    break;
            }
        }
    });
    }
    
    // Generate progress bars
    let html = '';
    
    Object.entries(breakdown).forEach(([currency, data]) => {
        const total = data.total;
        if (total <= 0) return;
        
        // Calculate percentages
        const tracedPct = (data.traced / total) * 100;
        const writeoffPct = (data.writeoff / total) * 100;
        const coldStoragePct = (data.coldStorage / total) * 100;
        const vaspPct = (data.vasp / total) * 100;
        const remainingPct = (data.remaining / total) * 100;
        
        html += `
            <div style="margin-bottom: 15px;">
                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 5px;">
                    <strong>${currency}</strong>
                    <span style="font-size: 12px; color: #666;">
                        ${data.total.toLocaleString()} total
                    </span>
                </div>
                
                <!-- Progress Bar -->
                <div style="position: relative; height: 30px; background: #f5f5f5; border-radius: 15px; overflow: hidden; box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);">
                    <!-- Traced (Green) -->
                    ${tracedPct > 0 ? `
                        <div style="position: absolute; left: 0; top: 0; height: 100%; width: ${tracedPct}%; background: #27ae60; transition: width 0.3s ease;"
                             title="Traced: ${data.traced.toLocaleString()} ${currency} (${tracedPct.toFixed(1)}%)">
                        </div>
                    ` : ''}
                    
                    <!-- VASP/Exchange (Purple) -->
                    ${vaspPct > 0 ? `
                        <div style="position: absolute; left: ${tracedPct}%; top: 0; height: 100%; width: ${vaspPct}%; background: #9b59b6; transition: all 0.3s ease;"
                             title="Sent to Exchange/VASP: ${data.vasp.toLocaleString()} ${currency} (${vaspPct.toFixed(1)}%)">
                        </div>
                    ` : ''}
                    
                    <!-- Write-off (Gray) -->
                    ${writeoffPct > 0 ? `
                        <div style="position: absolute; left: ${tracedPct + vaspPct}%; top: 0; height: 100%; width: ${writeoffPct}%; background: #95a5a6; transition: all 0.3s ease;"
                             title="Written off: ${data.writeoff.toLocaleString()} ${currency} (${writeoffPct.toFixed(1)}%)">
                        </div>
                    ` : ''}
                    
                    <!-- Cold Storage (Blue) -->
                    ${coldStoragePct > 0 ? `
                        <div style="position: absolute; left: ${tracedPct + vaspPct + writeoffPct}%; top: 0; height: 100%; width: ${coldStoragePct}%; background: #3498db; transition: all 0.3s ease;"
                             title="Cold Storage: ${data.coldStorage.toLocaleString()} ${currency} (${coldStoragePct.toFixed(1)}%)">
                        </div>
                    ` : ''}
                    
                    <!-- Remaining (Red) -->
                    ${remainingPct > 0.1 ? `
                        <div style="position: absolute; left: ${tracedPct + vaspPct + writeoffPct + coldStoragePct}%; top: 0; height: 100%; width: ${remainingPct}%; background: #e74c3c; transition: all 0.3s ease;"
                             title="Remaining to account: ${data.remaining.toLocaleString()} ${currency} (${remainingPct.toFixed(1)}%)">
                        </div>
                    ` : ''}
                    
                    <!-- Percentage labels -->
                    <div style="position: absolute; width: 100%; height: 100%; display: flex; align-items: center; padding: 0 10px; pointer-events: none;">
                        ${tracedPct > 15 ? `
                            <span style="color: white; font-size: 11px; font-weight: bold; text-shadow: 1px 1px 2px rgba(0,0,0,0.3);">
                                ${tracedPct.toFixed(0)}%
                            </span>
                        ` : ''}
                    </div>
                </div>
                
                <!-- Legend -->
                <div style="display: flex; gap: 15px; margin-top: 8px; font-size: 11px; flex-wrap: wrap;">
                    ${data.traced > 0 ? `
                        <span style="display: flex; align-items: center; gap: 5px;">
                            <span style="width: 12px; height: 12px; background: #27ae60; border-radius: 2px;"></span>
                            Traced: ${data.traced.toLocaleString()}
                        </span>
                    ` : ''}
                    ${data.vasp > 0 ? `
                        <span style="display: flex; align-items: center; gap: 5px;">
                            <span style="width: 12px; height: 12px; background: #9b59b6; border-radius: 2px;"></span>
                            Exchange/VASP: ${data.vasp.toLocaleString()}
                        </span>
                    ` : ''}
                    ${data.writeoff > 0 ? `
                        <span style="display: flex; align-items: center; gap: 5px;">
                            <span style="width: 12px; height: 12px; background: #95a5a6; border-radius: 2px;"></span>
                            Written off: ${data.writeoff.toLocaleString()}
                        </span>
                    ` : ''}
                    ${data.coldStorage > 0 ? `
                        <span style="display: flex; align-items: center; gap: 5px;">
                            <span style="width: 12px; height: 12px; background: #3498db; border-radius: 2px;"></span>
                            Cold Storage: ${data.coldStorage.toLocaleString()}
                        </span>
                    ` : ''}
                    ${data.remaining > 0 ? `
                        <span style="display: flex; align-items: center; gap: 5px;">
                            <span style="width: 12px; height: 12px; background: #e74c3c; border-radius: 2px;"></span>
                            Remaining: ${data.remaining.toLocaleString()}
                        </span>
                    ` : ''}
                </div>
            </div>
        `;
    });
    
    return html || '<div style="text-align: center; color: #999;">No ART data to display</div>';
}

// Show modal for ART completion options
function showARTCompletionModal(hop, validation) {
    const modalHTML = `
        <div id="artCompletionModal" class="modal" style="display: block;">
            <div class="modal-content">
                <div class="modal-header">
                    <h2> Complete ART Balance for Hop ${hop.hopNumber}</h2>
                    <p>All ART must be accounted for before starting the next hop</p>
                </div>
                
                <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 20px; margin: 20px 0;">
                    <h4 style="color: #856404; margin-bottom: 15px;">Unaccounted Amounts:</h4>
                    ${Object.entries(validation.remainingByCurrency).map(([currency, amount]) => 
                        amount > 0 ? `
                            <div style="margin-bottom: 15px; padding: 15px; background: white; border-radius: 6px; border-left: 4px solid #ffc107;">
                                <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 10px;">
                                    <strong>${currency}: ${amount.toLocaleString()} remaining</strong>
                                </div>
                                <div style="display: flex; gap: 10px;">
                                    <button class="btn btn-danger" onclick="createMaxWriteoff(${hop.id}, '${currency}', ${amount})">
                                         Write Off All ${amount.toLocaleString()} ${currency}
                                    </button>
                                    <button class="btn" style="background: #3498db;" onclick="createColdStorage(${hop.id}, '${currency}', ${amount})">
                                         Mark as Cold Storage
                                    </button>
                                </div>
                                <div style="margin-top: 10px; font-size: 12px; color: #666;">
                                    Or manually add trace/write-off entries to account for this amount
                                </div>
                            </div>
                        ` : ''
                    ).join('')}
                </div>
                
                <div style="text-align: center; margin-top: 25px;">
                    <button class="btn btn-secondary" onclick="closeARTCompletionModal()">
                        Cancel - Return to Fix Hop ${hop.hopNumber}
                    </button>
                </div>
            </div>
        </div>
    `;
    
    // Create centered modal
    createCenteredModal('artCompletionModal', modalHTML);
}

// Create maximum write-off entry to balance ART
function createMaxWriteoff(hopId, currency, amount) {
    const hop = investigation.hops.find(h => h.id === hopId);
    if (!hop) return;
    
    const writeoffEntry = {
        id: hop.entries.length + 1,
        hopId: hopId,
        hopNumber: hop.hopNumber,
        entryType: 'writeoff',
        notation: '',
        amount: amount.toString(),
        currency: currency,
        customCurrency: currency === 'CUSTOM' ? currency : '',
        category: 'operational',
        justification: `ART balancing write-off: ${amount.toLocaleString()} ${currency} to complete hop accounting`,
        // Enhanced fields
        sourceChain: [],
        displayNotation: '',
        summaryNotation: '',
        victimNumbers: '',
        transactionNumbers: '',
        availableSourceAmount: 0,
        sourceThreadId: '',
        sourceThreadData: null,
        assignmentPercentage: 0,
        generatedNotation: '',
        isConvergence: false,
        convergenceData: null,
        fromWallet: '',
        fromWalletType: '',
        fromWalletId: '',
        toWallet: '',
        toWalletType: '',
        toWalletId: '',
        txHash: '',
        timestamp: '',
        timezone: 'UTC',
        notes: `Auto-generated to balance ART for hop completion`
    };
    
    hop.entries.push(writeoffEntry);
    
    // Sort entries chronologically
    sortHopEntriesChronologically(hop);
    
    closeARTCompletionModal();
    renderHops();
    saveToStorage();
    
    alert(` Write-off created for ${amount.toLocaleString()} ${currency}. Hop ${hop.hopNumber} is now balanced.`);
}

// Create cold storage entry to account for funds
function createColdStorage(hopId, currency, amount) {
    const hop = investigation.hops.find(h => h.id === hopId);
    if (!hop) return;
    
    // Find the most recent trace entry with the same currency to get wallet info
    let sourceWallet = '';
    let sourceWalletType = '';
    
    for (let i = hop.entries.length - 1; i >= 0; i--) {
        const entry = hop.entries[i];
        const entryCurrency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
        if (entry.entryType === 'trace' && entryCurrency === currency && entry.toWallet) {
            sourceWallet = entry.toWallet;
            sourceWalletType = entry.toWalletType || 'black';
            break;
        }
    }
    
    const coldStorageEntry = {
        id: hop.entries.length + 1,
        hopId: hopId,
        hopNumber: hop.hopNumber,
        entryType: 'cold_storage',
        notation: '',
        amount: amount.toString(),
        currency: currency,
        customCurrency: currency === 'CUSTOM' ? currency : '',
        category: '',
        justification: '',
        // Enhanced fields
        sourceChain: [],
        displayNotation: '',
        summaryNotation: '',
        victimNumbers: '',
        transactionNumbers: '',
        availableSourceAmount: 0,
        sourceThreadId: '',
        sourceThreadData: null,
        assignmentPercentage: 0,
        generatedNotation: '',
        isConvergence: false,
        convergenceData: null,
        fromWallet: sourceWallet,
        fromWalletType: sourceWalletType,
        fromWalletId: '',
        toWallet: sourceWallet, // Same wallet, marking as cold storage
        toWalletType: 'blue', // BLUE = Cold Storage
        toWalletId: '',
        txHash: '',
        timestamp: '',
        timezone: 'UTC',
        notes: `Auto-generated cold storage classification: ${amount.toLocaleString()} ${currency} remains in this wallet`
    };
    
    hop.entries.push(coldStorageEntry);
    
    // Sort entries chronologically
    sortHopEntriesChronologically(hop);
    
    closeARTCompletionModal();
    renderHops();
    saveToStorage();
    
    alert(` Cold storage entry created for ${amount.toLocaleString()} ${currency}. Funds marked as BLUE (cold storage) in current wallet.`);
}

// Close ART completion modal
function closeARTCompletionModal() {
    const modal = document.getElementById('artCompletionModal');
    if (modal) {
        modal.remove();
    }
}
// Main function to finalize a hop with all validation and options
// Analyze which wallets have untraced balances
function analyzeUntracedBalances(hop) {
    const walletBalances = {};
    
    // Calculate incoming amounts to each wallet in this hop
    hop.entries.forEach(entry => {
        if (entry.entryType === 'trace' && entry.toWallet && parseFloat(entry.amount) > 0) {
            const wallet = entry.toWallet;
            const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
            const key = `${wallet}|${currency}`;
            
            if (!walletBalances[key]) {
                walletBalances[key] = {
                    wallet: wallet,
                    walletType: entry.toWalletType,
                    currency: currency,
                    incoming: 0,
                    outgoing: 0,
                    balance: 0
                };
            }
            walletBalances[key].incoming += parseFloat(entry.amount);
        }
    });
    
    // Check if these wallets have outgoing transactions in the next hop
    const nextHopNumber = hop.hopNumber + 1;
    const nextHop = investigation.hops.find(h => h.hopNumber === nextHopNumber);
    
    if (nextHop) {
        nextHop.entries.forEach(entry => {
            if (entry.sourceThreadId) {
                // Parse the source thread to find the originating wallet
                const sourceMatch = entry.sourceThreadId.match(/H(\d+)$/);
                if (sourceMatch && parseInt(sourceMatch[1]) === hop.hopNumber) {
                    // This entry sources from the current hop
                    // Find which wallet it came from by checking the current hop's entries
                    hop.entries.forEach(hopEntry => {
                        if (hopEntry.notation === entry.sourceThreadId.replace(/-H\d+$/, '') && hopEntry.toWallet) {
                            const wallet = hopEntry.toWallet;
                            const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                            const key = `${wallet}|${currency}`;
                            
                            if (walletBalances[key]) {
                                walletBalances[key].outgoing += parseFloat(entry.amount);
                            }
                        }
                    });
                }
            }
        });
    }
    
    // Calculate final balances and identify wallets with remaining funds
    const walletsWithFunds = [];
    Object.values(walletBalances).forEach(wb => {
        wb.balance = wb.incoming - wb.outgoing;
        if (wb.balance > 0.01) {  // Only consider significant balances
            walletsWithFunds.push({
                wallet: wb.wallet,
                walletType: wb.walletType,
                currency: wb.currency,
                remainingBalance: wb.balance,
                suggestColdStorage: wb.walletType !== 'blue' && wb.walletType !== 'purple' && wb.walletType !== 'gray'
            });
        }
    });
    
    return walletsWithFunds;
}

// New function to show comprehensive hop finalization summary
function showHopFinalizationSummary(hop, remainingByCurrency, walletsWithRemainingFunds) {
    // Calculate threads created in this hop
    const threadsCreated = [];
    hop.entries.forEach(entry => {
        if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0 && entry.notation) {
            const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
            threadsCreated.push({
                notation: entry.notation,
                amount: parseFloat(entry.amount),
                currency: currency,
                toWallet: entry.toWallet,
                toWalletType: entry.toWalletType
            });
        }
    });
    
    // Calculate balance status
    const isBalanced = Object.keys(remainingByCurrency).length === 0;
    const balanceStatusHTML = isBalanced ? `
        <div style="background: #d4edda; border: 2px solid #27ae60; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
            <h3 style="color: #155724; margin-top: 0;"> Hop is Balanced!</h3>
            <p style="color: #155724; margin-bottom: 0;">All Available Running Total (ART) has been accounted for. You can proceed to the next hop.</p>
        </div>
    ` : `
        <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
            <h3 style="color: #856404; margin-top: 0;"> Hop Has Unaccounted Amounts</h3>
            <p style="color: #856404;">The following amounts need to be accounted for before proceeding:</p>
            <ul style="margin-bottom: 0;">
                ${Object.entries(remainingByCurrency).map(([currency, amount]) => 
                    `<li><strong>${amount.toLocaleString()} ${currency}</strong> remaining</li>`
                ).join('')}
            </ul>
        </div>
    `;
    
    // Thread summary
    const threadSummaryHTML = threadsCreated.length > 0 ? `
        <div style="background: #e3f2fd; border: 2px solid #2196f3; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
            <h3 style="color: #0d47a1; margin-top: 0;"> Threads Created in Hop ${hop.hopNumber}</h3>
            <p style="color: #0d47a1; margin-bottom: 15px;">These threads will be available for tracing in Hop ${hop.hopNumber + 1}:</p>
            <div style="max-height: 200px; overflow-y: auto;">
                ${threadsCreated.map(thread => `
                    <div style="background: white; padding: 10px; margin-bottom: 10px; border-radius: 4px; border-left: 4px solid #2196f3;">
                        <strong>${thread.notation}</strong> - ${thread.amount.toLocaleString()} ${thread.currency}
                        <br><span style="font-size: 12px; color: #666;">To: ${thread.toWallet.substring(0, 16)}... (${walletTypes[thread.toWalletType] || thread.toWalletType})</span>
                    </div>
                `).join('')}
            </div>
        </div>
    ` : '';
    
    const modalHTML = `
        <div id="hopFinalizationModal" class="modal" style="display: block;">
            <div class="modal-content" style="max-width: 800px; max-height: 90vh; overflow-y: auto;">
                <div class="modal-header">
                    <h2> Finalize Hop ${hop.hopNumber}</h2>
                    <p>Review hop summary and balance any remaining amounts</p>
                </div>
                
                ${balanceStatusHTML}
                ${threadSummaryHTML}
                
                ${!isBalanced ? `
                    <div style="margin-bottom: 20px;">
                        <h3>Balance Remaining Amounts</h3>
                        <p style="color: #666; margin-bottom: 15px;">Choose how to account for the remaining amounts. These options close out funds without creating new threads:</p>
                        
                        ${Object.entries(remainingByCurrency).map(([currency, amount]) => `
                            <div style="background: white; border: 2px solid #ddd; border-radius: 8px; padding: 20px; margin-bottom: 15px;">
                                <h4 style="margin-top: 0;">${amount.toLocaleString()} ${currency} Remaining</h4>
                                <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 10px;">
                                    <button class="btn btn-warning" onclick="writeOffAmount(${hop.id}, '${currency}', ${amount})">
                                         Write Off
                                    </button>
                                    <button class="btn btn-primary" onclick="markAsColdStorage(${hop.id}, '${currency}', ${amount})">
                                         Cold Storage
                                    </button>
                                    <button class="btn btn-success" onclick="markAsVASPArrival(${hop.id}, '${currency}', ${amount})">
                                         VASP Arrival
                                    </button>
                                    <button class="btn btn-secondary" onclick="assignPartialAmount(${hop.id}, '${currency}', ${amount})">
                                         Split Amount
                                    </button>
                                </div>
                            </div>
                        `).join('')}
                    </div>
                ` : ''}
                
                <div style="margin-top: 30px; padding-top: 20px; border-top: 2px solid #e0e0e0; text-align: center;">
                    ${isBalanced ? `
                        <button class="btn btn-success btn-large" onclick="proceedWithHopFinalization(investigation.hops.find(h => h.id === ${hop.id}))">
                             Complete Hop ${hop.hopNumber}
                        </button>
                    ` : `
                        <p style="color: #666; margin-bottom: 10px;">Balance all remaining amounts to proceed</p>
                        <button class="btn btn-secondary" onclick="closeFinalizationModal()">
                            Cancel
                        </button>
                    `}
                </div>
            </div>
        </div>
    `;
    
    document.body.insertAdjacentHTML('beforeend', modalHTML);
}

function closeFinalizationModal() {
    const modal = document.getElementById('hopFinalizationModal');
    if (modal) modal.remove();
}

function finalizeHop(hopId) {
    const hop = investigation.hops.find(h => h.id === hopId);
    if (!hop) {
        alert('Hop not found');
        return;
    }
    
    // Validate all source threads are accounted for
    const validation = validateHopCompletion(hopId);
    
    // Calculate remaining ART by currency
    const remainingByCurrency = {};
    const startingART = hop.artAtStartByCurrency || {};
    const entryTotalsByCurrency = {};
    
    // Calculate totals from entries (including all entry types that account for funds)
    hop.entries.forEach(entry => {
        if (parseFloat(entry.amount) > 0) {
            const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
            if (!entryTotalsByCurrency[currency]) {
                entryTotalsByCurrency[currency] = 0;
            }
            // Include all entry types that account for funds
            if (['trace', 'writeoff', 'cold_storage', 'vasp_arrival'].includes(entry.entryType)) {
                entryTotalsByCurrency[currency] += parseFloat(entry.amount);
            }
        }
    });
    
    // Calculate remaining amounts
    Object.entries(startingART).forEach(([currency, startAmount]) => {
        const tracedAmount = entryTotalsByCurrency[currency] || 0;
        const remaining = startAmount - tracedAmount;
        if (Math.abs(remaining) >= 0.01) {
            remainingByCurrency[currency] = remaining;
        }
    });
    
    // Analyze wallets with untraced balances
    const walletsWithRemainingFunds = analyzeUntracedBalances(hop);
    
    // Always show finalization summary, even if balanced
    showHopFinalizationSummary(hop, remainingByCurrency, walletsWithRemainingFunds);
}

// Proceed with hop finalization after all amounts are accounted for
function proceedWithHopFinalization(hop) {
    // Check wallet classifications for suggestions
    const walletSuggestions = analyzeWalletBehaviors(hop);
    
    if (walletSuggestions.length > 0) {
        showWalletClassificationSuggestions(hop, walletSuggestions);
    } else {
        // No suggestions, complete the hop
        hop.completed = true;
        
        // Auto-collapse the completed hop
        window.hopCollapseState[hop.id] = true;
        
        saveToStorage();
        renderHops();
        updateInvestigationCompletionStatus();
        
        // Trigger autosave after hop completion
        if (isFileSystemAvailable) {
            autosaveInvestigation();
        }
        
        alert(` Hop ${hop.hopNumber} finalized successfully! All amounts balanced.`);
    }
}

// Analyze wallet behaviors for classification suggestions
function analyzeWalletBehaviors(hop) {
    const suggestions = [];
    const walletAnalysis = {};
    
    // Analyze each wallet in the hop
    hop.entries.forEach(entry => {
        if (entry.entryType === 'trace' && entry.toWallet) {
            const wallet = entry.toWallet;
            if (!walletAnalysis[wallet]) {
                walletAnalysis[wallet] = {
                    incomingCount: 0,
                    outgoingCount: 0,
                    currencies: new Set(),
                    totalAmount: 0,
                    currentType: entry.toWalletType || 'black'
                };
            }
            walletAnalysis[wallet].incomingCount++;
            walletAnalysis[wallet].currencies.add(entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency);
            walletAnalysis[wallet].totalAmount += parseFloat(entry.amount);
        }
    });
    
    // Check previous hops for outgoing transactions
    investigation.hops.forEach(h => {
        if (h.id !== hop.id) {
            h.entries.forEach(entry => {
                if (entry.entryType === 'trace' && entry.fromWallet && walletAnalysis[entry.fromWallet]) {
                    walletAnalysis[entry.fromWallet].outgoingCount++;
                }
            });
        }
    });
    
    // Generate suggestions based on behavior
    Object.entries(walletAnalysis).forEach(([wallet, analysis]) => {
        // Yellow wallet: Multiple incoming transactions (convergence)
        if (analysis.incomingCount >= 2 && analysis.currentType !== 'yellow') {
            suggestions.push({
                wallet: wallet,
                suggestedType: 'yellow',
                reason: `Convergence detected: ${analysis.incomingCount} incoming transactions`,
                currentType: analysis.currentType
            });
        }
        
        // Brown wallet: Multiple currencies (conversion)
        if (analysis.currencies.size > 1 && analysis.currentType !== 'brown') {
            suggestions.push({
                wallet: wallet,
                suggestedType: 'brown',
                reason: `Conversion detected: handles ${analysis.currencies.size} different currencies`,
                currentType: analysis.currentType
            });
        }
        
        // Blue wallet logic removed - will be handled at hop finalization
        // when we can properly identify wallets with untraced remaining balances
    });
    
    return suggestions;
}

// Show wallet classification suggestions
function showWalletClassificationSuggestions(hop, suggestions) {
    const modalHTML = `
        <div id="walletSuggestionsModal" class="modal" style="display: block;">
            <div class="modal-content" style="max-width: 800px;">
                <div class="modal-header">
                    <h2> Wallet Classification Suggestions</h2>
                    <p>Based on transaction patterns, we suggest updating these wallet classifications:</p>
                </div>
                
                <div style="margin: 20px 0;">
                    ${suggestions.map((suggestion, index) => `
                        <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid ${getWalletColor(suggestion.suggestedType)};">
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <strong style="font-family: monospace;">${suggestion.wallet.substring(0, 20)}...</strong><br>
                                    <span style="color: #666;">Current: ${walletTypes[suggestion.currentType] || suggestion.currentType}</span><br>
                                    <span style="color: ${getWalletColor(suggestion.suggestedType)};">Suggested: ${walletTypes[suggestion.suggestedType]}</span><br>
                                    <small style="color: #666;">${suggestion.reason}</small>
                                </div>
                                <div>
                                    <button class="btn btn-confirm" onclick="acceptWalletSuggestion('${suggestion.wallet}', '${suggestion.suggestedType}', ${index})">
                                         Accept
                                    </button>
                                    <button class="btn btn-secondary" onclick="declineWalletSuggestion(${index})">
                                         Decline
                                    </button>
                                </div>
                            </div>
                        </div>
                    `).join('')}
                </div>
                
                <div style="text-align: center;">
                    <button class="btn btn-confirm" onclick="completeWalletSuggestions(${hop.id})">
                        Continue to Complete Hop ${hop.hopNumber}
                    </button>
                </div>
            </div>
        </div>
    `;
    
    createCenteredModal('walletSuggestionsModal', modalHTML);
}

// Accept wallet classification suggestion
function acceptWalletSuggestion(walletAddress, newType, suggestionIndex) {
    // Update wallet in UWI
    const wallet = investigation.universalWalletIndex.find(w => w.address === walletAddress);
    if (wallet) {
        wallet.permanentType = newType;
        wallet.currentStatus = newType;
        wallet.statusHistory.push(newType);
        
        // Retroactively update all entries with this wallet
        updateWalletClassificationRetroactively(walletAddress, newType);
    }
    
    // Hide this suggestion
    const suggestionDiv = document.querySelectorAll('#walletSuggestionsModal .modal-content > div')[1].children[suggestionIndex];
    suggestionDiv.style.display = 'none';
    
    saveToStorage();
}

// Decline wallet classification suggestion
function declineWalletSuggestion(suggestionIndex) {
    const suggestionDiv = document.querySelectorAll('#walletSuggestionsModal .modal-content > div')[1].children[suggestionIndex];
    suggestionDiv.style.display = 'none';
}

// Complete wallet suggestions and finalize hop
function completeWalletSuggestions(hopId) {
    const modal = document.getElementById('walletSuggestionsModal');
    if (modal) modal.remove();
    
    const hop = investigation.hops.find(h => h.id === hopId);
    if (hop) {
        hop.completed = true;
        saveToStorage();
        renderHops();
        updateInvestigationCompletionStatus();
        
        alert(` Hop ${hop.hopNumber} finalized successfully!`);
    }
}

// Open Smart Allocation Modal
function openSmartAllocationModal(hopId, entryId) {
    const hop = investigation.hops.find(h => h.id === hopId);
    const entry = hop.entries.find(e => e.id === entryId);
    
    if (!hop || !entry) {
        alert('Error: Could not find hop or entry');
        return;
    }
    
    // Store current context
    window.smartAllocationContext = {
        hopId: hopId,
        entryId: entryId,
        hop: hop,
        entry: entry
    };
    
    // Get available currencies from sources
    const availableSourcesAll = getAvailableSourcesForHop(hop.hopNumber, null);
    const availableCurrencies = [...new Set(availableSourcesAll.map(s => s.currency))];
    
    // Populate currency dropdown
    const currencySelect = document.getElementById('smartAllocationTargetCurrency');
    currencySelect.innerHTML = '<option value="">Select currency...</option>' + 
        availableCurrencies.map(curr => {
            const currencyName = currencies[curr]?.name || curr;
            return `<option value="${curr}">${currencyName}</option>`;
        }).join('');
    
    // Clear previous state
    document.getElementById('smartAllocationTargetAmount').value = '';
    document.getElementById('smartAllocationAvailableSources').style.display = 'none';
    document.getElementById('smartAllocationPreview').style.display = 'none';
    document.getElementById('smartAllocationError').style.display = 'none';
    document.getElementById('confirmSmartAllocation').style.display = 'none';
    
    // Show modal
    showModal('smartAllocationModal');
    
    // Add event listeners
    document.getElementById('smartAllocationTargetAmount').addEventListener('input', updateSmartAllocationPreview);
    document.getElementById('smartAllocationTargetCurrency').addEventListener('change', function() {
        // Update step value when currency changes
        const currency = this.value;
        const amountInput = document.getElementById('smartAllocationTargetAmount');
        if (currency && amountInput) {
            amountInput.step = getCurrencyStep(currency);
        }
        updateSmartAllocationPreview();
    });
}

// Close Smart Allocation Modal
function closeSmartAllocationModal() {
    hideModal('smartAllocationModal');
    window.smartAllocationContext = null;
}

// Update Smart Allocation Preview
function updateSmartAllocationPreview() {
    const targetAmount = parseFloat(document.getElementById('smartAllocationTargetAmount').value);
    const targetCurrency = document.getElementById('smartAllocationTargetCurrency').value;
    
    if (!targetAmount || !targetCurrency || targetAmount <= 0) {
        document.getElementById('smartAllocationAvailableSources').style.display = 'none';
        document.getElementById('smartAllocationPreview').style.display = 'none';
        document.getElementById('smartAllocationError').style.display = 'none';
        document.getElementById('confirmSmartAllocation').style.display = 'none';
        return;
    }
    
    const context = window.smartAllocationContext;
    if (!context) return;
    
    // Get available sources for this currency
    const availableSources = getAvailableSourcesForHop(context.hop.hopNumber, targetCurrency);
    
    // Show available sources
    const sourcesListDiv = document.getElementById('availableSourcesList');
    sourcesListDiv.innerHTML = availableSources.map(source => `
        <div style="padding: 10px; margin-bottom: 5px; background: #f8f9fa; border-radius: 6px; border-left: 4px solid #3498db;">
            <div style="display: flex; justify-content: space-between; align-items: center;">
                <strong>${source.threadId}</strong>
                <span style="color: #27ae60; font-weight: bold;">${source.availableAmount.toLocaleString()} ${source.currency}</span>
            </div>
            <div style="font-size: 11px; color: #666; margin-top: 3px;">
                ${source.sourceType === 'victim_transaction' ? 'Victim Transaction (RED Wallet)' : 'Previous Hop Output'}
            </div>
        </div>
    `).join('');
    document.getElementById('smartAllocationAvailableSources').style.display = 'block';
    
    // Calculate allocation
    const allocation = calculateSmartAllocation(availableSources, targetAmount);
    
    if (allocation.error) {
        document.getElementById('smartAllocationError').innerHTML = ` ${allocation.error}`;
        document.getElementById('smartAllocationError').style.display = 'block';
        document.getElementById('smartAllocationPreview').style.display = 'none';
        document.getElementById('confirmSmartAllocation').style.display = 'none';
    } else {
        document.getElementById('smartAllocationError').style.display = 'none';
        
        // Show allocation preview
        const previewContent = document.getElementById('allocationPreviewContent');
        previewContent.innerHTML = `
            <div style="background: #f8f9fa; border: 1px solid #ddd; border-radius: 6px; padding: 15px;">
                ${allocation.allocations.map(alloc => `
                    <div style="margin-bottom: 10px; padding: 10px; background: white; border-radius: 4px; border-left: 4px solid ${alloc.fullyUsed ? '#e74c3c' : '#27ae60'};">
                        <div style="display: flex; justify-content: space-between; align-items: center;">
                            <strong>${alloc.threadId}</strong>
                            <span style="color: ${alloc.fullyUsed ? '#e74c3c' : '#27ae60'};">
                                Use ${alloc.amountToUse.toLocaleString()} of ${alloc.availableAmount.toLocaleString()} ${targetCurrency}
                            </span>
                        </div>
                        ${alloc.fullyUsed ? 
                            '<div style="font-size: 11px; color: #e74c3c; margin-top: 3px;"> Fully depleted</div>' : 
                            `<div style="font-size: 11px; color: #666; margin-top: 3px;">${alloc.remaining.toLocaleString()} ${targetCurrency} will remain</div>`
                        }
                    </div>
                `).join('')}
                
                <div style="margin-top: 15px; padding-top: 10px; border-top: 1px solid #ddd;">
                    <div style="display: flex; justify-content: space-between; align-items: center;">
                        <strong>Total Allocated:</strong>
                        <span style="color: #27ae60; font-size: 18px; font-weight: bold;">
                            ${allocation.totalAllocated.toLocaleString()} ${targetCurrency}
                        </span>
                    </div>
                    ${allocation.totalAllocated < targetAmount ? 
                        `<div style="color: #e74c3c; font-size: 12px; margin-top: 5px;">
                             Only ${allocation.totalAllocated.toLocaleString()} of ${targetAmount.toLocaleString()} ${targetCurrency} available
                        </div>` : ''
                    }
                </div>
            </div>
        `;
        
        document.getElementById('smartAllocationPreview').style.display = 'block';
        document.getElementById('confirmSmartAllocation').style.display = 'inline-block';
        
        // Store allocation for confirmation
        window.smartAllocationContext.allocation = allocation;
        window.smartAllocationContext.targetCurrency = targetCurrency;
    }
}

// Calculate Smart Allocation
function calculateSmartAllocation(sources, targetAmount) {
    let remainingAmount = targetAmount;
    const allocations = [];
    let totalAllocated = 0;
    
    for (const source of sources) {
        if (remainingAmount <= 0) break;
        
        const amountToUse = Math.min(source.availableAmount, remainingAmount);
        allocations.push({
            threadId: source.threadId,
            availableAmount: source.availableAmount,
            amountToUse: amountToUse,
            remaining: source.availableAmount - amountToUse,
            fullyUsed: amountToUse === source.availableAmount
        });
        
        totalAllocated += amountToUse;
        remainingAmount -= amountToUse;
    }
    
    if (totalAllocated < targetAmount) {
        const totalAvailable = sources.reduce((sum, s) => sum + s.availableAmount, 0);
        if (totalAvailable < targetAmount) {
            return {
                error: `Insufficient funds. Only ${totalAvailable.toLocaleString()} available, but ${targetAmount.toLocaleString()} requested.`,
                totalAvailable: totalAvailable
            };
        }
    }
    
    return {
        allocations: allocations,
        totalAllocated: totalAllocated,
        success: true
    };
}

// Confirm and Apply Smart Allocation
function confirmSmartAllocation() {
    const context = window.smartAllocationContext;
    if (!context || !context.allocation) return;
    
    const entry = context.entry;
    const allocation = context.allocation;
    const targetCurrency = context.targetCurrency;
    
    // Set up multiple source threads
    entry.multipleSourceThreads = allocation.allocations.map(a => a.threadId);
    entry.individualSourceAssignments = {};
    allocation.allocations.forEach(alloc => {
        entry.individualSourceAssignments[alloc.threadId] = alloc.amountToUse;
    });
    
    // Set total amount and currency, preserving full precision
    entry.amount = formatCurrencyAmount(allocation.totalAllocated, targetCurrency, true);
    entry.currency = targetCurrency;
    
    // Mark as convergence if multiple sources
    if (allocation.allocations.length > 1) {
        entry.isConvergence = true;
        entry.convergenceData = {
            sourceCount: allocation.allocations.length,
            sources: allocation.allocations
        };
    }
    
    // Close modal
    closeSmartAllocationModal();
    
    // Re-render the hop entries
    renderHops();
    saveToStorage();
    
    alert(` Smart allocation applied: ${allocation.totalAllocated.toLocaleString()} ${targetCurrency} allocated across ${allocation.allocations.length} source(s)`);
}

// Original smart allocation function (keep for compatibility)
function smartAllocateAmount(hopId, entryId) {
    // Redirect to the new modal-based approach
    openSmartAllocationModal(hopId, entryId);
}

// Clear all allocations
function clearAllAllocations(hopId, entryId) {
    const hop = investigation.hops.find(h => h.id === hopId);
    const entry = hop.entries.find(e => e.id === entryId);
    
    entry.multipleSourceThreads = [];
    entry.individualSourceAssignments = {};
    entry.sourceThreadId = '';
    entry.amount = '';
    
    const previewDiv = document.getElementById(`smartAllocationPreview_${hopId}_${entryId}`);
    if (previewDiv) {
        previewDiv.innerHTML = '';
    }
    
    const targetAmountInput = document.getElementById(`targetAmount_${hopId}_${entryId}`);
    if (targetAmountInput) {
        targetAmountInput.value = '';
    }
    
    renderHops();
    saveToStorage();
}

// Get wallet color based on type
function getWalletColor(walletType) {
    const colorMap = {
        'red': '#e74c3c',
        'pink': '#e91e63',
        'yellow': '#f1c40f',
        'orange': '#ff9800',
        'brown': '#795548',
        'black': '#2c3e50',
        'blue': '#3498db',
        'purple': '#9b59b6',
        'gray': '#95a5a6',
        'green': '#27ae60'
    };
    return colorMap[walletType] || '#95a5a6';
}

// Update wallet classification retroactively across all entries
function updateWalletClassificationRetroactively(walletAddress, newType) {
    // Update all hop entries with this wallet
    investigation.hops.forEach(hop => {
        hop.entries.forEach(entry => {
            if (entry.toWallet === walletAddress) {
                entry.toWalletType = newType;
                if (entry.toWalletId) {
                    // Update wallet ID if it exists
                    const wallet = investigation.universalWalletIndex.find(w => w.address === walletAddress);
                    if (wallet) {
                        entry.toWalletId = wallet.permanentId;
                    }
                }
            }
            if (entry.fromWallet === walletAddress) {
                entry.fromWalletType = newType;
                if (entry.fromWalletId) {
                    const wallet = investigation.universalWalletIndex.find(w => w.address === walletAddress);
                    if (wallet) {
                        entry.fromWalletId = wallet.permanentId;
                    }
                }
            }
        });
    });
    
    // Rebuild UWI to ensure consistency
    buildUniversalWalletIndex();
}

// Complete current hop and start the next one
function completeCurrentHopAndStartNext() {
    const lastHop = investigation.hops[investigation.hops.length - 1];
    if (!lastHop) {
        alert('No hop found to complete');
        return;
    }
    
    // Mark the hop as completed
    lastHop.completed = true;
    
    // Save the state
    saveToStorage();
    
    // Add a new hop
    addNewHop();
    
    // Update the display
    renderHops();
    updateInvestigationCompletionStatus();
    
    console.log(` Completed Hop ${lastHop.hopNumber} and started Hop ${lastHop.hopNumber + 1}`);
}

// Show modal for hop finalization options
function showHopFinalizationModal(hop, remainingByCurrency, walletsWithRemainingFunds = []) {
    // Generate wallet suggestions HTML
    let walletSuggestionsHTML = '';
    if (walletsWithRemainingFunds.length > 0) {
        const walletsByCurrency = {};
        walletsWithRemainingFunds.forEach(w => {
            if (!walletsByCurrency[w.currency]) {
                walletsByCurrency[w.currency] = [];
            }
            walletsByCurrency[w.currency].push(w);
        });
        
        walletSuggestionsHTML = `
            <div style="background: #e8f4f8; border: 2px solid #3498db; border-radius: 8px; padding: 20px; margin: 20px 0;">
                <h4 style="color: #2c3e50; margin-bottom: 15px;"> Wallets with Remaining Balances:</h4>
                <p style="margin-bottom: 15px; color: #34495e;">These wallets have funds that are not being traced forward. Consider marking them as cold storage:</p>
                ${Object.entries(walletsByCurrency).map(([currency, wallets]) => `
                    <div style="margin-bottom: 15px;">
                        <strong>${currency}:</strong>
                        ${wallets.map(w => `
                            <div style="margin: 10px 0; padding: 10px; background: white; border-radius: 4px; border-left: 3px solid ${w.suggestColdStorage ? '#3498db' : '#95a5a6'};">
                                <div style="font-family: monospace; font-size: 12px; color: #7f8c8d;">
                                    ${w.wallet.substring(0, 20)}...
                                </div>
                                <div style="margin-top: 5px;">
                                    <strong>${w.remainingBalance.toLocaleString()} ${w.currency}</strong> remaining
                                    ${w.suggestColdStorage ? 
                                        `<span style="color: #3498db; margin-left: 10px;"> Suggest: Mark as Cold Storage</span>` : 
                                        `<span style="color: #95a5a6; margin-left: 10px;">Already classified as ${w.walletType.toUpperCase()}</span>`
                                    }
                                </div>
                            </div>
                        `).join('')}
                    </div>
                `).join('')}
            </div>
        `;
    }
    
    const modalHTML = `
        <div id="hopFinalizationModal" class="modal" style="display: block;">
            <div class="modal-content" style="max-width: 700px;">
                <div class="modal-header">
                    <h2> Finalize Hop ${hop.hopNumber}</h2>
                    <p>Choose how to account for remaining amounts before proceeding to the next hop</p>
                </div>
                
                ${walletSuggestionsHTML}
                
                <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 20px; margin: 20px 0;">
                    <h4 style="color: #856404; margin-bottom: 15px;">Unaccounted Amounts:</h4>
                    ${Object.entries(remainingByCurrency).map(([currency, amount]) => `
                        <div style="margin-bottom: 20px; padding: 15px; background: white; border-radius: 6px; border-left: 4px solid #ffc107;">
                            <div style="font-size: 18px; font-weight: bold; margin-bottom: 15px;">
                                ${currency}: ${amount.toLocaleString()} remaining
                            </div>
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                                <button class="btn btn-danger" onclick="createAutoWriteoff(${hop.id}, '${currency}', ${amount})" style="padding: 15px;">
                                     Automatic Write-off
                                    <div style="font-size: 12px; margin-top: 5px; font-weight: normal;">Mark as unrecoverable</div>
                                </button>
                                <button class="btn" style="background: #3498db; padding: 15px;" onclick="markAsColdStorage(${hop.id}, '${currency}', ${amount})">
                                     Cold Storage
                                    <div style="font-size: 12px; margin-top: 5px; font-weight: normal;">Funds remain in current wallet</div>
                                </button>
                                <button class="btn" style="background: #9b59b6; padding: 15px;" onclick="markAsVASPArrival(${hop.id}, '${currency}', ${amount})">
                                     VASP Arrival
                                    <div style="font-size: 12px; margin-top: 5px; font-weight: normal;">Funds arrived at exchange/service</div>
                                </button>
                                <button class="btn btn-secondary" style="padding: 15px;" onclick="assignPartialAmount(${hop.id}, '${currency}', ${amount})">
                                     Partial Assignment
                                    <div style="font-size: 12px; margin-top: 5px; font-weight: normal;">Split amount across options</div>
                                </button>
                            </div>
                        </div>
                    `).join('')}
                </div>
                
                <div style="text-align: center; margin-top: 25px;">
                    <button class="btn btn-secondary" onclick="closeHopFinalizationModal()">
                        Cancel - Continue Editing Hop ${hop.hopNumber}
                    </button>
                </div>
            </div>
        </div>
    `;
    
    // Remove existing modal if present
    const existingModal = document.getElementById('hopFinalizationModal');
    if (existingModal) {
        existingModal.remove();
    }
    
    // Create centered modal
    createCenteredModal('hopFinalizationModal', modalHTML);
}

// Close hop finalization modal
function closeHopFinalizationModal() {
    const modal = document.getElementById('hopFinalizationModal');
    if (modal) {
        modal.remove();
    }
}

// Create automatic writeoff for remaining amount
function createAutoWriteoff(hopId, currency, amount) {
    const hop = investigation.hops.find(h => h.id === hopId);
    if (!hop) return;
    
    const writeoffEntry = {
        id: hop.entries.length + 1,
        hopId: hopId,
        hopNumber: hop.hopNumber,
        entryType: 'writeoff',
        notation: `H${hop.hopNumber}-WO`,
        amount: amount.toString(),
        currency: currency,
        customCurrency: currency === 'CUSTOM' ? currency : '',
        category: 'operational',
        justification: `Automatic write-off during hop finalization: ${amount.toLocaleString()} ${currency} unaccounted for`,
        // Default fields
        sourceChain: [],
        displayNotation: '',
        summaryNotation: '',
        victimNumbers: '',
        transactionNumbers: '',
        availableSourceAmount: 0,
        sourceThreadId: '',
        sourceThreadData: null,
        assignmentPercentage: 0,
        generatedNotation: '',
        isConvergence: false,
        convergenceData: null,
        fromWallet: '',
        fromWalletType: '',
        fromWalletId: '',
        toWallet: '',
        toWalletType: '',
        toWalletId: '',
        txHash: '',
        timestamp: new Date().toISOString(),
        timezone: 'UTC',
        notes: `Auto-generated during hop ${hop.hopNumber} finalization`
    };
    
    hop.entries.push(writeoffEntry);
    
    // Sort entries chronologically
    sortHopEntriesChronologically(hop);
    
    closeHopFinalizationModal();
    renderHops();
    saveToStorage();
    
    // Close the modal and re-run finalization to refresh the view
    closeFinalizationModal();
    
    // Re-run finalization to show updated state
    setTimeout(() => {
        finalizeHop(hopId);
    }, 100);
}

// Mark funds as cold storage
function markAsColdStorage(hopId, currency, amount) {
    const hop = investigation.hops.find(h => h.id === hopId);
    if (!hop) return;
    
    // Find the most recent wallet that handled this currency
    let lastWallet = '';
    let lastWalletType = 'black';
    
    for (let i = hop.entries.length - 1; i >= 0; i--) {
        const entry = hop.entries[i];
        const entryCurrency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
        if (entry.entryType === 'trace' && entryCurrency === currency && entry.toWallet) {
            lastWallet = entry.toWallet;
            lastWalletType = entry.toWalletType || 'black';
            break;
        }
    }
    
    const coldStorageEntry = {
        id: hop.entries.length + 1,
        hopId: hopId,
        hopNumber: hop.hopNumber,
        entryType: 'trace',
        notation: `H${hop.hopNumber}-CS`,
        amount: amount.toString(),
        currency: currency,
        customCurrency: currency === 'CUSTOM' ? currency : '',
        category: '',
        justification: '',
        // Enhanced fields
        sourceChain: [],
        displayNotation: '',
        summaryNotation: '',
        victimNumbers: '',
        transactionNumbers: '',
        availableSourceAmount: 0,
        sourceThreadId: '',
        sourceThreadData: null,
        assignmentPercentage: 0,
        generatedNotation: '',
        isConvergence: false,
        convergenceData: null,
        fromWallet: lastWallet,
        fromWalletType: lastWalletType,
        fromWalletId: '',
        toWallet: lastWallet,
        toWalletType: 'blue', // BLUE = Cold Storage
        toWalletId: '',
        txHash: '',
        timestamp: new Date().toISOString(),
        timezone: 'UTC',
        notes: `Cold storage: ${amount.toLocaleString()} ${currency} remains in wallet for future movement`
    };
    
    hop.entries.push(coldStorageEntry);
    
    // Sort entries chronologically
    sortHopEntriesChronologically(hop);
    
    // Update wallet classification in UWI
    let walletReclassified = false;
    if (investigation.universalWalletIndex && lastWallet) {
        const walletEntry = investigation.universalWalletIndex.find(w => w.address === lastWallet);
        if (walletEntry && walletEntry.currentStatus !== 'blue') {
            const previousType = walletEntry.currentStatus || 'unknown';
            walletEntry.currentStatus = 'blue';
            walletEntry.statusHistory = walletEntry.statusHistory || [];
            walletEntry.statusHistory.push(`Cold Storage (Hop ${hop.hopNumber})`);
            walletReclassified = true;
            
            // Show notification about wallet reclassification
            setTimeout(() => {
                alert(` Wallet Classification Updated\n\nWallet ${lastWallet.substring(0, 20)}... has been reclassified from ${previousType.toUpperCase()} to BLUE (Cold Storage) based on the remaining balance of ${amount.toLocaleString()} ${currency}.`);
            }, 100);
        }
    }
    
    closeHopFinalizationModal();
    renderHops();
    saveToStorage();
    
    // Close the modal and re-run finalization to refresh the view
    closeFinalizationModal();
    
    // Re-run finalization to show updated state
    setTimeout(() => {
        finalizeHop(hopId);
    }, 100);
}


// Mark funds as arriving at VASP
function markAsVASPArrival(hopId, currency, amount) {
    const hop = investigation.hops.find(h => h.id === hopId);
    if (!hop) return;
    
    // Prompt for VASP details
    const vaspName = prompt('Enter VASP/Exchange name:', 'Exchange');
    if (!vaspName) return;
    
    const vaspEntry = {
        id: hop.entries.length + 1,
        hopId: hopId,
        hopNumber: hop.hopNumber,
        entryType: 'trace',
        notation: `H${hop.hopNumber}-VASP`,
        amount: amount.toString(),
        currency: currency,
        customCurrency: currency === 'CUSTOM' ? currency : '',
        category: '',
        justification: '',
        // Enhanced fields
        sourceChain: [],
        displayNotation: '',
        summaryNotation: '',
        victimNumbers: '',
        transactionNumbers: '',
        availableSourceAmount: 0,
        sourceThreadId: '',
        sourceThreadData: null,
        assignmentPercentage: 0,
        generatedNotation: '',
        isConvergence: false,
        convergenceData: null,
        fromWallet: '',
        fromWalletType: 'black',
        fromWalletId: '',
        toWallet: vaspName,
        toWalletType: 'purple', // PURPLE = VASP
        toWalletId: '',
        txHash: '',
        timestamp: new Date().toISOString(),
        timezone: 'UTC',
        notes: `Funds arrived at VASP: ${vaspName} - ${amount.toLocaleString()} ${currency} (Fully traced)`
    };
    
    hop.entries.push(vaspEntry);
    
    // Sort entries chronologically
    sortHopEntriesChronologically(hop);
    
    // Create a new hop entry for the purple wallet to terminal exchange
    // This ensures the funds continue to be traced to their final destination
    const nextHopNumber = hop.hopNumber + 1;
    let nextHop = investigation.hops.find(h => h.hopNumber === nextHopNumber);
    
    if (!nextHop) {
        // Create the next hop if it doesn't exist
        nextHop = {
            id: investigation.hops.length + 1,
            hopNumber: nextHopNumber,
            entries: [],
            isCollapsed: false
        };
        investigation.hops.push(nextHop);
    }
    
    // Create the terminal exchange entry in the next hop
    const terminalEntry = {
        id: nextHop.entries.length + 1,
        hopId: nextHop.id,
        hopNumber: nextHop.hopNumber,
        entryType: 'trace',
        notation: `H${nextHop.hopNumber}-TERMINAL`,
        amount: amount.toString(),
        currency: currency,
        customCurrency: currency === 'CUSTOM' ? currency : '',
        category: '',
        justification: `Funds from ${vaspName} to terminal exchange wallet`,
        // Source from the VASP entry
        sourceChain: [{
            sourceNotation: vaspEntry.notation,
            amount: amount,
            currency: currency
        }],
        sourceThreadId: vaspEntry.notation,
        fromWallet: vaspName,
        fromWalletType: 'purple',
        toWallet: 'Terminal Exchange Wallet',
        toWalletType: 'purple',
        notes: `Terminal destination for ${amount.toLocaleString()} ${currency} from ${vaspName}`,
        timestamp: new Date().toISOString(),
        timezone: 'UTC'
    };
    
    nextHop.entries.push(terminalEntry);
    
    closeHopFinalizationModal();
    renderHops();
    saveToStorage();
    
    // Close the modal and re-run finalization to refresh the view
    closeFinalizationModal();
    
    // Re-run finalization to show updated state
    setTimeout(() => {
        finalizeHop(hopId);
    }, 100);
}

// Handle partial amount assignment
function assignPartialAmount(hopId, currency, totalAmount) {
    const modalHTML = `
        <div id="partialAssignmentModal" class="modal" style="display: block;">
            <div class="modal-content" style="max-width: 600px;">
                <div class="modal-header">
                    <h2> Partial Amount Assignment</h2>
                    <p>Split ${totalAmount.toLocaleString()} ${currency} across different options</p>
                </div>
                
                <div style="margin: 20px 0;">
                    <div style="margin-bottom: 20px;">
                        <label>Write-off Amount:</label>
                        <input type="number" id="partialWriteoff" step="0.01" min="0" max="${totalAmount}" 
                               value="0" onchange="updatePartialTotal(${totalAmount})">
                    </div>
                    <div style="margin-bottom: 20px;">
                        <label>Cold Storage Amount:</label>
                        <input type="number" id="partialColdStorage" step="0.01" min="0" max="${totalAmount}" 
                               value="0" onchange="updatePartialTotal(${totalAmount})">
                    </div>
                    <div style="margin-bottom: 20px;">
                        <label>VASP Arrival Amount:</label>
                        <input type="number" id="partialVASP" step="0.01" min="0" max="${totalAmount}" 
                               value="0" onchange="updatePartialTotal(${totalAmount})">
                    </div>
                    <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 6px;">
                        <strong>Total Assigned:</strong> <span id="partialTotal">0</span> / ${totalAmount.toLocaleString()} ${currency}
                        <div id="partialValidation" style="margin-top: 10px; color: #e74c3c;"></div>
                    </div>
                </div>
                
                <div style="text-align: center;">
                    <button class="btn btn-confirm" onclick="applyPartialAssignments(${hopId}, '${currency}', ${totalAmount})">
                        Apply Assignments
                    </button>
                    <button class="btn btn-secondary" onclick="closePartialAssignmentModal()">
                        Cancel
                    </button>
                </div>
            </div>
        </div>
    `;
    
    createCenteredModal('partialAssignmentModal', modalHTML);
}

// Update partial assignment total
function updatePartialTotal(totalAmount) {
    const writeoff = parseFloat(document.getElementById('partialWriteoff').value) || 0;
    const coldStorage = parseFloat(document.getElementById('partialColdStorage').value) || 0;
    const vasp = parseFloat(document.getElementById('partialVASP').value) || 0;
    
    const total = writeoff + coldStorage + vasp;
    document.getElementById('partialTotal').textContent = total.toLocaleString();
    
    const validation = document.getElementById('partialValidation');
    if (Math.abs(total - totalAmount) < 0.01) {
        validation.textContent = ' Amounts balance correctly';
        validation.style.color = '#27ae60';
    } else if (total > totalAmount) {
        validation.textContent = ' Total exceeds available amount';
        validation.style.color = '#e74c3c';
    } else {
        validation.textContent = ` ${(totalAmount - total).toLocaleString()} still unassigned`;
        validation.style.color = '#f39c12';
    }
}

// Apply partial assignments
function applyPartialAssignments(hopId, currency, totalAmount) {
    const writeoff = parseFloat(document.getElementById('partialWriteoff').value) || 0;
    const coldStorage = parseFloat(document.getElementById('partialColdStorage').value) || 0;
    const vasp = parseFloat(document.getElementById('partialVASP').value) || 0;
    
    const total = writeoff + coldStorage + vasp;
    if (Math.abs(total - totalAmount) >= 0.01) {
        alert('Assigned amounts must equal the total remaining amount');
        return;
    }
    
    closePartialAssignmentModal();
    closeHopFinalizationModal();
    
    // Apply each assignment
    if (writeoff > 0) {
        createAutoWriteoff(hopId, currency, writeoff);
    }
    if (coldStorage > 0) {
        markAsColdStorage(hopId, currency, coldStorage);
    }
    if (vasp > 0) {
        markAsVASPArrival(hopId, currency, vasp);
    }
}

// Close partial assignment modal
function closePartialAssignmentModal() {
    const modal = document.getElementById('partialAssignmentModal');
    if (modal) {
        modal.remove();
    }
}

// Proceed with hop finalization after ART is balanced
function proceedWithHopFinalization(hop) {
    // Mark hop as completed
    hop.completed = true;
    
    // Analyze wallet behaviors for classification suggestions
    const classificationSuggestions = analyzeWalletBehaviors(hop);
    
    if (classificationSuggestions.length > 0) {
        showWalletClassificationModal(classificationSuggestions, hop.hopNumber, () => {
            // After classification review, confirm hop and create next
            confirmHopAndProceed(hop);
        });
    } else {
        // No classification changes needed, proceed directly
        confirmHopAndProceed(hop);
    }
}

// Confirm hop completion and start next
function confirmHopAndProceed(completedHop) {
    // Show confirmation modal
    const nextHopART = {};
    
    // Calculate starting ART for next hop from trace outputs
    completedHop.entries.forEach(entry => {
        if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0 && entry.toWalletType !== 'purple') {
            const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
            if (!nextHopART[currency]) {
                nextHopART[currency] = 0;
            }
            nextHopART[currency] += parseFloat(entry.amount);
        }
    });
    
    const totalActiveAmount = Object.values(nextHopART).reduce((sum, amount) => sum + amount, 0);
    
    const confirmHTML = `
        <div id="hopConfirmModal" class="modal" style="display: block;">
            <div class="modal-content">
                <div class="modal-header">
                    <h2> Confirm Hop ${completedHop.hopNumber} Completion</h2>
                </div>
                
                <div style="margin: 20px 0;">
                    <p><strong>Hop ${completedHop.hopNumber} Summary:</strong></p>
                    <ul>
                        <li>Total Entries: ${completedHop.entries.length}</li>
                        <li>Traces: ${completedHop.entries.filter(e => e.entryType === 'trace').length}</li>
                        <li>Write-offs: ${completedHop.entries.filter(e => e.entryType === 'writeoff').length}</li>
                    </ul>
                    
                    ${totalActiveAmount > 0 ? `
                        <div style="margin-top: 20px; padding: 15px; background: #d4edda; border: 2px solid #27ae60; border-radius: 8px;">
                            <p><strong>Starting ART for Hop ${completedHop.hopNumber + 1}:</strong></p>
                            ${Object.entries(nextHopART).map(([currency, amount]) => 
                                `<div>${currency}: ${amount.toLocaleString()}</div>`
                            ).join('')}
                        </div>
                    ` : `
                        <div style="margin-top: 20px; padding: 15px; background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px;">
                            <p><strong>No active threads remaining - Investigation complete!</strong></p>
                        </div>
                    `}
                </div>
                
                <div style="text-align: center;">
                    <button class="btn btn-confirm" onclick="confirmHopCompletion(${completedHop.id})">
                        ${totalActiveAmount > 0 ? `Confirm & Start Hop ${completedHop.hopNumber + 1}` : 'Complete Investigation'}
                    </button>
                    <button class="btn btn-secondary" onclick="closeHopConfirmModal()">
                        Cancel
                    </button>
                </div>
            </div>
        </div>
    `;
    
    createCenteredModal('hopConfirmModal', confirmHTML);
}

// Confirm hop completion
function confirmHopCompletion(hopId) {
    const hop = investigation.hops.find(h => h.id === hopId);
    if (!hop) return;
    
    closeHopConfirmModal();
    
    // Create next hop if there are active threads
    createNextHopFromCurrent(hop);
}

// Close hop confirmation modal
function closeHopConfirmModal() {
    const modal = document.getElementById('hopConfirmModal');
    if (modal) {
        modal.remove();
    }
}

function validateHopCompletion(hopId) {
            const hop = investigation.hops.find(h => h.id === hopId);
            if (!hop) return { valid: false, errors: ['Hop not found'] };
            
            const errors = [];
            const warnings = [];
            
            // Get starting ART by currency for this hop
            const startingART = hop.artAtStartByCurrency || {};
            
            // Calculate totals by currency from all entries in this hop
            const entryTotalsByCurrency = {};
            hop.entries.forEach(entry => {
                if (parseFloat(entry.amount) > 0) {
                    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                    if (!entryTotalsByCurrency[currency]) {
                        entryTotalsByCurrency[currency] = 0;
                    }
                    // Include all entry types that account for funds
                    if (['trace', 'writeoff', 'cold_storage', 'vasp_arrival'].includes(entry.entryType)) {
                        entryTotalsByCurrency[currency] += parseFloat(entry.amount);
                    }
                }
            });
            
            // Validate each currency balances
            Object.entries(startingART).forEach(([currency, startAmount]) => {
                const tracedAmount = entryTotalsByCurrency[currency] || 0;
                const difference = Math.abs(startAmount - tracedAmount);
                
                if (difference >= 0.01) {
                    if (tracedAmount > startAmount) {
                        errors.push(`${currency}: Traced ${tracedAmount.toLocaleString()} exceeds ART ${startAmount.toLocaleString()}`);
                    } else {
                        warnings.push(`${currency}: Missing ${(startAmount - tracedAmount).toLocaleString()} (${tracedAmount.toLocaleString()} of ${startAmount.toLocaleString()} traced)`);
                    }
                }
            });
            
            // Check for source thread over-assignment
            const sourceThreadUsage = {};
            hop.entries.forEach(entry => {
                if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0) {
                    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                    
                    if (entry.sourceThreadId) {
                        if (!sourceThreadUsage[currency]) sourceThreadUsage[currency] = {};
                        if (!sourceThreadUsage[currency][entry.sourceThreadId]) {
                            sourceThreadUsage[currency][entry.sourceThreadId] = 0;
                        }
                        sourceThreadUsage[currency][entry.sourceThreadId] += parseFloat(entry.amount);
                    }
                    
                    if (entry.individualSourceAssignments) {
                        Object.entries(entry.individualSourceAssignments).forEach(([sourceId, amount]) => {
                            if (!sourceThreadUsage[currency]) sourceThreadUsage[currency] = {};
                            if (!sourceThreadUsage[currency][sourceId]) {
                                sourceThreadUsage[currency][sourceId] = 0;
                            }
                            sourceThreadUsage[currency][sourceId] += parseFloat(amount);
                        });
                    }
                }
            });
            
            // Validate source thread assignments don't exceed availability
            Object.entries(sourceThreadUsage).forEach(([currency, threads]) => {
                Object.entries(threads).forEach(([threadId, usedAmount]) => {
                    if (investigation.availableThreads[currency] && investigation.availableThreads[currency][threadId]) {
                        const totalAvailable = investigation.availableThreads[currency][threadId].totalAmount;
                        if (usedAmount > totalAvailable + 0.01) {
                            errors.push(`${threadId}: Assigned ${usedAmount.toLocaleString()} exceeds available ${totalAvailable.toLocaleString()} ${currency}`);
                        }
                    }
                });
            });
            
            // Calculate remaining by currency for the return object
            const remainingByCurrency = {};
            Object.entries(startingART).forEach(([currency, startAmount]) => {
                const tracedAmount = entryTotalsByCurrency[currency] || 0;
                const remaining = startAmount - tracedAmount;
                if (Math.abs(remaining) >= 0.01) {
                    remainingByCurrency[currency] = remaining;
                }
            });
            
            return {
                valid: errors.length === 0,
                errors: errors,
                warnings: warnings,
                balanceStatus: entryTotalsByCurrency,
                remainingByCurrency: remainingByCurrency
            };
        }

function updateInvestigationCompletionStatus() {
    const addHopBtn = document.getElementById('addHopBtn');
    const completeSection = document.getElementById('completeInvestigationSection');
    
    if (!addHopBtn || !completeSection) return;
    
    if (investigation.hops.length === 0) {
        addHopBtn.style.display = 'inline-block';
        completeSection.style.display = 'none';
        return;
    }
    
    let allHopsComplete = true;
    let lastHopComplete = false;
    let totalValidationErrors = 0;
    
    // Check all hops for completion and validation
    investigation.hops.forEach((hop, index) => {
        const isLastHop = index === investigation.hops.length - 1;
        const validation = validateHopCompletion(hop.id);
        
        if (validation.errors && validation.errors.length > 0) {
            totalValidationErrors += validation.errors.length;
        }
        
        if (!hop.completed) {
            allHopsComplete = false;
        } else if (isLastHop) {
            lastHopComplete = true;
        }
    });
    
    // Check if all threads have reached terminal wallets
    const threadStatus = checkAllThreadsTerminated();
    
    // Calculate next hop ART
    const lastHop = investigation.hops[investigation.hops.length - 1];
    let nextHopART = {};
    let hasActiveThreads = false;
    
    if (lastHop && lastHop.completed) {
        // Calculate ART from trace outputs of last completed hop
        lastHop.entries.forEach(entry => {
            if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0 && 
                entry.toWalletType !== 'purple' && entry.toWalletType !== 'gray') {
                const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                if (!nextHopART[currency]) {
                    nextHopART[currency] = 0;
                }
                nextHopART[currency] += parseFloat(entry.amount);
                hasActiveThreads = true;
            }
        });
    }
    
    // Show different buttons based on state
    if (threadStatus.allTerminated && allHopsComplete && totalValidationErrors === 0) {
        // Investigation truly complete - all threads at terminal wallets
        addHopBtn.style.display = 'none';
        completeSection.style.display = 'block';
        updateFinalThreadSummary();
    } else if (lastHopComplete && hasActiveThreads) {
        // Last hop complete with active threads - show what will be traced
        const artSummary = Object.entries(nextHopART)
            .map(([currency, amount]) => `${amount.toLocaleString()} ${currency}`)
            .join(' + ');
        
        addHopBtn.innerHTML = ` Start Hop ${lastHop.hopNumber + 1} (${artSummary} available)`;
        addHopBtn.style.display = 'inline-block';
        addHopBtn.onclick = function() { 
            addNewHop();
        };
        completeSection.style.display = 'none';
    } else if (lastHopComplete && !hasActiveThreads) {
        // No active threads found - investigation may be complete
        addHopBtn.innerHTML = ` Investigation Complete - No Active Threads`;
        addHopBtn.style.display = 'inline-block';
        addHopBtn.disabled = true;
        addHopBtn.style.opacity = '0.6';
        addHopBtn.onclick = null;
        
        // Show completion section
        completeSection.style.display = 'block';
        updateFinalThreadSummary();
    } else if (!lastHopComplete && investigation.hops.length > 0) {
        // Current hop not complete
        const currentHop = investigation.hops[investigation.hops.length - 1];
        addHopBtn.innerHTML = ` Complete Hop ${currentHop.hopNumber} First`;
        addHopBtn.style.display = 'inline-block';
        addHopBtn.disabled = true;
        addHopBtn.style.opacity = '0.6';
        addHopBtn.onclick = null;
        completeSection.style.display = 'none';
    } else {
        // Initial state or validation errors
        addHopBtn.innerHTML = ` Start First Hop`;
        addHopBtn.style.display = totalValidationErrors === 0 ? 'inline-block' : 'none';
        addHopBtn.disabled = false;
        addHopBtn.style.opacity = '1';
        addHopBtn.onclick = function() { addNewHop(); };
        completeSection.style.display = 'none';
        
        // Show validation status in console for debugging
        if (totalValidationErrors > 0) {
            console.log(` Investigation has ${totalValidationErrors} validation errors across hops`);
        }
    }
}

        function showWalletClassificationModal(suggestions, hopNumber, onComplete) {
            const modalHTML = `
                <div id="walletClassificationModal" class="modal" style="display: block;">
                    <div class="modal-content">
                        <div class="modal-header">
                            <h2> Wallet Classification Review - Hop ${hopNumber}</h2>
                            <p>Based on observed behaviors, these wallets may need reclassification:</p>
                        </div>
                        
                        <div style="max-height: 400px; overflow-y: auto;">
                            ${suggestions.map((suggestion, index) => `
                                <div style="background: #f8f9fa; border: 2px solid #3498db; border-radius: 8px; padding: 20px; margin: 15px 0;">
                                    <div style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 15px;">
                                        <div>
                                            <strong>Wallet:</strong> <span style="font-family: monospace; font-size: 12px;">${suggestion.walletAddress.substring(0, 20)}...</span>
                                        </div>
                                        <div>
                                            <strong>Amount:</strong> ${suggestion.totalAmount.toLocaleString()} ${suggestion.currencies.join('/')}
                                        </div>
                                    </div>
                                    
                                    <div style="margin-bottom: 15px;">
                                        <strong>Behavior Analysis:</strong> ${suggestion.reason}
                                    </div>
                                    
                                    <div style="margin-bottom: 15px;">
                                        <strong>Source Threads:</strong> ${suggestion.sourceThreads.join(', ')}
                                    </div>
                                    
                                    <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 15px; align-items: center;">
                                        <div>
                                            <strong>Current:</strong><br>
                                            <span class="wallet-display ${suggestion.currentType}" style="margin: 0; display: inline-block;">
                                                ${walletTypes[suggestion.currentType] || suggestion.currentType.toUpperCase()}
                                            </span>
                                        </div>
                                        <div style="text-align: center;">
                                            <strong> Suggested:</strong><br>
                                            <span class="wallet-display ${suggestion.suggestedType}" style="margin: 0; display: inline-block;">
                                                ${walletTypes[suggestion.suggestedType] || suggestion.suggestedType.toUpperCase()}
                                            </span>
                                        </div>
                                        <div style="text-align: center;">
                                            <label style="cursor: pointer;">
                                                <input type="checkbox" id="approve_${index}" checked style="margin-right: 8px;">
                                                <strong>Apply Change</strong>
                                            </label>
                                        </div>
                                    </div>
                                </div>
                            `).join('')}
                        </div>
                        
                        <div style="text-align: center; margin-top: 25px;">
                            <button class="btn btn-confirm" onclick="applyWalletClassificationChanges(${JSON.stringify(suggestions).replace(/"/g, '&quot;')}, ${hopNumber}, arguments.callee.onComplete)">
                                 Apply Selected Changes & Continue
                            </button>
                            <button class="btn btn-secondary" onclick="closeWalletClassificationModal(); arguments.callee.onComplete();">
                                Skip Classification Review
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            // Store callback for later use
            modalHTML.onComplete = onComplete;
            
            // Remove existing modal if present
            const existingModal = document.getElementById('walletClassificationModal');
            if (existingModal) {
                existingModal.remove();
            }
            
            // Create centered modal
            createCenteredModal('walletClassificationModal', modalHTML);
            
            // Store the callback on the window for access
            window.walletClassificationCallback = onComplete;
        }

        function applyWalletClassificationChanges(suggestions, hopNumber, onComplete) {
            console.log(' Applying wallet classification changes...');
            
            let changesApplied = 0;
            let walletUpdates = [];
            
            suggestions.forEach((suggestion, index) => {
                const checkbox = document.getElementById(`approve_${index}`);
                if (checkbox && checkbox.checked) {
                    walletUpdates.push({
                        address: suggestion.walletAddress,
                        newType: suggestion.suggestedType,
                        oldType: suggestion.currentType,
                        reason: suggestion.reason
                    });
                    
                    // Update all entries for this wallet address retroactively
                    investigation.hops.forEach(hop => {
                        hop.entries.forEach(entry => {
                            // Update toWallet references
                            if (entry.toWallet && entry.toWallet.trim() === suggestion.walletAddress) {
                                entry.toWalletType = suggestion.suggestedType;
                                changesApplied++;
                            }
                            // Also update fromWallet references
                            if (entry.fromWallet && entry.fromWallet.trim() === suggestion.walletAddress) {
                                entry.fromWalletType = suggestion.suggestedType;
                                changesApplied++;
                            }
                        });
                    });
                    
                    // Update Red Wallet Index if needed
                    if (investigation.redWalletIndex) {
                        investigation.redWalletIndex.forEach(redEntry => {
                            if (redEntry.walletAddress === suggestion.walletAddress) {
                                // Update the wallet ID to reflect new classification
                                const walletIndex = investigation.universalWalletIndex.find(w => w.address === suggestion.walletAddress);
                                if (walletIndex) {
                                    redEntry.walletId = walletIndex.permanentId;
                                }
                            }
                        });
                    }
                }
            });
            
            if (changesApplied > 0) {
                // Rebuild Universal Wallet Index with updated classifications
                buildUniversalWalletIndex();
                buildRedWalletIndex();
                
                // Apply permanent UWI updates
                applyPermanentUWIUpdates(walletUpdates);
                
                alert(` Applied ${changesApplied} wallet classification changes retroactively!\n\nUpdated wallets:\n${walletUpdates.map(u => ` ${u.address.substring(0, 20)}...  ${u.newType.toUpperCase()}`).join('\n')}`);
                saveToStorage();
                
                // Re-render all affected components
                renderHops();
                renderRedWalletIndex();
                renderUniversalWalletIndex();
            }
            
            closeWalletClassificationModal();
            
            // Call the completion callback
            if (window.walletClassificationCallback) {
                window.walletClassificationCallback();
                window.walletClassificationCallback = null;
            }
        }
        
        // Apply permanent updates to UWI
        function applyPermanentUWIUpdates(walletUpdates) {
            walletUpdates.forEach(update => {
                const walletEntry = investigation.universalWalletIndex.find(w => w.address === update.address);
                if (walletEntry) {
                    // Add audit trail entry
                    if (!walletEntry.auditTrail) {
                        walletEntry.auditTrail = [];
                    }
                    walletEntry.auditTrail.push({
                        timestamp: new Date().toISOString(),
                        action: 'Classification Update',
                        from: update.oldType,
                        to: update.newType,
                        reason: update.reason,
                        investigator: investigation.investigator || 'Unknown'
                    });
                    
                    // Update notes with classification reason
                    if (walletEntry.notes) {
                        walletEntry.notes += `\n[${new Date().toLocaleDateString()}] ${update.reason}`;
                    } else {
                        walletEntry.notes = `[${new Date().toLocaleDateString()}] ${update.reason}`;
                    }
                }
            });
        }

        function closeWalletClassificationModal() {
            const modal = document.getElementById('walletClassificationModal');
            if (modal) {
                modal.remove();
            }
        }
        
        // Show wallet selector modal
        function showWalletSelector(hopId, entryId) {
            const sortedWallets = [...(investigation.universalWalletIndex || [])].sort((a, b) => {
                if (a.permanentType !== b.permanentType) {
                    const typeOrder = ['red', 'pink', 'yellow', 'orange', 'brown', 'black', 'blue', 'purple', 'gray', 'green'];
                    return typeOrder.indexOf(a.permanentType) - typeOrder.indexOf(b.permanentType);
                }
                return a.permanentId.localeCompare(b.permanentId);
            });
            
            const modalHTML = `
                <div id="walletSelectorModal" class="modal" style="display: block;">
                    <div class="modal-content" style="max-width: 800px;">
                        <div class="modal-header">
                            <h2> Select Wallet</h2>
                            <p>Choose an existing wallet from the Universal Wallet Index</p>
                        </div>
                        
                        <div style="margin-bottom: 20px;">
                            <input type="text" 
                                   id="walletSearchInput" 
                                   placeholder="Search by wallet address or ID..."
                                   onkeyup="filterWalletList()"
                                   style="width: 100%; padding: 10px; border: 2px solid #e8f0fe; border-radius: 6px;">
                        </div>
                        
                        <div style="max-height: 400px; overflow-y: auto;">
                            <table style="width: 100%; border-collapse: collapse;">
                                <thead>
                                    <tr style="background: #f8f9fa; position: sticky; top: 0;">
                                        <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Wallet ID</th>
                                        <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Type</th>
                                        <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Address</th>
                                        <th style="border: 1px solid #ddd; padding: 12px; text-align: left;">Action</th>
                                    </tr>
                                </thead>
                                <tbody id="walletListBody">
                                    ${sortedWallets.map(wallet => `
                                        <tr class="wallet-row" data-address="${wallet.address.toLowerCase()}" data-id="${wallet.permanentId.toLowerCase()}">
                                            <td style="border: 1px solid #ddd; padding: 12px;">
                                                <div class="wallet-display ${wallet.permanentType}" style="margin: 0;">
                                                    ${wallet.permanentId}
                                                </div>
                                            </td>
                                            <td style="border: 1px solid #ddd; padding: 12px;">
                                                ${walletTypes[wallet.permanentType] || wallet.permanentType}
                                            </td>
                                            <td style="border: 1px solid #ddd; padding: 12px; font-family: monospace; font-size: 11px;">
                                                ${wallet.address}
                                            </td>
                                            <td style="border: 1px solid #ddd; padding: 12px; text-align: center;">
                                                <button class="btn btn-confirm" style="padding: 6px 12px;"
                                                        onclick="selectWallet(${hopId}, ${entryId}, '${wallet.address}', '${wallet.permanentType}')">
                                                    Select
                                                </button>
                                            </td>
                                        </tr>
                                    `).join('')}
                                </tbody>
                            </table>
                        </div>
                        
                        <div style="text-align: center; margin-top: 25px;">
                            <button class="btn btn-secondary" onclick="closeWalletSelectorModal()">
                                Cancel
                            </button>
                        </div>
                    </div>
                </div>
            `;
            
            // Remove existing modal if present
            const existingModal = document.getElementById('walletSelectorModal');
            if (existingModal) {
                existingModal.remove();
            }
            
            // Create centered modal
            createCenteredModal('walletSelectorModal', modalHTML);
        }
        
        // Filter wallet list in modal
        function filterWalletList() {
            const searchInput = document.getElementById('walletSearchInput');
            const filter = searchInput.value.toLowerCase();
            const rows = document.querySelectorAll('#walletListBody .wallet-row');
            
            rows.forEach(row => {
                const address = row.getAttribute('data-address');
                const id = row.getAttribute('data-id');
                
                if (address.includes(filter) || id.includes(filter)) {
                    row.style.display = '';
                } else {
                    row.style.display = 'none';
                }
            });
        }
        
        // Select wallet from modal
        function selectWallet(hopId, entryId, address, walletType) {
            // Update the entry
            const hop = investigation.hops.find(h => h.id === hopId);
            const entry = hop.entries.find(e => e.id === entryId);
            
            if (entry) {
                entry.toWallet = address;
                entry.toWalletType = walletType;
            }
            
            // Update the input field
            const input = document.getElementById(`toWallet_${hopId}_${entryId}`);
            if (input) {
                input.value = address;
            }
            
            // Update the wallet type dropdown
            const typeSelect = document.querySelector(`select[onchange="updateHopEntryWalletType(${hopId}, ${entryId}, this.value)"]`);
            if (typeSelect) {
                typeSelect.value = walletType;
            }
            
            // Close modal and save
            closeWalletSelectorModal();
            saveToStorage();
            
            // Re-render to update UI
            renderHops();
        }
        
        // Close wallet selector modal
        function closeWalletSelectorModal() {
            const modal = document.getElementById('walletSelectorModal');
            if (modal) {
                modal.remove();
            }
        }

        function analyzeWalletBehaviors(hop) {
            console.log(` Analyzing wallet behaviors for hop ${hop.hopNumber}...`);
            
            const suggestions = [];
            const walletBehaviors = {};
            
            // Analyze each entry to track wallet behaviors
            hop.entries.forEach(entry => {
                if (entry.entryType === 'trace' && entry.toWallet && parseFloat(entry.amount) > 0) {
                    const walletAddress = entry.toWallet.trim();
                    
                    if (!walletBehaviors[walletAddress]) {
                        walletBehaviors[walletAddress] = {
                            address: walletAddress,
                            currentClassification: entry.toWalletType,
                            sourceThreads: [],
                            totalAmount: 0,
                            currencies: new Set()
                        };
                    }
                    
                    const behavior = walletBehaviors[walletAddress];
                    const sourceThread = entry.sourceThreadId || 'Multiple Sources';
                    
                    if (!behavior.sourceThreads.includes(sourceThread)) {
                        behavior.sourceThreads.push(sourceThread);
                    }
                    
                    behavior.totalAmount += parseFloat(entry.amount);
                    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                    behavior.currencies.add(currency);
                }
            });
            
            // Analyze behaviors and suggest reclassifications
            Object.values(walletBehaviors).forEach(behavior => {
                const sourceCount = behavior.sourceThreads.length;
                const currencyCount = behavior.currencies.size;
                let suggestedType = behavior.currentClassification;
                let reason = '';
                
                // Multiple source threads = convergence behavior
                if (sourceCount > 1) {
                    if (behavior.currentClassification !== 'yellow') {
                        suggestedType = 'yellow';
                        reason = `Received funds from ${sourceCount} different source threads, indicating convergence/hub behavior`;
                    }
                }
                
                // Multiple currencies = conversion behavior
                if (currencyCount > 1) {
                    if (behavior.currentClassification !== 'brown') {
                        suggestedType = 'brown';
                        reason = `Handled ${currencyCount} different currencies, indicating asset conversion behavior`;
                    }
                }
                
                // Cold storage detection moved to hop finalization
                // BLUE wallet classification is now only suggested when:
                // 1. User is finalizing a hop with remaining balances
                // 2. User explicitly creates cold storage entries
                // This prevents false positives during active tracing
                
                // Add suggestion if classification should change
                if (suggestedType !== behavior.currentClassification) {
                    suggestions.push({
                        walletAddress: behavior.address,
                        currentType: behavior.currentClassification,
                        suggestedType: suggestedType,
                        reason: reason,
                        sourceThreads: behavior.sourceThreads,
                        totalAmount: behavior.totalAmount,
                        currencies: Array.from(behavior.currencies)
                    });
                }
            });
            
            console.log(` Found ${suggestions.length} wallet classification suggestions:`, suggestions);
            return suggestions;
        }

        function completeCurrentHopAndStartNext() {
            console.log(' Completing current hop and starting next...');
            
            const currentHop = investigation.hops[investigation.hops.length - 1];
            const validation = validateHopCompletion(currentHop.id);
            
            if (!validation.valid) {
                alert(`Cannot complete hop ${currentHop.hopNumber}. Please fix validation errors first:\n${validation.errors.join('\n')}`);
                return;
            }
            
            // Mark current hop as completed
            currentHop.completed = true;
            
            // Analyze wallet behaviors for classification suggestions
            const classificationSuggestions = analyzeWalletBehaviors(currentHop);
            
            if (classificationSuggestions.length > 0) {
                showWalletClassificationModal(classificationSuggestions, currentHop.hopNumber, () => {
                    // After classification review, create next hop
                    createNextHopFromCurrent(currentHop);
                });
            } else {
                // No classification changes needed, proceed directly
                createNextHopFromCurrent(currentHop);
            }
        }

        function createNextHopFromCurrent(completedHop) {
            console.log(` Creating hop ${completedHop.hopNumber + 1} from completed hop ${completedHop.hopNumber}`);
            
            // Calculate starting ART for next hop based on trace outputs from current hop
            const nextHopART = {};
            
            completedHop.entries.forEach(entry => {
                if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0) {
                    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                    if (!nextHopART[currency]) {
                        nextHopART[currency] = 0;
                    }
                    nextHopART[currency] += parseFloat(entry.amount);
                }
            });
            
            // Only create next hop if there are active threads to trace
            const totalActiveAmount = Object.values(nextHopART).reduce((sum, amount) => sum + amount, 0);
            
            if (totalActiveAmount > 0) {
                const nextHop = {
                    id: investigation.hops.length + 1,
                    hopNumber: completedHop.hopNumber + 1,
                    entries: [],
                    artAtStartByCurrency: nextHopART,
                    artAtStart: totalActiveAmount, // Legacy support
                    completed: false
                };
                
                investigation.hops.push(nextHop);
                
                // Rebuild thread index
                if (typeof buildAvailableThreadsIndex === 'function') {
                    buildAvailableThreadsIndex();
                }
                
                // Update Universal Wallet Index with any new wallets
                buildUniversalWalletIndex();
                
                renderHops();
                saveToStorage();
                updateWorkflowSteps();
                
                alert(` Hop ${completedHop.hopNumber} completed! \n Hop ${nextHop.hopNumber} ready with starting ART: ${Object.entries(nextHopART).map(([currency, amount]) => `${amount.toLocaleString()} ${currency}`).join(', ')}`);
                
                console.log(` Hop ${nextHop.hopNumber} created successfully with ART:`, nextHopART);
            } else {
                // No trace outputs from this hop - check if investigation is complete
                saveToStorage();
                renderHops();
                updateInvestigationCompletionStatus();
                
                // The completion status function will handle showing the appropriate message
                console.log(`Hop ${completedHop.hopNumber} completed with no trace outputs.`);
            }
        }
        
// Check if a wallet type is a terminal wallet (where traces should end)
function isTerminalWalletType(walletType) {
    // Terminal wallets: GRAY (obfuscated), PURPLE (exchange deposit), BLUE (cold storage - temporary terminal)
    return ['gray', 'purple', 'blue'].includes(walletType);
}

// Check if all active threads have reached terminal wallets
function checkAllThreadsTerminated() {
    const activeThreads = [];
    const nonTerminalThreads = [];
    
    // Find the most recent trace for each thread path
    const threadPaths = {};
    
    investigation.hops.forEach(hop => {
        hop.entries.forEach(entry => {
            if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0) {
                let threadPath = null;
                
                // Try to extract thread path from notation
                if (entry.notation) {
                    const pathMatch = entry.notation.match(/^(V\d+-T\d+)/);
                    if (pathMatch) {
                        threadPath = pathMatch[1];
                    }
                }
                
                // If no valid notation, create a unique identifier based on source
                if (!threadPath) {
                    // Use sourceThreadId or create a generic identifier
                    if (entry.sourceThreadId) {
                        threadPath = entry.sourceThreadId;
                    } else if (entry.victimNumbers && entry.transactionNumbers) {
                        threadPath = `V${entry.victimNumbers}-T${entry.transactionNumbers}`;
                    } else {
                        // Create a unique identifier for this entry
                        threadPath = `H${hop.hopNumber}-E${entry.id}`;
                    }
                }
                
                // Store the most recent (highest hop number) entry for each thread
                if (!threadPaths[threadPath] || hop.hopNumber > threadPaths[threadPath].hopNumber) {
                    threadPaths[threadPath] = {
                        hopNumber: hop.hopNumber,
                        entry: entry,
                        amount: parseFloat(entry.amount),
                        currency: entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency,
                        toWalletType: entry.toWalletType || 'black',
                        toWallet: entry.toWallet,
                        path: threadPath
                    };
                }
            }
        });
    });
    
    // Check each thread's terminal status
    Object.entries(threadPaths).forEach(([threadPath, threadData]) => {
        activeThreads.push({
            path: threadPath,
            ...threadData
        });
        
        if (!isTerminalWalletType(threadData.toWalletType)) {
            nonTerminalThreads.push({
                path: threadPath,
                ...threadData,
                walletTypeDisplay: walletTypes[threadData.toWalletType] || threadData.toWalletType
            });
        }
    });
    
    return {
        allTerminated: nonTerminalThreads.length === 0,
        activeThreads: activeThreads,
        nonTerminalThreads: nonTerminalThreads,
        totalActiveAmount: activeThreads.reduce((sum, thread) => sum + thread.amount, 0)
    };
}
        function updateFinalThreadSummary() {
            const summaryContainer = document.getElementById('finalThreadSummary');
            const threadStatus = checkAllThreadsTerminated();
            
            let summaryHTML = '<h4 style="margin-bottom: 15px; color: #2c3e50;"> Investigation Complete - All Threads at Terminal Wallets</h4>';
            
            if (threadStatus.activeThreads.length > 0) {
                // Group threads by currency and terminal status
                const threadsByCurrency = {};
                
                threadStatus.activeThreads.forEach(thread => {
                    if (!threadsByCurrency[thread.currency]) {
                        threadsByCurrency[thread.currency] = {
                            total: 0,
                            threads: []
                        };
                    }
                    threadsByCurrency[thread.currency].total += thread.amount;
                    threadsByCurrency[thread.currency].threads.push(thread);
                });
                
                Object.entries(threadsByCurrency).forEach(([currency, data]) => {
                    summaryHTML += `
                        <div style="margin-bottom: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                            <div style="font-weight: bold; margin-bottom: 10px;">
                                ${currency}: ${data.total.toLocaleString()} Total
                            </div>
                            <div style="font-size: 14px;">
                    `;
                    
                    data.threads.forEach(thread => {
                        const walletTypeColor = getWalletColor(thread.toWalletType);
                        const isTerminal = isTerminalWalletType(thread.toWalletType);
                        const icon = isTerminal ? '' : '';
                        
                        summaryHTML += `
                            <div style="margin: 5px 0; padding: 8px; background: white; border-radius: 4px; border-left: 4px solid ${walletTypeColor};">
                                ${icon} <strong>${thread.path}</strong>: ${thread.amount.toLocaleString()} ${currency} 
                                 <span style="color: ${walletTypeColor}; font-weight: bold;">
                                    ${walletTypes[thread.toWalletType] || thread.toWalletType}
                                </span>
                                ${thread.toWalletType === 'blue' ? '<small style="color: #666;"> (Cold Storage - Temporary Terminal)</small>' : ''}
                            </div>
                        `;
                    });
                    
                    summaryHTML += `
                            </div>
                        </div>
                    `;
                });
                
                // Add terminal wallet legend
                summaryHTML += `
                    <div style="margin-top: 20px; padding: 15px; background: #e8f5e8; border: 2px solid #27ae60; border-radius: 8px;">
                        <h5 style="color: #27ae60; margin-bottom: 10px;">Terminal Wallet Types:</h5>
                        <div style="font-size: 13px; color: #2c3e50;">
                            <div style="margin: 5px 0;">
                                <span style="background: ${getWalletColor('purple')}; color: white; padding: 2px 8px; border-radius: 4px;">PURPLE</span>
                                - Exchange/VASP Deposit (Final Destination)
                            </div>
                            <div style="margin: 5px 0;">
                                <span style="background: ${getWalletColor('gray')}; color: white; padding: 2px 8px; border-radius: 4px;">GRAY</span>
                                - Obfuscated/Mixed (Cannot trace further)
                            </div>
                            <div style="margin: 5px 0;">
                                <span style="background: ${getWalletColor('blue')}; color: white; padding: 2px 8px; border-radius: 4px;">BLUE</span>
                                - Cold Storage (Temporary - May move later)
                            </div>
                        </div>
                    </div>
                `;
            } else {
                summaryHTML += '<p style="color: #666; text-align: center;">No active threads found.</p>';
            }
            
            summaryContainer.innerHTML = summaryHTML;
        }

        function getCurrentThreadValues() {
            const threadsByCurrency = {};
            
            // Group entries by currency and V-T path
            const tracePathsByCurrency = {};
            
            investigation.hops.forEach(hop => {
                hop.entries.forEach(entry => {
                    if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0 && entry.notation) {
                        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                        
                        const pathMatch = entry.notation.match(/^(V\d+-T\d+)/);
                        if (pathMatch) {
                            const vtPath = pathMatch[1];
                            
                            if (!tracePathsByCurrency[currency]) {
                                tracePathsByCurrency[currency] = {};
                            }
                            if (!tracePathsByCurrency[currency][vtPath]) {
                                tracePathsByCurrency[currency][vtPath] = [];
                            }
                            
                            tracePathsByCurrency[currency][vtPath].push({
                                hopNumber: entry.hopNumber,
                                amount: parseFloat(entry.amount),
                                notation: entry.notation,
                                toWalletType: entry.toWalletType
                            });
                        }
                    }
                });
            });
            
            // For each currency, get current thread values and terminal types
            Object.entries(tracePathsByCurrency).forEach(([currency, paths]) => {
                threadsByCurrency[currency] = {
                    totalAmount: 0,
                    paths: [],
                    terminalTypes: new Set()
                };
                
                Object.entries(paths).forEach(([vtPath, entries]) => {
                    entries.sort((a, b) => b.hopNumber - a.hopNumber);
                    const currentEntry = entries[0];
                    
                    threadsByCurrency[currency].totalAmount += currentEntry.amount;
                    threadsByCurrency[currency].paths.push({
                        path: vtPath,
                        amount: currentEntry.amount,
                        notation: currentEntry.notation
                    });
                    
                    if (currentEntry.toWalletType) {
                        threadsByCurrency[currency].terminalTypes.add(walletTypes[currentEntry.toWalletType] || currentEntry.toWalletType);
                    }
                });
                
                threadsByCurrency[currency].terminalTypes = Array.from(threadsByCurrency[currency].terminalTypes);
            });
            
            return threadsByCurrency;
        }
        
        // =================================
        // PART 4: CORE THREAD TRACKING FUNCTIONS
        // Add these functions to your existing JavaScript
        // =================================

// DUPLICATE FUNCTION - Using the one at line 1572 instead
/*function buildAvailableThreadsIndex() {
    console.log(' Building available threads index...');
    console.log('Victims:', investigation.victims);
    
    investigation.availableThreads = {};
    
    // Start with ALL victim transactions
    investigation.victims.forEach(victim => {
        console.log(`Processing victim ${victim.id} with ${victim.transactions.length} transactions`);
        
        victim.transactions.forEach(transaction => {
            console.log(`Transaction ${transaction.id}:`, transaction);
            console.log(`Amount: "${transaction.amount}" (parsed: ${parseFloat(transaction.amount)})`);
            console.log(`Receiving Wallet: "${transaction.receivingWallet}" (length: ${transaction.receivingWallet ? transaction.receivingWallet.length : 'undefined'})`);
            
            const amountCheck = parseFloat(transaction.amount) > 0;
            const walletCheck = transaction.receivingWallet && transaction.receivingWallet.trim() !== '';
            
            console.log(`Amount check: ${amountCheck}, Wallet check: ${walletCheck}`);
            
            if (amountCheck && walletCheck) {
                const currency = transaction.currency === 'CUSTOM' ? 
                    transaction.customCurrency : transaction.currency;
                const threadId = `V${victim.id}-T${transaction.id}`;
                
                if (!investigation.availableThreads[currency]) {
                    investigation.availableThreads[currency] = {};
                }
                
                investigation.availableThreads[currency][threadId] = {
                    totalAmount: parseFloat(transaction.amount),
                    availableAmount: parseFloat(transaction.amount),
                    currency: currency
                };
                
                console.log(` Added thread ${threadId} with ${transaction.amount} ${currency}`);
            } else {
                console.log(` Skipped transaction ${transaction.id}: Amount check: ${amountCheck}, Wallet check: ${walletCheck}`);
            }
        });
    });
    
    // Add threads from hop outputs
    investigation.hops.forEach(hop => {
        hop.entries.forEach(entry => {
            if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0 && entry.notation) {
                const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                // Include hop suffix in thread ID to ensure uniqueness
                const threadId = `${entry.notation}-H${hop.hopNumber}`;
                
                if (!investigation.availableThreads[currency]) {
                    investigation.availableThreads[currency] = {};
                }
                
                // Only add if it doesn't already exist (to preserve any existing data)
                if (!investigation.availableThreads[currency][threadId]) {
                    investigation.availableThreads[currency][threadId] = {
                        totalAmount: parseFloat(entry.amount),
                        availableAmount: parseFloat(entry.amount),
                        currency: currency,
                        sourceType: 'hop_output',
                        hopLevel: entry.hopNumber,
                        fromWallet: entry.toWallet
                    };
                    
                    console.log(` Added hop output thread ${threadId} with ${entry.amount} ${currency} from hop ${entry.hopNumber}`);
                }
            }
        });
    });
    
    console.log(' Final available threads:', investigation.availableThreads);
}*/

// DUPLICATE FUNCTION - Using the one at line 1619 instead
/*function updateThreadAvailabilityFromHop(entry) {
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    const amount = parseFloat(entry.amount);
    
    if (!investigation.availableThreads[currency]) {
        investigation.availableThreads[currency] = {};
    }
    
    // Create new thread entry for this hop output
    const newThreadId = entry.notation;
    investigation.availableThreads[currency][newThreadId] = {
        totalAmount: amount,
        availableAmount: amount,
        assignments: [],
        sourceWallet: entry.toWallet,
        sourceType: 'hop_output',
        hopLevel: entry.hopNumber,
        createdAt: entry.timestamp || new Date().toISOString(),
        isActive: true,
        parentThreads: entry.sourceThreadId ? [entry.sourceThreadId] : [],
        childThreads: [],
        currency: currency
    };
    
    // Reduce availability from source thread if specified
    if (entry.sourceThreadId && investigation.availableThreads[currency][entry.sourceThreadId]) {
        const sourceThread = investigation.availableThreads[currency][entry.sourceThreadId];
        sourceThread.availableAmount -= amount;
        sourceThread.assignments.push({
            assignedTo: newThreadId,
            amount: amount,
            timestamp: new Date().toISOString(),
            isActive: true
        });
        
        // Add child reference
        if (!sourceThread.childThreads.includes(newThreadId)) {
            sourceThread.childThreads.push(newThreadId);
        }
    }
}*/

// DUPLICATE FUNCTION - Using the one at line 1663 instead
/*function getAvailableSourcesForHop(hopNumber, targetCurrency) {
    console.log(` Getting available sources for Hop ${hopNumber}, Currency filter: ${targetCurrency || 'ALL'}`);
    
    buildAvailableThreadsIndex(); // Refresh the index
    
    console.log('Available threads after build:', investigation.availableThreads);
    
    const availableSources = [];
    
    if (hopNumber === 1) {
        // First hop: ALL victim transactions (RED wallets) from ALL victims, ALL currencies
        console.log(` Checking ${investigation.victims.length} victims for available transactions`);
        
        investigation.victims.forEach(victim => {
            victim.transactions.forEach(transaction => {
                console.log(`Checking V${victim.id}-T${transaction.id}: Amount=${transaction.amount}, Wallet=${transaction.receivingWallet}, Currency=${transaction.currency}`);
                
                if (parseFloat(transaction.amount) > 0 && transaction.receivingWallet && transaction.receivingWallet.trim() !== '') {
                    const currency = transaction.currency === 'CUSTOM' ? transaction.customCurrency : transaction.currency;
                    
                    console.log(`Transaction currency: ${currency}, Target filter: ${targetCurrency || 'NONE'}`);
                    
                    // Only filter by currency if targetCurrency is specified
                    if (!targetCurrency || currency === targetCurrency) {
                        const threadId = `V${victim.id}-T${transaction.id}`;
                        
                        // Use the REAL-TIME availability calculation
                        const currentAvailable = getMaxAssignableAmount(threadId, currency);
                        
                        console.log(`Thread ${threadId}: Available ${currentAvailable} ${currency} from real-time calculation`);
                        
                        if (currentAvailable > 0) {
                            const source = {
                                threadId: threadId,
                                displayText: `${threadId} (RED Wallet)`,
                                availableAmount: currentAvailable,
                                currency: currency,
                                sourceWallet: transaction.receivingWallet,
                                sourceType: 'victim_transaction',
                                hopLevel: 0
                            };
                            
                            console.log(` Adding source:`, source);
                            availableSources.push(source);
                        } else {
                            console.log(` Skipping ${threadId}: No availability remaining`);
                        }
                    }
                }
            });
        });
    } else {
        // Subsequent hops: ALL outputs from previous hop level across ALL victim paths
        const previousHopNumber = hopNumber - 1;
        console.log(` Checking previous hop ${previousHopNumber} for available sources`);
        
        investigation.hops.forEach(hop => {
            if (hop.hopNumber === previousHopNumber) {
                hop.entries.forEach(entry => {
                    if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0 && entry.notation) {
                        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                        
                        if (!targetCurrency || currency === targetCurrency) {
                            // Use the correct thread ID format with hop suffix
                            const threadId = `${entry.notation}-H${hop.hopNumber}`;
                            const currentAvailable = getMaxAssignableAmount(threadId, currency);
                            
                            if (currentAvailable > 0) {
                                availableSources.push({
                                    threadId: threadId,
                                    displayText: `${threadId}`,
                                    availableAmount: currentAvailable,
                                    currency: currency,
                                    sourceWallet: entry.toWallet,
                                    sourceType: 'hop_output',
                                    hopLevel: previousHopNumber
                                });
                            }
                        }
                    }
                });
            }
        });
    }
    
    console.log(` Final available sources (${availableSources.length}):`, availableSources);
    
    return availableSources.sort((a, b) => a.threadId.localeCompare(b.threadId));
}*/

function getMaxAssignableAmount(sourceThreadId, currency, excludeEntryId = null, excludeHopId = null) {
    // First, find which currency this source thread actually has
    let threadCurrency = null;
    let threadData = null;
    
    // Search through all currencies to find this thread
    Object.entries(investigation.availableThreads || {}).forEach(([curr, threads]) => {
        if (threads[sourceThreadId]) {
            threadCurrency = curr;
            threadData = threads[sourceThreadId];
        }
    });
    
    if (!threadData) {
        return 0;
    }
    
    // If a specific currency was requested and it doesn't match the thread's currency, return 0
    if (currency && currency !== threadCurrency) {
        console.warn(`Currency mismatch: Thread ${sourceThreadId} has ${threadCurrency} but ${currency} was requested`);
        return 0;
    }
    
    // Use the thread data we found
    const thread = threadData;
    const actualCurrency = threadCurrency;
    let totalAssignedInCurrentSession = 0;
    
    // Calculate what's already been assigned across ALL hop entries in the current session
    investigation.hops.forEach(hop => {
        hop.entries.forEach(entry => {
            // Skip the entry being edited to avoid double-counting
            if (excludeEntryId && excludeHopId && entry.id === excludeEntryId && hop.id === excludeHopId) {
                return; // Skip this entry
            }
            
            if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0) {
                const entryCurrency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                
                if (entryCurrency === actualCurrency) {
                    // Check single source assignment
                    if (entry.sourceThreadId === sourceThreadId) {
                        totalAssignedInCurrentSession += parseFloat(entry.amount);
                    }
                    
                    // Check individual source assignments (for multiple source entries)
                    if (entry.individualSourceAssignments && entry.individualSourceAssignments[sourceThreadId]) {
                        totalAssignedInCurrentSession += parseFloat(entry.individualSourceAssignments[sourceThreadId]);
                    }
                }
            }
        });
    });
    
    const availableAmount = thread.totalAmount - totalAssignedInCurrentSession;
    console.log(`Thread ${sourceThreadId}: Original ${thread.totalAmount}, Assigned across all entries ${totalAssignedInCurrentSession}, Available ${availableAmount}`);
    
    return Math.max(0, availableAmount);
}

function validateThreadAssignment(sourceThreadId, requestedAmount, currency, excludeEntryId = null, excludeHopId = null) {
    const maxAmount = getMaxAssignableAmount(sourceThreadId, currency, excludeEntryId, excludeHopId);
    const amount = parseFloat(requestedAmount);
    
    if (isNaN(amount) || amount <= 0) {
        return { valid: false, error: 'Amount must be a positive number' };
    }
    
    if (amount > maxAmount) {
        // Get the actual currency from the source thread
        let actualCurrency = currency;
        if (!currency) {
            Object.entries(investigation.availableThreads || {}).forEach(([curr, threads]) => {
                if (threads[sourceThreadId]) {
                    actualCurrency = curr;
                }
            });
        }
        
        return { 
            valid: false, 
            error: `Amount ${amount.toLocaleString()} exceeds available ${maxAmount.toLocaleString()} ${actualCurrency}` 
        };
    }
    
    return { valid: true };
}

// DUPLICATE FUNCTION - Using the one at line 1760 instead which has Log Entry button and styling
/*function renderHopEntry(entry) {
    const isWriteoff = entry.entryType === 'writeoff';
    const isColdStorage = entry.entryType === 'cold_storage';
    const isTrace = entry.entryType === 'trace';
    
    // Get available source threads for ALL entry types (not just traces)
    const availableSourceThreads = getAvailableSourcesForHop(entry.hopNumber, null);    
    console.log(`Available sources for Hop ${entry.hopNumber}:`, availableSourceThreads);
    
    // Build source options properly with real-time amounts
    const sourceOptions = availableSourceThreads.map(source => 
        `<option value="${source.threadId}" ${entry.sourceThreadId === source.threadId ? 'selected' : ''}>
            ${source.displayText} - ${source.availableAmount.toLocaleString()} ${source.currency} available
        </option>`
    ).join('');
    
    // Determine if we should show single or multiple source selection
    const showMultipleSelection = availableSourceThreads.length > 1;
    
    // Calculate max amount for input field using real-time calculations
    let maxAmount = 0;
    if (entry.multipleSourceThreads && entry.multipleSourceThreads.length > 0) {
        // Multiple sources selected - sum them up without specifying currency
        entry.multipleSourceThreads.forEach(sourceId => {
            maxAmount += getMaxAssignableAmount(sourceId, null, entry.id, entry.hopId);
        });
    } else if (entry.sourceThreadId) {
        // Single source selected - don't pass currency, let the function find it
        maxAmount = getMaxAssignableAmount(entry.sourceThreadId, null, entry.id, entry.hopId);
    }
    
    // SOURCE SELECTION HTML - NOW AVAILABLE FOR ALL ENTRY TYPES
    let sourceSelectionHTML = '';
    if (showMultipleSelection) {
        // Multiple sources available - show checkboxes for commingling
        sourceSelectionHTML = `
            <div class="form-group">
                <label>Source Thread Selection ${isWriteoff ? '(Required for balanced accounting)' : '(Select multiple for commingling)'}</label>
                <div style="background: #f8f9fa; border: 1px solid #ddd; border-radius: 4px; padding: 10px;">
                    ${availableSourceThreads.map(source => {
                        const isSelected = entry.multipleSourceThreads && entry.multipleSourceThreads.includes(source.threadId);
                        const proposedAmount = entry.individualSourceAssignments && entry.individualSourceAssignments[source.threadId] || 0;
            
                        return `
                            <div style="margin-bottom: 8px;">
                                <!-- Source Selection Row -->
                                <div style="padding: 8px; background: white; border-radius: 3px; border: 1px solid ${isSelected ? '#3498db' : '#ddd'};">
                                    <input type="checkbox" 
                                        value="${source.threadId}" 
                                        ${isSelected ? 'checked' : ''}
                                        onchange="toggleSourceSelection(${entry.hopId}, ${entry.id}, '${source.threadId}')"
                                        style="margin-right: 10px; vertical-align: middle;"> 
                                    <span style="font-weight: bold; color: #2c3e50;">${source.displayText} - ${source.availableAmount.toLocaleString()} ${source.currency} available</span>
                                </div>
                    
                                <!-- Amount Input Row (only show if selected) -->
                                ${isSelected ? `
                                    <div style="margin-top: 6px; margin-left: 30px; display: flex; align-items: center; gap: 8px;">
                                        <span style="font-size: 12px; color: #666; min-width: 80px;">${isWriteoff ? 'Write off:' : 'Propose to use:'}</span>
                                        <input type="number" 
                                            step="0.01" 
                                            min="0" 
                                            max="${source.availableAmount}"
                                            value="${proposedAmount}"
                                            style="width: 120px; padding: 4px 6px; border: 1px solid #ddd; border-radius: 3px;"
                                            onchange="updateProposedAmount(${entry.hopId}, ${entry.id}, '${source.threadId}', this.value)"
                                            placeholder="0.00">
                                    <button type="button" 
                                            onclick="proposeMaxAmount(${entry.hopId}, ${entry.id}, '${source.threadId}')"
                                            style="padding: 4px 8px; font-size: 11px; background: #3498db; color: white; border: none; border-radius: 3px; cursor: pointer;">
                                        All
                                </button>
                                <span style="font-size: 11px; color: #666;">
                                    (${(source.availableAmount - proposedAmount).toLocaleString()} would remain)
                             </span>
                        </div>
                    ` : ''}
                </div>
            `;
                    }).join('')}
            
                    <!-- Assignment Summary and Action Button -->
                    ${entry.multipleSourceThreads && entry.multipleSourceThreads.length > 0 ? `
                        <div style="margin-top: 15px; padding: 15px; background: ${isWriteoff ? '#fff3cd' : '#e8f4f8'}; border: 1px solid ${isWriteoff ? '#ffc107' : '#3498db'}; border-radius: 6px;">
                            <div style="font-weight: bold; color: #2c3e50; margin-bottom: 10px;">${isWriteoff ? 'Proposed Write-off Summary:' : 'Proposed Assignment Summary:'}</div>
                            <div id="proposedSummary_${entry.hopId}_${entry.id}" style="margin-bottom: 15px;"></div>
                            <div style="text-align: center;">
                                <button type="button" 
                                        onclick="commitAssignmentToEntry(${entry.hopId}, ${entry.id})"
                                        style="padding: 10px 20px; font-size: 14px; background: ${isWriteoff ? '#e67e22' : '#27ae60'}; color: white; border: none; border-radius: 6px; cursor: pointer; font-weight: bold;">
                                    ${isWriteoff ? ' Confirm Write-off' : ' Assign to Hop Entry'} ${entry.id}
                                </button>
                            </div>
                        </div>
                    ` : ''}
                </div>
            </div>
        `;
    } else {
        // Single source or no sources - use dropdown
        sourceSelectionHTML = `
            <div class="form-group">
                <label>Source Thread Selection ${isWriteoff ? '(Required for balanced accounting)' : ''}</label>
                <select id="sourceSelect_${entry.hopId}_${entry.id}" 
                        onchange="handleSourceSelection(${entry.hopId}, ${entry.id}, this.value)">
                    <option value="">Select source thread...</option>
                    ${sourceOptions}
                </select>
                ${entry.sourceThreadId ? `
                    <div style="margin-top: 8px; font-size: 11px; color: #666;">
                        <strong>Source:</strong> ${entry.sourceThreadId} (${getMaxAssignableAmount(entry.sourceThreadId, entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency).toLocaleString()} available)
                    </div>
                ` : ''}
            </div>
        `;
    }

    return `
        <div style="background: white; border: 2px solid #e8f0fe; border-radius: 8px; padding: 20px; margin-bottom: 15px;">
            <div class="trace-header">
                <div>
                    <span class="trace-notation">Entry ${entry.id} - ${entryTypes[entry.entryType]}</span>
                    ${entry.notation ? `<br><small style="color: #666;">${entry.notation}</small>` : ''}
                </div>
                <button class="btn btn-danger" onclick="removeHopEntry(${entry.hopId}, ${entry.id})">Remove</button>
            </div>
            
            <div class="form-group">
                <label>Entry Type</label>
                <select onchange="updateHopEntry(${entry.hopId}, ${entry.id}, 'entryType', this.value)">
                    ${Object.entries(entryTypes).map(([key, value]) => 
                        `<option value="${key}" ${entry.entryType === key ? 'selected' : ''}>${value}</option>`
                    ).join('')}
                </select>
            </div>
            
            ${sourceSelectionHTML}
            
            ${isTrace && availableSourceThreads.length > 0 ? `
            <!-- Smart Allocation Button -->
            <div class="form-group" style="text-align: center; margin: 20px 0;">
                <button type="button" 
                        class="btn btn-confirm"
                        onclick="openSmartAllocationModal(${entry.hopId}, ${entry.id})"
                        style="background: linear-gradient(135deg, #27ae60 0%, #219a52 100%); padding: 12px 30px;">
                     Smart Amount Allocation
                </button>
                <div style="font-size: 11px; color: #666; margin-top: 8px;">
                    ${availableSourceThreads.length > 1 
                        ? `Automatically distribute amounts across ${availableSourceThreads.length} available source threads`
                        : `Allocate partial or full amount from source thread`
                    }
                </div>
                <div style="background: #e8f5e8; border: 1px solid #27ae60; border-radius: 4px; padding: 8px; margin-top: 8px; font-size: 11px;">
                    <strong> Use this when:</strong> You want to trace a specific total amount and need the tool to automatically 
                    calculate how much to take from each available source thread.
                </div>
            </div>
            ` : ''}
            
            <div class="form-group">
                <label>${isWriteoff ? 'Write-off Amount' : isColdStorage ? 'Cold Storage Amount' : 'New Thread Total'}</label>
                <div style="display: flex; gap: 10px; align-items: center;">
                    <input type="number" step="0.01" 
                           id="assignAmount_${entry.hopId}_${entry.id}"
                           value="${entry.amount || ''}"
                           max="${maxAmount}"
                           onchange="updateAssignmentAmount(${entry.hopId}, ${entry.id}, this.value)">
                    <button type="button" class="btn btn-secondary" 
                onclick="${isWriteoff ? 'assignMaxWriteoffAmount' : 'assignMaxAmount'}(${entry.hopId}, ${entry.id})"
                ${!isWriteoff && (!entry.sourceThreadId && (!entry.multipleSourceThreads || entry.multipleSourceThreads.length === 0)) ? 'disabled' : ''}>
                ${isWriteoff ? 'Balance ART' : 'Max'}
        </button>
                </div>
                <div style="font-size: 11px; color: #666; margin-top: 5px;">
                    Max assignable: ${maxAmount.toLocaleString()} ${entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency}
                </div>
                <div id="assignmentPreview_${entry.hopId}_${entry.id}" 
                     style="font-size: 12px; margin-top: 5px;"></div>
            </div>

            <div class="form-group">
                <label>Notation Builder</label>
                <div style="display: flex; align-items: center; gap: 5px; font-family: monospace; font-weight: bold;">
                    <span>V</span>
                    <input type="text" style="width: 60px; text-align: center;" 
                           placeholder="1" 
                           value="${entry.victimNumbers || ''}"
                           onchange="updateNotationField(${entry.hopId}, ${entry.id}, 'victims', this.value)">
                    <span>-T</span>
                    <input type="text" style="width: 80px; text-align: center;" 
                           placeholder="1,2,3" 
                           value="${entry.transactionNumbers || ''}"
                           onchange="updateNotationField(${entry.hopId}, ${entry.id}, 'transactions', this.value)">
                    <span>-H${entry.hopNumber}${isWriteoff ? '-WO' : isColdStorage ? '-CS' : ''}</span>
                </div>
                <div style="font-size: 12px; color: #666; margin-top: 5px;">
                    Preview: <span id="notation_preview_${entry.hopId}_${entry.id}" style="font-family: monospace; font-weight: bold;">${entry.notation || 'Enter V and T numbers'}</span>
                </div>
            </div>
            
            ${!isWriteoff ? `
                <div class="form-group">
                    <label>Full Notation Display</label>
                    <div id="notationPreview_${entry.hopId}_${entry.id}" 
                         style="font-family: monospace; padding: 10px; background: #f8f9fa; border-radius: 4px; min-height: 60px;">
                        ${entry.displayNotation || 'Complete source selection and notation to generate full display'}
                    </div>
                </div>
            ` : `
                <div class="form-group">
                    <label>Write-off Justification Display</label>
                    <div id="writeoffPreview_${entry.hopId}_${entry.id}" 
                         style="font-family: monospace; padding: 10px; background: #fff3cd; border-radius: 4px; min-height: 60px;">
                        ${entry.sourceThreadId ? `Writing off from: ${entry.sourceThreadId}` : 'Select source thread to track write-off'}
                    </div>
                </div>
            `}

            <div class="form-group">
                <label>Currency</label>
                <select onchange="updateHopEntry(${entry.hopId}, ${entry.id}, 'currency', this.value)">
                    ${Object.entries(currencies).map(([key, currency]) => 
                        `<option value="${key}" ${entry.currency === key ? 'selected' : ''}>${currency.name}</option>`
                    ).join('')}
                </select>
            </div>
            
            <div class="form-group ${entry.currency === 'CUSTOM' ? '' : 'custom-currency-input'}" 
                 id="customEntryCurrency_${entry.hopId}_${entry.id}">
                <label>Custom Currency Symbol</label>
                <input type="text" value="${entry.customCurrency || ''}" 
                       placeholder="e.g., DOGE, SHIB"
                       onchange="updateHopEntry(${entry.hopId}, ${entry.id}, 'customCurrency', this.value)">
            </div>
            
            ${!isWriteoff && !isColdStorage ? `
                <div class="form-group">
                    <label>To Wallet Address</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <div class="wallet-autocomplete-container" style="flex: 1;">
                            <input type="text" 
                                   id="toWallet_${entry.hopId}_${entry.id}"
                                   value="${entry.toWallet || ''}" 
                                   placeholder="Select existing or enter new wallet address"
                                   onchange="updateHopEntry(${entry.hopId}, ${entry.id}, 'toWallet', this.value)"
                                   oninput="handleWalletAutocomplete(this, ${entry.hopId}, ${entry.id})"
                                   autocomplete="off"
                                   list="walletList_${entry.hopId}_${entry.id}"
                                   style="width: 100%;">
                            <div id="autocomplete_${entry.hopId}_${entry.id}" class="wallet-autocomplete-dropdown"></div>
                        </div>
                        <datalist id="walletList_${entry.hopId}_${entry.id}">
                            ${(investigation.universalWalletIndex || []).map(wallet => `
                                <option value="${wallet.address}">
                                    ${wallet.permanentId} - ${wallet.address.substring(0, 20)}...
                                </option>
                            `).join('')}
                        </datalist>
                        <button type="button" class="btn btn-secondary" style="padding: 6px 12px; font-size: 12px;"
                                onclick="showWalletSelector(${entry.hopId}, ${entry.id})">
                             Browse
                        </button>
                    </div>
                    <div style="font-size: 11px; color: #666; margin-top: 5px;">
                        Type to search existing wallets or enter a new address
                    </div>
                </div>
                <div class="form-group">
                    <label>To Wallet Classification</label>
                    <select onchange="updateHopEntryWalletType(${entry.hopId}, ${entry.id}, this.value)">
                        <option value="">Select classification...</option>
                        ${Object.entries(walletTypes).filter(([key]) => key !== 'red').map(([key, value]) => 
                            `<option value="${key}" ${entry.toWalletType === key ? 'selected' : ''}>${value}</option>`
                        ).join('')}
                    </select>
                </div>
                <div class="form-group">
                    <label>Transaction Hash</label>
                    <div style="display: flex; gap: 10px; align-items: center;">
                        <input type="text" 
                               id="txHash_${entry.hopId}_${entry.id}"
                               value="${entry.txHash || ''}" 
                               placeholder="Blockchain transaction hash"
                               onchange="updateHopEntry(${entry.hopId}, ${entry.id}, 'txHash', this.value)"
                               style="flex: 1;">
                        <button type="button" 
                                class="btn btn-secondary" 
                                onclick="openBlockchainLookup(${entry.hopId}, ${entry.id})"
                                style="background: #3498db; color: white; padding: 8px 15px; font-size: 14px;">
                             Lookup
                        </button>
                    </div>
                </div>
                <div class="form-group">
                    <label>Timestamp with Timezone</label>
                    <div class="datetime-timezone">
                        <input type="datetime-local" 
                               id="timestamp_${entry.hopId}_${entry.id}"
                               value="${entry.timestamp || ''}" 
                               onchange="updateHopEntry(${entry.hopId}, ${entry.id}, 'timestamp', this.value)">
                        <select onchange="updateHopEntry(${entry.hopId}, ${entry.id}, 'timezone', this.value)">
                            ${Object.entries(timezones).map(([key, value]) => 
                                `<option value="${key}" ${entry.timezone === key ? 'selected' : ''}>${value}</option>`
                            ).join('')}
                        </select>
                    </div>
                </div>
            ` : ''}
            
            ${isWriteoff ? `
                <div class="form-group">
                    <label>Write-off Category</label>
                    <select onchange="updateHopEntry(${entry.hopId}, ${entry.id}, 'category', this.value)">
                        <option value="">Select category...</option>
                        ${Object.entries(writeoffCategories).map(([key, value]) => 
                            `<option value="${key}" ${entry.category === key ? 'selected' : ''}>${value}</option>`
                        ).join('')}
                    </select>
                </div>
                <div class="form-group" style="grid-column: span 2;">
                    <label>Justification</label>
                    <textarea rows="2" placeholder="Detailed explanation for abandoning this trace path..." 
                              onchange="updateHopEntry(${entry.hopId}, ${entry.id}, 'justification', this.value)">${entry.justification || ''}</textarea>
                </div>
            ` : `
                <div class="form-group" style="grid-column: span 2;">
                    <label>Notes</label>
                    <textarea rows="2" placeholder="PIFO application, convergence notes, etc." 
                              onchange="updateHopEntry(${entry.hopId}, ${entry.id}, 'notes', this.value)">${entry.notes || ''}</textarea>
                </div>
            `}
        </div>
    `;
}*/

// Enhanced Amount Assignment for Multiple Sources
function updateAssignmentAmountMultiple(hopId, entryId, amount) {
    const hop = investigation.hops.find(h => h.id === hopId);
    const entry = hop.entries.find(e => e.id === entryId);
    
    entry.amount = amount;
    
    if (entry.multipleSourceThreads && entry.multipleSourceThreads.length > 0) {
        updateMultipleSourcePreview(hopId, entryId);
        updateFullNotationDisplayMultiple(hopId, entryId);
    } else {
        updateAssignmentPreview(hopId, entryId);
        updateFullNotationDisplay(hopId, entryId);
    }
    
    saveToStorage();
}

// Enhanced Max Amount Assignment for Multiple Sources
function assignMaxAmountMultiple(hopId, entryId) {
    const hop = investigation.hops.find(h => h.id === hopId);
    const entry = hop.entries.find(e => e.id === entryId);
    
    let maxAmount = 0;
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    
    if (entry.multipleSourceThreads && entry.multipleSourceThreads.length > 0) {
        // First, validate that all sources have the same currency as the entry
        const availableSources = getAvailableSourcesForHop(hop.hopNumber, null);
        const invalidSources = [];
        
        entry.multipleSourceThreads.forEach(sourceId => {
            const source = availableSources.find(s => s.threadId === sourceId);
            if (source && source.currency !== currency) {
                invalidSources.push(`${sourceId} (${source.currency})`);
            }
        });
        
        if (invalidSources.length > 0) {
            alert(` Cannot mix different asset types!\n\nEntry currency: ${currency}\nMismatched sources: ${invalidSources.join(', ')}\n\nPlease select only ${currency} threads or change the entry currency.`);
            return;
        }
        
        // Calculate total from multiple sources
        entry.multipleSourceThreads.forEach(sourceId => {
            maxAmount += getMaxAssignableAmount(sourceId, currency);
        });
    } else if (entry.sourceThreadId) {
        // Single source
        maxAmount = getMaxAssignableAmount(entry.sourceThreadId, currency);
    } else {
        alert('Please select source thread(s) first.');
        return;
    }
    
    entry.amount = maxAmount.toString();
    
    const amountInput = document.getElementById(`assignAmount_${hopId}_${entryId}`);
    if (amountInput) {
        amountInput.value = maxAmount;
    }
    
    updateAssignmentAmountMultiple(hopId, entryId, maxAmount);
}


function showAddEntryWizard(hopId) {
    console.log('showAddEntryWizard called for hopId:', hopId);
    const hop = investigation.hops.find(h => h.id === hopId);
    if (!hop) {
        console.error('Hop not found:', hopId);
        return;
    }
    
    const entryTypeDescriptions = {
        'trace': {
            icon: '',
            description: 'Track funds moving from one wallet to another. The standard way to follow money through the blockchain.',
            color: '#3498db'
        },
        'writeoff': {
            icon: '',
            description: 'Mark funds as lost, stolen, or unrecoverable. Use when funds cannot be traced further.',
            color: '#e74c3c'
        },
        'cold_storage': {
            icon: '',
            description: 'Funds remain in current wallet but are marked as cold storage (BLUE wallet). Use when bad actors are holding funds.',
            color: '#00bcd4'
        }
    };
    
    const wizardHTML = `
        <div id="addEntryWizard" class="modal" style="display: block; z-index: 9998;">
            <div class="modal-content" style="max-width: 600px;">
                <div class="modal-header">
                    <h2> Add New Entry - Hop ${hop.hopNumber}</h2>
                    <p>Choose the type of entry you want to add:</p>
                </div>
                
                <div style="padding: 20px;">
                    ${Object.entries(entryTypes).map(([key, value]) => {
                        const info = entryTypeDescriptions[key] || { icon: '', description: '', color: '#95a5a6' };
                        return `
                            <div onclick="selectEntryType('${hopId}', '${key}')"
                                 style="background: white; border: 2px solid #e8f0fe; border-radius: 8px; padding: 20px; margin-bottom: 15px; cursor: pointer; transition: all 0.2s;"
                                 onmouseover="this.style.borderColor='${info.color}'; this.style.transform='translateY(-2px)'; this.style.boxShadow='0 4px 12px rgba(0,0,0,0.15)'"
                                 onmouseout="this.style.borderColor='#e8f0fe'; this.style.transform='translateY(0)'; this.style.boxShadow='none'">
                                <div style="display: flex; align-items: center; gap: 15px;">
                                    <span style="font-size: 32px;">${info.icon}</span>
                                    <div style="flex: 1;">
                                        <h3 style="margin: 0; color: #2c3e50;">${value}</h3>
                                        <p style="margin: 5px 0 0 0; color: #7f8c8d; font-size: 14px;">${info.description}</p>
                                    </div>
                                    <span style="color: ${info.color}; font-size: 24px;"></span>
                                </div>
                            </div>
                        `;
                    }).join('')}
                </div>
                
                <div class="modal-footer">
                    <button class="btn btn-secondary" onclick="closeAddEntryWizard()">Cancel</button>
                </div>
            </div>
        </div>
    `;
    
    createCenteredModal('addEntryWizard', wizardHTML);
}

function selectEntryType(hopId, entryType) {
    console.log('selectEntryType called with:', hopId, entryType);
    closeAddEntryWizard();
    
    // Check if we should use wizards
    const wizardDisabled = localStorage.getItem('bats_hop_wizard_disabled') === 'true';
    console.log('Wizard disabled:', wizardDisabled);
    
    // Add a small delay to prevent race condition with modal closing
    setTimeout(() => {
        console.log('Inside setTimeout - entryType:', entryType, 'wizardDisabled:', wizardDisabled);
        if (entryType === 'trace' && !wizardDisabled) {
            // Use the existing trace wizard
            console.log('About to call showHopEntryWizard for hopId:', hopId);
            try {
                showHopEntryWizard(hopId);
                console.log('showHopEntryWizard called successfully');
                // Check if wizard was created
                setTimeout(() => {
                    const wizard = document.getElementById('hopEntryWizard');
                    console.log('Wizard element found:', !!wizard);
                    if (!wizard) {
                        console.error('Wizard element not found after creation');
                    }
                }, 50);
            } catch (error) {
                console.error('Error showing hop entry wizard:', error);
                alert('Error opening wizard: ' + error.message);
            }
        } else {
            // For now, create other types directly
            // In the future, we could add specific wizards for each type
            console.log('Creating entry directly for type:', entryType);
            createHopEntryDirectly(hopId, entryType);
        }
    }, 250);
}

function closeAddEntryWizard() {
    const wizard = document.getElementById('addEntryWizard');
    if (wizard) wizard.remove();
}

function addHopEntry(hopId, entryType = 'trace') {
    // This function is now primarily used when wizards are disabled
    // or called from other parts of the code
    const hop = investigation.hops.find(h => h.id === hopId);
    if (!hop) return;
    
    // Check if wizard is disabled
    const wizardDisabled = localStorage.getItem('bats_hop_wizard_disabled') === 'true';
    
    if (entryType === 'trace' && !wizardDisabled) {
        // Show wizard for trace entries
        showHopEntryWizard(hopId);
    } else {
        // Direct creation for non-trace entries or when wizard is disabled
        createHopEntryDirectly(hopId, entryType);
    }
}

function createHopEntryDirectly(hopId, entryType = 'trace') {
    // Convert hopId to number to ensure type matching
    const numericHopId = typeof hopId === 'string' ? parseInt(hopId) : hopId;
    const hop = investigation.hops.find(h => h.id === numericHopId);
    if (!hop) {
        console.error('Hop not found in createHopEntryDirectly:', hopId, 'numericHopId:', numericHopId);
        return;
    }
    
    const entry = {
        id: hop.entries.length + 1,
        hopId: hopId,
        hopNumber: hop.hopNumber,
        entryType: entryType,
        notation: '',
        fromWallet: '',
        fromWalletType: hop.hopNumber === 1 ? 'red' : 'black',
        fromWalletId: '',
        toWallet: '',
        toWalletType: entryType === 'cold_storage' ? 'blue' : '', // Auto-set BLUE for cold storage
        toWalletId: '',
        amount: '',
        currency: '', // No default currency - must be set from source thread
        customCurrency: '',
        txHash: '',
        timestamp: '',
        timezone: 'UTC',
        notes: '',
        category: '',
        justification: '',
        // Enhanced fields
        sourceChain: [],
        displayNotation: '',
        summaryNotation: '',
        victimNumbers: '',
        transactionNumbers: '',
        availableSourceAmount: 0,
        sourceThreadId: '',
        sourceThreadData: null,
        assignmentPercentage: 0,
        generatedNotation: '',
        isConvergence: false,
        convergenceData: null
    };
    
    // Save undo state
    saveUndoState(`Add ${entryType} entry to Hop ${hop.hopNumber}`);
    
    hop.entries.push(entry);
    
    // Store the original entry reference before sorting
    const newEntry = entry;
    
    // Sort entries by timestamp to maintain chronological order
    sortHopEntriesChronologically(hop);
    
    // Find the entry's new ID after sorting
    const sortedEntryIndex = hop.entries.indexOf(newEntry);
    const sortedEntryId = sortedEntryIndex >= 0 ? hop.entries[sortedEntryIndex].id : entry.id;
    
    renderHops();
    saveToStorage();
    
    // Scroll to the newly created entry after a short delay to allow DOM update
    setTimeout(() => {
        const entryElement = document.getElementById(`entry_${hop.id}_${sortedEntryId}`);
        if (entryElement) {
            // Scroll the entry into view, centered on screen
            entryElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            
            // Add a temporary highlight effect
            entryElement.style.transition = 'background-color 0.5s ease';
            entryElement.style.backgroundColor = '#e3f2fd';
            setTimeout(() => {
                entryElement.style.backgroundColor = '';
            }, 2000);
        }
    }, 300);
}

function sortHopEntriesChronologically(hop) {
    // Sort entries by timestamp, with entries without timestamps at the end
    hop.entries.sort((a, b) => {
        // If both have timestamps, sort chronologically
        if (a.timestamp && b.timestamp) {
            return new Date(a.timestamp) - new Date(b.timestamp);
        }
        // If only one has timestamp, put the one with timestamp first
        if (a.timestamp && !b.timestamp) return -1;
        if (!a.timestamp && b.timestamp) return 1;
        // If neither has timestamp, maintain existing order
        return 0;
    });
    
    // Re-assign IDs to maintain sequential ordering
    hop.entries.forEach((entry, index) => {
        entry.id = index + 1;
    });
}

function showHopEntryWizard(hopId) {
    console.log('showHopEntryWizard called for hopId:', hopId, 'type:', typeof hopId);
    console.log('Available hops:', investigation.hops.map(h => ({ id: h.id, type: typeof h.id, hopNumber: h.hopNumber })));
    
    // Convert hopId to number to ensure type matching
    const numericHopId = typeof hopId === 'string' ? parseInt(hopId) : hopId;
    const hop = investigation.hops.find(h => h.id === numericHopId);
    
    if (!hop) {
        console.error('Hop not found in showHopEntryWizard:', hopId);
        console.error('Looking for id:', numericHopId, 'in hops:', investigation.hops);
        return;
    }
    console.log('Found hop:', hop);
    
    // Initialize wizard data
    window.hopWizardData = {
        hopId: numericHopId,
        hopNumber: hop.hopNumber,
        step: 1,
        selectedThreads: [],
        allocations: {},
        txHash: '',
        txData: null,
        entryMode: 'lookup', // 'lookup' or 'manual'
        manualData: {
            fromWallet: '',
            toWallet: '',
            timestamp: new Date().toISOString().slice(0, 16)
        }
    };
    
    const wizardHTML = `
        <div id="hopEntryWizard" class="modal" style="display: block; z-index: 9999;">
            <div class="modal-content" style="max-width: 800px; max-height: 90vh; overflow-y: auto;">
                <div class="modal-header" style="position: sticky; top: 0; background: white; z-index: 10; border-bottom: 2px solid #eee; padding-bottom: 15px;">
                    <h2> Hop Entry Wizard - Step 1 of 3</h2>
                    <div style="margin-top: 10px;">
                        <div style="background: #f0f0f0; height: 8px; border-radius: 4px;">
                            <div id="wizardProgress" style="background: #3498db; height: 100%; width: 33%; border-radius: 4px; transition: width 0.3s;"></div>
                        </div>
                    </div>
                </div>
                
                <div id="wizardContent" style="padding: 20px;">
                    <!-- Content will be dynamically updated -->
                </div>
                
                <div class="modal-footer" style="position: sticky; bottom: 0; background: white; border-top: 2px solid #eee; padding-top: 15px; display: flex; justify-content: space-between; align-items: center;">
                    <div>
                        <input type="checkbox" id="disableWizardCheckbox" onchange="toggleWizardPreference()">
                        <label for="disableWizardCheckbox" style="margin-left: 5px;">Don't show wizard for future entries</label>
                    </div>
                    <div>
                        <button class="btn btn-secondary" onclick="cancelWizardToManual()" title="Transfer data to manual entry">Cancel to Manual</button>
                        <button class="btn btn-secondary" id="wizardBackBtn" onclick="hopWizardBack()" style="display: none;">Back</button>
                        <button class="btn btn-primary" id="wizardNextBtn" onclick="hopWizardNext()">Next</button>
                        <button class="btn btn-secondary" onclick="skipWizardThisTime()" title="Skip wizard for this entry only">Skip This Time</button>
                    </div>
                </div>
            </div>
        </div>
    `;
    
    console.log('About to insert hop entry wizard HTML');
    createCenteredModal('hopEntryWizard', wizardHTML);
    console.log('Hop entry wizard HTML inserted');
    
    // Verify wizard was created
    const wizardElement = document.getElementById('hopEntryWizard');
    console.log('Wizard element exists after insertion:', !!wizardElement);
    if (wizardElement) {
        console.log('Wizard display style:', wizardElement.style.display);
    }
    
    // Show first step
    showHopWizardStep(1);
}

function showHopWizardStep(step) {
    const content = document.getElementById('wizardContent');
    const wizardData = window.hopWizardData;
    const progress = document.getElementById('wizardProgress');
    const backBtn = document.getElementById('wizardBackBtn');
    const nextBtn = document.getElementById('wizardNextBtn');
    const header = document.querySelector('#hopEntryWizard .modal-header h2');
    
    // Update progress
    progress.style.width = `${step * 33}%`;
    backBtn.style.display = step > 1 ? 'inline-block' : 'none';
    header.textContent = ` Hop Entry Wizard - Step ${step} of 3`;
    
    if (step === 1) {
        // Step 1: Select source threads
        const availableThreads = getAvailableSourcesForHop(wizardData.hopNumber, null);
        
        content.innerHTML = `
            <h3>Step 1: Select Source Threads</h3>
            <p>Choose which thread(s) you want to trace from. You can select multiple threads if the transaction combines funds.</p>
            
            <div style="margin-top: 20px;">
                ${availableThreads.length > 0 ? `
                    ${availableThreads.map(thread => `
                        <div style="background: white; border: 2px solid #e8f0fe; border-radius: 8px; padding: 15px; margin-bottom: 10px;">
                            <label style="display: flex; align-items: center; cursor: pointer;">
                                <input type="checkbox" 
                                       value="${thread.threadId}" 
                                       onchange="updateWizardThreadSelection('${thread.threadId}')"
                                       ${wizardData.selectedThreads.includes(thread.threadId) ? 'checked' : ''}
                                       style="margin-right: 10px;">
                                <div>
                                    <strong>${thread.displayText}</strong><br>
                                    <span style="color: #666;">${thread.availableAmount.toLocaleString()} ${thread.currency} available</span>
                                </div>
                            </label>
                        </div>
                    `).join('')}
                ` : `
                    <div style="background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px; padding: 15px;">
                        <strong> No source threads available</strong><br>
                        You need to complete previous hops or victim transactions first.
                    </div>
                `}
            </div>
        `;
        
        nextBtn.disabled = wizardData.selectedThreads.length === 0;
        nextBtn.textContent = 'Next';
        
    } else if (step === 2) {
        // Step 2: Allocate amounts
        content.innerHTML = `
            <h3>Step 2: Allocate Amounts</h3>
            <p>Specify how much from each selected thread will be traced in this transaction.</p>
            
            <div style="margin-top: 20px;">
                ${wizardData.selectedThreads.map(threadId => {
                    const thread = getAvailableSourcesForHop(wizardData.hopNumber, null).find(t => t.threadId === threadId);
                    const allocation = wizardData.allocations[threadId] || 0;
                    
                    return `
                        <div style="background: white; border: 2px solid #e8f0fe; border-radius: 8px; padding: 15px; margin-bottom: 15px;">
                            <h4 style="margin-top: 0;">${thread.displayText}</h4>
                            <div style="display: flex; align-items: center; gap: 10px;">
                                <label style="min-width: 80px;">Amount:</label>
                                <input type="number" 
                                       id="wizardAllocation_${threadId}"
                                       step="${getCurrencyStep(thread.currency)}" 
                                       min="0" 
                                       max="${thread.availableAmount}"
                                       value="${allocation}"
                                       onchange="updateWizardAllocation('${threadId}', this.value)"
                                       style="width: 150px; padding: 8px;">
                                <span>${thread.currency}</span>
                                <button class="btn btn-sm btn-primary" 
                                        onclick="setWizardMaxAllocation('${threadId}', ${thread.availableAmount})">
                                    Max (${thread.availableAmount.toLocaleString()})
                                </button>
                            </div>
                            <div style="margin-top: 8px; font-size: 12px; color: #666;">
                                ${allocation > 0 ? `${(thread.availableAmount - allocation).toLocaleString()} ${thread.currency} will remain` : ''}
                            </div>
                        </div>
                    `;
                }).join('')}
                
                <div style="margin-top: 20px; padding: 15px; background: #e8f4f8; border-radius: 8px;">
                    <strong>Total to trace:</strong> 
                    <span id="wizardTotalAmount">0</span>
                </div>
            </div>
        `;
        
        updateWizardTotal();
        const hasAllocations = Object.values(wizardData.allocations).some(v => v > 0);
        nextBtn.disabled = !hasAllocations;
        nextBtn.textContent = 'Next';
        
    } else if (step === 3) {
        // Step 3: Transaction details
        content.innerHTML = `
            <h3>Step 3: Transaction Details</h3>
            <p>Choose how to enter transaction details:</p>
            
            <div style="margin: 20px 0;">
                <div style="display: flex; gap: 10px; margin-bottom: 20px;">
                    <button class="btn ${wizardData.entryMode === 'lookup' ? 'btn-primary' : 'btn-secondary'}" 
                            onclick="setWizardEntryMode('lookup')" style="flex: 1;">
                         API Lookup
                    </button>
                    <button class="btn ${wizardData.entryMode === 'manual' ? 'btn-primary' : 'btn-secondary'}" 
                            onclick="setWizardEntryMode('manual')" style="flex: 1;">
                         Manual Entry
                    </button>
                </div>
                
                ${wizardData.entryMode === 'lookup' ? `
                    <div style="background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%); padding: 20px; border-radius: 8px; border: 2px solid #2196f3;">
                        <label style="font-weight: bold; color: #0d47a1;">Transaction Hash:</label>
                        <div style="display: flex; gap: 10px; margin-top: 10px;">
                            <input type="text" 
                                   id="wizardTxHash"
                                   placeholder="Paste transaction hash here"
                                   value="${wizardData.txHash || ''}"
                                   onchange="window.hopWizardData.txHash = this.value"
                                   style="flex: 1; padding: 12px; font-size: 16px;">
                            <button class="btn btn-primary" onclick="lookupWizardTransaction()">
                                 Lookup
                            </button>
                        </div>
                    </div>
                ` : `
                    <div style="background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%); padding: 20px; border-radius: 8px; border: 2px solid #ff9800;">
                        <h4 style="margin-top: 0; color: #e65100;">Manual Transaction Entry</h4>
                        
                        <div class="form-group">
                            <label>Transaction Hash:</label>
                            <input type="text" 
                                   id="wizardTxHashManual"
                                   placeholder="Enter transaction hash"
                                   value="${wizardData.txHash || ''}"
                                   onchange="window.hopWizardData.txHash = this.value"
                                   style="width: 100%;">
                        </div>
                        
                        <div class="form-group">
                            <label>From Wallet:</label>
                            <input type="text" 
                                   id="wizardFromWallet"
                                   placeholder="Enter sending wallet address"
                                   value="${wizardData.manualData?.fromWallet || ''}"
                                   onchange="updateWizardManualData('fromWallet', this.value)"
                                   style="width: 100%;">
                        </div>
                        
                        <div class="form-group">
                            <label>To Wallet:</label>
                            <input type="text" 
                                   id="wizardToWallet"
                                   placeholder="Enter receiving wallet address"
                                   value="${wizardData.manualData?.toWallet || ''}"
                                   onchange="updateWizardManualData('toWallet', this.value)"
                                   style="width: 100%;">
                        </div>
                        
                        <div class="form-group">
                            <label>Timestamp:</label>
                            <input type="datetime-local" 
                                   id="wizardTimestamp"
                                   value="${wizardData.manualData?.timestamp || ''}"
                                   onchange="updateWizardManualData('timestamp', this.value)"
                                   style="width: 100%;">
                        </div>
                    </div>
                `}
                
                <div id="wizardTxResult" style="margin-top: 20px;">
                    <!-- Transaction details will appear here -->
                </div>
                
                <div style="margin-top: 20px; padding: 15px; background: #f8f9fa; border-radius: 8px;">
                    <h4 style="margin-top: 0;">Summary</h4>
                    <div style="font-size: 14px; line-height: 1.6;">
                        ${wizardData.selectedThreads.map(threadId => {
                            const thread = getAvailableSourcesForHop(wizardData.hopNumber, null).find(t => t.threadId === threadId);
                            const allocation = wizardData.allocations[threadId] || 0;
                            return `<div><strong>${thread.displayText}:</strong> ${allocation.toLocaleString()} ${thread.currency}</div>`;
                        }).join('')}
                    </div>
                </div>
            </div>
        `;
        
        nextBtn.textContent = 'Create Entry';
        // Enable next button if we have required data
        if (wizardData.entryMode === 'manual') {
            nextBtn.disabled = !wizardData.txHash || !wizardData.manualData?.toWallet;
        } else {
            nextBtn.disabled = !wizardData.txHash || !wizardData.txData;
        }
    }
    
    wizardData.step = step;
}

function hopWizardNext() {
    const wizardData = window.hopWizardData;
    
    if (wizardData.step === 3) {
        // Create the entry
        createHopEntryFromWizard();
    } else {
        showHopWizardStep(wizardData.step + 1);
    }
}

function hopWizardBack() {
    const wizardData = window.hopWizardData;
    if (wizardData.step > 1) {
        showHopWizardStep(wizardData.step - 1);
    }
}

function closeHopWizard() {
    const wizard = document.getElementById('hopEntryWizard');
    if (wizard) wizard.remove();
    window.hopWizardData = null;
}

function skipHopWizard() {
    closeHopWizard();
    createHopEntryDirectly(window.hopWizardData.hopId, 'trace');
}

// Skip wizard just for this entry without disabling it permanently
function skipWizardThisTime() {
    const hopId = window.hopWizardData.hopId;
    closeHopWizard();
    createHopEntryDirectly(hopId, 'trace');
}

// Cancel wizard and transfer data to manual entry form
function cancelWizardToManual() {
    const wizardData = window.hopWizardData;
    if (!wizardData) return;
    
    const hopId = wizardData.hopId;
    
    // Close wizard
    closeHopWizard();
    
    // Create manual entry with pre-filled data
    createHopEntryDirectly(hopId, 'trace');
    
    // Wait for DOM update then fill in the data
    setTimeout(() => {
        // Find the last added entry form
        const hop = investigation.hops.find(h => h.id === hopId);
        if (!hop) return;
        
        const lastEntry = hop.entries[hop.entries.length - 1];
        if (!lastEntry) return;
        
        // Pre-fill amount if allocations exist
        const totalAmount = Object.values(wizardData.allocations).reduce((sum, val) => sum + val, 0);
        if (totalAmount > 0) {
            const amountInput = document.querySelector(`[onchange*="updateEntryAmount(${hopId}, ${lastEntry.id}"]`);
            if (amountInput) {
                amountInput.value = totalAmount;
                updateEntryAmount(hopId, lastEntry.id, totalAmount.toString());
            }
        }
        
        // Pre-fill transaction hash
        if (wizardData.txHash) {
            const txHashInput = document.querySelector(`[onchange*="updateEntryField(${hopId}, ${lastEntry.id}, 'txHash'"]`);
            if (txHashInput) {
                txHashInput.value = wizardData.txHash;
                updateEntryField(hopId, lastEntry.id, 'txHash', wizardData.txHash);
            }
        }
        
        // Pre-fill manual data if available
        if (wizardData.manualData) {
            if (wizardData.manualData.fromWallet) {
                const fromInput = document.querySelector(`[onchange*="updateEntryField(${hopId}, ${lastEntry.id}, 'fromWallet'"]`);
                if (fromInput) {
                    fromInput.value = wizardData.manualData.fromWallet;
                    updateEntryField(hopId, lastEntry.id, 'fromWallet', wizardData.manualData.fromWallet);
                }
            }
            
            if (wizardData.manualData.toWallet) {
                const toInput = document.querySelector(`[onchange*="updateEntryField(${hopId}, ${lastEntry.id}, 'toWallet'"]`);
                if (toInput) {
                    toInput.value = wizardData.manualData.toWallet;
                    updateEntryField(hopId, lastEntry.id, 'toWallet', wizardData.manualData.toWallet);
                }
            }
            
            if (wizardData.manualData.timestamp) {
                const timestampInput = document.querySelector(`[onchange*="updateEntryField(${hopId}, ${lastEntry.id}, 'timestamp'"]`);
                if (timestampInput) {
                    timestampInput.value = wizardData.manualData.timestamp;
                    updateEntryField(hopId, lastEntry.id, 'timestamp', wizardData.manualData.timestamp);
                }
            }
        }
        
        // Pre-fill source threads if single thread
        if (wizardData.selectedThreads.length === 1) {
            const threadId = wizardData.selectedThreads[0];
            const sourceSelect = document.querySelector(`[onchange*="updateSourceThread(${hopId}, ${lastEntry.id}"]`);
            if (sourceSelect) {
                sourceSelect.value = threadId;
                updateSourceThread(hopId, lastEntry.id, threadId);
            }
        }
        
        // Scroll to the new entry
        const entryElement = document.getElementById(`entry_${hopId}_${lastEntry.id}`);
        if (entryElement) {
            entryElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            // Highlight it briefly
            entryElement.style.border = '3px solid #3498db';
            setTimeout(() => {
                entryElement.style.border = '';
            }, 2000);
        }
    }, 100);
}

// Set wizard entry mode (lookup vs manual)
function setWizardEntryMode(mode) {
    window.hopWizardData.entryMode = mode;
    showHopWizardStep(3); // Refresh step 3
}

// Update wizard manual data
function updateWizardManualData(field, value) {
    if (!window.hopWizardData.manualData) {
        window.hopWizardData.manualData = {};
    }
    window.hopWizardData.manualData[field] = value;
    
    // Update next button state
    const nextBtn = document.getElementById('wizardNextBtn');
    if (window.hopWizardData.entryMode === 'manual') {
        nextBtn.disabled = !window.hopWizardData.txHash || !window.hopWizardData.manualData.toWallet;
    }
}

function toggleWizardPreference() {
    const checkbox = document.getElementById('disableWizardCheckbox');
    localStorage.setItem('bats_hop_wizard_disabled', checkbox.checked ? 'true' : 'false');
}

function updateWizardThreadSelection(threadId) {
    const wizardData = window.hopWizardData;
    const index = wizardData.selectedThreads.indexOf(threadId);
    
    if (index > -1) {
        wizardData.selectedThreads.splice(index, 1);
        delete wizardData.allocations[threadId];
    } else {
        wizardData.selectedThreads.push(threadId);
    }
    
    const nextBtn = document.getElementById('wizardNextBtn');
    nextBtn.disabled = wizardData.selectedThreads.length === 0;
}

function updateWizardAllocation(threadId, value) {
    window.hopWizardData.allocations[threadId] = parseFloat(value) || 0;
    updateWizardTotal();
}

function setWizardMaxAllocation(threadId, maxAmount) {
    document.getElementById(`wizardAllocation_${threadId}`).value = maxAmount;
    updateWizardAllocation(threadId, maxAmount);
}

function updateWizardTotal() {
    const wizardData = window.hopWizardData;
    const threads = getAvailableSourcesForHop(wizardData.hopNumber, null);
    
    let totalText = [];
    const currencyTotals = {};
    
    Object.entries(wizardData.allocations).forEach(([threadId, amount]) => {
        if (amount > 0) {
            const thread = threads.find(t => t.threadId === threadId);
            if (thread) {
                if (!currencyTotals[thread.currency]) {
                    currencyTotals[thread.currency] = 0;
                }
                currencyTotals[thread.currency] += amount;
            }
        }
    });
    
    Object.entries(currencyTotals).forEach(([currency, total]) => {
        totalText.push(`${total.toLocaleString()} ${currency}`);
    });
    
    const totalElement = document.getElementById('wizardTotalAmount');
    if (totalElement) {
        totalElement.textContent = totalText.join(' + ') || '0';
    }
    
    const nextBtn = document.getElementById('wizardNextBtn');
    const hasAllocations = Object.values(wizardData.allocations).some(v => v > 0);
    nextBtn.disabled = !hasAllocations;
}

async function lookupWizardTransaction() {
    const txHash = document.getElementById('wizardTxHash').value.trim();
    if (!txHash) return;
    
    const resultDiv = document.getElementById('wizardTxResult');
    resultDiv.innerHTML = '<div style="text-align: center;"> Looking up transaction...</div>';
    
    try {
        const detectedChain = detectBlockchainFromHash(txHash);
        if (!detectedChain) {
            throw new Error('Unable to detect blockchain from hash');
        }
        
        let txData;
        switch(detectedChain) {
            case 'ethereum':
                txData = await lookupEthereumTransaction(txHash);
                break;
            case 'bitcoin':
                txData = await lookupBitcoinTransaction(txHash);
                break;
            case 'tron':
                txData = await lookupTronTransaction(txHash);
                break;
            case 'solana':
                txData = await lookupSolanaTransaction(txHash);
                break;
            default:
                throw new Error('Unsupported blockchain');
        }
        
        window.hopWizardData.txData = txData;
        
        resultDiv.innerHTML = `
            <div style="background: #e8f4f8; border: 1px solid #3498db; border-radius: 8px; padding: 15px;">
                <h4 style="margin-top: 0;"> Transaction Found</h4>
                <div style="display: grid; gap: 8px; font-size: 14px;">
                    <div><strong>Chain:</strong> ${txData.blockchain}</div>
                    <div><strong>Amount:</strong> ${txData.amount} ${txData.currency}</div>
                    <div><strong>From:</strong> <span style="font-family: monospace; font-size: 12px;">${txData.from}</span></div>
                    <div><strong>To:</strong> <span style="font-family: monospace; font-size: 12px;">${txData.to}</span></div>
                    <div><strong>Time:</strong> ${new Date(txData.time).toLocaleString()} UTC</div>
                </div>
            </div>
        `;
        
        document.getElementById('wizardNextBtn').disabled = false;
        
    } catch (error) {
        resultDiv.innerHTML = `
            <div style="background: #f8d7da; border: 1px solid #f5c6cb; border-radius: 8px; padding: 15px;">
                <strong> Lookup Failed</strong><br>
                ${error.message}
            </div>
        `;
    }
}

function createHopEntryFromWizard() {
    const wizardData = window.hopWizardData;
    const hop = investigation.hops.find(h => h.id === wizardData.hopId);
    if (!hop) return;
    
    // Determine data source based on entry mode
    let fromWallet, toWallet, timestamp;
    
    if (wizardData.entryMode === 'manual') {
        fromWallet = wizardData.manualData?.fromWallet || '';
        toWallet = wizardData.manualData?.toWallet || '';
        timestamp = wizardData.manualData?.timestamp || '';
    } else {
        fromWallet = wizardData.txData?.from || '';
        toWallet = wizardData.txData?.to || '';
        timestamp = wizardData.txData ? new Date(wizardData.txData.time).toISOString().slice(0, 16) : '';
    }
    
    // Create entry with wizard data
    const entry = {
        id: hop.entries.length + 1,
        hopId: wizardData.hopId,
        hopNumber: hop.hopNumber,
        entryType: 'trace',
        notation: '',
        fromWallet: fromWallet,
        fromWalletType: hop.hopNumber === 1 ? 'red' : 'black',
        fromWalletId: '',
        toWallet: toWallet,
        toWalletType: '',
        toWalletId: '',
        amount: Object.values(wizardData.allocations).reduce((sum, val) => sum + val, 0).toString(),
        currency: wizardData.selectedThreads.length === 1 ? 
            getAvailableSourcesForHop(hop.hopNumber, null).find(t => t.threadId === wizardData.selectedThreads[0])?.currency : '',
        customCurrency: '',
        txHash: wizardData.txHash,
        timestamp: timestamp,
        timezone: 'UTC',
        notes: '',
        category: '',
        justification: '',
        // Enhanced fields
        sourceChain: [],
        displayNotation: '',
        summaryNotation: '',
        victimNumbers: '',
        transactionNumbers: '',
        availableSourceAmount: 0,
        sourceThreadId: wizardData.selectedThreads.length === 1 ? wizardData.selectedThreads[0] : '',
        sourceThreadData: null,
        assignmentPercentage: 0,
        generatedNotation: '',
        isConvergence: false,
        convergenceData: null,
        // New fields for multiple sources
        multipleSourceThreads: wizardData.selectedThreads.length > 1 ? wizardData.selectedThreads : [],
        individualSourceAssignments: wizardData.selectedThreads.length > 1 ? wizardData.allocations : {}
    };
    
    // Save undo state
    saveUndoState(`Add trace entry to Hop ${hop.hopNumber}`);
    
    hop.entries.push(entry);
    
    // Store the original entry reference before sorting
    const newEntry = entry;
    
    // Sort entries by timestamp to maintain chronological order
    sortHopEntriesChronologically(hop);
    
    // Find the entry's new ID after sorting
    const sortedEntryIndex = hop.entries.indexOf(newEntry);
    const sortedEntryId = sortedEntryIndex >= 0 ? hop.entries[sortedEntryIndex].id : entry.id;
    
    closeHopWizard();
    renderHops();
    saveToStorage();
    
    // Scroll to the newly created entry after a short delay to allow DOM update
    setTimeout(() => {
        const entryElement = document.getElementById(`entry_${hop.id}_${sortedEntryId}`);
        if (entryElement) {
            // Scroll the entry into view, centered on screen
            entryElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
            
            // Add a temporary highlight effect
            entryElement.style.transition = 'background-color 0.5s ease';
            entryElement.style.backgroundColor = '#e3f2fd';
            setTimeout(() => {
                entryElement.style.backgroundColor = '';
            }, 2000);
        }
    }, 300);
}
// Calculate remaining ART for write-offs
function calculateRemainingARTForHop(hopId, currency) {
    const hop = investigation.hops.find(h => h.id === hopId);
    if (!hop) return 0;
    
    // Get the starting ART for this hop
    const startingART = hop.artAtStartByCurrency || {};
    const artForCurrency = startingART[currency] || 0;
    
    // Calculate total traced/written off so far in this hop
    let totalAllocated = 0;
    hop.entries.forEach(entry => {
        const entryCurrency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
        if (entryCurrency === currency && parseFloat(entry.amount) > 0) {
            totalAllocated += parseFloat(entry.amount);
        }
    });
    
    const remaining = artForCurrency - totalAllocated;
    console.log(`Hop ${hop.hopNumber} ${currency}: Starting ART ${artForCurrency}, Allocated ${totalAllocated}, Remaining ${remaining}`);
    
    return Math.max(0, remaining); // Don't return negative
}

// Auto-fill max write-off amount
function assignMaxWriteoffAmount(hopId, entryId) {
    const hop = investigation.hops.find(h => h.id === hopId);
    const entry = hop.entries.find(e => e.id === entryId);
    
    if (entry.entryType !== 'writeoff') {
        alert('This function is only for write-off entries.');
        return;
    }
    
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    const remainingART = calculateRemainingARTForHop(hopId, currency);
    
    if (remainingART <= 0) {
        alert(`No remaining ${currency} to write off in this hop.`);
        return;
    }
    
    entry.amount = remainingART.toString();
    
    const amountInput = document.getElementById(`writeoffAmount_${hopId}_${entryId}`);
    if (amountInput) {
        amountInput.value = remainingART;
    }
    
    updateWriteoffPreview(hopId, entryId);
    saveToStorage();
    
    // Re-render hops to update validation
    renderHops();
}

// Update write-off preview with balance information
function updateWriteoffPreview(hopId, entryId) {
    const hop = investigation.hops.find(h => h.id === hopId);
    const entry = hop.entries.find(e => e.id === entryId);
    const previewElement = document.getElementById(`writeoffPreview_${hopId}_${entryId}`);
    
    if (!previewElement || entry.entryType !== 'writeoff') {
        return;
    }
    
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    const amount = parseFloat(entry.amount) || 0;
    const remainingART = calculateRemainingARTForHop(hopId, currency);
    const afterWriteoff = remainingART - amount;
    
    let previewHTML = '';
    if (amount > 0) {
        const isValid = amount <= remainingART;
        previewHTML = `
            <div style="background: #f8f9fa; border: 1px solid #ddd; border-radius: 4px; padding: 10px; margin-top: 10px;">
                <div style="font-weight: bold; margin-bottom: 8px; color: #2c3e50;">Write-off Impact:</div>
                <div style="font-size: 12px; color: #666; margin-bottom: 5px;">
                    Remaining ART before write-off: ${remainingART.toLocaleString()} ${currency}
                </div>
                <div style="color: ${isValid ? '#27ae60' : '#e74c3c'}; font-weight: bold;">
                    ${isValid ? '' : ''} Writing off: ${amount.toLocaleString()} ${currency}
                </div>
                ${isValid ? `
                    <div style="font-size: 12px; color: #666; margin-top: 5px;">
                        Remaining after write-off: ${afterWriteoff.toLocaleString()} ${currency}
                        ${afterWriteoff === 0 ? ' <span style="color: #27ae60; font-weight: bold;">(Fully balanced!)</span>' : ''}
                    </div>
                ` : `
                    <div style="font-size: 12px; color: #e74c3c; margin-top: 5px;">
                        Cannot write off more than remaining ART!
                    </div>
                `}
            </div>
        `;
    }
    
    previewElement.innerHTML = previewHTML;
}

// Get suggested write-off categories with descriptions
function getSuggestedWriteoffCategory(amount, currency) {
    if (amount < 50) {
        return {
            category: 'dust',
            suggestion: 'Dust - Below practical threshold',
            description: `Amount of ${amount.toLocaleString()} ${currency} is below the typical investigation threshold of $50.`
        };
    } else if (amount < 500) {
        return {
            category: 'operational',
            suggestion: 'Operational - Resource constraints',
            description: `Small amount of ${amount.toLocaleString()} ${currency} may not justify continued investigation resources.`
        };
    } else {
        return {
            category: 'dilution',
            suggestion: 'Dilution - Too diluted to trace',
            description: `Amount may have become too diluted in larger transactions to trace effectively.`
        };
    }
}

// Enhanced write-off section renderer
function renderWriteoffSection(entry) {
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    const amount = parseFloat(entry.amount) || 0;
    const suggestion = amount > 0 ? getSuggestedWriteoffCategory(amount, currency) : null;
    
    return `
        <div class="form-group">
            <label>Write-off Amount</label>
            <div style="display: flex; gap: 10px; align-items: center;">
                <input type="number" step="0.01" 
                       id="writeoffAmount_${entry.hopId}_${entry.id}"
                       value="${entry.amount || ''}"
                       onchange="updateWriteoffAmount(${entry.hopId}, ${entry.id}, this.value)">
                <button type="button" class="btn btn-secondary" 
                        onclick="assignMaxWriteoffAmount(${entry.hopId}, ${entry.id})">
                    Max (Balance ART)
                </button>
            </div>
            <div id="writeoffPreview_${entry.hopId}_${entry.id}" 
                 style="font-size: 12px; margin-top: 5px;"></div>
        </div>
        
        <div class="form-group">
            <label>Write-off Category</label>
            <select onchange="updateHopEntry(${entry.hopId}, ${entry.id}, 'category', this.value)">
                <option value="">Select category...</option>
                ${Object.entries(writeoffCategories).map(([key, value]) => 
                    `<option value="${key}" ${entry.category === key ? 'selected' : ''}>${value}</option>`
                ).join('')}
            </select>
            ${suggestion ? `
                <div style="margin-top: 8px; padding: 8px; background: #fff3cd; border: 1px solid #ffeaa7; border-radius: 4px; font-size: 12px;">
                    <strong> Suggestion:</strong> ${suggestion.suggestion}<br>
                    <small style="color: #666;">${suggestion.description}</small>
                </div>
            ` : ''}
        </div>
        
        <div class="form-group" style="grid-column: span 2;">
            <label>Justification</label>
            <textarea rows="3" 
                      placeholder="Detailed explanation for abandoning this trace path. Example: Amount too small to justify continued investigation resources..." 
                      onchange="updateHopEntry(${entry.hopId}, ${entry.id}, 'justification', this.value)">${entry.justification || ''}</textarea>
            ${suggestion && !entry.justification ? `
                <div style="margin-top: 5px; font-size: 11px; color: #666;">
                    <strong>Suggested justification:</strong> ${suggestion.description}
                </div>
            ` : ''}
        </div>
    `;
}

// Update write-off amount with validation
function updateWriteoffAmount(hopId, entryId, amount) {
    const hop = investigation.hops.find(h => h.id === hopId);
    const entry = hop.entries.find(e => e.id === entryId);
    
    entry.amount = amount;
    updateWriteoffPreview(hopId, entryId);
    updateHopEntry(hopId, entryId, 'amount', amount);
}
    const entry = {
        // Existing fields (keep exactly as they were)
        id: hop.entries.length + 1,
        hopId: hopId,
        hopNumber: hop.hopNumber,
        entryType: entryType,
        notation: '',
        fromWallet: '',
        fromWalletType: hop.hopNumber === 1 ? 'red' : 'black',
        fromWalletId: '',
        toWallet: '',
        toWalletType: '',
        toWalletId: '',
        amount: '',
        currency: 'USD',
        customCurrency: '',
        txHash: '',
        timestamp: '',
        timezone: 'UTC',
        notes: '',
        category: '',
        justification: '',
        sourceChain: [],                // Array of source thread objects
        displayNotation: '',            // Full chain notation for display
        summaryNotation: '',            // Compressed notation for summary
        victimNumbers: '',              // Comma-separated victim numbers for notation building
        transactionNumbers: '',         // Comma-separated transaction numbers for notation building
        availableSourceAmount: 0,       // Available amount from selected source
        sourceThreadId: '',             // Selected source thread identifier
        sourceThreadData: null,         // Full source thread information
        assignmentPercentage: 0,        // Percentage of source thread being used
        generatedNotation: '',          // Auto-generated V-T-H notation
        isConvergence: false,           // Flag for convergence scenarios
        convergenceData: null           // Data for convergence handling
    };
    
    hop.entries.push(entry);
    renderHops();
    saveToStorage();

        function updateHopEntry(hopId, entryId, field, value) {
            const hop = investigation.hops.find(h => h.id === hopId);
            const entry = hop.entries.find(e => e.id === entryId);
            entry[field] = value;
            
            // If timestamp changed, re-sort entries chronologically
            if (field === 'timestamp') {
                sortHopEntriesChronologically(hop);
            }
            
            if (field === 'entryType') {
                // Regenerate notation if victim and transaction numbers exist
                if (entry.victimNumbers && entry.transactionNumbers) {
                    generateNotationPreview(hopId, entryId);
                }
                renderHops();
                saveToStorage();
                return;
            }
            
            if (field === 'currency') {
                const customInput = document.getElementById(`customEntryCurrency_${hopId}_${entryId}`);
                if (customInput) {
                    if (value === 'CUSTOM') {
                        customInput.style.display = 'block';
                        customInput.classList.remove('custom-currency-input');
                    } else {
                        customInput.style.display = 'none';
                        customInput.classList.add('custom-currency-input');
                    }
                }
            }
            
            // Handle wallet address changes
            if (field === 'toWallet' || field === 'fromWallet') {
                // Check if this is a known wallet and auto-set the type
                if (field === 'toWallet' && value) {
                    const knownWallet = investigation.universalWalletIndex?.find(w => w.address === value.trim());
                    if (knownWallet) {
                        // Auto-set the wallet type from UWI
                        entry.toWalletType = knownWallet.permanentType;
                        
                        // Update the wallet type dropdown if it exists
                        const typeSelect = document.querySelector(`select[onchange="updateHopEntryWalletType(${hopId}, ${entryId}, this.value)"]`);
                        if (typeSelect) {
                            typeSelect.value = knownWallet.permanentType;
                        }
                    }
                }
                
                buildUniversalWalletIndex();
                buildRedWalletIndex();
            }
            
            if (field === 'amount' || field === 'currency' || field === 'toWallet' || field === 'entryType') {
                renderHops();
            }
            
            // If amount changed, mark downstream hops for validation
            if (field === 'amount' && parseFloat(value) !== parseFloat(entry._previousAmount || 0)) {
                entry._previousAmount = value;
                markDownstreamHopsForValidation(hop.hopNumber);
            }
            
            saveToStorage();
            updateValidationStatus();
            buildAvailableThreadsIndex(); // Rebuild thread index when entry is updated
        }
        
        // Mark all hops downstream from a given hop number for validation
        function markDownstreamHopsForValidation(fromHopNumber) {
            investigation.hops.forEach(hop => {
                if (hop.hopNumber > fromHopNumber) {
                    hop.needsValidation = true;
                }
            });
        }

        function updateHopEntryWalletType(hopId, entryId, walletType) {
            updateHopEntry(hopId, entryId, 'toWalletType', walletType);
            
            // If BROWN wallet is selected, open asset conversion modal
            if (walletType === 'brown') {
                openAssetConversionModal(hopId, entryId);
            }
        }

        function openAssetConversionModal(hopId, entryId) {
            showModal('assetConversionModal');
            
            // Store the hop and entry ID for later use
            window.currentConversionHopId = hopId;
            window.currentConversionEntryId = entryId;
            
            // Pre-populate with entry data if available
            const hop = investigation.hops.find(h => h.id === hopId);
            const entry = hop.entries.find(e => e.id === entryId);
            if (entry) {
                // Set from currency based on the entry's current currency
                if (entry.currency === 'CUSTOM') {
                    document.getElementById('conversionFromCurrency').value = 'CUSTOM';
                    document.getElementById('customFromCurrencyGroup').style.display = 'block';
                    document.getElementById('conversionFromCurrencyCustom').value = entry.customCurrency || '';
                } else {
                    document.getElementById('conversionFromCurrency').value = entry.currency || '';
                }
                document.getElementById('conversionFromAmount').value = entry.amount || '';
            }
        }

        function confirmAssetConversion() {
            const hopId = window.currentConversionHopId;
            const entryId = window.currentConversionEntryId;
            if (!hopId || !entryId) return;
            
            const fromCurrency = document.getElementById('conversionFromCurrency').value;
            const toCurrency = document.getElementById('conversionToCurrency').value;
            const fromAmount = document.getElementById('conversionFromAmount').value;
            const toAmount = document.getElementById('conversionToAmount').value;
            const platform = document.getElementById('conversionPlatform').value;
            const notes = document.getElementById('conversionNotes').value;
            
            // Get custom currencies if selected
            const fromCustom = document.getElementById('conversionFromCurrencyCustom').value;
            const toCustom = document.getElementById('conversionToCurrencyCustom').value;
            
            // Update entry with conversion data
            const hop = investigation.hops.find(h => h.id === hopId);
            const entry = hop.entries.find(e => e.id === entryId);
            if (entry) {
                // Store original currency info for the conversion record
                const originalCurrency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                const originalAmount = entry.amount || fromAmount;
                
                // Update the entry currency to the "to" currency
                entry.currency = toCurrency;
                entry.customCurrency = toCurrency === 'CUSTOM' ? toCustom : '';
                entry.amount = toAmount;
                
                // Add conversion info to notes
                const conversionInfo = `Asset Conversion: ${originalAmount} ${originalCurrency}  ${toAmount} ${toCurrency === 'CUSTOM' ? toCustom : toCurrency} via ${platform}. ${notes}`;
                entry.notes = entry.notes ? entry.notes + '\n' + conversionInfo : conversionInfo;
                
                // Mark this as a conversion entry
                entry.isConversion = true;
                entry.conversionData = {
                    fromCurrency: originalCurrency,
                    fromAmount: parseFloat(originalAmount) || 0,
                    toCurrency: toCurrency === 'CUSTOM' ? toCustom : toCurrency,
                    toAmount: parseFloat(toAmount) || 0,
                    platform: platform,
                    conversionRate: parseFloat(toAmount) / parseFloat(originalAmount)
                };
            }
            
            // Store conversion details
            const conversion = {
                id: (investigation.conversions || []).length + 1,
                hopId: hopId,
                entryId: entryId,
                fromCurrency: fromCurrency === 'CUSTOM' ? fromCustom : fromCurrency,
                toCurrency: toCurrency === 'CUSTOM' ? toCustom : toCurrency,
                fromAmount: parseFloat(fromAmount) || 0,
                toAmount: parseFloat(toAmount) || 0,
                platform: platform,
                notes: notes
            };
            
            if (!investigation.conversions) {
                investigation.conversions = [];
            }
            investigation.conversions.push(conversion);
            
            closeAssetConversionModal();
            renderHops();
            saveToStorage();
        }

        function closeAssetConversionModal() {
            hideModal('assetConversionModal');
            window.currentConversionHopId = null;
            window.currentConversionEntryId = null;
        }

        function openConvergenceHelper() {
            if (!investigation.hops || investigation.hops.length < 1) {
                alert('Need at least 1 hop with multiple entries to record convergence.');
                return;
            }
            
            let content = '<div style="margin: 15px 0;"><strong>Select entries that are converging:</strong></div>';
            investigation.hops.forEach(hop => {
                hop.entries.forEach(entry => {
                    if (entry.entryType === 'trace') {
                        content += `
                            <label style="display: block; margin: 8px 0; cursor: pointer;">
                                <input type="checkbox" value="${hop.id}_${entry.id}" onchange="updateConvergenceSelection()"> 
                                ${entry.notation || 'Entry ' + entry.id} - ${entry.amount} ${entry.currency} (H${entry.hopNumber})
                            </label>
                        `;
                    }
                });
            });
            
            document.getElementById('convergenceTraceSelection').innerHTML = content;
            showModal('convergenceModal');
        }

        function updateConvergenceSelection() {
            const selected = Array.from(document.querySelectorAll('#convergenceTraceSelection input:checked'));
            if (selected.length < 2) return;
            
            const selectedEntries = selected.map(input => {
                const [hopId, entryId] = input.value.split('_');
                const hop = investigation.hops.find(h => h.id == hopId);
                return hop.entries.find(e => e.id == entryId);
            });
            
            const maxHop = Math.max(...selectedEntries.map(e => e.hopNumber));
            document.getElementById('convergenceHopLevel').value = maxHop + 1;
            
            const totalAmount = selectedEntries.reduce((sum, entry) => sum + (parseFloat(entry.amount) || 0), 0);
            document.getElementById('convergenceAmount').value = totalAmount;
            
            const victimSets = new Set();
            const transactionSets = new Set();
            selectedEntries.forEach(entry => {
                const parts = entry.notation.split('-');
                if (parts.length >= 2) {
                    victimSets.add(parts[0]);
                    transactionSets.add(parts[1]);
                }
            });
            
            const victims = Array.from(victimSets).join(',');
            const transactions = Array.from(transactionSets).join('(') + (transactionSets.size > 1 ? ')' : '');
            const suggestedNotation = `${victims}-${transactions}-H${maxHop + 1}`;
            document.getElementById('convergenceNotation').value = suggestedNotation;
        }

        function createConvergenceTrace() {
            const notation = document.getElementById('convergenceNotation').value;
            const hopLevel = document.getElementById('convergenceHopLevel').value;
            const amount = document.getElementById('convergenceAmount').value;
            
            if (!notation) {
                alert('Please enter the convergence notation.');
                return;
            }
            
            // Create new hop for convergence
            const hop = {
                id: investigation.hops.length + 1,
                hopNumber: parseInt(hopLevel),
                entries: [],
                artAtStartByCurrency: { 'USD': parseFloat(amount) },
                completed: false
            };
            
            // Add convergence entry
            const entry = {
                id: 1,
                hopId: hop.id,
                hopNumber: hop.hopNumber,
                entryType: 'trace',
                notation: notation,
                fromWallet: 'CONVERGENCE',
                fromWalletType: 'yellow',
                toWallet: '',
                toWalletType: 'yellow',
                amount: amount,
                currency: 'USD',
                customCurrency: '',
                txHash: '',
                timestamp: '',
                timezone: 'UTC',
                notes: 'Convergence of multiple traces',
                category: '',
                justification: ''
            };
            
            hop.entries.push(entry);
            
            // Sort entries chronologically
            sortHopEntriesChronologically(hop);
            
            investigation.hops.push(hop);
            
            closeConvergenceModal();
            renderHops();
            saveToStorage();
        }

        function closeConvergenceModal() {
            hideModal('convergenceModal');
        }

        function setupConversionModalListeners() {
            const fromCurrencySelect = document.getElementById('conversionFromCurrency');
            const toCurrencySelect = document.getElementById('conversionToCurrency');
            
            if (fromCurrencySelect) {
                fromCurrencySelect.addEventListener('change', function() {
                    const customGroup = document.getElementById('customFromCurrencyGroup');
                    if (this.value === 'CUSTOM') {
                        customGroup.style.display = 'block';
                    } else {
                        customGroup.style.display = 'none';
                    }
                });
            }
            
            if (toCurrencySelect) {
                toCurrencySelect.addEventListener('change', function() {
                    const customGroup = document.getElementById('customToCurrencyGroup');
                    if (this.value === 'CUSTOM') {
                        customGroup.style.display = 'block';
                    } else {
                        customGroup.style.display = 'none';
                    }
                });
            }
        }

        function removeHop(hopId) {
            if (confirm('Are you sure you want to remove this entire hop?')) {
                const hop = investigation.hops.find(h => h.id === hopId);
                saveUndoState(`Remove Hop ${hop.hopNumber}`);
                
                investigation.hops = investigation.hops.filter(h => h.id !== hopId);
                renderHops();
                saveToStorage();
                updateValidationStatus();
                updateWorkflowSteps();
            }
        }

        function removeHopEntry(hopId, entryId) {
            const hop = investigation.hops.find(h => h.id === hopId);
            const entry = hop.entries.find(e => e.id === entryId);
            
            saveUndoState(`Remove entry ${entry.notation || `Entry ${entry.id}`} from Hop ${hop.hopNumber}`);
            
            hop.entries = hop.entries.filter(e => e.id !== entryId);
            
            // Mark downstream hops for validation since an entry was removed
            markDownstreamHopsForValidation(hop.hopNumber);
            
            renderHops();
            saveToStorage();
            updateValidationStatus();
        }

        function validateTransactionChronology(victim) {
            // Get all transactions with dates
            const transactionsWithDates = victim.transactions
                .filter(t => t.datetime && t.datetime.trim() !== '')
                .map(t => ({
                    id: t.id,
                    datetime: t.datetime,
                    timezone: t.timezone || 'UTC',
                    timestamp: convertToUTC(t.datetime, t.timezone || 'UTC')
                }));
            
            // Check if transactions are in chronological order
            for (let i = 0; i < transactionsWithDates.length - 1; i++) {
                const current = transactionsWithDates[i];
                const next = transactionsWithDates[i + 1];
                
                if (current.timestamp > next.timestamp) {
                    return `Transaction V${victim.id}-T${current.id} (${formatDateTimeDisplay(current.datetime, current.timezone)}) occurs AFTER V${victim.id}-T${next.id} (${formatDateTimeDisplay(next.datetime, next.timezone)}).\n\nTransaction IDs must be in chronological order.`;
                }
            }
            
            return null; // No errors
        }
        
        function convertToUTC(datetime, timezone) {
            // Convert datetime string to UTC timestamp for comparison
            // This is a simplified conversion - in production you'd use a library like moment.js
            const date = new Date(datetime);
            
            // Timezone offset map (simplified - doesn't account for DST)
            const timezoneOffsets = {
                'UTC': 0,
                'EST': -5,
                'EDT': -4,
                'CST': -6,
                'CDT': -5,
                'MST': -7,
                'MDT': -6,
                'PST': -8,
                'PDT': -7,
                'GMT': 0,
                'CET': 1,
                'JST': 9
            };
            
            const offset = timezoneOffsets[timezone] || 0;
            // Subtract offset to convert to UTC (negative offsets become positive)
            return date.getTime() - (offset * 60 * 60 * 1000);
        }
        
        function formatDateTimeDisplay(datetime, timezone) {
            if (!datetime) return 'No date';
            const date = new Date(datetime);
            const options = { 
                year: 'numeric', 
                month: '2-digit', 
                day: '2-digit',
                hour: '2-digit',
                minute: '2-digit'
            };
            return `${date.toLocaleDateString('en-US', options)} ${timezone}`;
        }

        function updateTransaction(victimId, transactionId, field, value) {
            const victim = investigation.victims.find(v => v.id === victimId);
            const transaction = victim.transactions.find(t => t.id === transactionId);
            
            // Store the old value in case we need to revert
            const oldValue = transaction[field];
            transaction[field] = value;
            
            // Validate chronological order when datetime is updated
            if (field === 'datetime' && value) {
                const chronologyError = validateTransactionChronology(victim);
                if (chronologyError) {
                    // Revert the change
                    transaction[field] = oldValue;
                    
                    // Show error message with fix option
                    const shouldFix = confirm(` Chronological Order Error!\n\n${chronologyError}\n\nTransactions must be entered in chronological order for proper PIFO (Proceeds In First Out) compliance and smart allocation features.\n\nWould you like to automatically fix the order?\n\nClick OK to automatically reorder transactions chronologically.\nClick Cancel to revert your change.`);
                    
                    if (shouldFix) {
                        // Fix the order
                        fixVictimTransactionOrder(victimId);
                        return;
                    }
                    
                    // Re-render to show the reverted value
                    renderVictims();
                    return;
                }
            }
            
            // If receiving wallet changed and root total is confirmed, rebuild Universal Wallet Index
            if (field === 'receivingWallet' && investigation.rootTotalConfirmed) {
                buildUniversalWalletIndex();
                buildRedWalletIndex();
                renderHops(); // Re-render to update dropdowns
            }
            
            // Update red wallet index when any transaction field changes
            if (investigation.rootTotalConfirmed) {
                buildRedWalletIndex();
            }
            
            saveToStorage();
            updateValidationStatus();
            updateWorkflowSteps();
            updateGenerateRootSection();
        }

        function removeVictim(victimId) {
            if (confirm('Are you sure you want to remove this victim? This will also reset the root total confirmation.')) {
                investigation.victims = investigation.victims.filter(v => v.id !== victimId);
                investigation.rootTotalConfirmed = false;
                investigation.confirmedRootTotal = 0;
                investigation.confirmedRootTotalsByCurrency = {};
                renderVictims();
                saveToStorage();
                updateValidationStatus();
                updateWorkflowSteps();
            }
        }
        
        function completeVictim(victimId) {
            const victim = investigation.victims.find(v => v.id === victimId);
            if (!victim) return;
            
            // Validate all transactions have required data
            const incompleteTransactions = victim.transactions.filter(t => 
                parseFloat(t.amount) > 0 && (!t.receivingWallet || t.receivingWallet.trim() === '')
            );
            
            if (incompleteTransactions.length > 0) {
                alert(`Cannot complete victim ${victimId}: ${incompleteTransactions.length} transaction(s) are missing receiving wallet addresses.`);
                return;
            }
            
            if (confirm(`Complete Victim ${victimId}?\n\nThis will minimize the view to show only a summary. You can edit later if needed.`)) {
                victim.isCompleted = true;
                
                // Build wallet indexes even before root total confirmation to allow early access
                buildUniversalWalletIndex();
                buildRedWalletIndex();
                
                renderVictims();
                saveToStorage();
                updateWorkflowSteps();
                updateGenerateRootSection();
            }
        }
        
        function reopenVictim(victimId) {
            const victim = investigation.victims.find(v => v.id === victimId);
            if (victim) {
                victim.isCompleted = false;
                renderVictims();
                saveToStorage();
            }
        }

        function renderSummary() {
            const container = document.getElementById('summaryContent');
            
            const totalVictims = investigation.victims.length;
            const totalTransactions = investigation.victims.reduce((sum, v) => sum + v.transactions.length, 0);
            
            // Calculate totals by currency
            const rootTotalsByCurrency = investigation.confirmedRootTotalsByCurrency || {};
            const writeoffsByCurrency = {};
            const artByCurrency = {};
            
            // Calculate write-offs by currency from hop entries
            investigation.hops.forEach(hop => {
                hop.entries.forEach(entry => {
                    if (entry.entryType === 'writeoff' && parseFloat(entry.amount) > 0) {
                        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                        if (!writeoffsByCurrency[currency]) {
                            writeoffsByCurrency[currency] = 0;
                        }
                        writeoffsByCurrency[currency] += parseFloat(entry.amount);
                    }
                });
            });
            
            // Calculate ART by currency
            Object.entries(rootTotalsByCurrency).forEach(([currency, rootAmount]) => {
                const writeoffAmount = writeoffsByCurrency[currency] || 0;
                artByCurrency[currency] = rootAmount - writeoffAmount;
            });

            container.innerHTML = `
                <div class="summary-grid">
                    <div class="summary-card">
                        <h3>Total Victims</h3>
                        <div class="value">${totalVictims}</div>
                    </div>
                    <div class="summary-card">
                        <h3>Total Transactions</h3>
                        <div class="value">${totalTransactions}</div>
                    </div>
                    <div class="summary-card">
                        <h3>Total Hops</h3>
                        <div class="value">${investigation.hops.length}</div>
                    </div>
                </div>
                
                <div style="margin: 30px 0;">
                    <h3 style="color: #2c3e50; margin-bottom: 20px;">Financial Summary by Currency</h3>
                    ${Object.keys(rootTotalsByCurrency).length > 0 ? `
                        <div style="background: #f8f9fa; border-radius: 8px; padding: 20px; border: 2px solid #e8f0fe;">
                            ${Object.entries(rootTotalsByCurrency).map(([currency, rootAmount]) => {
                                const writeoffAmount = writeoffsByCurrency[currency] || 0;
                                const artAmount = artByCurrency[currency] || rootAmount - writeoffAmount;
                                return `
                                    <div style="margin-bottom: 20px; padding: 15px; background: white; border-radius: 6px; border-left: 4px solid #3498db;">
                                        <h4 style="color: #2c3e50; margin-bottom: 10px;">${currency}</h4>
                                        <div style="display: grid; grid-template-columns: repeat(3, 1fr); gap: 15px; font-size: 14px;">
                                            <div>
                                                <strong>Root Total:</strong><br>
                                                <span style="font-size: 1.2rem; color: #27ae60;">${rootAmount.toLocaleString()}</span>
                                            </div>
                                            <div>
                                                <strong>Write-offs:</strong><br>
                                                <span style="font-size: 1.2rem; color: #e74c3c;">${writeoffAmount.toLocaleString()}</span>
                                            </div>
                                            <div>
                                                <strong>Adjusted Root Total:</strong><br>
                                                <span style="font-size: 1.2rem; color: #3498db;">${artAmount.toLocaleString()}</span>
                                            </div>
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    ` : `
                        <div style="text-align: center; padding: 40px; color: #7f8c8d; background: #f8f9fa; border-radius: 8px; border: 2px dashed #bdc3c7;">
                            <p>No root totals confirmed yet. Please complete the victim setup and confirm your root total.</p>
                        </div>
                    `}
                </div>
            `;
        }

        function updateValidationStatus() {
            const validationPanel = document.getElementById('validationStatus');
            
            // Early return if element doesn't exist (it was removed from the UI)
            if (!validationPanel) {
                return;
            }
            
            if (!investigation.rootTotalConfirmed) {
                validationPanel.className = 'validation-panel validation-warning';
                validationPanel.innerHTML = '<div> Setup Required</div><div>Complete steps 1-3 to begin tracing</div>';
                return;
            }

            const artByCurrency = getCurrentART();
            const currentThreadsByCurrency = {};
            
            // Calculate current thread totals by finding the highest hop entries for each trace path
            // Group entries by V-T notation to track each victim-transaction path
            const tracePathsByCurrency = {};
            
            investigation.hops.forEach(hop => {
                hop.entries.forEach(entry => {
                    if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0 && entry.notation) {
                        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                        
                        // Extract V-T path from notation (e.g., "V1-T1-H3" -> "V1-T1")
                        const pathMatch = entry.notation.match(/^(V\d+-T\d+)/);
                        if (pathMatch) {
                            const vtPath = pathMatch[1];
                            
                            if (!tracePathsByCurrency[currency]) {
                                tracePathsByCurrency[currency] = {};
                            }
                            if (!tracePathsByCurrency[currency][vtPath]) {
                                tracePathsByCurrency[currency][vtPath] = [];
                            }
                            
                            tracePathsByCurrency[currency][vtPath].push({
                                hopNumber: entry.hopNumber,
                                amount: parseFloat(entry.amount),
                                notation: entry.notation
                            });
                        }
                    }
                });
            });
            
            // For each currency and path, take only the highest hop number (current thread value)
            Object.entries(tracePathsByCurrency).forEach(([currency, paths]) => {
                if (!currentThreadsByCurrency[currency]) {
                    currentThreadsByCurrency[currency] = 0;
                }
                
                Object.entries(paths).forEach(([vtPath, entries]) => {
                    // Sort by hop number and take the highest (most recent)
                    entries.sort((a, b) => b.hopNumber - a.hopNumber);
                    const currentEntry = entries[0];
                    currentThreadsByCurrency[currency] += currentEntry.amount;
                });
            });
            
            // Check validation for each currency
            let allValid = true;
            let validationDetails = [];
            
            Object.keys(artByCurrency).forEach(currency => {
                const artAmount = artByCurrency[currency];
                const threadAmount = currentThreadsByCurrency[currency] || 0;
                const difference = Math.abs(threadAmount - artAmount);
                
                if (difference >= 0.01) {
                    allValid = false;
                    validationDetails.push(`${currency}: Thread ${threadAmount.toLocaleString()} != ART ${artAmount.toLocaleString()}`);
                } else {
                    validationDetails.push(`${currency}:  ${threadAmount.toLocaleString()}`);
                }
            });
            
            if (allValid && Object.keys(artByCurrency).length > 0) {
                validationPanel.className = 'validation-panel';
                validationPanel.innerHTML = `<div> Validation Passed</div><div>${validationDetails.join('<br>')}</div>`;
            } else {
                validationPanel.className = 'validation-panel validation-error';
                validationPanel.innerHTML = `<div> Validation Failed</div><div>${validationDetails.join('<br>')}</div>`;
            }
        }

        function validateTraces() {
            updateValidationStatus();
        }

        function getWalletColor(type) {
            const colors = {
                'red': '#e74c3c',
                'pink': '#e91e63', 
                'yellow': '#f1c40f',
                'orange': '#f39c12',
                'brown': '#8d6e63',
                'black': '#2c3e50',
                'blue': '#3498db',
                'purple': '#9b59b6',
                'gray': '#95a5a6',
                'green': '#27ae60'
            };
            return colors[type] || '#3498db';
        }

        async function saveInvestigation() {
            if (!investigation.caseId) {
                alert('Please enter a Case ID before saving.');
                return;
            }

            const dataStr = JSON.stringify(investigation, null, 2);
            
            // If we have a file handle from the File System Access API, use it
            if (fileHandle && isFileSystemAvailable) {
                try {
                    const writable = await fileHandle.createWritable();
                    await writable.write(dataStr);
                    await writable.close();
                    
                    showNotification('Investigation saved successfully!', 'success');
                    return;
                } catch (error) {
                    console.error('Error saving with file handle:', error);
                    // Fall back to download if file handle save fails
                }
            }
            
            // Default download method - use case ID as filename
            const filename = `${investigation.caseId}.bats`;
            downloadFile(dataStr, filename, 'application/json');
        }

        function loadInvestigation(event) {
    const file = event.target.files[0];
    if (!file) {
        console.log('No file selected');
        return;
    }

    console.log('Starting file load:', file.name, 'Size:', file.size, 'Type:', file.type);

    const reader = new FileReader();
    reader.onload = function(e) {
        try {
            console.log('File read successfully, parsing JSON...');
            const content = e.target.result;
            
            // Parse JSON
            const loadedData = JSON.parse(content);
            console.log('JSON parsed successfully:', loadedData);
            
            // Validate basic structure
            if (!loadedData.victims || !loadedData.hops) {
                throw new Error('Invalid BATS investigation file - missing required data structure');
            }
            
            console.log('Basic validation passed');
            
            // Initialize enhanced structure if missing
            initializeCompleteIntegration(loadedData);
            
            // Migrate data structure if needed
            migrateToEnhancedStructure(loadedData);
            
            // Set the global investigation object
            investigation = loadedData;
            
            // Sort all hop entries chronologically after loading
            if (investigation.hops) {
                investigation.hops.forEach(hop => {
                    if (hop.entries && hop.entries.length > 0) {
                        sortHopEntriesChronologically(hop);
                    }
                });
            }
            
            // Update form fields
            updateFormFieldsFromInvestigation();
            
            // Check chronological order of transactions
            const chronologyErrors = [];
            investigation.victims.forEach(victim => {
                const error = validateTransactionChronology(victim);
                if (error) {
                    chronologyErrors.push(`Victim ${victim.id}:\n${error}`);
                }
            });
            
            // Re-render everything
            renderAll();
            updateWorkflowSteps();
            
            // Alert about chronology errors after rendering
            if (chronologyErrors.length > 0) {
                setTimeout(() => {
                    alert(` WARNING: Transaction Chronology Issues Detected!\n\n${chronologyErrors.join('\n\n')}\n\nThe V-T notation requires transactions to be numbered in chronological order. Please review and correct the transaction order to ensure PIFO (Proceeds In First Out) compliance.\n\nYou can manually adjust the dates or re-number the transactions.`);
                }, 500);
            }
            
            // Clear the file input to allow re-loading the same file
            event.target.value = '';
            
            console.log('Investigation loaded successfully!');
            alert('Investigation loaded successfully!');
            
        } catch (error) {
            console.error('Error loading file:', error);
            alert('Error loading file: ' + error.message);
            
            // Clear the file input on error too
            event.target.value = '';
        }
    };
    
    reader.onerror = function() {
        console.error('File reading failed');
        alert('Failed to read the file. Please try again.');
        event.target.value = '';
    };
    
    reader.readAsText(file);
}
        function exportReport() {
            const report = generateBATSReport();
            downloadFile(report, 'BATS_Report_' + (investigation.caseId || 'Investigation') + '.html', 'text/html');
        }

        function exportJSON() {
            const data = JSON.stringify(investigation, null, 2);
            const filename = 'BATS_Data_' + (investigation.caseId || 'Investigation') + '.json';
            downloadFile(data, filename, 'application/json');
        }

        function exportCSV() {
            let csv = 'Type,Notation,Amount,Currency,From,To,WalletType,Hop,DateTime,Timezone,Notes\n';
            
            // Export hop entries (including writeoffs)
            investigation.hops.forEach(hop => {
                hop.entries.forEach(entry => {
                    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                    csv += `${entry.entryType},"${entry.notation}","${entry.amount}","${currency}","${entry.fromWallet}","${entry.toWallet}","${entry.toWalletType}","${entry.hopNumber}","${entry.timestamp}","${entry.timezone}","${entry.notes || entry.justification || ''}"\n`;
                });
            });
            
            const filename = 'BATS_Data_' + (investigation.caseId || 'Investigation') + '.csv';
            downloadFile(csv, filename, 'text/csv');
        }

        function generateBATSReport() {
            const totalVictims = investigation.victims.length;
            const rootTotalsByCurrency = investigation.confirmedRootTotalsByCurrency || {};
            
            // Calculate write-offs by currency from hop entries
            const writeoffsByCurrency = {};
            investigation.hops.forEach(hop => {
                hop.entries.forEach(entry => {
                    if (entry.entryType === 'writeoff' && parseFloat(entry.amount) > 0) {
                        const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                        if (!writeoffsByCurrency[currency]) {
                            writeoffsByCurrency[currency] = 0;
                        }
                        writeoffsByCurrency[currency] += parseFloat(entry.amount);
                    }
                });
            });

            // Build Red Wallet Index section
            const redWalletSection = investigation.redWalletIndex && investigation.redWalletIndex.length > 0 ? `
                <div class="section">
                    <div class="section-title">Section 2: Red Wallet Index - Victim Deposit Summary</div>
                    <table>
                        <tr>
                            <th>V-T Notation</th>
                            <th>Wallet ID</th>
                            <th>Deposit Date</th>
                            <th>Amount</th>
                            <th>Currency</th>
                            <th>Wallet Address</th>
                            <th>Notes</th>
                        </tr>
                        ${investigation.redWalletIndex.map(entry => `
                            <tr>
                                <td>${entry.vtNotation}</td>
                                <td>${entry.walletId || 'Not assigned'}</td>
                                <td>${entry.depositDate ? `${entry.depositDate} ${entry.timezone}` : 'Not specified'}</td>
                                <td>${entry.amount.toLocaleString()}</td>
                                <td>${entry.currency}</td>
                                <td style="font-family: monospace; font-size: 11px; word-break: break-all;">${entry.walletAddress}</td>
                                <td>${(entry.notes || '') + (entry.investigativeNotes ? ' | ' + entry.investigativeNotes : '')}</td>
                            </tr>
                        `).join('')}
                    </table>
                </div>
            ` : '';

            return `<!DOCTYPE html>
<html>
<head>
    <title>B.A.T.S. Investigation Report - ${investigation.caseId}</title>
    <style>
        body { font-family: 'Segoe UI', Arial, sans-serif; margin: 40px; line-height: 1.6; color: #2c3e50; }
        .header { text-align: center; border-bottom: 3px solid #2c3e50; padding-bottom: 20px; margin-bottom: 30px; }
        .section { margin: 30px 0; }
        .section-title { background: #2c3e50; color: white; padding: 15px; margin-bottom: 20px; font-weight: 600; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        th, td { border: 1px solid #ddd; padding: 12px; text-align: left; }
        th { background: #f8f9fa; font-weight: bold; color: #2c3e50; }
        .summary-box { background: #e8f5e8; border: 2px solid #27ae60; padding: 20px; margin: 20px 0; border-radius: 8px; }
        .currency-section { background: #f8f9fa; border: 1px solid #ddd; padding: 15px; margin: 10px 0; border-radius: 6px; }
    </style>
</head>
<body>
    <div class="header">
        <h1>B.A.T.S. Investigation Report</h1>
        <h2>Block Audit Tracing Standard</h2>
        <p><strong>Case ID:</strong> ${investigation.caseId}</p>
        <p><strong>Investigator:</strong> ${investigation.investigator}</p>
        <p><strong>Report Generated:</strong> ${new Date().toLocaleString()}</p>
    </div>

    <div class="section">
        <div class="section-title">Section 1: Case Summary</div>
        <p><strong>Case Type:</strong> ${investigation.caseType}</p>
        <p><strong>Total Victims:</strong> ${totalVictims}</p>
        <p><strong>Investigation Period:</strong> ${new Date(investigation.created).toLocaleDateString()} - ${new Date().toLocaleDateString()}</p>
        ${investigation.caseSynopsis ? `
        <div style="margin-top: 20px;">
            <p><strong>Case Synopsis:</strong></p>
            <div style="background: #f8f9fa; border-left: 4px solid #3498db; padding: 15px; margin-top: 10px;">
                ${investigation.caseSynopsis.replace(/\n/g, '<br>')}
            </div>
        </div>
        ` : ''}
    </div>

    ${redWalletSection}

    ${investigation.hops.length > 0 ? `
    <div class="section">
        <div class="section-title">Section 3: Hop Documentation</div>
        ${investigation.hops.map(hop => `
            <h3>Hop ${hop.hopNumber}</h3>
            <table>
                <tr>
                    <th>Entry Type</th>
                    <th>Notation</th>
                    <th>Amount</th>
                    <th>Currency</th>
                    <th>From Wallet</th>
                    <th>To Wallet</th>
                    <th>Classification</th>
                    <th>Transaction Hash</th>
                    <th>Timestamp</th>
                    <th>Notes</th>
                </tr>
                ${hop.entries.map(entry => `
                    <tr>
                        <td>${entry.entryType}</td>
                        <td>${entry.notation}</td>
                        <td>${(parseFloat(entry.amount) || 0).toLocaleString()}</td>
                        <td>${entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency}</td>
                        <td style="font-family: monospace; font-size: 11px; word-break: break-all;">${entry.fromWallet}</td>
                        <td style="font-family: monospace; font-size: 11px; word-break: break-all;">${entry.toWallet}</td>
                        <td>${walletTypes[entry.toWalletType] || entry.toWalletType}</td>
                        <td style="font-family: monospace; font-size: 11px; word-break: break-all;">${entry.txHash}</td>
                        <td>${entry.timestamp}</td>
                        <td>${entry.notes || entry.justification || ''}</td>
                    </tr>
                `).join('')}
            </table>
        `).join('')}
    </div>
    ` : ''}

    <div class="section">
        <div class="section-title">Section 4: Summary of Findings</div>
        <div class="summary-box">
            <h3>Golden Thread Analysis by Currency</h3>
            ${Object.keys(rootTotalsByCurrency).length > 0 ? Object.entries(rootTotalsByCurrency).map(([currency, rootAmount]) => {
                const writeoffAmount = writeoffsByCurrency[currency] || 0;
                const adjustedTotal = rootAmount - writeoffAmount;
                
                // Calculate traced amount for this currency
                let tracedAmount = 0;
                investigation.hops.forEach(hop => {
                    hop.entries.forEach(entry => {
                        if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0) {
                            const entryCurrency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                            if (entryCurrency === currency) {
                                tracedAmount += parseFloat(entry.amount);
                            }
                        }
                    });
                });
                
                const isValid = Math.abs(tracedAmount - adjustedTotal) < 0.01;
                
                return `
                    <div class="currency-section">
                        <h4>${currency}</h4>
                        <p><strong>Root Total:</strong> ${rootAmount.toLocaleString()}</p>
                        <p><strong>Write-offs:</strong> ${writeoffAmount.toLocaleString()}</p>
                        <p><strong>Adjusted Root Total:</strong> ${adjustedTotal.toLocaleString()}</p>
                        <p><strong>Traced Amount:</strong> ${tracedAmount.toLocaleString()}</p>
                        <p><strong>Mathematical Validation:</strong> <span style="color: ${isValid ? 'green' : 'red'}; font-weight: bold;">${isValid ? 'PASSED' : 'FAILED'}</span></p>
                    </div>
                `;
            }).join('') : '<p>No confirmed root totals available.</p>'}
        </div>
    </div>
</body>
</html>`;
        }
// =================================
// PART 4: ENHANCED EXPORT FUNCTIONS
// Add these functions to your existing JavaScript
// =================================

function generateSourceChainReport() {
    console.log(' Generating source chain report...');
    
    const report = {
        timestamp: new Date().toISOString(),
        caseId: investigation.caseId,
        investigator: investigation.investigator,
        sourceChains: [],
        statistics: {
            totalChains: 0,
            totalConvergences: 0,
            totalSingleSource: 0,
            currenciesAnalyzed: new Set()
        }
    };
    
    // Analyze source chains for each trace entry
    investigation.hops.forEach(hop => {
        hop.entries.forEach(entry => {
            if (entry.entryType === 'trace' && entry.sourceChain && entry.sourceChain.length > 0) {
                const chainAnalysis = {
                    notation: entry.notation,
                    hopNumber: entry.hopNumber,
                    targetAmount: parseFloat(entry.amount),
                    currency: entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency,
                    sourceCount: entry.sourceChain.length,
                    isConvergence: entry.sourceChain.length > 1,
                    sources: entry.sourceChain.map(source => ({
                        sourceNotation: source.sourceNotation,
                        amount: source.amount,
                        percentage: (source.amount / parseFloat(entry.amount)) * 100,
                        currency: source.currency
                    })),
                    displayNotation: entry.displayNotation || '',
                    summaryNotation: entry.summaryNotation || '',
                    toWallet: entry.toWallet,
                    toWalletType: entry.toWalletType
                };
                
                report.sourceChains.push(chainAnalysis);
                report.statistics.totalChains++;
                report.statistics.currenciesAnalyzed.add(chainAnalysis.currency);
                
                if (chainAnalysis.isConvergence) {
                    report.statistics.totalConvergences++;
                } else {
                    report.statistics.totalSingleSource++;
                }
            }
        });
    });
    
    // Convert Set to Array for JSON serialization
    report.statistics.currenciesAnalyzed = Array.from(report.statistics.currenciesAnalyzed);
    
    // Store the report
    investigation.sourceChainReports.push(report);
    
    console.log(' Source chain report generated:', report);
    return report;
}

function exportEnhancedReport() {
    console.log(' Generating enhanced B.A.T.S. report...');
    
    // Run latest validation
    const validationResults = validateTracesEnhanced();
    
    // Generate source chain report
    const sourceChainReport = generateSourceChainReport();
    
    // Generate enhanced HTML report
    const enhancedReport = generateEnhancedBATSReport(validationResults, sourceChainReport);
    
    const filename = `Enhanced_BATS_Report_${investigation.caseId || 'Investigation'}_${new Date().toISOString().slice(0,10)}.html`;
    downloadFile(enhancedReport, filename, 'text/html');
}

function exportSourceChainReport() {
    const sourceChainReport = generateSourceChainReport();
    const filename = `Source_Chain_Analysis_${investigation.caseId || 'Investigation'}_${new Date().toISOString().slice(0,10)}.json`;
    downloadFile(JSON.stringify(sourceChainReport, null, 2), filename, 'application/json');
}

function generateEnhancedBATSReport(validationResults, sourceChainReport) {
    const timestamp = new Date().toLocaleString();
    
    return `<!DOCTYPE html>
<html>
<head>
    <title>Enhanced B.A.T.S. Investigation Report - ${investigation.caseId}</title>
    <style>
        body { font-family: 'Segoe UI', Arial, sans-serif; margin: 40px; line-height: 1.6; color: #2c3e50; }
        .header { text-align: center; border-bottom: 3px solid #2c3e50; padding-bottom: 20px; margin-bottom: 30px; }
        .section { margin: 30px 0; }
        .section-title { background: #2c3e50; color: white; padding: 15px; margin-bottom: 20px; font-weight: 600; }
        .enhanced-section { background: #3498db; color: white; padding: 15px; margin-bottom: 20px; font-weight: 600; }
        table { width: 100%; border-collapse: collapse; margin: 20px 0; }
        th, td { border: 1px solid #ddd; padding: 12px; text-align: left; }
        th { background: #f8f9fa; font-weight: bold; color: #2c3e50; }
        .summary-box { background: #e8f5e8; border: 2px solid #27ae60; padding: 20px; margin: 20px 0; border-radius: 8px; }
        .warning-box { background: #fff3cd; border: 2px solid #ffc107; padding: 20px; margin: 20px 0; border-radius: 8px; }
        .error-box { background: #f8d7da; border: 2px solid #dc3545; padding: 20px; margin: 20px 0; border-radius: 8px; }
        .currency-section { background: #f8f9fa; border: 1px solid #ddd; padding: 15px; margin: 10px 0; border-radius: 6px; }
        .thread-analysis { background: #e8f4f8; border: 1px solid #3498db; padding: 15px; margin: 10px 0; border-radius: 6px; }
        .source-chain { font-family: 'Courier New', monospace; background: #f8f9fa; padding: 10px; border-radius: 4px; margin: 5px 0; }
        .convergence { background: #fff3cd; border-left: 4px solid #ffc107; padding: 10px; margin: 5px 0; }
    </style>
</head>
<body>
    <div class="header">
        <h1>Enhanced B.A.T.S. Investigation Report</h1>
        <h2>Block Audit Tracing Standard - Phase 3 Complete Integration</h2>
        <p><strong>Case ID:</strong> ${investigation.caseId}</p>
        <p><strong>Investigator:</strong> ${investigation.investigator}</p>
        <p><strong>Report Generated:</strong> ${timestamp}</p>
        <p><strong>Integration Version:</strong> ${investigation.integrationVersion}</p>
    </div>

    <div class="section">
        <div class="enhanced-section">Section 1: Enhanced Validation Results</div>
        ${validationResults.overall ? 
            '<div class="summary-box"><h3> Validation Status: PASSED</h3><p>All mathematical balances verified, thread assignments validated, source chains confirmed.</p></div>' :
            '<div class="error-box"><h3> Validation Status: FAILED</h3><p>Critical errors detected in thread tracking or mathematical balance.</p></div>'
        }
        
        <h3>Thread Analysis by Currency</h3>
        ${Object.entries(validationResults.threadAnalysis).map(([currency, analysis]) => `
            <div class="thread-analysis">
                <h4>${currency}</h4>
                <p><strong>Total Threads:</strong> ${analysis.totalThreads}</p>
                <p><strong>Total Available:</strong> ${analysis.totalAvailable.toLocaleString()}</p>
                <p><strong>Total Assigned:</strong> ${analysis.totalAssigned.toLocaleString()}</p>
                ${analysis.unassignedThreads.length > 0 ? `<p style="color: #e67e22;"><strong>Unassigned Threads:</strong> ${analysis.unassignedThreads.join(', ')}</p>` : ''}
                ${analysis.overassignedThreads.length > 0 ? `<p style="color: #dc3545;"><strong>Over-assigned Threads:</strong> ${analysis.overassignedThreads.join(', ')}</p>` : ''}
            </div>
        `).join('')}

        <h3>Mathematical Balance Verification</h3>
        ${Object.entries(validationResults.mathematicalBalance).map(([currency, balance]) => `
            <div class="currency-section">
                <h4>${currency}</h4>
                <p><strong>Root Total:</strong> ${balance.rootTotal.toLocaleString()}</p>
                <p><strong>Write-offs:</strong> ${balance.writeoffAmount.toLocaleString()}</p>
                <p><strong>Adjusted Root Total:</strong> ${balance.adjustedRootTotal.toLocaleString()}</p>
                <p><strong>Current Thread Total:</strong> ${balance.currentThreadTotal.toLocaleString()}</p>
                <p><strong>Difference:</strong> ${balance.difference.toLocaleString()}</p>
                <p><strong>Balance Status:</strong> <span style="color: ${balance.isValid ? 'green' : 'red'}; font-weight: bold;">${balance.isValid ? 'BALANCED' : 'IMBALANCED'}</span></p>
            </div>
        `).join('')}
        
        ${validationResults.errors.length > 0 ? `
            <div class="error-box">
                <h3>Validation Errors</h3>
                <ul>
                    ${validationResults.errors.map(error => `<li>${error}</li>`).join('')}
                </ul>
            </div>
        ` : ''}
        
        ${validationResults.warnings.length > 0 ? `
            <div class="warning-box">
                <h3>Validation Warnings</h3>
                <ul>
                    ${validationResults.warnings.map(warning => `<li>${warning}</li>`).join('')}
                </ul>
            </div>
        ` : ''}
    </div>

    <div class="section">
        <div class="enhanced-section">Section 2: Source Chain Analysis</div>
        <div class="summary-box">
            <h3>Source Chain Statistics</h3>
            <p><strong>Total Source Chains:</strong> ${sourceChainReport.statistics.totalChains}</p>
            <p><strong>Single Source Chains:</strong> ${sourceChainReport.statistics.totalSingleSource}</p>
            <p><strong>Convergence Chains:</strong> ${sourceChainReport.statistics.totalConvergences}</p>
            <p><strong>Currencies Analyzed:</strong> ${sourceChainReport.statistics.currenciesAnalyzed.join(', ')}</p>
        </div>
        
        <h3>Detailed Source Chain Documentation</h3>
        <table>
            <tr>
                <th>Target Notation</th>
                <th>Hop</th>
                <th>Source Type</th>
                <th>Source Chain</th>
                <th>Amount</th>
                <th>Currency</th>
                <th>Target Wallet</th>
            </tr>
            ${sourceChainReport.sourceChains.map(chain => `
                <tr>
                    <td><strong>${chain.notation}</strong></td>
                    <td>${chain.hopNumber}</td>
                    <td>${chain.isConvergence ? '<span class="convergence">CONVERGENCE</span>' : 'Single Source'}</td>
                    <td class="source-chain">
                        ${chain.sources.map(source => 
                            `${source.sourceNotation}(${source.amount.toLocaleString()})`
                        ).join(' + ')}  ${chain.notation}
                    </td>
                    <td>${chain.targetAmount.toLocaleString()}</td>
                    <td>${chain.currency}</td>
                    <td style="font-family: monospace; font-size: 11px;">${chain.toWallet}</td>
                </tr>
            `).join('')}
        </table>
    </div>

    <div class="section">
        <div class="enhanced-section">Section 3: Investigation Integrity Assessment</div>
        <div class="summary-box">
            <h3>Golden Thread Verification</h3>
            <p>This enhanced B.A.T.S. report includes mathematical thread tracking that ensures every dollar traced can be accounted for from victim loss to final disposition.</p>
            <p><strong>Validation Timestamp:</strong> ${validationResults.timestamp}</p>
            <p><strong>Thread Tracking Status:</strong> ${validationResults.overall ? 'VERIFIED' : 'REQUIRES ATTENTION'}</p>
            <p><strong>Source Chain Completeness:</strong> ${sourceChainReport.statistics.totalChains > 0 ? 'DOCUMENTED' : 'INCOMPLETE'}</p>
        </div>
    </div>
</body>
</html>`;
}

function downloadFile(content, filename, mimeType) {
            const blob = new Blob([content], { type: mimeType });
            const url = window.URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            window.URL.revokeObjectURL(url);
        }

        function clearAll() {
            if (confirm('Are you sure you want to clear all data? This cannot be undone.')) {
                investigation = {
                    caseId: '',
                    investigator: '',
                    caseType: '',
                    victims: [],
                    hops: [],
                    conversions: [],
                    redWalletIndex: [],
                    universalWalletIndex: [],
                    rootTotalConfirmed: false,
                    confirmedRootTotal: 0,
                    confirmedRootTotalsByCurrency: {},
                    currentART: {},
                    created: new Date().toISOString()
                };
                renderAll();
                saveToStorage();
                updateWorkflowSteps();
            }
        }

        function renderAll() {
            renderVictims();
            renderHops();
            updateValidationStatus();
            checkOnboardingState();
        }

        // Storage functions
        function saveToStorage() {
            investigation.caseId = document.getElementById('caseId').value;
            investigation.investigator = document.getElementById('investigator').value;
            investigation.caseType = document.getElementById('caseType').value;
            investigation.caseSynopsis = document.getElementById('caseSynopsis').value || '';
            
            window.batsData = investigation;
            updateWorkflowSteps();
        }
        function saveToStorageEnhanced() {
        // Call existing saveToStorage function
        saveToStorage();
    
        // Additional validation for enhanced structure
        const errors = validateEnhancedDataStructure();
        if (errors.length > 0) {
        console.warn('Data structure validation errors:', errors);
         }
    }
        function loadFromStorage() {
            if (window.batsData) {
                investigation = window.batsData;
                
                // Ensure all hops have entries arrays
                if (investigation.hops) {
                    investigation.hops.forEach(hop => {
                        if (!hop.entries) {
                            hop.entries = [];
                        }
                    });
                }
                
                document.getElementById('caseId').value = investigation.caseId || '';
                document.getElementById('investigator').value = investigation.investigator || '';
                document.getElementById('caseType').value = investigation.caseType || '';
                document.getElementById('caseSynopsis').value = investigation.caseSynopsis || '';
            }
        }

        // Close modals when clicking outside
        window.onclick = function(event) {
            const modals = ['rootTotalModal', 'convergenceModal', 'assetConversionModal', 'excelImportModal'];
            modals.forEach(modalId => {
                const modal = document.getElementById(modalId);
                if (event.target == modal) {
                    modal.style.display = 'none';
                }
            });
        }

        // Excel Import Functions
        let parsedExcelData = null;

        function importExcelTraces(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    let data;
                    if (file.name.endsWith('.csv')) {
                        data = parseCSV(e.target.result);
                    } else {
                        // For Excel files, we'll need to handle this differently
                        // For now, show instructions for CSV format
                        alert('Please export your data as CSV format. Excel support coming soon!');
                        return;
                    }
                    
                    if (data && data.length > 0) {
                        parsedExcelData = data;
                        showImportPreview(data);
                        showModal('excelImportModal');
                    } else {
                        alert('No valid data found in file. Please check the format.');
                    }
                } catch (error) {
                    alert('Error reading file: ' + error.message);
                }
            };
            
            if (file.name.endsWith('.csv')) {
                reader.readAsText(file);
            } else {
                reader.readAsArrayBuffer(file);
            }
        }

        function parseCSV(csvText) {
            const lines = csvText.split('\n').map(line => line.trim()).filter(line => line);
            if (lines.length < 2) return [];
            
            const headers = lines[0].split(',').map(h => h.trim().toLowerCase());
            const data = [];
            
            // Expected headers
            const expectedHeaders = ['hop_notation', 'wallet_address', 'wallet_id', 'amount', 'currency'];
            const headerMap = {};
            
            // Map headers to expected format
            expectedHeaders.forEach(expected => {
                const found = headers.find(h => 
                    h.includes(expected.replace('_', '')) || 
                    h.includes(expected) ||
                    (expected === 'hop_notation' && (h.includes('notation') || h.includes('hop'))) ||
                    (expected === 'wallet_address' && (h.includes('address') || h.includes('wallet'))) ||
                    (expected === 'wallet_id' && h.includes('id')) ||
                    (expected === 'amount' && h.includes('amount')) ||
                    (expected === 'currency' && h.includes('currency'))
                );
                if (found) {
                    headerMap[expected] = headers.indexOf(found);
                }
            });
            
            // Parse data rows
            for (let i = 1; i < lines.length; i++) {
                const row = lines[i].split(',').map(cell => cell.trim().replace(/"/g, ''));
                if (row.length >= 5) {
                    const entry = {
                        hopNotation: row[headerMap.hop_notation] || '',
                        walletAddress: row[headerMap.wallet_address] || '',
                        walletId: row[headerMap.wallet_id] || '',
                        amount: parseFloat(row[headerMap.amount]) || 0,
                        currency: row[headerMap.currency] || 'USD'
                    };
                    
                    if (entry.hopNotation && entry.walletAddress && entry.amount > 0) {
                        data.push(entry);
                    }
                }
            }
            
            return data;
        }

        function showImportPreview(data) {
            const victims = new Set();
            const wallets = new Set();
            const currencies = new Set();
            let totalEntries = data.length;
            let errors = [];
            
            // Analyze the data
            data.forEach((entry, index) => {
                // Extract victim info
                const match = entry.hopNotation.match(/^V(\d+)-T(\d+)/);
                if (match) {
                    victims.add(`V${match[1]}-T${match[2]}`);
                }
                
                wallets.add(entry.walletId);
                currencies.add(entry.currency);
                
                // Validate wallet ID format
                if (!entry.walletId.match(/^(RED|BLACK|BLUE|PURPLE|YELLOW|ORANGE|BROWN|PINK|GRAY|GREEN)\d+$/i)) {
                    errors.push(`Row ${index + 2}: Invalid wallet ID format "${entry.walletId}"`);
                }
            });
            
            // Show summary
            const summary = `
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px;">
                    <div><strong>Total Entries:</strong> ${totalEntries}</div>
                    <div><strong>Victim Transactions:</strong> ${victims.size}</div>
                    <div><strong>Unique Wallets:</strong> ${wallets.size}</div>
                    <div><strong>Currencies:</strong> ${Array.from(currencies).join(', ')}</div>
                </div>
                <div style="margin-top: 15px;">
                    <strong>Victims Found:</strong> ${Array.from(victims).join(', ')}
                </div>
            `;
            
            document.getElementById('importSummary').innerHTML = summary;
            document.getElementById('importPreview').style.display = 'block';
            
            if (errors.length > 0) {
                document.getElementById('importErrors').innerHTML = `
                    <div style="background: #fdf2f2; border: 2px solid #e74c3c; border-radius: 6px; padding: 15px; margin-bottom: 15px;">
                        <h4 style="color: #c0392b; margin-bottom: 10px;"> Validation Errors</h4>
                        ${errors.map(error => `<div style="color: #c0392b; margin-bottom: 5px;"> ${error}</div>`).join('')}
                    </div>
                `;
                document.getElementById('importErrors').style.display = 'block';
            } else {
                document.getElementById('importErrors').style.display = 'none';
                document.getElementById('confirmImportBtn').style.display = 'inline-block';
            }
        }

        function confirmExcelImport() {
            if (!parsedExcelData) return;
            
            try {
                // Clear existing data
                investigation = {
                    caseId: '',
                    investigator: '',
                    caseType: '',
                    victims: [],
                    hops: [],
                    conversions: [],
                    redWalletIndex: [],
                    universalWalletIndex: [],
                    rootTotalConfirmed: false,
                    confirmedRootTotal: 0,
                    confirmedRootTotalsByCurrency: {},
                    currentART: {},
                    created: new Date().toISOString()
                };
                
                // Process the imported data
                processImportedData(parsedExcelData);
                
                // Check chronological order of imported transactions
                const chronologyErrors = [];
                investigation.victims.forEach(victim => {
                    const error = validateTransactionChronology(victim);
                    if (error) {
                        chronologyErrors.push(`Victim ${victim.id}:\n${error}`);
                    }
                });
                
                // Update UI
                renderAll();
                updateWorkflowSteps();
                
                closeExcelImportModal();
                
                // Show success message with chronology warning if needed
                if (chronologyErrors.length > 0) {
                    const shouldFix = confirm(` Import Successful with Warnings!\n\nImported ${parsedExcelData.length} entries, but transaction chronology issues were detected:\n\n${chronologyErrors.join('\n\n')}\n\nThe V-T notation requires transactions to be numbered in chronological order.\n\nWould you like to automatically fix the order?\n\nClick OK to reorder transactions chronologically.\nClick Cancel to fix manually later.`);
                    
                    if (shouldFix) {
                        // Fix order for all victims with errors
                        investigation.victims.forEach(victim => {
                            const error = validateTransactionChronology(victim);
                            if (error) {
                                fixVictimTransactionOrder(victim.id);
                            }
                        });
                        alert(` Transactions have been reordered chronologically!`);
                    }
                } else {
                    alert(`Successfully imported ${parsedExcelData.length} entries! Please review and confirm your root total.`);
                }
                
                // Clear the file input
                document.getElementById('excelInput').value = '';
                
            } catch (error) {
                alert('Error processing import: ' + error.message);
            }
        }

        function processImportedData(data) {
            const victimMap = new Map();
            const hopMap = new Map();
            
            // First pass: identify victims and transactions
            data.forEach(entry => {
                const match = entry.hopNotation.match(/^V(\d+)-T(\d+)(?:-H(\d+))?$/);
                if (match) {
                    const victimId = parseInt(match[1]);
                    const transactionId = parseInt(match[2]);
                    const hopNumber = match[3] ? parseInt(match[3]) : 0;
                    
                    if (hopNumber === 0) {
                        // This is a victim transaction
                        if (!victimMap.has(victimId)) {
                            victimMap.set(victimId, {
                                id: victimId,
                                transactions: []
                            });
                        }
                        
                        const victim = victimMap.get(victimId);
                        victim.transactions.push({
                            id: transactionId,
                            amount: entry.amount.toString(),
                            currency: entry.currency,
                            customCurrency: '',
                            receivingWallet: entry.walletAddress,
                            datetime: '',
                            timezone: 'UTC',
                            notes: `Imported from trace data`
                        });
                    } else {
                        // This is a hop entry
                        const hopKey = `${victimId}-${transactionId}-${hopNumber}`;
                        if (!hopMap.has(hopNumber)) {
                            hopMap.set(hopNumber, {
                                id: hopNumber,
                                hopNumber: hopNumber,
                                entries: [],
                                artAtStartByCurrency: {},
                                completed: false
                            });
                        }
                        
                        const hop = hopMap.get(hopNumber);
                        
                        // Find the source wallet from previous hop or victim transaction
                        let fromWallet = '';
                        if (hopNumber === 1) {
                            // Source is the victim transaction wallet
                            fromWallet = data.find(d => d.hopNotation === `V${victimId}-T${transactionId}`)?.walletAddress || '';
                        } else {
                            // Source is from previous hop
                            const prevEntry = data.find(d => d.hopNotation === `V${victimId}-T${transactionId}-H${hopNumber-1}`);
                            fromWallet = prevEntry?.walletAddress || '';
                        }
                        
                        hop.entries.push({
                            id: hop.entries.length + 1,
                            hopId: hopNumber,
                            hopNumber: hopNumber,
                            entryType: 'trace',
                            notation: entry.hopNotation,
                            fromWallet: fromWallet,
                            fromWalletType: hopNumber === 1 ? 'red' : 'black',
                            fromWalletId: '',
                            toWallet: entry.walletAddress,
                            toWalletType: parseWalletType(entry.walletId),
                            toWalletId: '',
                            amount: entry.amount.toString(),
                            currency: entry.currency,
                            customCurrency: '',
                            txHash: '',
                            timestamp: '',
                            timezone: 'UTC',
                            notes: `Imported from trace data`,
                            category: '',
                            justification: ''
                        });
                    }
                }
            });
            
            // Convert to arrays
            investigation.victims = Array.from(victimMap.values());
            investigation.hops = Array.from(hopMap.values());
            
            // Calculate root total and ART for each hop
            investigation.confirmedRootTotal = calculateRootTotal();
            investigation.rootTotalConfirmed = true;
            
            // Calculate confirmed root totals by currency
            investigation.confirmedRootTotalsByCurrency = {};
            investigation.victims.forEach(victim => {
                victim.transactions.forEach(transaction => {
                    if (parseFloat(transaction.amount) > 0) {
                        const currency = transaction.currency === 'CUSTOM' ? transaction.customCurrency : transaction.currency;
                        if (!investigation.confirmedRootTotalsByCurrency[currency]) {
                            investigation.confirmedRootTotalsByCurrency[currency] = 0;
                        }
                        investigation.confirmedRootTotalsByCurrency[currency] += parseFloat(transaction.amount);
                    }
                });
            });
            
            investigation.hops.forEach(hop => {
                hop.artAtStartByCurrency = getCurrentART();
            });
            
            // Build Universal Wallet Index
            buildUniversalWalletIndex();
            buildRedWalletIndex();
        }

        function parseWalletType(walletId) {
            const match = walletId.match(/^([A-Z]+)\d+$/);
            if (match) {
                return match[1].toLowerCase();
            }
            return 'black';
        }

        function closeExcelImportModal() {
            hideModal('excelImportModal');
            document.getElementById('importPreview').style.display = 'none';
            document.getElementById('confirmImportBtn').style.display = 'none';
            parsedExcelData = null;
        }
        function closeExcelImportModal() {
            hideModal('excelImportModal');
            document.getElementById('importPreview').style.display = 'none';
            document.getElementById('confirmImportBtn').style.display = 'none';
            parsedExcelData = null;
        }

        // ADD THE NEW HELPER FUNCTIONS HERE:
        function updateIndividualSourceAssignment(hopId, entryId, sourceId, amount) {
            const hop = investigation.hops.find(h => h.id === hopId);
    const entry = hop.entries.find(e => e.id === entryId);
    
    if (!entry.individualSourceAssignments) {
        entry.individualSourceAssignments = {};
    }
    
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    const maxAmount = getMaxAssignableAmount(sourceId, currency, entry.id, entry.hopId);
    const assignedAmount = Math.min(parseFloat(amount) || 0, maxAmount);
    
    entry.individualSourceAssignments[sourceId] = assignedAmount;
    
    // Calculate total from all individual assignments
    let totalAssigned = 0;
    Object.values(entry.individualSourceAssignments).forEach(amt => {
        totalAssigned += parseFloat(amt) || 0;
    });
    
    // Update the main amount field
    entry.amount = totalAssigned.toString();
    
    // Update the main amount input field in the UI
    const mainAmountInput = document.getElementById(`assignAmount_${hopId}_${entryId}`);
    if (mainAmountInput) {
        mainAmountInput.value = totalAssigned;
    }
}

function validateHopCompletion(hopId) {
    const hop = investigation.hops.find(h => h.id === hopId);
    if (!hop) return { valid: false, errors: ['Hop not found'] };
    
    const errors = [];
    const warnings = [];
    
    // Get starting ART by currency for this hop
    const startingART = hop.artAtStartByCurrency || {};
    
    // Calculate totals by currency from all entries in this hop
    const entryTotalsByCurrency = {};
    hop.entries.forEach(entry => {
        if (parseFloat(entry.amount) > 0) {
            const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
            if (!entryTotalsByCurrency[currency]) {
                entryTotalsByCurrency[currency] = 0;
            }
            entryTotalsByCurrency[currency] += parseFloat(entry.amount);
        }
    });
    
    // Validate each currency balances
    Object.entries(startingART).forEach(([currency, startAmount]) => {
        const tracedAmount = entryTotalsByCurrency[currency] || 0;
        const difference = Math.abs(startAmount - tracedAmount);
        
        if (difference >= 0.01) {
            if (tracedAmount > startAmount) {
                errors.push(`${currency}: Traced ${tracedAmount.toLocaleString()} exceeds ART ${startAmount.toLocaleString()}`);
            } else {
                warnings.push(`${currency}: Missing ${(startAmount - tracedAmount).toLocaleString()} (${tracedAmount.toLocaleString()} of ${startAmount.toLocaleString()} traced)`);
            }
        }
    });
    
    // Check for source thread over-assignment
    const sourceThreadUsage = {};
    hop.entries.forEach(entry => {
        if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0) {
            const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
            
            if (entry.sourceThreadId) {
                if (!sourceThreadUsage[currency]) sourceThreadUsage[currency] = {};
                if (!sourceThreadUsage[currency][entry.sourceThreadId]) {
                    sourceThreadUsage[currency][entry.sourceThreadId] = 0;
                }
                sourceThreadUsage[currency][entry.sourceThreadId] += parseFloat(entry.amount);
            }
            
            if (entry.individualSourceAssignments) {
                Object.entries(entry.individualSourceAssignments).forEach(([sourceId, amount]) => {
                    if (!sourceThreadUsage[currency]) sourceThreadUsage[currency] = {};
                    if (!sourceThreadUsage[currency][sourceId]) {
                        sourceThreadUsage[currency][sourceId] = 0;
                    }
                    sourceThreadUsage[currency][sourceId] += parseFloat(amount);
                });
            }
        }
    });
    
    // Validate source thread assignments don't exceed availability
    Object.entries(sourceThreadUsage).forEach(([currency, threads]) => {
        Object.entries(threads).forEach(([threadId, usedAmount]) => {
            if (investigation.availableThreads[currency] && investigation.availableThreads[currency][threadId]) {
                const totalAvailable = investigation.availableThreads[currency][threadId].totalAmount;
                if (usedAmount > totalAvailable + 0.01) {
                    errors.push(`${threadId}: Assigned ${usedAmount.toLocaleString()} exceeds available ${totalAvailable.toLocaleString()} ${currency}`);
                }
            }
        });
    });
    
    return {
        valid: errors.length === 0,
        errors: errors,
        warnings: warnings,
        balanceStatus: entryTotalsByCurrency
    };
}

function autoGenerateNotationFromSource(hopId, entryId, sourceThreadId) {
    const hop = investigation.hops.find(h => h.id === hopId);
    const entry = hop.entries.find(e => e.id === entryId);
    
    console.log(` Auto-generating notation from source: ${sourceThreadId}`);
    
    // Parse the source thread ID (e.g., "V1-T1" or "V1-T1-H2" or "V(1)-T(1)-H1")
    const match = sourceThreadId.match(/^V([^-]+)-T([^-]+)/);
    if (match) {
        let victimPart = match[1];
        let transactionPart = match[2];
        
        console.log(` Parsed victim: ${victimPart}, transaction: ${transactionPart}`);
        
        // If the parts are simple numbers, add parentheses
        if (/^\d+$/.test(victimPart)) {
            victimPart = `(${victimPart})`;
        }
        if (/^\d+$/.test(transactionPart)) {
            transactionPart = `(${transactionPart})`;
        }
        
        // Auto-fill notation fields
        entry.victimNumbers = victimPart;
        entry.transactionNumbers = transactionPart;
        
        // Generate the notation
        generateNotationPreview(hopId, entryId);
        
        // Update the UI fields
        updateNotationFieldsInUI(hopId, entryId);
        
        console.log(` Notation auto-generated: ${entry.notation}`);
    } else {
        console.log(` Could not parse source thread ID: ${sourceThreadId}`);
    }
}

function autoGenerateNotationFromMultipleSources(hopId, entryId, selectedSources) {
    const hop = investigation.hops.find(h => h.id === hopId);
    const entry = hop.entries.find(e => e.id === entryId);
    
    console.log(` Auto-generating notation from multiple sources:`, selectedSources);
    
    const victimNumbers = new Set();
    const transactionNumbers = new Set();
    
    // Parse all selected source thread IDs
    selectedSources.forEach(sourceId => {
        const match = sourceId.match(/^V(\d+)-T(\d+)/);
        if (match) {
            victimNumbers.add(match[1]);
            transactionNumbers.add(match[2]);
            console.log(` Parsed from ${sourceId}: V${match[1]}, T${match[2]}`);
        }
    });
    
    // Convert to sorted arrays and format with parentheses
    const sortedVictims = Array.from(victimNumbers).sort((a, b) => parseInt(a) - parseInt(b));
    const sortedTransactions = Array.from(transactionNumbers).sort((a, b) => parseInt(a) - parseInt(b));
    
    // Format with individual parentheses: V(1)(2) - T(1)(3)
    entry.victimNumbers = sortedVictims.map(v => `(${v})`).join('');
    entry.transactionNumbers = sortedTransactions.map(t => `(${t})`).join('');
    
    console.log(` Generated victim numbers: ${entry.victimNumbers}, transaction numbers: ${entry.transactionNumbers}`);
    
    // Generate the notation
    generateNotationPreview(hopId, entryId);
    
    console.log(` Final notation: ${entry.notation}`);
    
    // Update the UI fields
    updateNotationFieldsInUI(hopId, entryId);
}

function clearNotationFields(hopId, entryId) {
    const hop = investigation.hops.find(h => h.id === hopId);
    const entry = hop.entries.find(e => e.id === entryId);
    
    entry.victimNumbers = '';
    entry.transactionNumbers = '';
    entry.notation = '';
    entry.generatedNotation = '';
    
    updateNotationFieldsInUI(hopId, entryId);
}

function updateNotationFieldsInUI(hopId, entryId) {
    const hop = investigation.hops.find(h => h.id === hopId);
    const entry = hop.entries.find(e => e.id === entryId);
    
    console.log(` Updating notation UI for hop ${hopId} entry ${entryId}:`, {
        victimNumbers: entry.victimNumbers,
        transactionNumbers: entry.transactionNumbers,
        notation: entry.notation
    });
    
    // Find and update the victim numbers input - try multiple selectors
    let victimInput = document.querySelector(`input[onchange*="updateNotationField(${hopId}, ${entryId}, 'victims'"]`);
    if (!victimInput) {
        // Try finding by ID pattern
        const inputs = document.querySelectorAll('input');
        inputs.forEach(input => {
            if (input.getAttribute('onchange') && input.getAttribute('onchange').includes(`updateNotationField(${hopId}, ${entryId}, 'victims'`)) {
                victimInput = input;
            }
        });
    }
    
    if (victimInput) {
        victimInput.value = entry.victimNumbers || '';
        console.log(` Updated victim input to: ${entry.victimNumbers}`);
    } else {
        console.log(` Could not find victim input for hop ${hopId} entry ${entryId}`);
    }
    
    // Find and update the transaction numbers input
    let transactionInput = document.querySelector(`input[onchange*="updateNotationField(${hopId}, ${entryId}, 'transactions'"]`);
    if (!transactionInput) {
        // Try finding by ID pattern
        const inputs = document.querySelectorAll('input');
        inputs.forEach(input => {
            if (input.getAttribute('onchange') && input.getAttribute('onchange').includes(`updateNotationField(${hopId}, ${entryId}, 'transactions'`)) {
                transactionInput = input;
            }
        });
    }
    
    if (transactionInput) {
        transactionInput.value = entry.transactionNumbers || '';
        console.log(` Updated transaction input to: ${entry.transactionNumbers}`);
    } else {
        console.log(` Could not find transaction input for hop ${hopId} entry ${entryId}`);
    }
    
    // Update the preview
    const previewElement = document.getElementById(`notation_preview_${hopId}_${entryId}`);
    if (previewElement) {
        previewElement.textContent = entry.notation || 'Enter V and T numbers';
        console.log(` Updated preview to: ${entry.notation}`);
    } else {
        console.log(` Could not find preview element`);
    }
}
function assignMaxToIndividualSource(hopId, entryId, sourceId) {
    const hop = investigation.hops.find(h => h.id === hopId);
    const entry = hop.entries.find(e => e.id === entryId);
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    
    // Get REAL-TIME maximum amount available
    const maxAmount = getMaxAssignableAmount(sourceId, currency, entry.id, entry.hopId);
    
    updateIndividualSourceAssignment(hopId, entryId, sourceId, maxAmount);
    
    // Also update the input field in the UI immediately
    const inputField = document.querySelector(`input[onchange*="updateIndividualSourceAssignment(${hopId}, ${entryId}, '${sourceId}'"]`);
    if (inputField) {
        inputField.value = maxAmount;
        inputField.max = maxAmount; // Update the max attribute too
    }
}
function toggleSourceSelection(hopId, entryId, sourceId) {
    const hop = investigation.hops.find(h => h.id === hopId);
    const entry = hop.entries.find(e => e.id === entryId);
    
    if (!entry.multipleSourceThreads) {
        entry.multipleSourceThreads = [];
    }
    if (!entry.individualSourceAssignments) {
        entry.individualSourceAssignments = {};
    }
    
    const isCurrentlySelected = entry.multipleSourceThreads.includes(sourceId);
    
    if (isCurrentlySelected) {
        // Remove from selection
        entry.multipleSourceThreads = entry.multipleSourceThreads.filter(id => id !== sourceId);
        delete entry.individualSourceAssignments[sourceId];
        
        // If no sources are selected anymore, clear the currency
        if (entry.multipleSourceThreads.length === 0) {
            entry.currency = '';
            entry.customCurrency = '';
        }
    } else {
        // Before adding, check if currencies match
        const availableSourceThreads = getAvailableSourcesForHop(entry.hopNumber, null);
        const newSource = availableSourceThreads.find(s => s.threadId === sourceId);
        
        if (newSource && entry.multipleSourceThreads.length > 0) {
            // Check if the new source has the same currency as existing sources
            const existingCurrencies = new Set();
            entry.multipleSourceThreads.forEach(existingId => {
                const existingSource = availableSourceThreads.find(s => s.threadId === existingId);
                if (existingSource) {
                    existingCurrencies.add(existingSource.currency);
                }
            });
            
            if (existingCurrencies.size > 0 && !existingCurrencies.has(newSource.currency)) {
                alert(` Cannot mix different asset types!\n\nSelected threads have: ${Array.from(existingCurrencies).join(', ')}\nThis thread has: ${newSource.currency}\n\nPlease select threads with the same currency only.`);
                
                // Uncheck the checkbox
                const checkbox = document.querySelector(`#smartAllocationModal input[data-source-id="${sourceId}"]`);
                if (checkbox) {
                    checkbox.checked = false;
                }
                return;
            }
        }
        
        // Add to selection
        entry.multipleSourceThreads.push(sourceId);
        entry.individualSourceAssignments[sourceId] = 0; // Start with 0
        
        // Auto-update currency from the first selected source
        if (entry.multipleSourceThreads.length === 1) {
            const sourceThread = availableSourceThreads.find(s => s.threadId === sourceId);
            
            if (sourceThread) {
                const currency = sourceThread.currency;
                const isCustomCurrency = !Object.keys(currencies).includes(currency);
                
                if (isCustomCurrency) {
                    entry.currency = 'CUSTOM';
                    entry.customCurrency = currency;
                } else {
                    entry.currency = currency;
                    entry.customCurrency = '';
                }
            }
        }
    }
    
    // Clear the committed amounts since we're changing the selection
    entry.amount = '';
    const mainAmountInput = document.getElementById(`assignAmount_${hopId}_${entryId}`);
    if (mainAmountInput) {
        mainAmountInput.value = '';
    }
    
    // Re-render to show/hide amount inputs
    renderHops();
    saveToStorage();
}

function updateProposedAmount(hopId, entryId, sourceId, amount) {
    const hop = investigation.hops.find(h => h.id === hopId);
    const entry = hop.entries.find(e => e.id === entryId);
    
    if (!entry.individualSourceAssignments) {
        entry.individualSourceAssignments = {};
    }
    
    // Get the currency from the source thread, not the entry
    const availableSourceThreads = getAvailableSourcesForHop(entry.hopNumber, null);
    const sourceThread = availableSourceThreads.find(s => s.threadId === sourceId);
    
    if (!sourceThread) {
        alert(`Source thread ${sourceId} not found.`);
        return;
    }
    
    const currency = sourceThread.currency;
    
    // Auto-update entry currency to match source thread if needed
    if (entry.currency !== currency || (entry.currency === 'CUSTOM' && entry.customCurrency !== currency)) {
        const isCustomCurrency = !Object.keys(currencies).includes(currency);
        
        if (isCustomCurrency) {
            entry.currency = 'CUSTOM';
            entry.customCurrency = currency;
        } else {
            entry.currency = currency;
            entry.customCurrency = '';
        }
    }
    
    const maxAmount = getMaxAssignableAmount(sourceId, currency, entry.id, entry.hopId);
    const proposedAmount = Math.min(parseFloat(amount) || 0, maxAmount);
    
    entry.individualSourceAssignments[sourceId] = proposedAmount;
    
    // Update the proposed summary
    updateProposedSummary(hopId, entryId);
    saveToStorage();
}

function proposeMaxAmount(hopId, entryId, sourceId) {
    const hop = investigation.hops.find(h => h.id === hopId);
    const entry = hop.entries.find(e => e.id === entryId);
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    const maxAmount = getMaxAssignableAmount(sourceId, currency, entry.id, entry.hopId);
    
    updateProposedAmount(hopId, entryId, sourceId, maxAmount);
    
    // Update the input field
    const inputField = document.querySelector(`input[onchange*="updateProposedAmount(${hopId}, ${entryId}, '${sourceId}'"]`);
    if (inputField) {
        inputField.value = maxAmount;
    }
}

function updateProposedSummary(hopId, entryId) {
    const hop = investigation.hops.find(h => h.id === hopId);
    const entry = hop.entries.find(e => e.id === entryId);
    const summaryElement = document.getElementById(`proposedSummary_${hopId}_${entryId}`);
    
    if (!summaryElement || !entry.individualSourceAssignments) return;
    
    // GET THE CORRECT CURRENCY FROM THE ENTRY (not defaulting to USD)
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    let totalProposed = 0;
    let summaryHTML = '';
    
    Object.entries(entry.individualSourceAssignments).forEach(([sourceId, amount]) => {
        if (amount > 0) {
            totalProposed += amount;
            summaryHTML += `<div style="font-size: 12px; margin-bottom: 3px;"> ${sourceId}: ${amount.toLocaleString()} ${currency}</div>`;
        }
    });
    
    summaryHTML += `<div style="font-weight: bold; margin-top: 8px; padding-top: 8px; border-top: 1px solid #ddd;">Total Proposed: ${totalProposed.toLocaleString()} ${currency}</div>`;
    
    summaryElement.innerHTML = summaryHTML;
}

function commitAssignmentToEntry(hopId, entryId) {
    const hop = investigation.hops.find(h => h.id === hopId);
    const entry = hop.entries.find(e => e.id === entryId);
    
    if (!entry.individualSourceAssignments) {
        alert('No amounts proposed for assignment.');
        return;
    }
    
    // Calculate total proposed amount
    let totalAmount = 0;
    Object.values(entry.individualSourceAssignments).forEach(amount => {
        totalAmount += parseFloat(amount) || 0;
    });
    
    if (totalAmount <= 0) {
        alert('Please specify amounts to assign from selected sources.');
        return;
    }
    
    // Commit the assignment
    entry.amount = totalAmount.toString();
    
    // Update the main amount input field
    const mainAmountInput = document.getElementById(`assignAmount_${hopId}_${entryId}`);
    if (mainAmountInput) {
        mainAmountInput.value = totalAmount;
    }
    
    // Generate notation if needed
    if (entry.multipleSourceThreads && entry.multipleSourceThreads.length > 0) {
        autoGenerateNotationFromMultipleSources(hopId, entryId, entry.multipleSourceThreads);
    }
    
    // Update full notation display
    updateFullNotationDisplayMultiple(hopId, entryId);
    
    alert(` Assignment committed! New thread total: ${totalAmount.toLocaleString()} ${entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency}`);
    
    saveToStorage();
    
    // Re-render all hops to update availability for other entries
    renderHops();
}
// ADD THESE MISSING FUNCTIONS

function validateTracesEnhanced() {
    console.log(' Running enhanced validation...');
    
    const errors = [];
    const warnings = [];
    const threadAnalysis = {};
    const mathematicalBalance = {};
    
    // Build analysis by currency
    Object.keys(investigation.confirmedRootTotalsByCurrency || {}).forEach(currency => {
        threadAnalysis[currency] = {
            totalThreads: 0,
            totalAvailable: 0,
            totalAssigned: 0,
            unassignedThreads: [],
            overassignedThreads: []
        };
        
        mathematicalBalance[currency] = {
            rootTotal: investigation.confirmedRootTotalsByCurrency[currency] || 0,
            writeoffAmount: 0,
            adjustedRootTotal: 0,
            currentThreadTotal: 0,
            difference: 0,
            isValid: false
        };
    });
    
    // Calculate write-offs
    investigation.hops.forEach(hop => {
        hop.entries.forEach(entry => {
            if (entry.entryType === 'writeoff' && parseFloat(entry.amount) > 0) {
                const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                if (mathematicalBalance[currency]) {
                    mathematicalBalance[currency].writeoffAmount += parseFloat(entry.amount);
                }
            }
        });
    });
    
    // Complete balance calculations
    Object.keys(mathematicalBalance).forEach(currency => {
        const balance = mathematicalBalance[currency];
        balance.adjustedRootTotal = balance.rootTotal - balance.writeoffAmount;
        
        // Calculate current thread total
        let currentTotal = 0;
        investigation.hops.forEach(hop => {
            hop.entries.forEach(entry => {
                if (entry.entryType === 'trace' && parseFloat(entry.amount) > 0) {
                    const entryCurrency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
                    if (entryCurrency === currency) {
                        currentTotal += parseFloat(entry.amount);
                    }
                }
            });
        });
        
        balance.currentThreadTotal = currentTotal;
        balance.difference = Math.abs(balance.adjustedRootTotal - balance.currentThreadTotal);
        balance.isValid = balance.difference < 0.01;
        
        if (!balance.isValid) {
            errors.push(`${currency}: Balance mismatch - ART: ${balance.adjustedRootTotal}, Current: ${balance.currentThreadTotal}`);
        }
    });
    
    return {
        overall: errors.length === 0,
        errors: errors,
        warnings: warnings,
        threadAnalysis: threadAnalysis,
        mathematicalBalance: mathematicalBalance,
        timestamp: new Date().toISOString()
    };
}

function distributeProportionally(hopId, entryId) {
    const hop = investigation.hops.find(h => h.id === hopId);
    const entry = hop.entries.find(e => e.id === entryId);
    
    if (!entry.multipleSourceThreads || entry.multipleSourceThreads.length === 0) return;
    
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    let totalAvailable = 0;
    
    // Calculate total available
    entry.multipleSourceThreads.forEach(sourceId => {
        totalAvailable += getMaxAssignableAmount(sourceId, currency);
    });
    
    if (totalAvailable <= 0) return;
    
    // Distribute proportionally
    entry.multipleSourceThreads.forEach(sourceId => {
        const available = getMaxAssignableAmount(sourceId, currency);
        const proportion = available / totalAvailable;
        const assignedAmount = proportion * totalAvailable;
        
        if (!entry.individualSourceAssignments) {
            entry.individualSourceAssignments = {};
        }
        entry.individualSourceAssignments[sourceId] = assignedAmount;
    });
    
    // Update total
    entry.amount = totalAvailable.toString();
    updateMultipleSourcePreview(hopId, entryId);
    saveToStorage();
}

function depleteInOrder(hopId, entryId) {
    const hop = investigation.hops.find(h => h.id === hopId);
    const entry = hop.entries.find(e => e.id === entryId);
    
    if (!entry.multipleSourceThreads || entry.multipleSourceThreads.length === 0) return;
    
    const currency = entry.currency === 'CUSTOM' ? entry.customCurrency : entry.currency;
    
    if (!entry.individualSourceAssignments) {
        entry.individualSourceAssignments = {};
    }
    
    // Deplete each source in order
    entry.multipleSourceThreads.forEach(sourceId => {
        const maxAmount = getMaxAssignableAmount(sourceId, currency, entry.id, entry.hopId);
        entry.individualSourceAssignments[sourceId] = maxAmount;
    });
    
    // Calculate total
    let total = 0;
    Object.values(entry.individualSourceAssignments).forEach(amount => {
        total += parseFloat(amount) || 0;
    });
    
    entry.amount = total.toString();
    updateMultipleSourcePreview(hopId, entryId);
    saveToStorage();
}

function clearAllAssignments(hopId, entryId) {
    const hop = investigation.hops.find(h => h.id === hopId);
    const entry = hop.entries.find(e => e.id === entryId);
    
    if (entry.individualSourceAssignments) {
        Object.keys(entry.individualSourceAssignments).forEach(sourceId => {
            entry.individualSourceAssignments[sourceId] = 0;
        });
    }
    
    entry.amount = '0';
    updateMultipleSourcePreview(hopId, entryId);
    saveToStorage();
}

// Blockchain API Integration Functions
function detectBlockchainFromHash(hash) {
    const detectedDiv = document.getElementById('detectedBlockchain');
    const chainSelector = document.getElementById('chainSelector');
    
    // If a chain is manually selected, don't auto-detect
    if (chainSelector && chainSelector.value) {
        return chainSelector.value;
    }
    
    if (!hash || hash.length < 10) {
        detectedDiv.innerHTML = '';
        return null;
    }
    
    // Check each blockchain pattern
    for (const [chain, config] of Object.entries(blockchainAPIs)) {
        if (config.txPattern.test(hash)) {
            detectedDiv.innerHTML = `<span style="color: #27ae60;"> Detected: ${config.name} transaction</span>`;
            return chain;
        }
    }
    
    detectedDiv.innerHTML = '<span style="color: #e74c3c;"> Unknown transaction format</span>';
    return null;
}

function updateChainDisplay() {
    const chainSelector = document.getElementById('chainSelector');
    const detectedDiv = document.getElementById('detectedBlockchain');
    
    if (chainSelector.value) {
        const config = blockchainAPIs[chainSelector.value];
        detectedDiv.innerHTML = `<span style="color: #3498db;"> Selected: ${config.name}</span>`;
    } else {
        // Re-detect from hash if present
        const txHash = document.getElementById('txHashInput').value;
        if (txHash) {
            detectBlockchainFromHash(txHash);
        } else {
            detectedDiv.innerHTML = '';
        }
    }
}

function openBlockchainLookup(hopId, entryId) {
    // Store context for applying data later
    targetEntryContext = { hopId, entryId };
    
    // Clear previous data
    currentTxData = null;
    document.getElementById('txHashInput').value = '';
    document.getElementById('chainSelector').value = '';
    document.getElementById('detectedBlockchain').innerHTML = '';
    document.getElementById('lookupResult').style.display = 'none';
    document.getElementById('lookupError').style.display = 'none';
    document.getElementById('applyTxDataBtn').style.display = 'none';
    
    showModal('blockchainLookupModal');
}

function closeBlockchainLookupModal() {
    hideModal('blockchainLookupModal');
    targetEntryContext = null;
    currentTxData = null;
}

async function lookupTransaction() {
    const txHash = document.getElementById('txHashInput').value.trim();
    const selectedChain = document.getElementById('chainSelector').value;
    let detectedChain = selectedChain || detectBlockchainFromHash(txHash);
    
    if (!txHash) {
        showLookupError('Please enter a transaction hash');
        return;
    }
    
    if (!detectedChain) {
        showLookupError('Please select a blockchain or enter a valid transaction hash');
        return;
    }
    
    const config = blockchainAPIs[detectedChain];
    const corsEnabled = localStorage.getItem('bats_cors_proxy_enabled') === 'true';
    const corsProxyUrl = localStorage.getItem('bats_cors_proxy_url') || 'https://cors-anywhere.herokuapp.com/';
    
    // Show loading
    document.getElementById('lookupLoading').style.display = 'block';
    document.getElementById('lookupError').style.display = 'none';
    document.getElementById('lookupResult').style.display = 'none';
    
    // Build array of URLs to try (primary + fallbacks)
    const urlsToTry = [config.apiUrl, ...(config.fallbackUrls || [])];
    let lastError = null;
    
    for (let apiUrl of urlsToTry) {
        try {
            let data;
            let url;
            let tokenData = null; // Define tokenData at this scope
            
            if (detectedChain === 'bitcoin') {
                url = apiUrl + txHash;
                if (config.apiKey) {
                    url += `?api_key=${config.apiKey}`;
                }
                if (corsEnabled) url = corsProxyUrl + url;
                
                const response = await fetch(url);
                if (!response.ok) throw new Error('Transaction not found');
                data = await response.json();
                
            } else if (detectedChain === 'ethereum') {
                const apiKey = localStorage.getItem('bats_etherscan_api_key') || config.apiKey || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8';
                
                // First get the basic transaction
                url = `${apiUrl}${txHash}&apikey=${apiKey}`;
                if (corsEnabled) url = corsProxyUrl + url;
                
                const response = await fetch(url);
                if (!response.ok) throw new Error('API request failed');
                data = await response.json();
                if (!data.result || data.result === null) throw new Error('Transaction not found');
                
                // Get block data for timestamp - but don't let it block token transfers
                let blockData = null;
                if (data.result && data.result.blockNumber) {
                    try {
                        const blockUrl = corsEnabled ?
                            corsProxyUrl + `${config.blockApiUrl}${data.result.blockNumber}&boolean=true&apikey=${apiKey}` :
                            `${config.blockApiUrl}${data.result.blockNumber}&boolean=true&apikey=${apiKey}`;
                        
                        const blockResponse = await fetch(blockUrl);
                        if (blockResponse.ok) {
                            blockData = await blockResponse.json();
                            if (blockData && blockData.result && blockData.result.timestamp) {
                                blockTimestamp = parseInt(blockData.result.timestamp, 16) * 1000;
                                console.log('Got block timestamp:', new Date(blockTimestamp).toISOString());
                            }
                        }
                    } catch (err) {
                        console.log('Failed to fetch block timestamp, will proceed without it:', err);
                    }
                }
                
                // Small delay to avoid rate limit
                if (blockTimestamp) {
                    await new Promise(resolve => setTimeout(resolve, 300));
                }
                
                // Also check for token transfers
                let tokenData = null;
                try {
                    const tokenUrl = corsEnabled ? 
                        corsProxyUrl + `${config.tokenApiUrl}${txHash}&apikey=${apiKey}` :
                        `${config.tokenApiUrl}${txHash}&apikey=${apiKey}`;
                    
                    const tokenResponse = await fetch(tokenUrl);
                    if (tokenResponse.ok) {
                        tokenData = await tokenResponse.json();
                        console.log('Receipt/Token data received:', tokenData);
                        
                        // Check if Etherscan returned an error
                        if (tokenData && tokenData.status === '0' && tokenData.message === 'NOTOK') {
                            console.error('Etherscan API error:', tokenData.result);
                            throw new Error(tokenData.result);
                        }
                    }
                } catch (err) {
                    console.log('No token transfers found');
                }
                
            } else if (detectedChain === 'tron') {
                url = apiUrl + txHash;
                if (config.apiKey) {
                    // TronGrid uses header authentication
                    const headers = { 'TRON-PRO-API-KEY': config.apiKey };
                    if (corsEnabled) url = corsProxyUrl + url;
                    
                    const response = await fetch(url, { headers });
                    if (!response.ok) throw new Error('Transaction not found');
                    data = await response.json();
                } else {
                    if (corsEnabled) url = corsProxyUrl + url;
                    const response = await fetch(url);
                    if (!response.ok) throw new Error('Transaction not found');
                    data = await response.json();
                }
                
            } else if (detectedChain === 'solana') {
                url = apiUrl;
                if (corsEnabled) url = corsProxyUrl + url;
                
                // Solana RPC call
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        jsonrpc: '2.0',
                        id: 1,
                        method: 'getTransaction',
                        params: [txHash, { encoding: 'json', maxSupportedTransactionVersion: 0 }]
                    })
                });
                if (!response.ok) throw new Error('RPC request failed');
                data = await response.json();
                if (data.error) throw new Error(data.error.message);
            }
            
            // Parse the response (pass tokenData and blockTimestamp for EVM chains)
            const isEVMChain = ['ethereum', 'base', 'arbitrum', 'optimism', 'polygon', 'bsc'].includes(detectedChain);
            currentTxData = isEVMChain ? 
                config.parseResponse(data, tokenData, blockTimestamp) : 
                config.parseResponse(data);
            if (!currentTxData) throw new Error('Failed to parse transaction data');
            
            currentTxData.blockchain = config.name;
            currentTxData.rawHash = txHash;
            
            // Display the results
            displayTransactionData(currentTxData);
            
            // Success! Break out of the loop
            return;
            
        } catch (error) {
            console.error(`Failed with ${apiUrl}:`, error);
            lastError = error;
            // Continue to next URL
        }
    }
    
    // If we get here, all URLs failed
    const errorMsg = lastError ? lastError.message : 'Failed to fetch transaction';
    if (errorMsg.includes('CORS') || errorMsg.includes('Failed to fetch')) {
        showLookupError(`${errorMsg}\n\nTip: Enable CORS Proxy in API Settings or add your API key.`);
    } else {
        showLookupError(`Failed to fetch transaction: ${errorMsg}`);
    }
    
    document.getElementById('lookupLoading').style.display = 'none';
}

function showLookupError(message) {
    const errorDiv = document.getElementById('lookupError');
    errorDiv.textContent = message;
    errorDiv.style.display = 'block';
}

function displayTransactionData(txData) {
    const displayDiv = document.getElementById('txDetailsDisplay');
    
    const timeFormatted = new Date(txData.time).toLocaleString();
    
    displayDiv.innerHTML = `
        <div style="display: grid; gap: 10px;">
            <div><strong>Blockchain:</strong> ${txData.blockchain}</div>
            <div><strong>Hash:</strong> <span style="font-family: monospace; font-size: 12px; word-break: break-all;">${txData.rawHash}</span></div>
            <div><strong>Time:</strong> ${timeFormatted} (UTC)</div>
            <div><strong>Amount:</strong> ${txData.amount.toFixed(8)} ${txData.currency}</div>
            <div><strong>From:</strong> <span style="font-family: monospace; font-size: 12px; word-break: break-all;">${txData.from}</span></div>
            <div><strong>To:</strong> <span style="font-family: monospace; font-size: 12px; word-break: break-all;">${txData.to}</span></div>
            ${txData.fee ? `<div><strong>Fee:</strong> ${txData.fee} ${txData.currency}</div>` : ''}
        </div>
    `;
    
    document.getElementById('lookupResult').style.display = 'block';
    document.getElementById('applyTxDataBtn').style.display = 'inline-block';
}

function applyTransactionData() {
    if (!currentTxData || !targetEntryContext) return;
    
    const { hopId, entryId } = targetEntryContext;
    const hop = investigation.hops.find(h => h.id === hopId);
    const entry = hop.entries.find(e => e.id === entryId);
    
    // Apply the data to the entry
    entry.txHash = currentTxData.rawHash;
    entry.timestamp = new Date(currentTxData.time).toISOString().slice(0, 16); // Format for datetime-local
    entry.timezone = 'UTC';
    entry.amount = currentTxData.amount.toString();
    entry.currency = currentTxData.currency;
    entry.fromWallet = currentTxData.from;
    entry.toWallet = currentTxData.to;
    
    // Update the form fields
    document.getElementById(`txHash_${hopId}_${entryId}`).value = entry.txHash;
    document.getElementById(`timestamp_${hopId}_${entryId}`).value = entry.timestamp;
    document.getElementById(`assignAmount_${hopId}_${entryId}`).value = entry.amount;
    document.getElementById(`toWallet_${hopId}_${entryId}`).value = entry.toWallet;
    
    // Note: fromWallet is stored but not displayed in the form
    // It's used internally for transaction tracking
    
    // Update currency dropdown
    const currencySelect = document.querySelector(`select[onchange*="updateEntry(${hopId}, ${entryId}, 'currency'"]`);
    if (currencySelect) {
        currencySelect.value = entry.currency;
    }
    
    saveToStorage();
    closeBlockchainLookupModal();
    
    let alertMessage = ` Transaction data applied successfully!\n\nAmount: ${entry.amount} ${entry.currency}\nFrom: ${entry.fromWallet.slice(0, 20)}...\nTo: ${entry.toWallet.slice(0, 20)}...`;
    
    if (currentTxData.hasRealTimestamp === false) {
        alertMessage += '\n\n WARNING: Could not retrieve actual transaction timestamp. Please manually verify and update the date/time field!';
    }
    
    alert(alertMessage);
}

// API Settings Management Functions
function openApiSettings() {
    // Load saved settings
    const savedEtherscan = localStorage.getItem('bats_etherscan_api_key');
    const savedBlockchain = localStorage.getItem('bats_blockchain_api_key');
    const savedTrongrid = localStorage.getItem('bats_trongrid_api_key');
    const savedSolanaRpc = localStorage.getItem('bats_solana_rpc_endpoint');
    const savedCorsEnabled = localStorage.getItem('bats_cors_proxy_enabled') === 'true';
    const savedCorsUrl = localStorage.getItem('bats_cors_proxy_url');
    
    // Populate form fields
    document.getElementById('etherscanApiKey').value = savedEtherscan || '';
    document.getElementById('blockchainApiKey').value = savedBlockchain || '';
    document.getElementById('trongridApiKey').value = savedTrongrid || '';
    document.getElementById('solanaRpcEndpoint').value = savedSolanaRpc || 'https://api.mainnet-beta.solana.com';
    document.getElementById('enableCorsProxy').checked = savedCorsEnabled;
    document.getElementById('corsProxyUrl').value = savedCorsUrl || 'https://cors-anywhere.herokuapp.com/';
    document.getElementById('corsProxyUrl').disabled = !savedCorsEnabled;
    
    // Show modal
    showModal('apiSettingsModal');
}

function closeApiSettingsModal() {
    hideModal('apiSettingsModal');
}

function saveApiSettings() {
    // Get values from form
    const etherscanKey = document.getElementById('etherscanApiKey').value.trim();
    const blockchainKey = document.getElementById('blockchainApiKey').value.trim();
    const trongridKey = document.getElementById('trongridApiKey').value.trim();
    const solanaRpc = document.getElementById('solanaRpcEndpoint').value.trim();
    const corsEnabled = document.getElementById('enableCorsProxy').checked;
    const corsUrl = document.getElementById('corsProxyUrl').value.trim();
    
    // Save to localStorage
    if (etherscanKey) localStorage.setItem('bats_etherscan_api_key', etherscanKey);
    else localStorage.removeItem('bats_etherscan_api_key');
    
    if (blockchainKey) localStorage.setItem('bats_blockchain_api_key', blockchainKey);
    else localStorage.removeItem('bats_blockchain_api_key');
    
    if (trongridKey) localStorage.setItem('bats_trongrid_api_key', trongridKey);
    else localStorage.removeItem('bats_trongrid_api_key');
    
    if (solanaRpc) localStorage.setItem('bats_solana_rpc_endpoint', solanaRpc);
    else localStorage.removeItem('bats_solana_rpc_endpoint');
    
    localStorage.setItem('bats_cors_proxy_enabled', corsEnabled.toString());
    
    if (corsUrl) localStorage.setItem('bats_cors_proxy_url', corsUrl);
    else localStorage.removeItem('bats_cors_proxy_url');
    
    // Update blockchain API configurations
    blockchainAPIs.ethereum.apiKey = etherscanKey || null;
    blockchainAPIs.bitcoin.apiKey = blockchainKey || null;
    blockchainAPIs.tron.apiKey = trongridKey || null;
    blockchainAPIs.solana.apiUrl = solanaRpc || 'https://api.mainnet-beta.solana.com';
    
    closeApiSettingsModal();
    alert(' API settings saved successfully!');
}

// Enable/disable CORS proxy URL input based on checkbox
document.addEventListener('DOMContentLoaded', function() {
    const corsCheckbox = document.getElementById('enableCorsProxy');
    const corsUrlInput = document.getElementById('corsProxyUrl');
    
    if (corsCheckbox && corsUrlInput) {
        corsCheckbox.addEventListener('change', function() {
            corsUrlInput.disabled = !this.checked;
        });
    }
    
    // Load API settings on startup
    loadApiSettingsOnStartup();
});

function loadApiSettingsOnStartup() {
    // Load saved API keys
    const savedEtherscan = localStorage.getItem('bats_etherscan_api_key');
    const savedBlockchain = localStorage.getItem('bats_blockchain_api_key');
    const savedTrongrid = localStorage.getItem('bats_trongrid_api_key');
    const savedSolanaRpc = localStorage.getItem('bats_solana_rpc_endpoint');
    
    // Update blockchain API configurations
    if (savedEtherscan) blockchainAPIs.ethereum.apiKey = savedEtherscan;
    if (savedBlockchain) blockchainAPIs.bitcoin.apiKey = savedBlockchain;
    if (savedTrongrid) blockchainAPIs.tron.apiKey = savedTrongrid;
    if (savedSolanaRpc) blockchainAPIs.solana.apiUrl = savedSolanaRpc;
}

// Wallet Address Autocomplete Functions
let autocompleteTimeout = null;
let currentAutocompleteRequest = null;

function detectBlockchainFromAddress(address) {
    if (!address || address.length < 3) return null;
    
    // Check each blockchain's address pattern
    for (const [chain, config] of Object.entries(blockchainAPIs)) {
        // First check prefixes for quick detection
        if (config.addressPrefixes) {
            for (const prefix of config.addressPrefixes) {
                if (address.startsWith(prefix)) {
                    // For longer prefixes like 'bc1', check if we have enough characters
                    if (prefix.length > 1 && address.length < 10) continue;
                    return chain;
                }
            }
        }
    }
    return null;
}

async function handleWalletAutocomplete(input, hopId, entryId) {
    const value = input.value.trim();
    const dropdown = document.getElementById(`autocomplete_${hopId}_${entryId}`);
    
    // Clear any pending timeout
    if (autocompleteTimeout) {
        clearTimeout(autocompleteTimeout);
    }
    
    // Hide dropdown if input is too short
    if (value.length < 9) {
        dropdown.style.display = 'none';
        return;
    }
    
    // First check if it matches any existing wallet in UWI
    const existingMatches = (investigation.universalWalletIndex || [])
        .filter(wallet => wallet.address.toLowerCase().startsWith(value.toLowerCase()))
        .slice(0, 5); // Limit to 5 matches
    
    if (existingMatches.length > 0) {
        // Show existing matches immediately
        showAutocompleteResults(dropdown, existingMatches.map(wallet => ({
            address: wallet.address,
            type: 'existing',
            walletInfo: wallet
        })), hopId, entryId);
        return;
    }
    
    // Detect blockchain type
    const detectedChain = detectBlockchainFromAddress(value);
    if (!detectedChain) {
        dropdown.style.display = 'none';
        return;
    }
    
    // Show loading state
    dropdown.innerHTML = '<div class="wallet-autocomplete-loading">Searching blockchain...</div>';
    dropdown.style.display = 'block';
    
    // Debounce API calls
    autocompleteTimeout = setTimeout(async () => {
        try {
            const suggestions = await fetchAddressSuggestions(value, detectedChain);
            if (suggestions && suggestions.length > 0) {
                showAutocompleteResults(dropdown, suggestions, hopId, entryId);
            } else {
                dropdown.innerHTML = `<div class="wallet-autocomplete-loading">No addresses found starting with "${value}"</div>`;
                setTimeout(() => { dropdown.style.display = 'none'; }, 2000);
            }
        } catch (error) {
            console.error('Autocomplete error:', error);
            dropdown.style.display = 'none';
        }
    }, 300); // 300ms debounce
}

async function fetchAddressSuggestions(partialAddress, blockchain) {
    const config = blockchainAPIs[blockchain];
    if (!config) return [];
    
    try {
        // For now, we'll validate the address format
        // In a real implementation, you'd query blockchain explorers for similar addresses
        // Most blockchains don't offer address autocomplete APIs, so we'll provide format validation
        
        const suggestions = [];
        
        // Check if the partial address could be valid when completed
        if (blockchain === 'bitcoin') {
            // Bitcoin addresses are 26-34 chars for P2PKH/P2SH, 42-62 for Bech32
            if (partialAddress.startsWith('1') || partialAddress.startsWith('3')) {
                // Legacy/SegWit addresses
                if (partialAddress.length >= 26) {
                    suggestions.push({
                        address: partialAddress,
                        type: 'valid',
                        blockchain: 'Bitcoin',
                        note: 'Valid Bitcoin address format'
                    });
                } else {
                    suggestions.push({
                        address: partialAddress + '...',
                        type: 'partial',
                        blockchain: 'Bitcoin',
                        note: `Need ${26 - partialAddress.length} more characters (min 26)`
                    });
                }
            } else if (partialAddress.startsWith('bc1')) {
                // Bech32 addresses
                if (partialAddress.length >= 42) {
                    suggestions.push({
                        address: partialAddress,
                        type: 'valid',
                        blockchain: 'Bitcoin',
                        note: 'Valid Bitcoin Bech32 address format'
                    });
                } else {
                    suggestions.push({
                        address: partialAddress + '...',
                        type: 'partial',
                        blockchain: 'Bitcoin',
                        note: `Need ${42 - partialAddress.length} more characters (min 42)`
                    });
                }
            }
        } else if (blockchain === 'ethereum') {
            // Ethereum addresses are exactly 42 chars (including 0x)
            if (partialAddress.length === 42) {
                suggestions.push({
                    address: partialAddress,
                    type: 'valid',
                    blockchain: 'Ethereum',
                    note: 'Valid Ethereum address format'
                });
            } else if (partialAddress.length < 42) {
                suggestions.push({
                    address: partialAddress + '...',
                    type: 'partial',
                    blockchain: 'Ethereum',
                    note: `Need ${42 - partialAddress.length} more characters (exactly 42)`
                });
            }
        } else if (blockchain === 'tron') {
            // Tron addresses are exactly 34 chars
            if (partialAddress.length === 34) {
                suggestions.push({
                    address: partialAddress,
                    type: 'valid',
                    blockchain: 'Tron',
                    note: 'Valid Tron address format'
                });
            } else if (partialAddress.length < 34) {
                suggestions.push({
                    address: partialAddress + '...',
                    type: 'partial',
                    blockchain: 'Tron',
                    note: `Need ${34 - partialAddress.length} more characters (exactly 34)`
                });
            }
        } else if (blockchain === 'solana') {
            // Solana addresses are 32-44 chars
            if (partialAddress.length >= 32 && partialAddress.length <= 44) {
                suggestions.push({
                    address: partialAddress,
                    type: 'valid',
                    blockchain: 'Solana',
                    note: 'Valid Solana address format'
                });
            } else if (partialAddress.length < 32) {
                suggestions.push({
                    address: partialAddress + '...',
                    type: 'partial',
                    blockchain: 'Solana',
                    note: `Need ${32 - partialAddress.length} more characters (min 32)`
                });
            }
        }
        
        return suggestions;
    } catch (error) {
        console.error('Error fetching address suggestions:', error);
        return [];
    }
}

function showAutocompleteResults(dropdown, results, hopId, entryId) {
    dropdown.innerHTML = '';
    dropdown.style.display = 'block';
    
    results.forEach((result, index) => {
        const item = document.createElement('div');
        item.className = 'wallet-autocomplete-item';
        
        if (result.type === 'existing') {
            // Existing wallet from UWI
            item.innerHTML = `
                <div>${result.address}</div>
                <div class="wallet-autocomplete-blockchain">
                    ${result.walletInfo.permanentId} - ${walletTypes[result.walletInfo.permanentType] || result.walletInfo.permanentType}
                </div>
            `;
            item.onclick = () => selectAutocompleteAddress(result.address, hopId, entryId);
        } else {
            // Blockchain validation result
            const statusColor = result.type === 'valid' ? '#27ae60' : '#e67e22';
            item.innerHTML = `
                <div style="color: ${statusColor};">${result.address}</div>
                <div class="wallet-autocomplete-blockchain">${result.blockchain} - ${result.note}</div>
            `;
            if (result.type === 'valid') {
                item.onclick = () => selectAutocompleteAddress(result.address, hopId, entryId);
            }
        }
        
        dropdown.appendChild(item);
    });
}

function selectAutocompleteAddress(address, hopId, entryId) {
    const input = document.getElementById(`toWallet_${hopId}_${entryId}`);
    const dropdown = document.getElementById(`autocomplete_${hopId}_${entryId}`);
    
    input.value = address;
    dropdown.style.display = 'none';
    
    // Trigger the change event
    updateHopEntry(hopId, entryId, 'toWallet', address);
}

// Close autocomplete when clicking outside
document.addEventListener('click', function(event) {
    if (!event.target.matches('input[id^="toWallet_"]')) {
        document.querySelectorAll('.wallet-autocomplete-dropdown').forEach(dropdown => {
            dropdown.style.display = 'none';
        });
    }
});

// Bulk Transaction Modal Functions
function openBulkTransactionModal(victimId) {
    currentBulkVictimId = victimId;
    document.getElementById('bulkTransactionHashes').value = '';
    document.getElementById('bulkProcessingStatus').style.display = 'none';
    document.getElementById('bulkProcessingResults').style.display = 'none';
    document.getElementById('bulkProcessBtn').disabled = false;
    showModal('bulkTransactionModal');
}

function closeBulkTransactionModal() {
    hideModal('bulkTransactionModal');
    currentBulkVictimId = null;
    // Re-render to show the new transactions with correct V-T notation
    renderVictims();
}

async function processBulkTransactions() {
    const hashesText = document.getElementById('bulkTransactionHashes').value.trim();
    if (!hashesText) {
        alert('Please paste transaction hashes first');
        return;
    }
    
    // Parse hashes (one per line)
    const hashes = hashesText.split('\n')
        .map(h => h.trim())
        .filter(h => h.length > 0);
    
    if (hashes.length === 0) {
        alert('No valid transaction hashes found');
        return;
    }
    
    // Disable button and show progress
    document.getElementById('bulkProcessBtn').disabled = true;
    document.getElementById('bulkProcessingStatus').style.display = 'block';
    document.getElementById('bulkProcessingResults').style.display = 'none';
    
    const victim = investigation.victims.find(v => v.id === currentBulkVictimId);
    const results = [];
    const tempTransactions = [];
    
    // Process each hash
    for (let i = 0; i < hashes.length; i++) {
        const hash = hashes[i];
        const progress = ((i + 1) / hashes.length) * 100;
        
        // Update progress
        document.getElementById('bulkProgressFill').style.width = progress + '%';
        document.getElementById('bulkProgressText').textContent = `Processing ${i + 1} of ${hashes.length}...`;
        
        try {
            // Detect blockchain
            const detectedChain = detectBlockchainFromHash(hash);
            if (!detectedChain) {
                results.push({ hash, status: 'error', message: 'Unknown blockchain format' });
                continue;
            }
            
            // Fetch transaction data
            const txData = await fetchTransactionData(hash, detectedChain);
            
            if (txData) {
                // Create transaction object
                const transaction = {
                    id: 0, // Will be reassigned after sorting
                    txHash: hash,
                    amount: txData.amount.toString(),
                    currency: txData.currency,
                    customCurrency: '',
                    receivingWallet: txData.to,
                    datetime: new Date(txData.time).toISOString().slice(0, 16),
                    timezone: 'UTC',
                    notes: `From: ${txData.from} | ${txData.blockchain} transaction`
                };
                
                tempTransactions.push(transaction);
                results.push({ 
                    hash, 
                    status: 'success', 
                    message: `${txData.amount} ${txData.currency}  ${txData.to.substring(0, 20)}...`,
                    timestamp: txData.time
                });
            } else {
                results.push({ hash, status: 'error', message: 'Failed to fetch data' });
            }
            
        } catch (error) {
            results.push({ hash, status: 'error', message: error.message });
        }
        
        // Small delay to avoid rate limiting
        await new Promise(resolve => setTimeout(resolve, 500));
    }
    
    // Add all successful transactions to the victim
    tempTransactions.forEach(tx => {
        victim.transactions.push(tx);
    });
    
    // Show results
    document.getElementById('bulkProgressText').textContent = 'Complete! Sorting transactions chronologically...';
    showBulkResults(results);
    
    // Save and re-render (which will sort chronologically)
    saveToStorage();
    
    // Give user time to see results before closing
    setTimeout(() => {
        alert(` Processed ${hashes.length} transaction hashes!\n\n${results.filter(r => r.status === 'success').length} successful\n${results.filter(r => r.status === 'error').length} failed\n\nTransactions have been sorted chronologically and V-T notation has been updated.`);
        closeBulkTransactionModal();
    }, 2000);
}

function showBulkResults(results) {
    const resultsList = document.getElementById('bulkResultsList');
    resultsList.innerHTML = results.map(result => {
        const icon = result.status === 'success' ? '' : '';
        const color = result.status === 'success' ? '#27ae60' : '#dc3545';
        return `
            <div style="padding: 8px; border-bottom: 1px solid #e0e0e0;">
                <span style="color: ${color};">${icon}</span>
                <span style="font-family: monospace; font-size: 12px;">${result.hash.substring(0, 20)}...</span>
                <span style="color: #666; margin-left: 10px;">${result.message}</span>
            </div>
        `;
    }).join('');
    
    document.getElementById('bulkProcessingResults').style.display = 'block';
}

async function fetchTransactionData(hash, blockchain) {
    const config = blockchainAPIs[blockchain];
    const corsEnabled = localStorage.getItem('bats_cors_proxy_enabled') === 'true';
    const corsProxyUrl = localStorage.getItem('bats_cors_proxy_url') || 'https://cors-anywhere.herokuapp.com/';
    
    // Try primary and fallback URLs
    const urlsToTry = [config.apiUrl, ...(config.fallbackUrls || [])];
    
    for (let apiUrl of urlsToTry) {
        try {
            let data;
            let url;
            let tokenData = null; // Define tokenData at this scope
            
            if (blockchain === 'bitcoin') {
                url = apiUrl + hash;
                if (config.apiKey) url += `?api_key=${config.apiKey}`;
                if (corsEnabled) url = corsProxyUrl + url;
                
                const response = await fetch(url);
                if (!response.ok) continue;
                data = await response.json();
                
            } else if (blockchain === 'ethereum') {
                const apiKey = localStorage.getItem('bats_etherscan_api_key') || config.apiKey || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8';
                
                // First get the basic transaction
                url = `${apiUrl}${hash}&apikey=${apiKey}`;
                if (corsEnabled) url = corsProxyUrl + url;
                
                const response = await fetch(url);
                if (!response.ok) continue;
                data = await response.json();
                if (!data.result || data.result === null) continue;
                
                // Also check for token transfers
                let tokenData = null;
                try {
                    const tokenUrl = corsEnabled ? 
                        corsProxyUrl + `${config.tokenApiUrl}${hash}&apikey=${apiKey}` :
                        `${config.tokenApiUrl}${hash}&apikey=${apiKey}`;
                    
                    const tokenResponse = await fetch(tokenUrl);
                    if (tokenResponse.ok) {
                        tokenData = await tokenResponse.json();
                        console.log('Receipt/Token data received:', tokenData);
                        
                        // Check if Etherscan returned an error
                        if (tokenData && tokenData.status === '0' && tokenData.message === 'NOTOK') {
                            console.error('Etherscan API error:', tokenData.result);
                            throw new Error(tokenData.result);
                        }
                    }
                } catch (err) {
                    console.log('No token transfers found');
                }
                
            } else if (blockchain === 'tron') {
                url = apiUrl + hash;
                const headers = config.apiKey ? { 'TRON-PRO-API-KEY': config.apiKey } : {};
                if (corsEnabled) url = corsProxyUrl + url;
                
                const response = await fetch(url, { headers });
                if (!response.ok) continue;
                data = await response.json();
                
            } else if (blockchain === 'solana') {
                url = apiUrl;
                if (corsEnabled) url = corsProxyUrl + url;
                
                const response = await fetch(url, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        jsonrpc: '2.0',
                        id: 1,
                        method: 'getTransaction',
                        params: [hash, { encoding: 'json', maxSupportedTransactionVersion: 0 }]
                    })
                });
                if (!response.ok) continue;
                data = await response.json();
                if (data.error) continue;
            }
            
            // Parse and return the data (pass tokenData for Ethereum)
            const txData = blockchain === 'ethereum' ? 
                config.parseResponse(data, tokenData) : 
                config.parseResponse(data);
            if (txData) {
                txData.blockchain = config.name;
                return txData;
            }
            
        } catch (error) {
            console.error(`Failed with ${apiUrl}:`, error);
            // Continue to next URL
        }
    }
    
    return null;
}

// Individual blockchain lookup functions for hop transactions
async function lookupEthereumTransaction(txHash) {
    const config = blockchainAPIs.ethereum;
    const corsEnabled = localStorage.getItem('bats_cors_proxy_enabled') === 'true';
    const corsProxyUrl = localStorage.getItem('bats_cors_proxy_url') || 'https://cors-anywhere.herokuapp.com/';
    const apiKey = config.apiKey || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8';
    
    // Build array of URLs to try (primary + fallbacks)
    const urlsToTry = [config.apiUrl, ...(config.fallbackUrls || [])];
    
    for (let apiUrl of urlsToTry) {
        try {
            // First get the basic transaction
            let url = `${apiUrl}${txHash}&apikey=${apiKey}`;
            if (corsEnabled) url = corsProxyUrl + url;
            
            const response = await fetch(url);
            if (!response.ok) continue;
            const data = await response.json();
            if (!data.result || data.result === null) continue;
            
            // Also check for token transfers
            let tokenData = null;
            try {
                const tokenUrl = corsEnabled ? 
                    corsProxyUrl + `${config.tokenApiUrl}${txHash}&apikey=${apiKey}` :
                    `${config.tokenApiUrl}${txHash}&apikey=${apiKey}`;
                
                const tokenResponse = await fetch(tokenUrl);
                if (tokenResponse.ok) {
                    tokenData = await tokenResponse.json();
                }
            } catch (err) {
                console.log('No token transfers found');
            }
            
            // Parse the response
            const txData = config.parseResponse(data, tokenData);
            if (txData) {
                txData.blockchain = config.name;
                txData.rawHash = txHash;
                return txData;
            }
        } catch (error) {
            console.error(`Failed with ${apiUrl}:`, error);
        }
    }
    
    throw new Error('Failed to fetch Ethereum transaction');
}

async function lookupBitcoinTransaction(txHash) {
    const config = blockchainAPIs.bitcoin;
    const corsEnabled = localStorage.getItem('bats_cors_proxy_enabled') === 'true';
    const corsProxyUrl = localStorage.getItem('bats_cors_proxy_url') || 'https://cors-anywhere.herokuapp.com/';
    
    const urlsToTry = [config.apiUrl, ...(config.fallbackUrls || [])];
    
    for (let apiUrl of urlsToTry) {
        try {
            let url = apiUrl + txHash;
            if (config.apiKey) {
                url += `?api_key=${config.apiKey}`;
            }
            if (corsEnabled) url = corsProxyUrl + url;
            
            const response = await fetch(url);
            if (!response.ok) continue;
            const data = await response.json();
            
            const txData = config.parseResponse(data);
            if (txData) {
                txData.blockchain = config.name;
                txData.rawHash = txHash;
                return txData;
            }
        } catch (error) {
            console.error(`Failed with ${apiUrl}:`, error);
        }
    }
    
    throw new Error('Failed to fetch Bitcoin transaction');
}

async function lookupTronTransaction(txHash) {
    const config = blockchainAPIs.tron;
    const corsEnabled = localStorage.getItem('bats_cors_proxy_enabled') === 'true';
    const corsProxyUrl = localStorage.getItem('bats_cors_proxy_url') || 'https://cors-anywhere.herokuapp.com/';
    
    const urlsToTry = [config.apiUrl, ...(config.fallbackUrls || [])];
    
    for (let apiUrl of urlsToTry) {
        try {
            let url = apiUrl + txHash;
            const headers = config.apiKey ? { 'TRON-PRO-API-KEY': config.apiKey } : {};
            
            if (corsEnabled) url = corsProxyUrl + url;
            
            const response = await fetch(url, { headers });
            if (!response.ok) continue;
            const data = await response.json();
            
            const txData = config.parseResponse(data);
            if (txData) {
                txData.blockchain = config.name;
                txData.rawHash = txHash;
                return txData;
            }
        } catch (error) {
            console.error(`Failed with ${apiUrl}:`, error);
        }
    }
    
    throw new Error('Failed to fetch Tron transaction');
}

async function lookupSolanaTransaction(txHash) {
    const config = blockchainAPIs.solana;
    const corsEnabled = localStorage.getItem('bats_cors_proxy_enabled') === 'true';
    const corsProxyUrl = localStorage.getItem('bats_cors_proxy_url') || 'https://cors-anywhere.herokuapp.com/';
    
    const urlsToTry = [config.apiUrl, ...(config.fallbackUrls || [])];
    
    for (let apiUrl of urlsToTry) {
        try {
            let url = apiUrl;
            if (corsEnabled) url = corsProxyUrl + url;
            
            const response = await fetch(url, {
                method: 'POST',
                headers: { 'Content-Type': 'application/json' },
                body: JSON.stringify({
                    jsonrpc: '2.0',
                    id: 1,
                    method: 'getTransaction',
                    params: [txHash, { encoding: 'json', maxSupportedTransactionVersion: 0 }]
                })
            });
            
            if (!response.ok) continue;
            const data = await response.json();
            if (data.error) continue;
            
            const txData = config.parseResponse(data);
            if (txData) {
                txData.blockchain = config.name;
                txData.rawHash = txHash;
                return txData;
            }
        } catch (error) {
            console.error(`Failed with ${apiUrl}:`, error);
        }
    }
    
    throw new Error('Failed to fetch Solana transaction');
}

// Victim Transaction Lookup Function
async function lookupHopTransaction(hopId, entryId) {
    const hop = investigation.hops.find(h => h.id === hopId);
    const entry = hop?.entries.find(e => e.id === entryId);
    if (!hop || !entry) return;
    
    const txHash = document.getElementById(`txHash_${hopId}_${entryId}`)?.value?.trim();
    if (!txHash) {
        alert('Please enter a transaction hash');
        return;
    }
    
    const detectedChain = detectBlockchainFromHash(txHash);
    if (!detectedChain) {
        alert('Cannot determine blockchain from hash format');
        return;
    }
    
    // Show loading indicator
    const button = event.target;
    const originalText = button.textContent;
    button.textContent = ' Looking up...';
    button.disabled = true;
    
    try {
        let txData = null;
        
        switch(detectedChain) {
            case 'ethereum':
                txData = await lookupEthereumTransaction(txHash);
                break;
            case 'bitcoin':
                txData = await lookupBitcoinTransaction(txHash);
                break;
            case 'tron':
                txData = await lookupTronTransaction(txHash);
                break;
            case 'solana':
                txData = await lookupSolanaTransaction(txHash);
                break;
            default:
                throw new Error('Unsupported blockchain');
        }
        
        if (txData) {
            // Handle multiple transfers case (batch transactions)
            if (txData.multipleTransfers) {
                // Show transfer selection modal
                showTransferSelectionForHop(hopId, entryId, txData.transfers);
                return;
            }
            
            // Auto-populate hop entry fields
            updateHopEntry(hopId, entryId, 'fromWallet', txData.from);
            updateHopEntry(hopId, entryId, 'toWallet', txData.to);
            updateHopEntry(hopId, entryId, 'amount', txData.amount); // Use 'amount' not 'value'
            updateHopEntry(hopId, entryId, 'currency', txData.currency);
            updateHopEntry(hopId, entryId, 'timestamp', formatDatetimeLocal(txData.time));
            
            // Update UI fields directly
            const amountField = document.getElementById(`amount_${hopId}_${entryId}`);
            if (amountField) amountField.value = txData.amount; // Use 'amount' not 'value'
            
            const currencySelect = document.querySelector(`[onchange*="updateHopEntry(${hopId}, ${entryId}, 'currency'"]`);
            if (currencySelect) {
                currencySelect.value = txData.currency;
                // Trigger currency change to update step
                updateHopEntry(hopId, entryId, 'currency', txData.currency);
            }
            
            const timestampField = document.getElementById(`timestamp_${hopId}_${entryId}`);
            if (timestampField) timestampField.value = formatDatetimeLocal(txData.time);
            
            const toWalletField = document.getElementById(`toWallet_${hopId}_${entryId}`);
            if (toWalletField) toWalletField.value = txData.to;
            
            // Update from wallet field if it exists
            const fromWalletField = document.querySelector(`input[onchange*="updateHopEntry(${hopId}, ${entryId}, 'fromWallet'"]`);
            if (fromWalletField) fromWalletField.value = txData.from;
            
            alert(` Transaction data loaded:\n\nFrom: ${txData.from}\nTo: ${txData.to}\nAmount: ${txData.amount} ${txData.currency}\nTime: ${new Date(txData.time).toLocaleString()}`);
        }
    } catch (error) {
        console.error('Lookup error:', error);
        alert(` Failed to lookup transaction: ${error.message}`);
    } finally {
        button.textContent = originalText;
        button.disabled = false;
    }
}

function showTransferSelectionForHop(hopId, entryId, transfers) {
    const modalHTML = `
        <div id="hopTransferModal" class="modal" style="display: block;">
            <div class="modal-content" style="max-width: 700px;">
                <div class="modal-header">
                    <h2> Multiple Transfers Detected</h2>
                    <p>This transaction contains ${transfers.length} transfers. Select the one to use:</p>
                </div>
                
                <div style="max-height: 400px; overflow-y: auto; margin: 20px 0;">
                    ${transfers.map((transfer, index) => `
                        <div style="background: white; border: 2px solid #e8f0fe; border-radius: 8px; padding: 15px; margin-bottom: 10px; cursor: pointer; transition: all 0.2s;"
                             onmouseover="this.style.borderColor='#3498db'; this.style.transform='translateY(-2px)'"
                             onmouseout="this.style.borderColor='#e8f0fe'; this.style.transform='translateY(0)'"
                             onclick="selectHopTransfer(${hopId}, ${entryId}, ${index})">
                            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px;">
                                <div>
                                    <strong>From:</strong><br>
                                    <span style="font-family: monospace; font-size: 12px;">${transfer.from}</span>
                                </div>
                                <div>
                                    <strong>To:</strong><br>
                                    <span style="font-family: monospace; font-size: 12px;">${transfer.to}</span>
                                </div>
                            </div>
                            <div style="margin-top: 10px; font-size: 18px; font-weight: bold; color: #2c3e50;">
                                ${transfer.amount} ${transfer.currency}
                            </div>
                        </div>
                    `).join('')}
                </div>
                
                <div style="text-align: center; margin-top: 20px;">
                    <button class="btn btn-secondary" onclick="closeHopTransferModal()">
                        Cancel
                    </button>
                </div>
            </div>
        </div>
    `;
    
    // Store transfers data for selection
    window.hopTransferData = transfers;
    
    // Create centered modal
    createCenteredModal('hopTransferModal', modalHTML);
}

function selectHopTransfer(hopId, entryId, transferIndex) {
    const transfer = window.hopTransferData[transferIndex];
    if (!transfer) return;
    
    // Populate the hop entry with selected transfer
    updateHopEntry(hopId, entryId, 'fromWallet', transfer.from);
    updateHopEntry(hopId, entryId, 'toWallet', transfer.to);
    updateHopEntry(hopId, entryId, 'amount', transfer.amount);
    updateHopEntry(hopId, entryId, 'currency', transfer.currency);
    
    // Update UI fields
    const amountField = document.getElementById(`amount_${hopId}_${entryId}`);
    if (amountField) amountField.value = transfer.amount;
    
    const toWalletField = document.getElementById(`toWallet_${hopId}_${entryId}`);
    if (toWalletField) toWalletField.value = transfer.to;
    
    alert(` Transfer selected:\n\nFrom: ${transfer.from}\nTo: ${transfer.to}\nAmount: ${transfer.amount} ${transfer.currency}`);
    
    closeHopTransferModal();
}

function closeHopTransferModal() {
    const modal = document.getElementById('hopTransferModal');
    if (modal) modal.remove();
    window.hopTransferData = null;
}

async function lookupVictimTransaction(victimId, transactionId) {
    const txHashInputElement = document.getElementById(`txHash_victim_${victimId}_${transactionId}`);
    const txHash = txHashInputElement.value.trim();
    
    if (!txHash) {
        alert('Please paste a transaction hash first');
        return;
    }
    
    // Detect blockchain from hash
    const detectedChain = detectBlockchainFromHash(txHash);
    if (!detectedChain) {
        alert('Unable to detect blockchain from transaction hash format');
        return;
    }
    
    // Show loading state - find the button that was clicked
    const lookupBtn = document.querySelector(`button[onclick*="lookupVictimTransaction(${victimId}, ${transactionId})"]`);
    const originalText = lookupBtn.textContent;
    lookupBtn.textContent = ' Loading...';
    lookupBtn.disabled = true;
    
    try {
        const config = blockchainAPIs[detectedChain];
        const corsEnabled = localStorage.getItem('bats_cors_proxy_enabled') === 'true';
        const corsProxyUrl = localStorage.getItem('bats_cors_proxy_url') || 'https://cors-anywhere.herokuapp.com/';
        
        // Build array of URLs to try (primary + fallbacks)
        const urlsToTry = [config.apiUrl, ...(config.fallbackUrls || [])];
        let lastError = null;
        let txData = null;
        
        for (let apiUrl of urlsToTry) {
            try {
                let data;
                let url;
                let tokenData = null; // Define tokenData at this scope
                let blockTimestamp = null; // Define blockTimestamp at this scope
                let blockData = null; // Define blockData at this scope
                
                if (detectedChain === 'bitcoin') {
                    url = apiUrl + txHash;
                    if (config.apiKey) {
                        url += `?api_key=${config.apiKey}`;
                    }
                    if (corsEnabled) url = corsProxyUrl + url;
                    
                    const response = await fetch(url);
                    if (!response.ok) throw new Error('Transaction not found');
                    data = await response.json();
                    
                } else if (['ethereum', 'base', 'arbitrum', 'optimism', 'polygon', 'bsc'].includes(detectedChain)) {
                    const apiKey = localStorage.getItem('bats_etherscan_api_key') || config.apiKey || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8';
                    
                    // First get the basic transaction
                    url = `${apiUrl}${txHash}&apikey=${apiKey}`;
                    if (corsEnabled) url = corsProxyUrl + url;
                    
                    const response = await fetch(url);
                    if (!response.ok) throw new Error('API request failed');
                    data = await response.json();
                    if (!data.result || data.result === null) throw new Error('Transaction not found');
                    
                    // Get block data for timestamp - but don't let it block token transfers
                    if (data.result && data.result.blockNumber) {
                        try {
                            const blockUrl = corsEnabled ?
                                corsProxyUrl + `${config.blockApiUrl}${data.result.blockNumber}&boolean=true&apikey=${apiKey}` :
                                `${config.blockApiUrl}${data.result.blockNumber}&boolean=true&apikey=${apiKey}`;
                            
                            const blockResponse = await fetch(blockUrl);
                            if (blockResponse.ok) {
                                const blockData = await blockResponse.json();
                                if (blockData && blockData.result && blockData.result.timestamp) {
                                    blockTimestamp = parseInt(blockData.result.timestamp, 16) * 1000;
                                    console.log('Got block timestamp:', new Date(blockTimestamp).toISOString());
                                }
                            }
                        } catch (err) {
                            console.log('Failed to fetch block timestamp, will proceed without it:', err);
                        }
                    }
                    
                    // Small delay to avoid rate limit
                    if (blockTimestamp) {
                        await new Promise(resolve => setTimeout(resolve, 300));
                    }
                    
                    // Also check for token transfers
                    try {
                        const tokenUrl = corsEnabled ? 
                            corsProxyUrl + `${config.tokenApiUrl}${txHash}&apikey=${apiKey}` :
                            `${config.tokenApiUrl}${txHash}&apikey=${apiKey}`;
                        
                        const tokenResponse = await fetch(tokenUrl);
                        if (tokenResponse.ok) {
                            tokenData = await tokenResponse.json();
                            console.log('Receipt/Token data received:', tokenData);
                            
                            // Check if Etherscan returned an error
                            if (tokenData && tokenData.status === '0' && tokenData.message === 'NOTOK') {
                                console.error('Etherscan API error:', tokenData.result);
                                throw new Error(tokenData.result);
                            }
                        }
                    } catch (err) {
                        console.log('No token transfers found');
                    }
                    
                } else if (detectedChain === 'tron') {
                    url = apiUrl + txHash;
                    if (config.apiKey) {
                        const headers = { 'TRON-PRO-API-KEY': config.apiKey };
                        if (corsEnabled) url = corsProxyUrl + url;
                        
                        const response = await fetch(url, { headers });
                        if (!response.ok) throw new Error('Transaction not found');
                        data = await response.json();
                    } else {
                        if (corsEnabled) url = corsProxyUrl + url;
                        const response = await fetch(url);
                        if (!response.ok) throw new Error('Transaction not found');
                        data = await response.json();
                    }
                    
                } else if (detectedChain === 'solana') {
                    url = apiUrl;
                    if (corsEnabled) url = corsProxyUrl + url;
                    
                    const response = await fetch(url, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            jsonrpc: '2.0',
                            id: 1,
                            method: 'getTransaction',
                            params: [txHash, { encoding: 'json', maxSupportedTransactionVersion: 0 }]
                        })
                    });
                    if (!response.ok) throw new Error('RPC request failed');
                    data = await response.json();
                    if (data.error) throw new Error(data.error.message);
                }
                
                // Parse the response (pass tokenData and blockTimestamp for EVM chains)
                const isEVMChain = ['ethereum', 'base', 'arbitrum', 'optimism', 'polygon', 'bsc'].includes(detectedChain);
                txData = isEVMChain ? 
                    config.parseResponse(data, tokenData, blockTimestamp) : 
                    config.parseResponse(data);
                
                console.log('Parsed transaction data:', txData);
                
                if (!txData) throw new Error('This is a 0 ETH transaction with no token transfers');
                
                // Check if multiple transfers were detected
                if (txData.multipleTransfers) {
                    console.log('Multiple transfers detected, showing selection modal with', txData.transfers.length, 'transfers');
                    // Store the callback with proper context
                    window.pendingTransferContext = {
                        victimId: victimId,
                        transactionId: transactionId,
                        txHash: txHash,
                        transfers: txData.transfers,
                        timestamp: txData.time,
                        hasRealTimestamp: txData.hasRealTimestamp
                    };
                    pendingTransferCallback = (selectedTransfer) => {
                        // Apply the selected transfer with timestamp
                        applyTransferToVictim(victimId, transactionId, selectedTransfer, txHash, txData.time, txData.hasRealTimestamp);
                    };
                    showTransferSelectionModal(txData.transfers);
                    lookupBtn.textContent = originalText;
                    lookupBtn.disabled = false;
                    return; // Exit early - will continue after selection
                }
                
                // Success! Break out of the loop
                break;
                
            } catch (error) {
                console.error(`Failed with ${apiUrl}:`, error);
                lastError = error;
                // Continue to next URL
            }
        }
        
        if (!txData) {
            throw lastError || new Error('Failed to fetch transaction');
        }
        
        // Apply the data to the victim transaction
        const victim = investigation.victims.find(v => v.id === victimId);
        const transaction = victim.transactions.find(t => t.id === transactionId);
        
        // Update amount
        document.getElementById(`amount_victim_${victimId}_${transactionId}`).value = txData.amount;
        transaction.amount = txData.amount.toString();
        
        // Update currency
        document.getElementById(`currency_victim_${victimId}_${transactionId}`).value = txData.currency;
        transaction.currency = txData.currency;
        
        // Update receiving wallet (the "to" address is the RED wallet)
        document.getElementById(`receivingWallet_victim_${victimId}_${transactionId}`).value = txData.to;
        transaction.receivingWallet = txData.to;
        
        // Update datetime with validation
        if (txData.time && !isNaN(txData.time)) {
            const date = new Date(txData.time);
            if (!isNaN(date.getTime())) {
                const dateTimeLocal = date.toISOString().slice(0, 16);
                document.getElementById(`datetime_victim_${victimId}_${transactionId}`).value = dateTimeLocal;
                transaction.datetime = dateTimeLocal;
            } else {
                console.warn('Invalid date from transaction time:', txData.time);
                // Leave datetime empty for manual entry
            }
        } else {
            console.warn('No valid timestamp in transaction data');
            // Leave datetime empty for manual entry
        }
        
        // Set timezone to UTC
        document.getElementById(`timezone_victim_${victimId}_${transactionId}`).value = 'UTC';
        transaction.timezone = 'UTC';
        
        // Add note about the transaction
        const notesInput = document.querySelector(`input[onchange*="updateTransaction(${victimId}, ${transactionId}, 'notes'"]`);
        if (notesInput) {
            notesInput.value = `From: ${txData.from} | ${config.name} transaction`;
            transaction.notes = notesInput.value;
        }
        
        // Save and re-render
        saveToStorage();
        renderVictims();
        
        const timeString = txData.time && !isNaN(txData.time) ? 
            `\nTime: ${new Date(txData.time).toLocaleString()} UTC` : 
            '\nTime: Not available (please enter manually)';
        
        let alertMessage = ` Transaction data retrieved successfully!\n\nAmount: ${txData.amount} ${txData.currency}\nFrom: ${txData.from}\nTo (RED Wallet): ${txData.to}${timeString}`;
        
        if (txData.hasRealTimestamp === false) {
            alertMessage += '\n\n WARNING: Could not retrieve actual transaction timestamp. Current time was used. Please manually update the date/time field!';
        }
        
        alert(alertMessage);
        
    } catch (error) {
        console.error('Lookup error:', error);
        const errorMsg = error.message || 'Failed to fetch transaction';
        if (errorMsg.includes('CORS') || errorMsg.includes('Failed to fetch')) {
            alert(` ${errorMsg}\n\nTip: Enable CORS Proxy in API Settings or try again.`);
        } else {
            alert(` Failed to fetch transaction: ${errorMsg}`);
        }
    } finally {
        lookupBtn.textContent = originalText;
        lookupBtn.disabled = false;
    }
}
        // Transfer Selection Modal Functions
        function showTransferSelectionModal(transfers) {
            const modal = document.getElementById('transferSelectionModal');
            const transfersList = document.getElementById('transfersList');
            
            // Store transfers globally for filtering
            window.allTransfers = transfers;
            window.filteredTransfers = transfers;
            
            // Populate asset filter dropdown
            const assetFilter = document.getElementById('transferAssetFilter');
            assetFilter.innerHTML = '<option value="">All Assets</option>';
            
            // Get unique assets
            const uniqueAssets = [...new Set(transfers.map(t => t.currency))].sort();
            uniqueAssets.forEach(asset => {
                const option = document.createElement('option');
                option.value = asset;
                option.textContent = asset;
                assetFilter.appendChild(option);
            });
            
            // Clear filters
            document.getElementById('transferAmountFilter').value = '';
            document.getElementById('transferAddressFilter').value = '';
            assetFilter.value = '';
            
            // Render transfers
            renderTransferCards(transfers);
            
            // Update filter info
            updateFilterInfo(transfers.length, transfers.length);
            
            // Show the modal
            modal.classList.add('show');
        }
        
        function renderTransferCards(transfers) {
            const transfersList = document.getElementById('transfersList');
            transfersList.innerHTML = '';
            
            if (transfers.length === 0) {
                transfersList.innerHTML = '<div style="text-align: center; padding: 40px; color: #666;">No transfers match your filters</div>';
                return;
            }
            
            transfers.forEach((transfer, index) => {
                // Find the original index for correct selection
                const originalIndex = window.allTransfers.indexOf(transfer);
                
                const transferCard = document.createElement('div');
                transferCard.className = 'transfer-card';
                transferCard.style.cssText = `
                    background: white;
                    border: 2px solid #e8f0fe;
                    border-radius: 8px;
                    padding: 20px;
                    margin-bottom: 15px;
                    cursor: pointer;
                    transition: all 0.3s ease;
                `;
                
                transferCard.onmouseover = () => {
                    transferCard.style.borderColor = '#3498db';
                    transferCard.style.backgroundColor = '#f0f8ff';
                };
                
                transferCard.onmouseout = () => {
                    transferCard.style.borderColor = '#e8f0fe';
                    transferCard.style.backgroundColor = 'white';
                };
                
                transferCard.innerHTML = `
                    <div style="display: grid; grid-template-columns: 1fr auto; gap: 15px; align-items: start;">
                        <div>
                            <h4 style="margin: 0 0 10px 0; color: #2c3e50;">
                                Transfer ${originalIndex + 1}: <span style="color: #3498db; font-weight: 600;">${formatNumber(transfer.amount)}</span> <span style="color: #27ae60; font-weight: 600;">${transfer.currency}</span>
                            </h4>
                            <div style="font-size: 14px; color: #555;">
                                <div style="margin-bottom: 5px;">
                                    <strong>From:</strong> <span style="font-family: monospace;">${transfer.from}</span>
                                </div>
                                <div style="margin-bottom: 5px;">
                                    <strong>To:</strong> <span style="font-family: monospace;">${transfer.to}</span>
                                </div>
                                <div>
                                    <strong>Token Contract:</strong> <span style="font-family: monospace;">${transfer.contractAddress}</span>
                                </div>
                            </div>
                        </div>
                        <button class="btn btn-confirm" onclick="selectTransfer(${originalIndex})" style="margin-top: 0;">
                            Select This Transfer
                        </button>
                    </div>
                `;
                
                transfersList.appendChild(transferCard);
            });
        }
        
        function filterTransfers() {
            const assetFilter = document.getElementById('transferAssetFilter').value;
            const amountFilter = document.getElementById('transferAmountFilter').value.trim();
            const addressFilter = document.getElementById('transferAddressFilter').value.trim().toLowerCase();
            
            window.filteredTransfers = window.allTransfers.filter(transfer => {
                // Asset filter
                if (assetFilter && transfer.currency !== assetFilter) {
                    return false;
                }
                
                // Amount filter
                if (amountFilter) {
                    const filterAmount = parseFloat(amountFilter);
                    if (!isNaN(filterAmount)) {
                        // Allow for slight variations due to decimal precision
                        if (Math.abs(transfer.amount - filterAmount) > 0.000001) {
                            return false;
                        }
                    }
                }
                
                // Address filter (check both from and to)
                if (addressFilter) {
                    const fromMatch = transfer.from.toLowerCase().includes(addressFilter);
                    const toMatch = transfer.to.toLowerCase().includes(addressFilter);
                    if (!fromMatch && !toMatch) {
                        return false;
                    }
                }
                
                return true;
            });
            
            // Re-render filtered transfers
            renderTransferCards(window.filteredTransfers);
            
            // Update filter info
            updateFilterInfo(window.filteredTransfers.length, window.allTransfers.length);
        }
        
        function clearTransferFilters() {
            document.getElementById('transferAssetFilter').value = '';
            document.getElementById('transferAmountFilter').value = '';
            document.getElementById('transferAddressFilter').value = '';
            window.filteredTransfers = window.allTransfers;
            renderTransferCards(window.allTransfers);
            updateFilterInfo(window.allTransfers.length, window.allTransfers.length);
        }
        
        function updateFilterInfo(shown, total) {
            const infoDiv = document.getElementById('filterResultsInfo');
            if (shown === total) {
                infoDiv.textContent = `Showing all ${total} transfers`;
            } else {
                infoDiv.textContent = `Showing ${shown} of ${total} transfers`;
            }
        }
        
        function closeTransferSelectionModal() {
            const modal = document.getElementById('transferSelectionModal');
            modal.classList.remove('show');
            
            // Clear pending data
            pendingTransfers = null;
            pendingTransferCallback = null;
        }
        
        function selectTransfer(index) {
            if (!window.allTransfers || !pendingTransferCallback) {
                console.error('No pending transfer data');
                return;
            }
            
            const selectedTransfer = window.allTransfers[index];
            
            // Store the callback before closing modal (which clears it)
            const callback = pendingTransferCallback;
            
            // Close the modal
            closeTransferSelectionModal();
            
            // Execute the callback with the selected transfer
            callback(selectedTransfer);
        }
        
        function applyTransferToVictim(victimId, transactionId, transfer, txHash, timestamp, hasRealTimestamp) {
            console.log('Applying transfer to victim:', { victimId, transactionId, transfer, txHash });
            
            // Ensure transfer data is valid
            if (!transfer || !transfer.amount || !transfer.to) {
                console.error('Invalid transfer data:', transfer);
                alert('Error: Invalid transfer data received');
                return;
            }
            
            const victim = investigation.victims.find(v => v.id === victimId);
            if (!victim) {
                console.error('Victim not found:', victimId);
                alert('Error: Victim not found');
                return;
            }
            
            const transaction = victim.transactions.find(t => t.id === transactionId);
            if (!transaction) {
                console.error('Transaction not found:', transactionId);
                alert('Error: Transaction not found');
                return;
            }
            
            // Update transaction hash first
            const txHashField = document.getElementById(`txHash_victim_${victimId}_${transactionId}`);
            if (txHashField && txHash) {
                txHashField.value = txHash;
                transaction.txHash = txHash;
            }
            
            // Update amount
            const amountInput = document.getElementById(`amount_victim_${victimId}_${transactionId}`);
            if (amountInput) {
                amountInput.value = transfer.amount;
                transaction.amount = transfer.amount.toString();
            } else {
                console.error('Amount input not found:', `amount_victim_${victimId}_${transactionId}`);
            }
            
            // Update currency
            const currencySelect = document.getElementById(`currency_victim_${victimId}_${transactionId}`);
            if (!currencySelect) {
                console.error('Currency select not found:', `currency_victim_${victimId}_${transactionId}`);
            } else {
                // If the currency doesn't exist in the select, add it
                const optionExists = Array.from(currencySelect.options).some(opt => opt.value === transfer.currency);
                if (!optionExists && transfer.currency !== 'CUSTOM') {
                    const newOption = document.createElement('option');
                    newOption.value = transfer.currency;
                    newOption.textContent = transfer.currency;
                    currencySelect.appendChild(newOption);
                }
                
                currencySelect.value = transfer.currency;
                transaction.currency = transfer.currency;
            }
            
            // Update receiving wallet (the "to" address is the RED wallet)
            const receivingWalletInput = document.getElementById(`receivingWallet_victim_${victimId}_${transactionId}`);
            if (receivingWalletInput) {
                receivingWalletInput.value = transfer.to;
                transaction.receivingWallet = transfer.to;
            } else {
                console.error('Receiving wallet input not found');
            }
            
            // Update datetime with transaction timestamp if available
            if (timestamp && !isNaN(timestamp)) {
                const date = new Date(timestamp);
                if (!isNaN(date.getTime())) {
                    const dateTimeLocal = date.toISOString().slice(0, 16);
                    const datetimeInput = document.getElementById(`datetime_victim_${victimId}_${transactionId}`);
                    if (datetimeInput) {
                        datetimeInput.value = dateTimeLocal;
                        transaction.datetime = dateTimeLocal;
                    }
                } else {
                    console.warn('Invalid timestamp provided:', timestamp);
                }
            } else {
                console.warn('No timestamp provided for transfer');
            }
            
            // Set timezone to UTC
            const timezoneSelect = document.getElementById(`timezone_victim_${victimId}_${transactionId}`);
            if (timezoneSelect) {
                timezoneSelect.value = 'UTC';
                transaction.timezone = 'UTC';
            }
            
            // Add note about the transaction
            const notesInput = document.querySelector(`input[onchange*="updateTransaction(${victimId}, ${transactionId}, 'notes'"]`);
            if (notesInput) {
                notesInput.value = `From: ${transfer.from} | Ethereum ${transfer.currency} transfer | Contract: ${transfer.contractAddress}`;
                transaction.notes = notesInput.value;
            }
            
            // Store the transaction hash
            transaction.txHash = txHash;
            
            // Also update the transaction hash input field
            const txHashElem = document.getElementById(`txHash_victim_${victimId}_${transactionId}`);
            if (txHashElem) {
                txHashElem.value = txHash;
            }
            
            // Save to storage
            saveToStorage();
            
            // Update the workflow steps to reflect progress
            updateWorkflowSteps();
            
            // Show success message
            let alertMessage = ` Transaction data retrieved successfully!

Amount: ${formatNumber(transfer.amount)} ${transfer.currency}
From: ${transfer.from}
To (RED Wallet): ${transfer.to}`;
            
            if (!hasRealTimestamp) {
                alertMessage += '\n\n WARNING: Could not retrieve actual transaction timestamp. Current time was used. Please manually update the date/time field!';
            }
            
            alert(alertMessage);
            
            // Log for debugging
            console.log('Transfer applied successfully:', {
                victimId,
                transactionId,
                amount: transfer.amount,
                currency: transfer.currency,
                to: transfer.to
            });
        }
        
        // Entity Detection Functions
        async function detectWalletEntity(address, blockchain) {
            const config = blockchainAPIs[blockchain];
            if (!config) return null;
            
            const corsEnabled = localStorage.getItem('bats_cors_proxy_enabled') === 'true';
            const corsProxyUrl = localStorage.getItem('bats_cors_proxy_url') || 'https://cors-anywhere.herokuapp.com/';
            
            try {
                if (blockchain === 'bitcoin' && config.entityApiUrl) {
                    // WalletExplorer API for Bitcoin
                    let url = config.entityApiUrl + address;
                    if (corsEnabled) url = corsProxyUrl + url;
                    
                    const response = await fetch(url);
                    if (response.ok) {
                        const data = await response.json();
                        if (data && data.label && data.label !== 'Unknown') {
                            return {
                                entity: data.label,
                                category: data.category || 'Exchange/Service',
                                confidence: 'high',
                                source: 'WalletExplorer'
                            };
                        }
                    }
                } else if (blockchain === 'ethereum' && config.labelApiUrl) {
                    // Etherscan labels API
                    const apiKey = localStorage.getItem('bats_etherscan_api_key') || config.apiKey || '3X65ZBIMYIGFZEV6B3D2YWWXUJD1DWAKP8';
                    let url = `${config.labelApiUrl}${address}&apikey=${apiKey}`;
                    if (corsEnabled) url = corsProxyUrl + url;
                    
                    const response = await fetch(url);
                    if (response.ok) {
                        const data = await response.json();
                        if (data.status === '1' && data.result) {
                            // Check for name tag (exchange/service label)
                            if (data.result.length > 0) {
                                const labelInfo = data.result[0];
                                if (labelInfo.nameTag && labelInfo.nameTag !== '') {
                                    return {
                                        entity: labelInfo.nameTag,
                                        category: 'Exchange/Service',
                                        confidence: 'high',
                                        source: 'Etherscan'
                                    };
                                }
                            }
                        }
                    }
                }
                
                // Check against known exchange patterns
                const knownPatterns = checkKnownExchangePatterns(address, blockchain);
                if (knownPatterns) {
                    return knownPatterns;
                }
                
            } catch (error) {
                console.error('Entity detection error:', error);
            }
            
            return null;
        }
        
        function checkKnownExchangePatterns(address, blockchain) {
            // Common exchange address patterns and known addresses
            const knownExchanges = {
                bitcoin: {
                    // Binance cold wallets often start with bc1q
                    patterns: [
                        { prefix: '3BMEX', entity: 'BitMEX', category: 'Exchange' },
                        { prefix: '3JZq4atUahhuA9rLhX', entity: 'Bitfinex', category: 'Exchange' },
                        { prefix: '1NDyJtNTjmwk5xPNhjgAMu4HDHigtobu1s', entity: 'Binance', category: 'Exchange' }
                    ],
                    addresses: {
                        '1A1zP1eP5QGefi2DMPTfTL5SLmv7DivfNa': { entity: 'Genesis Block', category: 'Historical' },
                        '12cgpFdJViXbwHbhrA3TuW1EGnL25Zqc3P': { entity: 'Binance Cold Wallet', category: 'Exchange' }
                    }
                },
                ethereum: {
                    addresses: {
                        '0x3f5ce5fbfe3e9af3971dd833d26ba9b5c936f0be': { entity: 'Binance', category: 'Exchange' },
                        '0xd551234ae421e3bcba99a0da6d736074f22192ff': { entity: 'Binance 2', category: 'Exchange' },
                        '0x564286362092d8e7936f0549571a803b203aaced': { entity: 'Binance 3', category: 'Exchange' },
                        '0x28c6c06298d514db089934071355e5743bf21d60': { entity: 'Binance 14', category: 'Exchange' },
                        '0x21a31ee1afc51d94c2efccaa2092ad1028285549': { entity: 'Binance 15', category: 'Exchange' },
                        '0xdfd5293d8e347dfe59e90efd55b2956a1343963d': { entity: 'Binance 16', category: 'Exchange' },
                        '0x56eddb7aa87536c09ccc2793473599fd21a8b17f': { entity: 'Binance 17', category: 'Exchange' },
                        '0x9696f59e4d72e237be84ffd425dcad154bf96976': { entity: 'Binance 18', category: 'Exchange' },
                        '0x4e9ce36e442e55ecd9025b9a6e0d88485d628a67': { entity: 'Binance US', category: 'Exchange' },
                        '0xbe0eb53f46cd790cd13851d5eff43d12404d33e8': { entity: 'Binance 7', category: 'Exchange' },
                        '0x876eabf441b2ee5b5b0554fd502a8e0600950cfa': { entity: 'Bitfinex', category: 'Exchange' },
                        '0xc6bed363b30df7f35b601a5547fe56cd31ec63da': { entity: 'Bitfinex 2', category: 'Exchange' },
                        '0x29728d0efd284d85187362faa2d4d76c2cfc2612': { entity: 'Bitfinex 3', category: 'Exchange' },
                        '0xe92d1a43df510f82c66382592a047d288f85226f': { entity: 'Bitfinex 4', category: 'Exchange' },
                        '0x8103683202aa8da10536036edef04cdd865c225e': { entity: 'Bitfinex 5', category: 'Exchange' },
                        '0xab7c74abc0c4d48d1bdad5dcb26153fc8780f83e': { entity: 'Bitfinex MultiSig', category: 'Exchange' },
                        '0x6262998ced04146fa42253a5c0af90ca02dfd2a3': { entity: 'Crypto.com', category: 'Exchange' },
                        '0x46340b20830761efd32832a74d7169b29feb9758': { entity: 'Crypto.com 2', category: 'Exchange' },
                        '0x71660c4005ba85c37ccec55d0c4493e66fe775d3': { entity: 'Coinbase 1', category: 'Exchange' },
                        '0x503828976d22510aad0201ac7ec88293211d23da': { entity: 'Coinbase 2', category: 'Exchange' },
                        '0xddfabcdc4d8ffc6d5beaf154f18b778f892a0740': { entity: 'Coinbase 3', category: 'Exchange' },
                        '0x3cd751e6b0078be393132286c442345e5dc49699': { entity: 'Coinbase 4', category: 'Exchange' },
                        '0xb5d85cbf7cb3ee0d56b3bb207d5fc4b82f43f511': { entity: 'Coinbase 5', category: 'Exchange' },
                        '0xeb2629a2734e272bcc07bda959863f316f4bd4cf': { entity: 'Coinbase 6', category: 'Exchange' },
                        '0xa090e606e30bd747d4e6245a1517ebe430f0057e': { entity: 'Coinbase Miscellaneous', category: 'Exchange' },
                        '0x6cc5f688a315f3dc28a7781717a9a798a59fda7b': { entity: 'OKEx', category: 'Exchange' },
                        '0x236f9f97e0e62388479bf9e5ba4889e46b0273c3': { entity: 'OKEx 2', category: 'Exchange' },
                        '0xa7efae728d2936e78bda97dc267687568dd593f3': { entity: 'OKEx 3', category: 'Exchange' },
                        '0x2c8fbb630289363ac80705a1a61273f76fd5a161': { entity: 'Poloniex', category: 'Exchange' },
                        '0x32be343b94f860124dc4fee278fdcbd38c102d88': { entity: 'Poloniex', category: 'Exchange' },
                        '0x209c4784ab1e8183cf58ca33cb740efbf3fc18ef': { entity: 'Poloniex 2', category: 'Exchange' },
                        '0xb794f5ea0ba39494ce839613fffba74279579268': { entity: 'Poloniex 3', category: 'Exchange' },
                        '0x0a869d79a7052c7f1b55a8ebabbea3420f0d1e13': { entity: 'KuCoin', category: 'Exchange' },
                        '0x2b5634c42055806a59e9107ed44d43c426e58258': { entity: 'KuCoin 2', category: 'Exchange' },
                        '0x689c56aef474df92d44a1b70850f808488f9769c': { entity: 'KuCoin 3', category: 'Exchange' },
                        '0xa1d8d972560c2f8144af871db508f0b0b10a3fbf': { entity: 'KuCoin 4', category: 'Exchange' },
                        '0x4ad64983349c49defe8d7a4686202d24b25d0ce8': { entity: 'KuCoin 5', category: 'Exchange' },
                        '0x1692e170361cefd1eb7240ec13d048fd9af6d667': { entity: 'KuCoin 6', category: 'Exchange' },
                        '0xd6216fc19db775df9774a6e33526131da7d19a2c': { entity: 'KuCoin 7', category: 'Exchange' },
                        '0xe59cd29be3be4461d79c0881d238cbe87d64595a': { entity: 'Kraken', category: 'Exchange' },
                        '0x43984d578803891dfa9706bdeee6078d80cfc79e': { entity: 'Kraken 2', category: 'Exchange' },
                        '0x66c57bf505a85a74609d2c83e94aabb26d691e41': { entity: 'Kraken 3', category: 'Exchange' },
                        '0xda9dfa130df4de4673b89022ee50ff26f6ea73cf': { entity: 'Kraken 4', category: 'Exchange' },
                        '0xa83b11093c858c86321fbc4c20fe82cdbd58e09e': { entity: 'Kraken 5', category: 'Exchange' },
                        '0x0a98fb70939162725ae66e626fe4b52cff62c2e5': { entity: 'Gate.io', category: 'Exchange' },
                        '0xf56e08ee4e8ac390c28bba0431c22e6c1cb54529': { entity: 'Gate.io 2', category: 'Exchange' },
                        '0x7793cd85c11a924478d358d49b05b37e91b5810f': { entity: 'Gate.io 3', category: 'Exchange' },
                        '0x1c4b70a3968436b9a0a9cf5205c787eb81bb558c': { entity: 'Gate.io 4', category: 'Exchange' },
                        '0xd793281182a0e3e023116004778f45c29fc14f19': { entity: 'Gate.io 5', category: 'Exchange' },
                        '0x9f5ca0012b9b72e8f3db57092a6f26bf4f13dc69': { entity: 'Gate.io 6', category: 'Exchange' },
                        '0xc882b111a75c0c657fc507c04fbfcd2cc984f071': { entity: 'Gate.io 7', category: 'Exchange' }
                    }
                }
            };
            
            const lowerAddress = address.toLowerCase();
            
            // Check exact matches
            if (knownExchanges[blockchain] && knownExchanges[blockchain].addresses) {
                const match = knownExchanges[blockchain].addresses[lowerAddress];
                if (match) {
                    return {
                        entity: match.entity,
                        category: match.category,
                        confidence: 'high',
                        source: 'Known Address Database'
                    };
                }
            }
            
            // Check patterns
            if (knownExchanges[blockchain] && knownExchanges[blockchain].patterns) {
                for (const pattern of knownExchanges[blockchain].patterns) {
                    if (address.startsWith(pattern.prefix)) {
                        return {
                            entity: pattern.entity,
                            category: pattern.category,
                            confidence: 'medium',
                            source: 'Address Pattern Match'
                        };
                    }
                }
            }
            
            return null;
        }
        
        // Update wallet classification based on entity
        function updateWalletClassificationFromEntity(entityData, walletType) {
            if (!entityData) return walletType;
            
            // If it's an exchange, mark as purple
            if (entityData.category === 'Exchange' || entityData.category === 'Exchange/Service') {
                return 'purple';
            }
            
            // Keep original classification if no exchange detected
            return walletType;
        }
        
        // Check wallet entity when address is entered
        async function checkWalletEntity(address, hopId, entryId) {
            if (!address || address.trim() === '') return;
            
            // Detect blockchain from address
            let detectedBlockchain = null;
            for (const [blockchain, config] of Object.entries(blockchainAPIs)) {
                if (config.addressPattern && config.addressPattern.test(address)) {
                    detectedBlockchain = blockchain;
                    break;
                }
            }
            
            if (!detectedBlockchain) return;
            
            // Show loading state
            const entityInfoDiv = document.getElementById(`entityInfo_${hopId}_${entryId}`);
            if (entityInfoDiv) {
                entityInfoDiv.style.display = 'block';
                entityInfoDiv.innerHTML = '<div style="text-align: center;"> Checking wallet entity...</div>';
            }
            
            try {
                const entityData = await detectWalletEntity(address, detectedBlockchain);
                
                if (entityData) {
                    // Display entity information
                    if (entityInfoDiv) {
                        entityInfoDiv.innerHTML = `
                            <div style="display: flex; justify-content: space-between; align-items: center;">
                                <div>
                                    <strong> Entity Detected:</strong> ${entityData.entity}<br>
                                    <small>Category: ${entityData.category} | Confidence: ${entityData.confidence} | Source: ${entityData.source}</small>
                                </div>
                                <div>
                                    ${entityData.category === 'Exchange' || entityData.category === 'Exchange/Service' ? 
                                        '<span style="background: #9b59b6; color: white; padding: 4px 12px; border-radius: 4px; font-weight: bold;">PURPLE</span>' : 
                                        ''}
                                </div>
                            </div>
                        `;
                        
                        // Auto-update wallet type if it's an exchange
                        if (entityData.category === 'Exchange' || entityData.category === 'Exchange/Service') {
                            const walletTypeSelect = document.querySelector(`select[onchange*="updateHopEntryWalletType(${hopId}, ${entryId}"]`);
                            if (walletTypeSelect && walletTypeSelect.value !== 'purple') {
                                walletTypeSelect.value = 'purple';
                                updateHopEntryWalletType(hopId, entryId, 'purple');
                                
                                // Add note about auto-classification
                                entityInfoDiv.innerHTML += `
                                    <div style="margin-top: 10px; padding: 8px; background: rgba(255,255,255,0.5); border-radius: 4px; font-size: 12px;">
                                         Wallet automatically classified as PURPLE (Exchange)
                                    </div>
                                `;
                                
                                // Show terminal wallet notification
                                showTerminalWalletNotification(entityData, address, hopId, entryId);
                            }
                        }
                    }
                } else {
                    // No entity found
                    if (entityInfoDiv) {
                        entityInfoDiv.style.display = 'none';
                    }
                }
            } catch (error) {
                console.error('Entity detection error:', error);
                if (entityInfoDiv) {
                    entityInfoDiv.style.display = 'none';
                }
            }
        }
        
        // File system save functionality
        async function saveAndCaptureFilePath() {
            try {
                // Check if File System Access API is available
                if ('showSaveFilePicker' in window) {
                    const options = {
                        types: [{
                            description: 'BATS Investigation Files',
                            accept: { 'application/json': ['.bats'] }
                        }],
                        suggestedName: `BATS_${investigation.caseId || 'Investigation'}_${new Date().toISOString().split('T')[0]}.bats`
                    };
                    
                    // Show save file picker
                    fileHandle = await window.showSaveFilePicker(options);
                    
                    // Create the file content
                    const fileData = JSON.stringify(investigation, null, 2);
                    
                    // Write the file
                    const writable = await fileHandle.createWritable();
                    await writable.write(fileData);
                    await writable.close();
                    
                    // Capture file path info
                    savedFilePath = fileHandle.name;
                    isFileSystemAvailable = true;
                    
                    // Update UI
                    document.getElementById('saveRequiredMessage').style.display = 'none';
                    document.getElementById('generateRootBtn').style.display = 'block';
                    
                    alert(` Investigation saved successfully!\n\nFile: ${savedFilePath}\nLocation: ${fileHandle.name}\n\n Automatic saving is now enabled!\nYour investigation will be automatically saved to this location after each hop.`);
                    
                } else {
                    // Fallback to regular download
                    const fileData = JSON.stringify(investigation, null, 2);
                    const filename = `BATS_${investigation.caseId || 'Investigation'}_${new Date().toISOString().split('T')[0]}.bats`;
                    
                    const blob = new Blob([fileData], { type: 'application/json' });
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename;
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                    URL.revokeObjectURL(url);
                    
                    // Mark as saved (but without autosave capability)
                    savedFilePath = filename;
                    isFileSystemAvailable = false;
                    
                    // Update UI
                    document.getElementById('saveRequiredMessage').style.display = 'none';
                    document.getElementById('generateRootBtn').style.display = 'block';
                    
                    let helpText = ` Investigation saved to Downloads folder!\n\nFile: ${filename}\n\n Browser Limitation: `;
                    
                    if (window.location.protocol === 'file:') {
                        helpText += `You're running this tool from a local file (file://), which limits some features.\n\nFor full functionality including custom save locations:\n Host on a local server (e.g., python -m http.server)\n Use a tool like Live Server in VS Code\n Upload to a web server with HTTPS\n Or continue with manual saves to Downloads folder`;
                    } else {
                        helpText += `Your browser doesn't support the File System API.\n\nFor custom save locations, use:\n Chrome 86+ or Edge 86+ (Chromium-based)\n Opera 72+\n Make sure you're on HTTPS`;
                    }
                    
                    alert(helpText);
                }
            } catch (error) {
                if (error.name === 'AbortError') {
                    // User cancelled the save dialog
                    return;
                }
                console.error('Save error:', error);
                alert(' Error saving file: ' + error.message);
            }
        }
        
        // Autosave function for hops
        async function autosaveInvestigation() {
            if (!isFileSystemAvailable || !fileHandle) {
                console.log('Autosave not available - no file handle');
                return;
            }
            
            try {
                const fileData = JSON.stringify(investigation, null, 2);
                const writable = await fileHandle.createWritable();
                await writable.write(fileData);
                await writable.close();
                
                // Show subtle save indicator
                showAutosaveIndicator();
                
            } catch (error) {
                console.error('Autosave error:', error);
                // Don't alert on every autosave failure, just log it
            }
        }
        
        function showAutosaveIndicator() {
            // Create or update autosave indicator
            let indicator = document.getElementById('autosaveIndicator');
            if (!indicator) {
                indicator = document.createElement('div');
                indicator.id = 'autosaveIndicator';
                indicator.style.cssText = `
                    position: fixed;
                    bottom: 20px;
                    right: 20px;
                    background: #27ae60;
                    color: white;
                    padding: 10px 20px;
                    border-radius: 20px;
                    font-size: 14px;
                    z-index: 1000;
                    opacity: 0;
                    transition: opacity 0.3s ease;
                    pointer-events: none;
                `;
                document.body.appendChild(indicator);
            }
            
            indicator.textContent = ' Autosaved';
            indicator.style.opacity = '1';
            
            setTimeout(() => {
                indicator.style.opacity = '0';
            }, 2000);
        }
        
        // General notification function
        function showNotification(message, type = 'info') {
            let notification = document.getElementById('notification');
            if (!notification) {
                notification = document.createElement('div');
                notification.id = 'notification';
                notification.style.cssText = `
                    position: fixed;
                    top: 20px;
                    right: 20px;
                    padding: 15px 25px;
                    border-radius: 8px;
                    font-size: 14px;
                    z-index: 1000;
                    opacity: 0;
                    transition: opacity 0.3s ease;
                    pointer-events: none;
                    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
                `;
                document.body.appendChild(notification);
            }
            
            // Set color based on type
            const colors = {
                success: '#27ae60',
                error: '#e74c3c',
                warning: '#f39c12',
                info: '#3498db'
            };
            
            notification.style.background = colors[type] || colors.info;
            notification.style.color = 'white';
            notification.textContent = message;
            notification.style.opacity = '1';
            
            setTimeout(() => {
                notification.style.opacity = '0';
            }, 3000);
        }
        
        // Show terminal wallet notification
        function showTerminalWalletNotification(entityData, address, hopId, entryId) {
            // Create overlay
            const overlay = document.createElement('div');
            overlay.className = 'terminal-notification-overlay';
            overlay.onclick = () => closeTerminalNotification();
            
            // Create notification
            const notification = document.createElement('div');
            notification.className = 'terminal-notification';
            notification.innerHTML = `
                <div style="background: linear-gradient(135deg, #9b59b6 0%, #8e44ad 100%); color: white; padding: 25px; border-radius: 12px 12px 0 0;">
                    <h2 style="margin: 0; font-size: 24px; display: flex; align-items: center; gap: 10px;">
                         Exchange Detected - Terminal Wallet
                    </h2>
                </div>
                
                <div style="padding: 30px;">
                    <div style="background: #f3e6ff; border: 2px solid #9b59b6; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
                        <h3 style="color: #9b59b6; margin: 0 0 10px 0;">${entityData.entity}</h3>
                        <p style="margin: 0; color: #555; font-size: 14px;">
                            <strong>Address:</strong> <code style="background: #fff; padding: 2px 6px; border-radius: 3px;">${address.substring(0, 20)}...${address.substring(address.length - 10)}</code><br>
                            <strong>Confidence:</strong> ${entityData.confidence.toUpperCase()}<br>
                            <strong>Source:</strong> ${entityData.source}
                        </p>
                    </div>
                    
                    <div style="background: #fff3cd; border: 2px solid #ffc107; border-radius: 8px; padding: 20px; margin-bottom: 20px;">
                        <h4 style="color: #856404; margin: 0 0 10px 0;"> Important: Terminal Wallet Considerations</h4>
                        <ul style="margin: 0; padding-left: 20px; color: #666;">
                            <li>This appears to be an <strong>exchange deposit address</strong></li>
                            <li>Funds sent here are typically <strong>commingled</strong> with other users' funds</li>
                            <li>You may need to <strong>serve legal process</strong> to the exchange for further tracing</li>
                            <li>Consider this a <strong>potential endpoint</strong> for this trace thread</li>
                        </ul>
                    </div>
                    
                    <div style="display: flex; gap: 15px; justify-content: center;">
                        <button class="btn btn-confirm" onclick="markAsTerminal(${hopId}, ${entryId})" style="background: #9b59b6; padding: 12px 30px; font-size: 16px;">
                             Mark as Terminal & Continue
                        </button>
                        <button class="btn btn-secondary" onclick="closeTerminalNotification()" style="padding: 12px 30px; font-size: 16px;">
                            Continue Tracing
                        </button>
                    </div>
                    
                    <p style="text-align: center; margin-top: 20px; color: #666; font-size: 12px;">
                        Tip: You can always change the classification later if needed
                    </p>
                </div>
            `;
            
            // Add to page
            document.body.appendChild(overlay);
            document.body.appendChild(notification);
        }
        
        function closeTerminalNotification() {
            const overlay = document.querySelector('.terminal-notification-overlay');
            const notification = document.querySelector('.terminal-notification');
            if (overlay) overlay.remove();
            if (notification) notification.remove();
        }
        
        function markAsTerminal(hopId, entryId) {
            // The wallet is already marked as purple, just close the notification
            closeTerminalNotification();
            
            // Optionally add a note about terminal status
            const hop = investigation.hops.find(h => h.id === hopId);
            if (hop) {
                const entry = hop.entries.find(e => e.id === entryId);
                if (entry) {
                    const currentNotes = entry.notes || '';
                    const terminalNote = 'TERMINAL: Exchange deposit - may require legal process for further tracing';
                    if (!currentNotes.includes('TERMINAL')) {
                        entry.notes = currentNotes ? `${currentNotes} | ${terminalNote}` : terminalNote;
                        saveToStorage();
                        renderHops();
                    }
                }
            }
        }
        
        // Welcome Screen and Onboarding Functions
        function checkOnboardingState() {
            const hasBasicInfo = investigation.caseId || investigation.investigator || investigation.caseType;
            const hasVictims = investigation.victims && investigation.victims.length > 0;
            const welcomeScreen = document.getElementById('welcomeScreen');
            const allTabs = document.querySelectorAll('.tab-content');
            const navTabs = document.querySelectorAll('.nav-tab');
            
            // Show welcome screen if no basic info or victims
            if (!hasBasicInfo && !hasVictims) {
                // Hide all tab content
                allTabs.forEach(tab => tab.style.display = 'none');
                // Show welcome screen
                welcomeScreen.style.display = 'block';
                
                // Disable tabs except victims
                navTabs.forEach((tab, index) => {
                    if (index > 0) { // Keep victims tab enabled
                        tab.style.opacity = '0.5';
                        tab.style.cursor = 'not-allowed';
                        tab.onclick = (e) => {
                            e.preventDefault();
                            alert('Please complete the victim transactions first before accessing this section.');
                        };
                    }
                });
            } else {
                // Hide welcome screen
                welcomeScreen.style.display = 'none';
                
                // Update tab states based on progress
                updateTabStates();
            }
        }
        
        function updateTabStates() {
            const navTabs = document.querySelectorAll('.nav-tab');
            const hasVictims = investigation.victims && investigation.victims.length > 0;
            const hasRootTotal = investigation.rootTotalConfirmed;
            const hasHops = investigation.hops && investigation.hops.length > 0;
            
            navTabs.forEach((tab, index) => {
                const tabText = tab.textContent;
                
                // Always enable victims tab
                if (tabText.includes('Victims')) {
                    tab.style.opacity = '1';
                    tab.style.cursor = 'pointer';
                    tab.onclick = () => switchTab('victims');
                }
                // Enable traces tab only after root total confirmed
                else if (tabText.includes('Trace')) {
                    if (hasRootTotal) {
                        tab.style.opacity = '1';
                        tab.style.cursor = 'pointer';
                        tab.onclick = () => switchTab('traces');
                    } else {
                        tab.style.opacity = '0.5';
                        tab.style.cursor = 'not-allowed';
                        tab.onclick = (e) => {
                            e.preventDefault();
                            alert('Please confirm your root total before starting trace documentation.');
                        };
                    }
                }
                // Enable wallet indexes after some traces
                else if (tabText.includes('Wallet')) {
                    if (hasHops) {
                        tab.style.opacity = '1';
                        tab.style.cursor = 'pointer';
                        tab.onclick = () => switchTab('walletindexes');
                    } else {
                        tab.style.opacity = '0.5';
                        tab.style.cursor = 'not-allowed';
                        tab.onclick = (e) => {
                            e.preventDefault();
                            alert('Start documenting traces to build wallet indexes.');
                        };
                    }
                }
                // Enable summary after traces
                else if (tabText.includes('Summary')) {
                    if (hasHops) {
                        tab.style.opacity = '1';
                        tab.style.cursor = 'pointer';
                        tab.onclick = () => switchTab('summary');
                    } else {
                        tab.style.opacity = '0.5';
                        tab.style.cursor = 'not-allowed';
                        tab.onclick = (e) => {
                            e.preventDefault();
                            alert('Complete some trace documentation before accessing the summary.');
                        };
                    }
                }
            });
        }
        
        // Flow Diagram Functions
        function generateFlowDiagram() {
            const svg = document.getElementById('flowDiagramSVG');
            svg.innerHTML = ''; // Clear existing content
            
            if (!investigation.hops || investigation.hops.length === 0) {
                svg.innerHTML = '<text x="50%" y="50%" text-anchor="middle" fill="#999">No trace data available</text>';
                return;
            }
            
            // Configuration
            const walletColumnWidth = 200;
            const hopLaneWidth = 250;
            const nodeRadius = 20;
            const verticalSpacing = 80;
            const topMargin = 60;
            const bottomMargin = 100;
            const leftMargin = 20;
            
            // Calculate dimensions
            const numHops = investigation.hops.length;
            const totalWidth = leftMargin + walletColumnWidth + (numHops * hopLaneWidth) + 50;
            
            // Calculate total height needed
            let yPosition = topMargin + 40; // Start position after titles
            const walletPositions = new Map();
            
            // Map all wallet positions
            investigation.victims.forEach((victim, idx) => {
                const walletId = `V${victim.id}`;
                walletPositions.set(walletId, yPosition);
                yPosition += verticalSpacing;
            });
            
            // Add spacing between victims and other wallets
            yPosition += 30;
            
            // Map all unique wallets from hops
            const processedWallets = new Set();
            investigation.hops.forEach(hop => {
                hop.entries.filter(e => !e.isWriteoff).forEach(entry => {
                    const walletKey = `${entry.toWallet}-${entry.toWalletType}`;
                    if (!processedWallets.has(walletKey)) {
                        processedWallets.add(walletKey);
                        walletPositions.set(walletKey, yPosition);
                        yPosition += verticalSpacing;
                    }
                });
            });
            
            const totalHeight = yPosition + bottomMargin;
            
            // Set SVG dimensions
            svg.setAttribute('width', totalWidth);
            svg.setAttribute('height', totalHeight);
            svg.setAttribute('viewBox', `0 0 ${totalWidth} ${totalHeight}`);
            
            // Draw hop lanes (colored backgrounds)
            for (let i = 0; i < numHops; i++) {
                const laneX = leftMargin + walletColumnWidth + (i * hopLaneWidth);
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', laneX);
                rect.setAttribute('y', 0);
                rect.setAttribute('width', hopLaneWidth);
                rect.setAttribute('height', totalHeight);
                rect.setAttribute('class', `flow-hop-lane flow-hop-lane-${(i % 5) + 1}`);
                svg.appendChild(rect);
                
                // Hop title
                const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                title.setAttribute('x', laneX + hopLaneWidth / 2);
                title.setAttribute('y', 30);
                title.setAttribute('text-anchor', 'middle');
                title.setAttribute('class', 'flow-hop-title');
                title.textContent = `HOP ${i + 1}`;
                svg.appendChild(title);
            }
            
            // Draw all wallets on the left side
            const walletData = [];
            
            // Draw victim wallets (RED)
            investigation.victims.forEach(victim => {
                const walletId = `V${victim.id}`;
                const y = walletPositions.get(walletId);
                const totalAmount = victim.transactions.reduce((sum, t) => sum + parseFloat(t.amount || 0), 0);
                
                // Red circle
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', leftMargin + walletColumnWidth / 2);
                circle.setAttribute('cy', y);
                circle.setAttribute('r', nodeRadius);
                circle.setAttribute('class', 'flow-wallet-node');
                circle.setAttribute('fill', '#e74c3c');
                circle.onclick = () => showWalletDetails({
                    address: victim.transactions[0]?.receivingWallet || 'Unknown',
                    type: 'victim',
                    notation: `V-${victim.id}`
                });
                svg.appendChild(circle);
                
                // Wallet number inside circle
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', leftMargin + walletColumnWidth / 2);
                label.setAttribute('y', y + 5);
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('class', 'flow-wallet-label');
                label.textContent = victim.id;
                svg.appendChild(label);
                
                // Wallet address to the right of circle
                const addressText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                addressText.setAttribute('x', leftMargin + walletColumnWidth / 2 + nodeRadius + 10);
                addressText.setAttribute('y', y + 5);
                addressText.setAttribute('text-anchor', 'start');
                addressText.setAttribute('font-size', '11px');
                addressText.setAttribute('fill', '#666');
                const address = victim.transactions[0]?.receivingWallet || 'Unknown';
                addressText.textContent = address.length > 20 ? address.substring(0, 8) + '...' + address.slice(-6) : address;
                svg.appendChild(addressText);
                
                walletData.push({
                    id: walletId,
                    x: leftMargin + walletColumnWidth / 2,
                    y: y,
                    amount: totalAmount,
                    type: 'victim'
                });
            });
            
            // Draw hop wallets
            const walletsByAddress = new Map();
            investigation.hops.forEach(hop => {
                hop.entries.filter(e => !e.isWriteoff).forEach(entry => {
                    const walletKey = `${entry.toWallet}-${entry.toWalletType}`;
                    if (!walletsByAddress.has(walletKey)) {
                        const y = walletPositions.get(walletKey);
                        
                        // Wallet circle
                        const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                        circle.setAttribute('cx', leftMargin + walletColumnWidth / 2);
                        circle.setAttribute('cy', y);
                        circle.setAttribute('r', nodeRadius);
                        circle.setAttribute('class', 'flow-wallet-node');
                        circle.setAttribute('fill', getWalletColor(entry.toWalletType));
                        circle.onclick = () => showWalletDetails({
                            address: entry.toWallet,
                            type: entry.toWalletType,
                            notation: entry.notation
                        });
                        svg.appendChild(circle);
                        
                        // Wallet notation inside circle
                        const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        label.setAttribute('x', leftMargin + walletColumnWidth / 2);
                        label.setAttribute('y', y + 5);
                        label.setAttribute('text-anchor', 'middle');
                        label.setAttribute('class', 'flow-wallet-label');
                        // Extract number from notation (e.g., "V1-T1-H1" -> "1")
                        const hopNum = entry.notation ? entry.notation.split('-H')[1] : '';
                        label.textContent = hopNum || '';
                        svg.appendChild(label);
                        
                        // Wallet entity name if known
                        if (entry.entityName) {
                            const entityText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            entityText.setAttribute('x', leftMargin + walletColumnWidth / 2 + nodeRadius + 10);
                            entityText.setAttribute('y', y + 5);
                            entityText.setAttribute('text-anchor', 'start');
                            entityText.setAttribute('font-size', '11px');
                            entityText.setAttribute('fill', '#666');
                            entityText.setAttribute('font-weight', 'bold');
                            entityText.textContent = entry.entityName;
                            svg.appendChild(entityText);
                        }
                        
                        walletsByAddress.set(walletKey, {
                            x: leftMargin + walletColumnWidth / 2,
                            y: y,
                            type: entry.toWalletType,
                            notation: entry.notation
                        });
                    }
                });
            });
            
            // Draw connections and amounts
            const hopSums = [];
            
            investigation.hops.forEach((hop, hopIndex) => {
                const laneX = leftMargin + walletColumnWidth + (hopIndex * hopLaneWidth);
                const laneCenterX = laneX + hopLaneWidth / 2;
                
                hop.entries.forEach(entry => {
                    if (entry.isWriteoff) {
                        // Track writeoffs separately for display
                        if (!hopSums[hopIndex]) hopSums[hopIndex] = { total: 0, writeoffs: 0 };
                        hopSums[hopIndex].writeoffs += parseFloat(entry.amount || 0);
                        return;
                    }
                    
                    // Initialize hop sum if needed
                    if (!hopSums[hopIndex]) hopSums[hopIndex] = { total: 0, writeoffs: 0 };
                    
                    // Find source wallet position
                    let sourceY;
                    if (entry.sourceThread) {
                        // Check if it's from a victim
                        const victimMatch = entry.sourceThread.match(/V-(\d+)/);
                        if (victimMatch) {
                            sourceY = walletPositions.get(`V${victimMatch[1]}`);
                        } else {
                            // Find the source hop entry
                            for (let i = hopIndex - 1; i >= 0; i--) {
                                const sourceHop = investigation.hops[i];
                                const sourceEntry = sourceHop.entries.find(e => e.notation === entry.sourceThread);
                                if (sourceEntry) {
                                    const sourceKey = `${sourceEntry.toWallet}-${sourceEntry.toWalletType}`;
                                    sourceY = walletPositions.get(sourceKey);
                                    break;
                                }
                            }
                        }
                    }
                    
                    // Find destination wallet position
                    const destKey = `${entry.toWallet}-${entry.toWalletType}`;
                    const destY = walletPositions.get(destKey);
                    
                    if (sourceY && destY) {
                        // Draw straight line
                        const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                        line.setAttribute('x1', leftMargin + walletColumnWidth / 2 + nodeRadius);
                        line.setAttribute('y1', sourceY);
                        line.setAttribute('x2', laneCenterX);
                        line.setAttribute('y2', destY);
                        line.setAttribute('class', 'flow-connection-line');
                        svg.appendChild(line);
                        
                        // Add amount text on the line
                        const amountText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        amountText.setAttribute('x', laneCenterX - 10);
                        amountText.setAttribute('y', destY - 5);
                        amountText.setAttribute('text-anchor', 'end');
                        amountText.setAttribute('class', 'flow-thread-amount');
                        amountText.textContent = formatCurrency(parseFloat(entry.amount || 0));
                        svg.appendChild(amountText);
                    }
                    
                    // Add to hop sum
                    hopSums[hopIndex].total += parseFloat(entry.amount || 0);
                });
                
                // Draw sum at bottom of hop lane
                const sumData = hopSums[hopIndex] || { total: 0, writeoffs: 0 };
                const sumText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                sumText.setAttribute('x', laneCenterX);
                sumText.setAttribute('y', totalHeight - 30);
                sumText.setAttribute('text-anchor', 'middle');
                sumText.setAttribute('class', 'flow-sum-text');
                sumText.textContent = formatCurrency(sumData.total);
                svg.appendChild(sumText);
                
                // Show writeoffs if any
                if (sumData.writeoffs > 0) {
                    const writeoffText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    writeoffText.setAttribute('x', laneCenterX);
                    writeoffText.setAttribute('y', totalHeight - 10);
                    writeoffText.setAttribute('text-anchor', 'middle');
                    writeoffText.setAttribute('font-size', '12px');
                    writeoffText.setAttribute('fill', '#666');
                    writeoffText.textContent = `(${formatCurrency(sumData.writeoffs)}) WO`;
                    svg.appendChild(writeoffText);
                }
                
                // Add "SUM:" label
                const sumLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                sumLabel.setAttribute('x', laneCenterX);
                sumLabel.setAttribute('y', totalHeight - 50);
                sumLabel.setAttribute('text-anchor', 'middle');
                sumLabel.setAttribute('font-size', '14px');
                sumLabel.setAttribute('fill', '#666');
                sumLabel.textContent = 'SUM:';
                svg.appendChild(sumLabel);
            });
        }
        
        function getWalletColor(type) {
            const colors = {
                'victim': '#e74c3c',
                'red': '#e74c3c',
                'purple': '#9b59b6',
                'blue': '#3498db',
                'green': '#27ae60',
                'unknown': '#95a5a6'
            };
            return colors[type] || colors.unknown;
        }
        
        
        function showWalletDetails(walletData) {
            alert(`Wallet: ${walletData.address || 'Unknown'}\nType: ${walletData.type}\nNotation: ${walletData.notation || 'N/A'}`);
        }
        
        // Generate BATS Training Example Visualization
        function generateBATSTrainingExample() {
            const svg = document.getElementById('flowDiagramSVG');
            svg.innerHTML = ''; // Clear existing content
            
            // Configuration
            const walletColumnWidth = 250;
            const hopLaneWidth = 300;
            const nodeRadius = 25;
            const verticalSpacing = 100;
            const topMargin = 80;
            const bottomMargin = 120;
            const leftMargin = 20;
            
            // Example data structure
            const exampleData = {
                victims: [
                    { id: 1, wallet: '0xVictim1...ABC', amount: 50000, label: 'Exchange Hack Victim' },
                    { id: 2, wallet: '0xVictim2...DEF', amount: 75000, label: 'DeFi Protocol Hack' },
                    { id: 3, wallet: '0xVictim3...GHI', amount: 25000, label: 'Phishing Victim' }
                ],
                hops: [
                    {
                        number: 1,
                        entries: [
                            { from: 'V1', to: '0xHub1...123', amount: 50000, type: 'purple', label: 'Hub Wallet', notation: 'V1-T1-H1' },
                            { from: 'V2', to: '0xHub1...123', amount: 75000, type: 'purple', label: 'Hub Wallet', notation: 'V2-T1-H1' },
                            { from: 'V3', to: '0xCold1...456', amount: 25000, type: 'gray', label: 'Cold Storage', notation: 'V3-T1-H1' }
                        ]
                    },
                    {
                        number: 2,
                        entries: [
                            { from: 'V1-T1-H1', to: '0xExchange1...789', amount: 45000, type: 'blue', label: 'Binance', notation: 'V1-T1-H2', entity: true },
                            { from: 'V1-T1-H1', to: '0xMixer...ABC', amount: 5000, type: 'red', label: 'Mixer', notation: 'V1-T1-H2', writeoff: true },
                            { from: 'V2-T1-H1', to: '0xExchange2...DEF', amount: 70000, type: 'blue', label: 'Coinbase', notation: 'V2-T1-H2', entity: true },
                            { from: 'V2-T1-H1', to: '0xUnknown...123', amount: 5000, type: 'red', label: 'Unknown', notation: 'V2-T1-H2', writeoff: true }
                        ]
                    },
                    {
                        number: 3,
                        entries: [
                            { from: 'V1-T1-H2', to: '0xExchange3...GHI', amount: 40000, type: 'blue', label: 'Kraken', notation: 'V1-T1-H3', entity: true },
                            { from: 'V1-T1-H2', to: '0xCold2...JKL', amount: 5000, type: 'gray', label: 'Cold Storage', notation: 'V1-T1-H3' },
                            { from: 'V2-T1-H2', to: '0xExchange3...GHI', amount: 70000, type: 'blue', label: 'Kraken', notation: 'V2-T1-H3', entity: true }
                        ]
                    }
                ]
            };
            
            // Calculate dimensions
            const numHops = exampleData.hops.length;
            const totalWidth = leftMargin + walletColumnWidth + (numHops * hopLaneWidth) + 50;
            const totalHeight = topMargin + (8 * verticalSpacing) + bottomMargin;
            
            // Set SVG dimensions
            svg.setAttribute('width', totalWidth);
            svg.setAttribute('height', totalHeight);
            svg.setAttribute('viewBox', `0 0 ${totalWidth} ${totalHeight}`);
            
            // Add title
            const title = document.createElementNS('http://www.w3.org/2000/svg', 'text');
            title.setAttribute('x', totalWidth / 2);
            title.setAttribute('y', 30);
            title.setAttribute('text-anchor', 'middle');
            title.setAttribute('font-size', '24px');
            title.setAttribute('font-weight', 'bold');
            title.setAttribute('fill', '#2c3e50');
            title.textContent = 'BATS Training Example - Multiple Principles';
            svg.appendChild(title);
            
            // Draw hop lanes
            for (let i = 0; i < numHops; i++) {
                const laneX = leftMargin + walletColumnWidth + (i * hopLaneWidth);
                const rect = document.createElementNS('http://www.w3.org/2000/svg', 'rect');
                rect.setAttribute('x', laneX);
                rect.setAttribute('y', 50);
                rect.setAttribute('width', hopLaneWidth);
                rect.setAttribute('height', totalHeight - 70);
                rect.setAttribute('class', `flow-hop-lane flow-hop-lane-${(i % 5) + 1}`);
                svg.appendChild(rect);
                
                // Hop title
                const hopTitle = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                hopTitle.setAttribute('x', laneX + hopLaneWidth / 2);
                hopTitle.setAttribute('y', 75);
                hopTitle.setAttribute('text-anchor', 'middle');
                hopTitle.setAttribute('class', 'flow-hop-title');
                hopTitle.textContent = `HOP ${i + 1}`;
                svg.appendChild(hopTitle);
            }
            
            // Draw victim wallets
            let yPosition = topMargin + 50;
            exampleData.victims.forEach((victim, idx) => {
                // Red circle
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', leftMargin + 40);
                circle.setAttribute('cy', yPosition);
                circle.setAttribute('r', nodeRadius);
                circle.setAttribute('class', 'flow-wallet-node');
                circle.setAttribute('fill', '#e74c3c');
                svg.appendChild(circle);
                
                // Victim number
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', leftMargin + 40);
                label.setAttribute('y', yPosition + 5);
                label.setAttribute('text-anchor', 'middle');
                label.setAttribute('fill', 'white');
                label.setAttribute('font-weight', 'bold');
                label.textContent = victim.id;
                svg.appendChild(label);
                
                // Description
                const desc = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                desc.setAttribute('x', leftMargin + 75);
                desc.setAttribute('y', yPosition + 5);
                desc.setAttribute('font-size', '12px');
                desc.setAttribute('fill', '#666');
                desc.textContent = victim.label;
                svg.appendChild(desc);
                
                yPosition += verticalSpacing;
            });
            
            // Add legend
            const legendY = yPosition + 20;
            const legendItems = [
                { color: '#e74c3c', label: 'RED - Victim/High Risk' },
                { color: '#9b59b6', label: 'PURPLE - Hub Wallet' },
                { color: '#3498db', label: 'BLUE - Exchange/Service' },
                { color: '#95a5a6', label: 'GRAY - Cold Storage' }
            ];
            
            legendItems.forEach((item, idx) => {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', leftMargin + 40);
                circle.setAttribute('cy', legendY + (idx * 30));
                circle.setAttribute('r', 10);
                circle.setAttribute('fill', item.color);
                svg.appendChild(circle);
                
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', leftMargin + 60);
                text.setAttribute('y', legendY + (idx * 30) + 5);
                text.setAttribute('font-size', '12px');
                text.setAttribute('fill', '#2c3e50');
                text.textContent = item.label;
                svg.appendChild(text);
            });
            
            // Draw hop wallets and connections
            const walletPositions = new Map();
            let currentY = topMargin + 50;
            
            // Position all wallets
            exampleData.hops.forEach((hop, hopIdx) => {
                const uniqueWallets = new Map();
                hop.entries.forEach(entry => {
                    if (!entry.writeoff && !uniqueWallets.has(entry.to)) {
                        uniqueWallets.set(entry.to, { type: entry.type, label: entry.label, entity: entry.entity });
                    }
                });
                
                uniqueWallets.forEach((wallet, address) => {
                    if (!walletPositions.has(address)) {
                        walletPositions.set(address, { y: currentY, ...wallet });
                        currentY += verticalSpacing * 0.8;
                    }
                });
            });
            
            // Draw wallet nodes
            walletPositions.forEach((wallet, address) => {
                const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
                circle.setAttribute('cx', leftMargin + walletColumnWidth - 50);
                circle.setAttribute('cy', wallet.y);
                circle.setAttribute('r', nodeRadius);
                circle.setAttribute('class', 'flow-wallet-node');
                circle.setAttribute('fill', getWalletColor(wallet.type));
                svg.appendChild(circle);
                
                // Wallet type icon/number
                const icon = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                icon.setAttribute('x', leftMargin + walletColumnWidth - 50);
                icon.setAttribute('y', wallet.y + 5);
                icon.setAttribute('text-anchor', 'middle');
                icon.setAttribute('fill', 'white');
                icon.setAttribute('font-weight', 'bold');
                icon.textContent = wallet.entity ? 'E' : wallet.type === 'gray' ? 'C' : 'H';
                svg.appendChild(icon);
                
                // Wallet label
                const label = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                label.setAttribute('x', leftMargin + walletColumnWidth - 15);
                label.setAttribute('y', wallet.y + 5);
                label.setAttribute('font-size', '12px');
                label.setAttribute('fill', '#2c3e50');
                label.setAttribute('font-weight', wallet.entity ? 'bold' : 'normal');
                label.textContent = wallet.label;
                svg.appendChild(label);
            });
            
            // Draw connections and amounts
            exampleData.hops.forEach((hop, hopIdx) => {
                const laneX = leftMargin + walletColumnWidth + (hopIdx * hopLaneWidth);
                const laneCenterX = laneX + hopLaneWidth / 2;
                let hopTotal = 0;
                let hopWriteoffs = 0;
                
                hop.entries.forEach(entry => {
                    let sourceY;
                    
                    // Find source position
                    if (entry.from.startsWith('V')) {
                        const victimId = parseInt(entry.from.substring(1));
                        sourceY = topMargin + 50 + ((victimId - 1) * verticalSpacing);
                    } else {
                        // Find from previous hop
                        for (let i = hopIdx - 1; i >= 0; i--) {
                            const prevHop = exampleData.hops[i];
                            const prevEntry = prevHop.entries.find(e => e.notation === entry.from);
                            if (prevEntry) {
                                sourceY = walletPositions.get(prevEntry.to)?.y;
                                break;
                            }
                        }
                    }
                    
                    if (entry.writeoff) {
                        hopWriteoffs += entry.amount;
                        
                        // Draw writeoff notation
                        const writeoffText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                        writeoffText.setAttribute('x', laneCenterX);
                        writeoffText.setAttribute('y', sourceY);
                        writeoffText.setAttribute('text-anchor', 'middle');
                        writeoffText.setAttribute('font-size', '12px');
                        writeoffText.setAttribute('fill', '#e74c3c');
                        writeoffText.setAttribute('font-weight', 'bold');
                        writeoffText.textContent = `Write-off: ${formatCurrency(entry.amount)} (${entry.label})`;
                        svg.appendChild(writeoffText);
                    } else {
                        hopTotal += entry.amount;
                        const destY = walletPositions.get(entry.to)?.y;
                        
                        if (sourceY && destY) {
                            // Draw line
                            const line = document.createElementNS('http://www.w3.org/2000/svg', 'line');
                            line.setAttribute('x1', entry.from.startsWith('V') ? leftMargin + 65 : leftMargin + walletColumnWidth - 25);
                            line.setAttribute('y1', sourceY);
                            line.setAttribute('x2', laneCenterX);
                            line.setAttribute('y2', destY);
                            line.setAttribute('class', 'flow-connection-line');
                            svg.appendChild(line);
                            
                            // Amount on line
                            const amountText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                            amountText.setAttribute('x', laneCenterX - 10);
                            amountText.setAttribute('y', destY - 5);
                            amountText.setAttribute('text-anchor', 'end');
                            amountText.setAttribute('class', 'flow-thread-amount');
                            amountText.textContent = formatCurrency(entry.amount);
                            svg.appendChild(amountText);
                        }
                    }
                });
                
                // Draw hop totals
                const sumY = totalHeight - 60;
                const sumText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                sumText.setAttribute('x', laneCenterX);
                sumText.setAttribute('y', sumY);
                sumText.setAttribute('text-anchor', 'middle');
                sumText.setAttribute('class', 'flow-sum-text');
                sumText.textContent = formatCurrency(hopTotal);
                svg.appendChild(sumText);
                
                if (hopWriteoffs > 0) {
                    const writeoffSumText = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                    writeoffSumText.setAttribute('x', laneCenterX);
                    writeoffSumText.setAttribute('y', sumY + 20);
                    writeoffSumText.setAttribute('text-anchor', 'middle');
                    writeoffSumText.setAttribute('font-size', '12px');
                    writeoffSumText.setAttribute('fill', '#e74c3c');
                    writeoffSumText.textContent = `WO: (${formatCurrency(hopWriteoffs)})`;
                    svg.appendChild(writeoffSumText);
                }
                
                // Sum label
                const sumLabel = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                sumLabel.setAttribute('x', laneCenterX);
                sumLabel.setAttribute('y', sumY - 20);
                sumLabel.setAttribute('text-anchor', 'middle');
                sumLabel.setAttribute('font-size', '14px');
                sumLabel.setAttribute('fill', '#666');
                sumLabel.textContent = 'SUM:';
                svg.appendChild(sumLabel);
            });
            
            // Add explanatory notes
            const notesY = totalHeight - 30;
            const notes = [
                'Hub Wallets (Purple): Consolidate funds from multiple sources',
                'Cold Storage (Gray): Long-term storage, harder to trace',
                'Exchanges (Blue): Known entities, potential recovery points',
                'Write-offs (Red): Lost/untraceable funds, reduce ART'
            ];
            
            notes.forEach((note, idx) => {
                const text = document.createElementNS('http://www.w3.org/2000/svg', 'text');
                text.setAttribute('x', leftMargin);
                text.setAttribute('y', notesY + (idx * 15));
                text.setAttribute('font-size', '11px');
                text.setAttribute('fill', '#666');
                text.textContent = ` ${note}`;
                svg.appendChild(text);
            });
        }
        
        function exportFlowDiagram(format) {
            const svg = document.getElementById('flowDiagramSVG');
            
            if (format === 'svg') {
                const svgData = new XMLSerializer().serializeToString(svg);
                const blob = new Blob([svgData], { type: 'image/svg+xml' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `BATS_Flow_${investigation.caseId || 'Diagram'}.svg`;
                a.click();
                URL.revokeObjectURL(url);
            } else if (format === 'png') {
                // Convert SVG to PNG
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                const img = new Image();
                
                const svgData = new XMLSerializer().serializeToString(svg);
                const svgBlob = new Blob([svgData], { type: 'image/svg+xml;charset=utf-8' });
                const url = URL.createObjectURL(svgBlob);
                
                img.onload = function() {
                    canvas.width = img.width;
                    canvas.height = img.height;
                    ctx.fillStyle = 'white';
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    ctx.drawImage(img, 0, 0);
                    
                    canvas.toBlob(function(blob) {
                        const a = document.createElement('a');
                        a.href = URL.createObjectURL(blob);
                        a.download = `BATS_Flow_${investigation.caseId || 'Diagram'}.png`;
                        a.click();
                    });
                    
                    URL.revokeObjectURL(url);
                };
                
                img.src = url;
            }
        }
        
        function printFlowDiagram() {
            window.print();
        }
        
        // New function to show welcome screen
        function showWelcomeScreen() {
            // Hide all tabs
            document.querySelectorAll('.tab-content').forEach(tab => {
                tab.style.display = 'none';
            });
            
            // Show welcome screen
            const welcomeScreen = document.getElementById('welcomeScreen');
            welcomeScreen.style.display = 'block';
            
            // Update nav tabs to show welcome is active
            document.querySelectorAll('.nav-tab').forEach(tab => {
                tab.classList.remove('active');
            });
        }
        
        // Quick start from welcome screen
        function quickStartInvestigation() {
            const caseId = document.getElementById('welcomeCaseId').value.trim();
            const investigator = document.getElementById('welcomeInvestigator').value.trim();
            const caseType = document.getElementById('welcomeCaseType').value;
            
            if (!caseId || !investigator || !caseType) {
                // Highlight missing fields
                if (!caseId) document.getElementById('welcomeCaseId').style.borderColor = '#e74c3c';
                if (!investigator) document.getElementById('welcomeInvestigator').style.borderColor = '#e74c3c';
                if (!caseType) document.getElementById('welcomeCaseType').style.borderColor = '#e74c3c';
                
                alert('Please fill in all required fields');
                return;
            }
            
            // Get synopsis value
            const caseSynopsis = document.getElementById('welcomeCaseSynopsis').value.trim();
            
            // Save to investigation object
            investigation.caseId = caseId;
            investigation.investigator = investigator;
            investigation.caseType = caseType;
            investigation.caseSynopsis = caseSynopsis;
            investigation.setupComplete = true;
            
            // Update main form fields
            document.getElementById('caseId').value = caseId;
            document.getElementById('investigator').value = investigator;
            document.getElementById('caseType').value = caseType;
            document.getElementById('caseSynopsis').value = caseSynopsis;
            
            // Save to storage
            saveToStorage();
            
            // Hide welcome screen
            document.getElementById('welcomeScreen').style.display = 'none';
            
            // Switch to victims tab
            switchTab('victims');
            
            // Auto-collapse setup card
            setTimeout(() => {
                const setupContent = document.getElementById('setupContent');
                if (setupContent && setupContent.style.display !== 'none') {
                    toggleSetupCard();
                }
                
                // Focus on add victim button
                const addVictimBtn = document.querySelector('button[onclick="addVictim()"]');
                if (addVictimBtn) {
                    addVictimBtn.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    // Add pulsing animation
                    addVictimBtn.style.animation = 'pulse 2s infinite';
                    addVictimBtn.style.boxShadow = '0 0 20px rgba(255, 152, 0, 0.5)';
                }
            }, 300);
        }
        
        // Skip welcome screen
        function skipWelcome() {
            document.getElementById('welcomeScreen').style.display = 'none';
            switchTab('victims');
        }
        
        function startInvestigation() {
            // Check if case details are filled
            const caseId = document.getElementById('caseId').value;
            const investigator = document.getElementById('investigator').value;
            const caseType = document.getElementById('caseType').value;
            
            if (!caseId || !investigator || !caseType) {
                alert('Please fill in the case details in the left sidebar first:\n- Case ID\n- Investigator Name\n- Case Type');
                
                // Highlight the fields
                if (!caseId) document.getElementById('caseId').style.borderColor = '#e74c3c';
                if (!investigator) document.getElementById('investigator').style.borderColor = '#e74c3c';
                if (!caseType) document.getElementById('caseType').style.borderColor = '#e74c3c';
                
                // Reset field highlighting after 3 seconds
                setTimeout(() => {
                    document.getElementById('caseId').style.borderColor = '';
                    document.getElementById('investigator').style.borderColor = '';
                    document.getElementById('caseType').style.borderColor = '';
                }, 3000);
                
                return;
            }
            
            // Hide welcome screen and show victims tab
            document.getElementById('welcomeScreen').style.display = 'none';
            switchTab('victims');
            
            // Focus on add victim button
            setTimeout(() => {
                const addVictimBtn = document.querySelector('button[onclick="addVictim()"]');
                if (addVictimBtn) {
                    addVictimBtn.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    addVictimBtn.style.animation = 'pulse 2s infinite';
                }
            }, 300);
        }

        // Save case details from Case Details tab
        function saveCaseDetails() {
            const caseId = document.getElementById('caseId').value.trim();
            const investigator = document.getElementById('investigator').value.trim();
            const caseType = document.getElementById('caseType').value;
            const caseSynopsis = document.getElementById('caseSynopsis').value.trim();
            
            // Update investigation object
            investigation.caseId = caseId;
            investigation.investigator = investigator;
            investigation.caseType = caseType;
            investigation.caseSynopsis = caseSynopsis;
            
            // Mark as complete if all required fields are filled
            if (caseId && investigator && caseType) {
                investigation.setupComplete = true;
            }
            
            // Save to storage
            saveToStorage();
            
            // Show success message
            alert('Case details saved successfully!');
            
            // Update stats
            updateCaseStats();
        }
        
        // Check if setup is complete
        function isSetupComplete() {
            // First check the saved state
            if (investigation.setupComplete) {
                return true;
            }
            
            // Otherwise check current form values
            const caseId = document.getElementById('caseId').value;
            const investigator = document.getElementById('investigator').value;
            const caseType = document.getElementById('caseType').value;
            const caseSynopsis = document.getElementById('caseSynopsis').value;
            
            return caseId && investigator && caseType && caseSynopsis;
        }
        
        // Update case statistics
        function updateCaseStats() {
            const statsContainer = document.getElementById('caseStats');
            if (!statsContainer) return;
            
            const totalVictims = investigation.victims.length;
            const totalTransactions = investigation.victims.reduce((sum, v) => sum + v.transactions.length, 0);
            const totalHops = investigation.hops.length;
            const totalWallets = investigation.universalWalletIndex.length;
            
            // Calculate total traced amounts
            let totalTracedAmounts = {};
            investigation.victims.forEach(victim => {
                victim.transactions.forEach(tx => {
                    const currency = tx.customCurrency || tx.currency;
                    totalTracedAmounts[currency] = (totalTracedAmounts[currency] || 0) + parseFloat(tx.amount || 0);
                });
            });
            
            // Format amounts
            const amountsHtml = Object.entries(totalTracedAmounts)
                .map(([currency, amount]) => `<div>${formatCurrency(amount, currency)}</div>`)
                .join('');
            
            statsContainer.innerHTML = `
                <div style="background: linear-gradient(135deg, #e8f5e9 0%, #c8e6c9 100%); padding: 20px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 2rem; font-weight: bold; color: #2e7d32;">${totalVictims}</div>
                    <div style="color: #388e3c;">Victims</div>
                </div>
                <div style="background: linear-gradient(135deg, #e3f2fd 0%, #bbdefb 100%); padding: 20px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 2rem; font-weight: bold; color: #1565c0;">${totalTransactions}</div>
                    <div style="color: #1976d2;">Transactions</div>
                </div>
                <div style="background: linear-gradient(135deg, #f3e5f5 0%, #e1bee7 100%); padding: 20px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 2rem; font-weight: bold; color: #6a1b9a;">${totalHops}</div>
                    <div style="color: #7b1fa2;">Hops Traced</div>
                </div>
                <div style="background: linear-gradient(135deg, #fff3e0 0%, #ffe0b2 100%); padding: 20px; border-radius: 8px; text-align: center;">
                    <div style="font-size: 2rem; font-weight: bold; color: #e65100;">${totalWallets}</div>
                    <div style="color: #f57c00;">Wallets Tracked</div>
                </div>
                <div style="background: linear-gradient(135deg, #fce4ec 0%, #f8bbd0 100%); padding: 20px; border-radius: 8px; text-align: center; grid-column: span 2;">
                    <div style="font-size: 1.2rem; font-weight: bold; color: #c2185b;">Total Traced:</div>
                    <div style="color: #d81b60;">${amountsHtml || 'No amounts traced yet'}</div>
                </div>
            `;
        }
        
        // Helper function to toggle setup card (kept for compatibility)
        function toggleSetupCard() {
            // No longer needed since setup card is in its own tab
        }
        
        // Helper function to update setup card (kept for compatibility)
        function updateSetupCard() {
            // No longer needed since setup card is in its own tab
        }
        
        // Helper function to validate and proceed (kept for compatibility)
        function validateAndProceedSetup() {
            // This functionality is now handled by saveCaseDetails()
            saveCaseDetails();
            switchTab('victims');
            
            // Show success message
            setTimeout(() => {
                alert(' Investigation setup complete!\n\nNow add victim transactions to begin your investigation.');
            }, 100);
        }
        
        // Make functions globally accessible
        window.validateAndProceedSetup = validateAndProceedSetup;
        window.saveCaseDetails = saveCaseDetails;
        window.updateCaseStats = updateCaseStats;

        // Add event listeners to setup fields
        document.addEventListener('DOMContentLoaded', function() {
            // Load existing values if they exist
            if (investigation.caseId) document.getElementById('caseId').value = investigation.caseId;
            if (investigation.investigator) document.getElementById('investigator').value = investigation.investigator;
            if (investigation.caseType) document.getElementById('caseType').value = investigation.caseType;
            if (investigation.caseSynopsis) document.getElementById('caseSynopsis').value = investigation.caseSynopsis;
            
            // Update card appearance on load
            updateSetupCard();
        });
    </script>
</body>
</html>